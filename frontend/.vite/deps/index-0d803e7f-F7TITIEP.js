import {
  Edt,
  Fdt,
  Gne,
  Gs,
  Gv,
  Hvn,
  K_,
  L5,
  NZr,
  Nct,
  Ndt,
  P_,
  RZr,
  Sdt,
  UZr,
  Vdt,
  Vv,
  W5,
  X_,
  Y_,
  ZQn,
  ao,
  cRe,
  cie,
  eg,
  fw,
  gQn,
  gRe,
  hRe,
  hl,
  k5,
  lE,
  lRe,
  lie,
  oRe,
  pw,
  rFn,
  tvn,
  uFn,
  vdt,
  wQn,
  wZr,
  wne,
  xv,
  yvn,
  z_
} from "./chunk-BBHCMWC6.js";
import "./chunk-XXCRK5JG.js";
import {
  require_react
} from "./chunk-WNPTCGAH.js";
import {
  __toESM
} from "./chunk-5WRI5ZAA.js";

// node_modules/vitessce/dist/index-0d803e7f.js
var import_react = __toESM(require_react(), 1);
function RR(n, e) {
  for (var t = 0; t < e.length; t++) {
    const i = e[t];
    if (typeof i != "string" && !Array.isArray(i)) {
      for (const r in i)
        if (r !== "default" && !(r in n)) {
          const s = Object.getOwnPropertyDescriptor(i, r);
          s && Object.defineProperty(n, r, s.get ? s : {
            enumerable: true,
            get: () => i[r]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }));
}
var yv = {};
var pp = Y_;
var MR = xv;
var NR = k5;
var vE = function(n, e) {
  var t = (MR.Object || {})[n] || Object[n], i = {};
  i[n] = e(t), pp(pp.S + pp.F * NR(function() {
    t(1);
  }), "Object", i);
};
var _R = oRe;
var OR = cie;
vE("keys", function() {
  return function(e) {
    return OR(_R(e));
  };
});
var VR = xv.Object.keys;
var BR = { default: VR, __esModule: true };
var un = Gs(BR);
var wg = vdt;
var FR = K_("toStringTag");
var UR = wg(/* @__PURE__ */ function() {
  return arguments;
}()) == "Arguments";
var zR = function(n, e) {
  try {
    return n[e];
  } catch {
  }
};
var Sh = function(n) {
  var e, t, i;
  return n === void 0 ? "Undefined" : n === null ? "Null" : typeof (t = zR(e = Object(n), FR)) == "string" ? t : UR ? wg(e) : (i = wg(e)) == "Object" && typeof e.callee == "function" ? "Arguments" : i;
};
var GR = Sh;
var $R = K_("iterator");
var WR = lRe;
var HR = xv.isIterable = function(n) {
  var e = Object(n);
  return e[$R] !== void 0 || "@@iterator" in e || WR.hasOwnProperty(GR(e));
};
var jR = HR;
var JR = { default: jR, __esModule: true };
var YR = Sh;
var qR = K_("iterator");
var KR = lRe;
var Sv = xv.getIteratorMethod = function(n) {
  if (n != null)
    return n[qR] || n["@@iterator"] || KR[YR(n)];
};
var ZR = W5;
var XR = Sv;
var QR = xv.getIterator = function(n) {
  var e = XR(n);
  if (typeof e != "function")
    throw TypeError(n + " is not iterable!");
  return ZR(e.call(n));
};
var eM = QR;
var yE = { default: eM, __esModule: true };
var bv = Gs(yE);
var tM = JR;
var nM = SE(tM);
var iM = yE;
var rM = SE(iM);
function SE(n) {
  return n && n.__esModule ? n : { default: n };
}
var ce = /* @__PURE__ */ function() {
  function n(e, t) {
    var i = [], r = true, s = false, a = void 0;
    try {
      for (var l = (0, rM.default)(e), d; !(r = (d = l.next()).done) && (i.push(d.value), !(t && i.length === t)); r = true)
        ;
    } catch (u) {
      s = true, a = u;
    } finally {
      try {
        !r && l.return && l.return();
      } finally {
        if (s)
          throw a;
      }
    }
    return i;
  }
  return function(e, t) {
    if (Array.isArray(e))
      return e;
    if ((0, nM.default)(Object(e)))
      return n(e, t);
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  };
}();
var sM = P_;
var bh = function(n, e, t) {
  for (var i in e)
    t && n[i] ? n[i] = e[i] : sM(n, i, e[i]);
  return n;
};
var Ch = function(n, e, t, i) {
  if (!(n instanceof e) || i !== void 0 && i in n)
    throw TypeError(t + ": incorrect invocation!");
  return n;
};
var bE = { exports: {} };
var vb = W5;
var CE = function(n, e, t, i) {
  try {
    return i ? e(vb(t)[0], t[1]) : e(t);
  } catch (s) {
    var r = n.return;
    throw r !== void 0 && vb(r.call(n)), s;
  }
};
var aM = lRe;
var oM = K_("iterator");
var lM = Array.prototype;
var wE = function(n) {
  return n !== void 0 && (aM.Array === n || lM[oM] === n);
};
var cM = Edt;
var dM = CE;
var uM = wE;
var hM = W5;
var fM = wQn;
var pM = Sv;
var xg = {};
var Eg = {};
var xE = bE.exports = function(n, e, t, i, r) {
  var s = r ? function() {
    return n;
  } : pM(n), a = cM(t, i, e ? 2 : 1), l = 0, d, u, f, g;
  if (typeof s != "function")
    throw TypeError(n + " is not iterable!");
  if (uM(s)) {
    for (d = fM(n.length); d > l; l++)
      if (g = e ? a(hM(u = n[l])[0], u[1]) : a(n[l]), g === xg || g === Eg)
        return g;
  } else
    for (f = s.call(n); !(u = f.next()).done; )
      if (g = dM(f, a, u.value, e), g === xg || g === Eg)
        return g;
};
xE.BREAK = xg;
xE.RETURN = Eg;
var jo = bE.exports;
var gM = fw;
var yb = xv;
var mM = Gv;
var vM = Vv;
var Sb = K_("species");
var EE = function(n) {
  var e = typeof yb[n] == "function" ? yb[n] : gM[n];
  vM && e && !e[Sb] && mM.f(e, Sb, {
    configurable: true,
    get: function() {
      return this;
    }
  });
};
var yM = X_;
var ma = function(n, e) {
  if (!yM(n) || n._t !== e)
    throw TypeError("Incompatible receiver, " + e + " required!");
  return n;
};
var SM = Gv.f;
var bM = gRe;
var CM = bh;
var wM = Edt;
var xM = Ch;
var EM = jo;
var TM = Vdt;
var Fd = Hvn;
var kM = EE;
var TE = Vv;
var kE = rFn.fastKey;
var Qa = ma;
var zl = TE ? "_s" : "size";
var Ud = function(n, e) {
  var t = kE(e), i;
  if (t !== "F")
    return n._i[t];
  for (i = n._f; i; i = i.n)
    if (i.k == e)
      return i;
};
var IE = {
  getConstructor: function(n, e, t, i) {
    var r = n(function(s, a) {
      xM(s, r, e, "_i"), s._t = e, s._i = bM(null), s._f = void 0, s._l = void 0, s[zl] = 0, a != null && EM(a, t, s[i], s);
    });
    return CM(r.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function() {
        for (var a = Qa(this, e), l = a._i, d = a._f; d; d = d.n)
          d.r = true, d.p && (d.p = d.p.n = void 0), delete l[d.i];
        a._f = a._l = void 0, a[zl] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      delete: function(s) {
        var a = Qa(this, e), l = Ud(a, s);
        if (l) {
          var d = l.n, u = l.p;
          delete a._i[l.i], l.r = true, u && (u.n = d), d && (d.p = u), a._f == l && (a._f = d), a._l == l && (a._l = u), a[zl]--;
        }
        return !!l;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function(a) {
        Qa(this, e);
        for (var l = wM(a, arguments.length > 1 ? arguments[1] : void 0, 3), d; d = d ? d.n : this._f; )
          for (l(d.v, d.k, this); d && d.r; )
            d = d.p;
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function(a) {
        return !!Ud(Qa(this, e), a);
      }
    }), TE && SM(r.prototype, "size", {
      get: function() {
        return Qa(this, e)[zl];
      }
    }), r;
  },
  def: function(n, e, t) {
    var i = Ud(n, e), r, s;
    return i ? i.v = t : (n._l = i = {
      i: s = kE(e, true),
      // <- index
      k: e,
      // <- key
      v: t,
      // <- value
      p: r = n._l,
      // <- previous entry
      n: void 0,
      // <- next entry
      r: false
      // <- removed
    }, n._f || (n._f = i), r && (r.n = i), n[zl]++, s !== "F" && (n._i[s] = i)), n;
  },
  getEntry: Ud,
  setStrong: function(n, e, t) {
    TM(n, e, function(i, r) {
      this._t = Qa(i, e), this._k = r, this._l = void 0;
    }, function() {
      for (var i = this, r = i._k, s = i._l; s && s.r; )
        s = s.p;
      return !i._t || !(i._l = s = s ? s.n : i._t._f) ? (i._t = void 0, Fd(1)) : r == "keys" ? Fd(0, s.k) : r == "values" ? Fd(0, s.v) : Fd(0, [s.k, s.v]);
    }, t ? "entries" : "values", !t, true), kM(e);
  }
};
var IM = X_;
var bb = uFn;
var LM = K_("species");
var DM = function(n) {
  var e;
  return bb(n) && (e = n.constructor, typeof e == "function" && (e === Array || bb(e.prototype)) && (e = void 0), IM(e) && (e = e[LM], e === null && (e = void 0))), e === void 0 ? Array : e;
};
var PM = DM;
var AM = function(n, e) {
  return new (PM(n))(e);
};
var RM = Edt;
var MM = Fdt;
var NM = oRe;
var _M = wQn;
var OM = AM;
var Cv = function(n, e) {
  var t = n == 1, i = n == 2, r = n == 3, s = n == 4, a = n == 6, l = n == 5 || a, d = e || OM;
  return function(u, f, g) {
    for (var v = NM(u), y = MM(v), w = RM(f, g, 3), C = _M(y.length), b = 0, E = t ? d(u, C) : i ? d(u, 0) : void 0, L, R; C > b; b++)
      if ((l || b in y) && (L = y[b], R = w(L, b, v), n)) {
        if (t)
          E[b] = R;
        else if (R)
          switch (n) {
            case 3:
              return true;
            case 5:
              return L;
            case 6:
              return b;
            case 2:
              E.push(L);
          }
        else if (s)
          return false;
      }
    return a ? -1 : r || s ? s : E;
  };
};
var VM = fw;
var zd = Y_;
var BM = rFn;
var FM = k5;
var UM = P_;
var zM = bh;
var GM = jo;
var Cb = Ch;
var $M = X_;
var WM = cRe;
var HM = Gv.f;
var jM = Cv(0);
var JM = Vv;
var wh = function(n, e, t, i, r, s) {
  var a = VM[n], l = a, d = r ? "set" : "add", u = l && l.prototype, f = {};
  return !JM || typeof l != "function" || !(s || u.forEach && !FM(function() {
    new l().entries().next();
  })) ? (l = i.getConstructor(e, n, r, d), zM(l.prototype, t), BM.NEED = true) : (l = e(function(g, v) {
    Cb(g, l, n, "_c"), g._c = new a(), v != null && GM(v, r, g[d], g);
  }), jM("add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON".split(","), function(g) {
    var v = g == "add" || g == "set";
    g in u && !(s && g == "clear") && UM(l.prototype, g, function(y, w) {
      if (Cb(this, l, g), !v && s && !$M(y))
        return g == "get" ? void 0 : false;
      var C = this._c[g](y === 0 ? 0 : y, w);
      return v ? this : C;
    });
  }), s || HM(l.prototype, "size", {
    get: function() {
      return this._c.size;
    }
  })), WM(l, n), f[n] = l, zd(zd.G + zd.W + zd.F, f), s || i.setStrong(l, n, r), l;
};
var gp = IE;
var wb = ma;
var mp = "Map";
wh(mp, function(n) {
  return function() {
    return n(this, arguments.length > 0 ? arguments[0] : void 0);
  };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function(e) {
    var t = gp.getEntry(wb(this, mp), e);
    return t && t.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function(e, t) {
    return gp.def(wb(this, mp), e === 0 ? 0 : e, t);
  }
}, gp, true);
var vp;
var xb;
function YM() {
  if (xb)
    return vp;
  xb = 1;
  var n = jo;
  return vp = function(e, t) {
    var i = [];
    return n(e, false, i.push, i, t), i;
  }, vp;
}
var yp;
var Eb;
function LE() {
  if (Eb)
    return yp;
  Eb = 1;
  var n = Sh, e = YM();
  return yp = function(t) {
    return function() {
      if (n(this) != t)
        throw TypeError(t + "#toJSON isn't generic");
      return e(this);
    };
  }, yp;
}
var Sp = Y_;
Sp(Sp.P + Sp.R, "Map", { toJSON: LE()("Map") });
var Tb = Y_;
var xh = function(n) {
  Tb(Tb.S, n, { of: function() {
    for (var t = arguments.length, i = new Array(t); t--; )
      i[t] = arguments[t];
    return new this(i);
  } });
};
xh("Map");
var kb = Y_;
var Ib = gQn;
var qM = Edt;
var Lb = jo;
var Eh = function(n) {
  kb(kb.S, n, { from: function(t) {
    var i = arguments[1], r, s, a, l;
    return Ib(this), r = i !== void 0, r && Ib(i), t == null ? new this() : (s = [], r ? (a = 0, l = qM(i, arguments[2], 2), Lb(t, false, function(d) {
      s.push(l(d, a++));
    })) : Lb(t, false, s.push, s), new this(s));
  } });
};
Eh("Map");
var KM = xv.Map;
var ZM = { default: KM, __esModule: true };
var de = Gs(ZM);
var XM = Gv;
var QM = lie;
var eN = function(n, e, t) {
  e in n ? XM.f(n, e, QM(0, t)) : n[e] = t;
};
var bp;
var Db;
function DE() {
  if (Db)
    return bp;
  Db = 1;
  var n = K_("iterator"), e = false;
  try {
    var t = [7][n]();
    t.return = function() {
      e = true;
    }, Array.from(t, function() {
      throw 2;
    });
  } catch {
  }
  return bp = function(i, r) {
    if (!r && !e)
      return false;
    var s = false;
    try {
      var a = [7], l = a[n]();
      l.next = function() {
        return { done: s = true };
      }, a[n] = function() {
        return l;
      }, i(a);
    } catch {
    }
    return s;
  }, bp;
}
var tN = Edt;
var Cp = Y_;
var nN = oRe;
var iN = CE;
var rN = wE;
var sN = wQn;
var Pb = eN;
var aN = Sv;
Cp(Cp.S + Cp.F * !DE()(function(n) {
  Array.from(n);
}), "Array", {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function(e) {
    var t = nN(e), i = typeof this == "function" ? this : Array, r = arguments.length, s = r > 1 ? arguments[1] : void 0, a = s !== void 0, l = 0, d = aN(t), u, f, g, v;
    if (a && (s = tN(s, r > 2 ? arguments[2] : void 0, 2)), d != null && !(i == Array && rN(d)))
      for (v = d.call(t), f = new i(); !(g = v.next()).done; l++)
        Pb(f, l, a ? iN(v, s, [g.value, l], true) : g.value);
    else
      for (u = sN(t.length), f = new i(u); u > l; l++)
        Pb(f, l, a ? s(t[l], l) : t[l]);
    return f.length = l, f;
  }
});
var oN = xv.Array.from;
var PE = { default: oN, __esModule: true };
var De = Gs(PE);
var Ab = IE;
var lN = ma;
var Rb = "Set";
wh(Rb, function(n) {
  return function() {
    return n(this, arguments.length > 0 ? arguments[0] : void 0);
  };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function(e) {
    return Ab.def(lN(this, Rb), e = e === 0 ? 0 : e, e);
  }
}, Ab);
var wp = Y_;
wp(wp.P + wp.R, "Set", { toJSON: LE()("Set") });
xh("Set");
Eh("Set");
var cN = xv.Set;
var dN = { default: cN, __esModule: true };
var je = Gs(dN);
var Mb = xv;
var Nb = Mb.JSON || (Mb.JSON = { stringify: JSON.stringify });
var uN = function(e) {
  return Nb.stringify.apply(Nb, arguments);
};
var hN = { default: uN, __esModule: true };
var se = Gs(hN);
function AE(n, e) {
  let t = n.length, i = 0;
  for (let r = 0; r < t; ++r)
    e(n[r], r, n) && (n[i] = n[r], ++i);
  n.length = i;
}
function fN(n, e) {
  if (n.length === e)
    return n;
  let t = new n.constructor(e);
  return t.set(n), t;
}
function Tg(n, e, t, i) {
  const r = n.length / e, s = n.length * t * i, a = new n.constructor(s), l = n.length * i, d = e, u = e * i;
  for (let f = 0; f < r; ++f)
    for (let g = 0; g < e; ++g) {
      const v = n[f * e + g], y = f * u + g;
      for (let w = 0; w < t; ++w)
        for (let C = 0; C < i; ++C)
          a[w * l + C * d + y] = v;
    }
  return a;
}
function pN(n, e, t, i = 0, r = n.length) {
  for (; i < r; ) {
    const s = i + r - 1 >> 1, a = t(e, n[s]);
    if (a > 0)
      i = s + 1;
    else if (a < 0)
      r = s;
    else
      return s;
  }
  return ~i;
}
function gN(n, e, t) {
  let i = e - n;
  for (; i > 0; ) {
    let r = Math.floor(i / 2), s = n + r;
    t(s) ? i = r : (n = s + 1, i -= r + 1);
  }
  return n;
}
function mN(n, e) {
  const t = [];
  for (let i = 0, r = n.length; i < r; ++i)
    n[i] === e && t.push(i);
  return t;
}
function Fe(n, e) {
  const t = n.length;
  if (e.length !== t)
    return false;
  for (let i = 0; i < t; ++i)
    if (n[i] !== e[i])
      return false;
  return true;
}
function kg(n, e, t = (i, r) => i === r) {
  const i = n.length;
  if (e.length !== i)
    return false;
  for (let r = 0; r < i; ++r)
    if (!t(n[r], e[r]))
      return false;
  return true;
}
function vN(n, e, t) {
  const i = [];
  if (t === e) {
    for (let r = 0; r < n; ++r)
      i[r] = r;
    return i;
  }
  i[t] = e;
  for (let r = 0, s = 0; r < n; ) {
    if (r === e) {
      ++r;
      continue;
    }
    s === t && ++s, i[s++] = r++;
  }
  return i;
}
function _b(n, e, t) {
  for (let i = 0, r = t.length; i < r; ++i) {
    const s = t[i];
    s !== -1 && (n[i] = e[s]);
  }
  return n;
}
function Rc(n) {
  const e = [];
  for (let t = 0, i = n.length; t < i; ++t) {
    const r = n[t];
    for (let s = 0, a = r.length; s < a; ++s) {
      let l = e[s];
      l === void 0 && (l = e[s] = []), l.push(r[s]);
    }
  }
  return e;
}
function yN(n, e) {
  const t = [];
  let i = 0;
  for (let a = 0, l = e.length; a < l; ++a) {
    var r = e[a];
    const d = r.retainCount, u = r.deleteCount, f = r.insertCount;
    d !== 0 && (t.push(n.slice(i, i + d)), i += d), i += u, f !== 0 && t.push(new Array(f));
  }
  const s = n.length;
  return i !== s && t.push(n.slice(i)), new Array(0).concat(...t);
}
function SN(n, e, t) {
  const i = [];
  let r = 0, s = 0, a = n.length, l = e.length;
  for (; r < a && s < l; ) {
    let d, u = n[r], f = e[s];
    if (d = t(u, f), d === 0) {
      let g = 1;
      for (++r, ++s; r < a && s < l && (d = t(n[r], e[s])) === 0; )
        ++g, ++r, ++s;
      i.push({ retainCount: g, deleteCount: 0, insertCount: 0 });
      continue;
    }
    if (d < 0) {
      let g = 1;
      for (; ++r < a && (d = t(n[r], f)) < 0; )
        ++g;
      i.push({ retainCount: 0, deleteCount: g, insertCount: 0 });
      continue;
    }
    if (d > 0) {
      let g = 1;
      for (; ++s < l && (d = t(u, e[s])) > 0; )
        ++g;
      i.push({ retainCount: 0, deleteCount: 0, insertCount: g });
      continue;
    }
  }
  return (r < a || s < l) && i.push({ retainCount: 0, deleteCount: a - r, insertCount: l - s }), i;
}
function bN(n, e, t, i, r, s) {
  let a = 0, l = 0;
  if (n !== 0 && e !== 0)
    for (; ; ) {
      const d = t(a, l);
      if (d < 0) {
        if (i(a), ++a === n)
          break;
      } else if (d > 0) {
        if (r(l), ++l === e)
          break;
      } else if (s(a, l), ++a, ++l, a === n || l === e)
        break;
    }
  for (; a < n; )
    i(a), ++a;
  for (; l < e; )
    r(l), ++l;
}
var CN = lE;
var wN = function() {
  return CN.Date.now();
};
var xN = wN;
var EN = /\s/;
function TN(n) {
  for (var e = n.length; e-- && EN.test(n.charAt(e)); )
    ;
  return e;
}
var kN = TN;
var IN = kN;
var LN = /^\s+/;
function DN(n) {
  return n && n.slice(0, IN(n) + 1).replace(LN, "");
}
var PN = DN;
var AN = wne;
var RN = Gne;
var MN = "[object Symbol]";
function NN(n) {
  return typeof n == "symbol" || RN(n) && AN(n) == MN;
}
var _N = NN;
var ON = PN;
var Ob = Nct;
var VN = _N;
var Vb = 0 / 0;
var BN = /^[-+]0x[0-9a-f]+$/i;
var FN = /^0b[01]+$/i;
var UN = /^0o[0-7]+$/i;
var zN = parseInt;
function GN(n) {
  if (typeof n == "number")
    return n;
  if (VN(n))
    return Vb;
  if (Ob(n)) {
    var e = typeof n.valueOf == "function" ? n.valueOf() : n;
    n = Ob(e) ? e + "" : e;
  }
  if (typeof n != "string")
    return n === 0 ? n : +n;
  n = ON(n);
  var t = FN.test(n);
  return t || UN.test(n) ? zN(n.slice(2), t ? 2 : 8) : BN.test(n) ? Vb : +n;
}
var $N = GN;
var WN = Nct;
var xp = xN;
var Bb = $N;
var HN = "Expected a function";
var jN = Math.max;
var JN = Math.min;
function YN(n, e, t) {
  var i, r, s, a, l, d, u = 0, f = false, g = false, v = true;
  if (typeof n != "function")
    throw new TypeError(HN);
  e = Bb(e) || 0, WN(t) && (f = !!t.leading, g = "maxWait" in t, s = g ? jN(Bb(t.maxWait) || 0, e) : s, v = "trailing" in t ? !!t.trailing : v);
  function y(I) {
    var P = i, N = r;
    return i = r = void 0, u = I, a = n.apply(N, P), a;
  }
  function w(I) {
    return u = I, l = setTimeout(E, e), f ? y(I) : a;
  }
  function C(I) {
    var P = I - d, N = I - u, O = e - P;
    return g ? JN(O, s - N) : O;
  }
  function b(I) {
    var P = I - d, N = I - u;
    return d === void 0 || P >= e || P < 0 || g && N >= s;
  }
  function E() {
    var I = xp();
    if (b(I))
      return L(I);
    l = setTimeout(E, C(I));
  }
  function L(I) {
    return l = void 0, v && i ? y(I) : (i = r = void 0, a);
  }
  function R() {
    l !== void 0 && clearTimeout(l), u = 0, i = d = r = l = void 0;
  }
  function _() {
    return l === void 0 ? a : L(xp());
  }
  function A() {
    var I = xp(), P = b(I);
    if (i = arguments, r = this, d = I, P) {
      if (l === void 0)
        return w(d);
      if (g)
        return clearTimeout(l), l = setTimeout(E, e), y(d);
    }
    return l === void 0 && (l = setTimeout(E, e)), a;
  }
  return A.cancel = R, A.flush = _, A;
}
var RE = YN;
var lt = Gs(RE);
function ME(n) {
  typeof n == "object" ? n.dispose() : n();
}
function Co(n) {
  for (let e = n.length; e > 0; --e)
    ME(n[e - 1]);
}
function Vi(n, e, t, i) {
  return n.addEventListener(e, t, i), () => n.removeEventListener(e, t, i);
}
var Z = class {
  constructor() {
    this.refCount = 1;
  }
  addRef() {
    return ++this.refCount, this;
  }
  dispose() {
    --this.refCount === 0 && this.refCountReachedZero();
  }
  refCountReachedZero() {
    this.disposed();
    let e = this.disposers;
    e !== void 0 && (Co(e), this.disposers = void 0), this.wasDisposed = true;
  }
  disposed() {
  }
  registerDisposer(e) {
    let t = this.disposers;
    return t == null ? this.disposers = [e] : t.push(e), e;
  }
  unregisterDisposer(e) {
    let t = this.disposers;
    if (t != null) {
      let i = t.indexOf(e);
      i !== -1 && t.splice(i, 1);
    }
    return e;
  }
  registerEventListener(e, t, i, r) {
    this.registerDisposer(Vi(e, t, i, r));
  }
  registerCancellable(e) {
    return this.registerDisposer(() => {
      e.cancel();
    }), e;
  }
};
var NE = class extends Z {
  constructor(e) {
    super(), this.value = e;
  }
};
function _E(n) {
  return () => {
    if (n !== void 0) {
      let e = n;
      n = void 0, ME(e);
    }
  };
}
var ot = class {
  constructor() {
    this.handlers = new je(), this.count = 0;
    const e = this;
    this.dispatch = function() {
      ++e.count, e.handlers.forEach((t) => {
        t.apply(this, arguments);
      });
    };
  }
  /**
   * Add a handler function.  If `dispatch` is currently be called, then the new handler will be
   * called before `dispatch` returns.
   *
   * @param handler The handler function to add.
   *
   * @return A function that unregisters the handler.
   */
  add(e) {
    return this.handlers.add(e), () => this.remove(e);
  }
  /**
   * Remove a handler function.  If `dispatch` is currently be called and the new handler has not
   * yet been called, then it will not be called.
   *
   * @param handler Handler to remove.
   * @return `true` if the handler was present, `false` otherwise.
   */
  remove(e) {
    return this.handlers.delete(e);
  }
  /**
   * Disposes of resources.  No methods, including `dispatch`, may be invoked afterwards.
   */
  dispose() {
    this.handlers = void 0;
  }
};
var Ee = class extends ot {
};
var OE = {
  count: 0,
  add(n) {
    return () => {
    };
  },
  remove(n) {
    return false;
  }
};
var gt = class {
  constructor(e) {
    this.value_ = e, this.changed = new Ee();
  }
  get value() {
    return this.value_;
  }
  set value(e) {
    e !== this.value_ && (this.value_ = e, this.changed.dispatch());
  }
};
var hn = class extends gt {
  constructor(e, t, i = e) {
    super(e), this.validator = t, this.defaultValue = i;
  }
  toJSON() {
    if (this.value_ !== this.defaultValue)
      return this.value_;
  }
  reset() {
    this.value = this.defaultValue;
  }
  restoreState(e) {
    if (e !== void 0) {
      let t = this.validator;
      try {
        this.value = t(e);
        return;
      } catch {
      }
    }
    this.value = this.defaultValue;
  }
};
var VE = class extends Z {
  constructor(e, t) {
    super(), this.changed = new Ee(), this.f = e, this.ws = t;
    for (const i of t)
      this.registerDisposer(i.changed.add(this.changed.dispatch));
  }
  get value() {
    return this.f(...this.ws.map((e) => e.value));
  }
};
function Fb(n, ...e) {
  return new VE(n, e);
}
var qN = class extends Z {
  constructor(e, t) {
    super(), this.changed = new Ee(), this.valueGeneration = -1, this.f = e, this.ws = t;
    for (const i of t)
      this.registerDisposer(i.changed.add(this.changed.dispatch));
  }
  get value() {
    const e = this.changed.count;
    return e !== this.valueGeneration && (this.value_ = this.f(...this.ws.map((t) => t.value)), this.valueGeneration = e), this.value_;
  }
};
function rr(n, ...e) {
  return new qN(n, e);
}
var BE = class extends Z {
  constructor(e, t = (i, r) => i === r) {
    super(), this.changed = new ot(), this.value = e.value, this.registerDisposer(e.changed.add(() => {
      const i = e.value;
      t(this.value, i) || (this.value = i, this.changed.dispatch());
    }));
  }
};
function wi(n, e, t) {
  const i = new VE(n, e), r = new BE(i, t);
  return r.registerDisposer(i), r;
}
var FE = class extends Z {
  constructor(e) {
    super(), this.changed = new Ee();
    const t = e(this), i = un(t), r = () => {
      const s = Array.isArray(t) ? [] : {};
      for (const a of i)
        s[a] = t[a].value;
      this.value = s, this.changed.dispatch();
    };
    r();
    for (const s of i) {
      const a = t[s];
      this.registerDisposer(a.changed.add(() => r()));
    }
  }
};
var KN = class {
  constructor(e) {
    this.changed = new Ee(), e === void 0 ? this.values = new je() : this.values = new je(e);
  }
  add(e) {
    const t = this.values;
    return t.has(e) || (t.add(e), this.changed.dispatch()), this;
  }
  delete(e) {
    return this.values.delete(e) ? (this.changed.dispatch(), true) : false;
  }
  has(e) {
    return this.values.has(e);
  }
  get size() {
    return this.values.size;
  }
  [wZr]() {
    return bv(this.values);
  }
  clear() {
    const e = this.values;
    e.size > 0 && (e.clear(), this.changed.dispatch());
  }
};
function Ur(n, ...e) {
  let t = e.map((d) => d.value);
  const i = e.length;
  let r = new Z(), s = n(r, ...t);
  const a = lt(() => {
    let d = false;
    for (let u = 0; u < i; ++u) {
      const g = e[u].value;
      t[u] !== g && (t[u] = g, d = true);
    }
    d && (r.dispose(), r = new Z(), s = n(r, ...t));
  }, 0), l = e.map((d) => d.changed.add(a));
  return {
    flush() {
      a.flush();
    },
    dispose() {
      a.cancel(), Co(l), r.dispose();
    },
    get value() {
      return a.flush(), s;
    }
  };
}
function wo(n, ...e) {
  let t = e.map((d) => d.value);
  const i = e.length;
  let r = new Z(), s = n(r, ...t);
  const a = () => {
    let d = false;
    for (let u = 0; u < i; ++u) {
      const g = e[u].value;
      t[u] !== g && (t[u] = g, d = true);
    }
    d && (r.dispose(), r = new Z(), s = n(r, ...t));
  }, l = e.map((d) => d.changed.add(a));
  return {
    dispose() {
      Co(l), r.dispose();
    },
    get value() {
      return s;
    }
  };
}
function oa(n) {
  return { changed: OE, value: n };
}
function Vr(n, e) {
  return n(e.value), e.changed.add(() => n(e.value));
}
var ou = class {
  constructor(e, t) {
    this.outer = e, this.getInner = t, this.changed = new Ee(), this.update = () => {
      const i = this.disposer, r = this.outer;
      i !== void 0 && i();
      const s = this.inner = this.getInner(r.value);
      this.disposer = s.changed.add(this.changed.dispatch), this.changed.dispatch();
    }, e.changed.add(this.update), this.update();
  }
  dispose() {
    this.outer.changed.remove(this.update), this.disposer();
  }
  get value() {
    return this.inner.value;
  }
  set value(e) {
    this.inner.value = e;
  }
};
var Ep = class extends ou {
  reset() {
    this.inner.reset();
  }
  restoreState(e) {
    this.inner.restoreState(e);
  }
  toJSON() {
    return this.inner.toJSON();
  }
};
var Gd = new Float32Array(1);
function ZN(n) {
  Gd[0] = n, n = Gd[0];
  for (let e = 1; e < 21; ++e) {
    let t = n.toPrecision(e);
    if (Gd[0] = parseFloat(t), Gd[0] === n)
      return t;
  }
  return n.toString();
}
var lu = 1e-6;
var Rn = typeof Float32Array < "u" ? Float32Array : Array;
Math.hypot || (Math.hypot = function() {
  for (var n = 0, e = arguments.length; e--; )
    n += arguments[e] * arguments[e];
  return Math.sqrt(n);
});
function Mc() {
  var n = new Rn(9);
  return Rn != Float32Array && (n[1] = 0, n[2] = 0, n[3] = 0, n[5] = 0, n[6] = 0, n[7] = 0), n[0] = 1, n[4] = 1, n[8] = 1, n;
}
function XN(n, e) {
  if (n === e) {
    var t = e[1], i = e[2], r = e[5];
    n[1] = e[3], n[2] = e[6], n[3] = t, n[5] = e[7], n[6] = i, n[7] = r;
  } else
    n[0] = e[0], n[1] = e[3], n[2] = e[6], n[3] = e[1], n[4] = e[4], n[5] = e[7], n[6] = e[2], n[7] = e[5], n[8] = e[8];
  return n;
}
function QN(n, e) {
  var t = e[0], i = e[1], r = e[2], s = e[3], a = e[4], l = e[5], d = e[6], u = e[7], f = e[8], g = f * a - l * u, v = -f * s + l * d, y = u * s - a * d, w = t * g + i * v + r * y;
  return w ? (w = 1 / w, n[0] = g * w, n[1] = (-f * i + r * u) * w, n[2] = (l * i - r * a) * w, n[3] = v * w, n[4] = (f * t - r * d) * w, n[5] = (-l * t + r * s) * w, n[6] = y * w, n[7] = (-u * t + i * d) * w, n[8] = (a * t - i * s) * w, n) : null;
}
function wv(n) {
  var e = n[0], t = n[1], i = n[2], r = n[3], s = n[4], a = n[5], l = n[6], d = n[7], u = n[8];
  return e * (u * s - a * d) + t * (-u * r + a * l) + i * (d * r - s * l);
}
function UE(n, e) {
  var t = e[0], i = e[1], r = e[2], s = e[3], a = t + t, l = i + i, d = r + r, u = t * a, f = i * a, g = i * l, v = r * a, y = r * l, w = r * d, C = s * a, b = s * l, E = s * d;
  return n[0] = 1 - g - w, n[3] = f - E, n[6] = v + b, n[1] = f + E, n[4] = 1 - u - w, n[7] = y - C, n[2] = v - b, n[5] = y + C, n[8] = 1 - u - g, n;
}
function et() {
  var n = new Rn(16);
  return Rn != Float32Array && (n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0), n[0] = 1, n[5] = 1, n[10] = 1, n[15] = 1, n;
}
function e_(n) {
  var e = new Rn(16);
  return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], e;
}
function Cu(n, e) {
  return n[0] = e[0], n[1] = e[1], n[2] = e[2], n[3] = e[3], n[4] = e[4], n[5] = e[5], n[6] = e[6], n[7] = e[7], n[8] = e[8], n[9] = e[9], n[10] = e[10], n[11] = e[11], n[12] = e[12], n[13] = e[13], n[14] = e[14], n[15] = e[15], n;
}
function zE(n) {
  return n[0] = 1, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = 1, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[10] = 1, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, n;
}
function xv2(n, e) {
  if (n === e) {
    var t = e[1], i = e[2], r = e[3], s = e[6], a = e[7], l = e[11];
    n[1] = e[4], n[2] = e[8], n[3] = e[12], n[4] = t, n[6] = e[9], n[7] = e[13], n[8] = i, n[9] = s, n[11] = e[14], n[12] = r, n[13] = a, n[14] = l;
  } else
    n[0] = e[0], n[1] = e[4], n[2] = e[8], n[3] = e[12], n[4] = e[1], n[5] = e[5], n[6] = e[9], n[7] = e[13], n[8] = e[2], n[9] = e[6], n[10] = e[10], n[11] = e[14], n[12] = e[3], n[13] = e[7], n[14] = e[11], n[15] = e[15];
  return n;
}
function xs(n, e) {
  var t = e[0], i = e[1], r = e[2], s = e[3], a = e[4], l = e[5], d = e[6], u = e[7], f = e[8], g = e[9], v = e[10], y = e[11], w = e[12], C = e[13], b = e[14], E = e[15], L = t * l - i * a, R = t * d - r * a, _ = t * u - s * a, A = i * d - r * l, I = i * u - s * l, P = r * u - s * d, N = f * C - g * w, O = f * b - v * w, B = f * E - y * w, j = g * b - v * C, U = g * E - y * C, V = v * E - y * b, G = L * V - R * U + _ * j + A * B - I * O + P * N;
  return G ? (G = 1 / G, n[0] = (l * V - d * U + u * j) * G, n[1] = (r * U - i * V - s * j) * G, n[2] = (C * P - b * I + E * A) * G, n[3] = (v * I - g * P - y * A) * G, n[4] = (d * B - a * V - u * O) * G, n[5] = (t * V - r * B + s * O) * G, n[6] = (b * _ - w * P - E * R) * G, n[7] = (f * P - v * _ + y * R) * G, n[8] = (a * U - l * B + u * N) * G, n[9] = (i * B - t * U - s * N) * G, n[10] = (w * I - C * _ + E * L) * G, n[11] = (g * _ - f * I - y * L) * G, n[12] = (l * O - a * j - d * N) * G, n[13] = (t * j - i * O + r * N) * G, n[14] = (C * R - w * A - b * L) * G, n[15] = (f * A - g * R + v * L) * G, n) : null;
}
function mn(n, e, t) {
  var i = e[0], r = e[1], s = e[2], a = e[3], l = e[4], d = e[5], u = e[6], f = e[7], g = e[8], v = e[9], y = e[10], w = e[11], C = e[12], b = e[13], E = e[14], L = e[15], R = t[0], _ = t[1], A = t[2], I = t[3];
  return n[0] = R * i + _ * l + A * g + I * C, n[1] = R * r + _ * d + A * v + I * b, n[2] = R * s + _ * u + A * y + I * E, n[3] = R * a + _ * f + A * w + I * L, R = t[4], _ = t[5], A = t[6], I = t[7], n[4] = R * i + _ * l + A * g + I * C, n[5] = R * r + _ * d + A * v + I * b, n[6] = R * s + _ * u + A * y + I * E, n[7] = R * a + _ * f + A * w + I * L, R = t[8], _ = t[9], A = t[10], I = t[11], n[8] = R * i + _ * l + A * g + I * C, n[9] = R * r + _ * d + A * v + I * b, n[10] = R * s + _ * u + A * y + I * E, n[11] = R * a + _ * f + A * w + I * L, R = t[12], _ = t[13], A = t[14], I = t[15], n[12] = R * i + _ * l + A * g + I * C, n[13] = R * r + _ * d + A * v + I * b, n[14] = R * s + _ * u + A * y + I * E, n[15] = R * a + _ * f + A * w + I * L, n;
}
function t_(n, e, t) {
  var i = t[0], r = t[1], s = t[2], a, l, d, u, f, g, v, y, w, C, b, E;
  return e === n ? (n[12] = e[0] * i + e[4] * r + e[8] * s + e[12], n[13] = e[1] * i + e[5] * r + e[9] * s + e[13], n[14] = e[2] * i + e[6] * r + e[10] * s + e[14], n[15] = e[3] * i + e[7] * r + e[11] * s + e[15]) : (a = e[0], l = e[1], d = e[2], u = e[3], f = e[4], g = e[5], v = e[6], y = e[7], w = e[8], C = e[9], b = e[10], E = e[11], n[0] = a, n[1] = l, n[2] = d, n[3] = u, n[4] = f, n[5] = g, n[6] = v, n[7] = y, n[8] = w, n[9] = C, n[10] = b, n[11] = E, n[12] = a * i + f * r + w * s + e[12], n[13] = l * i + g * r + C * s + e[13], n[14] = d * i + v * r + b * s + e[14], n[15] = u * i + y * r + E * s + e[15]), n;
}
function n_(n, e, t) {
  var i = t[0], r = t[1], s = t[2];
  return n[0] = e[0] * i, n[1] = e[1] * i, n[2] = e[2] * i, n[3] = e[3] * i, n[4] = e[4] * r, n[5] = e[5] * r, n[6] = e[6] * r, n[7] = e[7] * r, n[8] = e[8] * s, n[9] = e[9] * s, n[10] = e[10] * s, n[11] = e[11] * s, n[12] = e[12], n[13] = e[13], n[14] = e[14], n[15] = e[15], n;
}
function i_(n, e, t, i) {
  var r = e[0], s = e[1], a = e[2], l = e[3], d = r + r, u = s + s, f = a + a, g = r * d, v = r * u, y = r * f, w = s * u, C = s * f, b = a * f, E = l * d, L = l * u, R = l * f, _ = i[0], A = i[1], I = i[2];
  return n[0] = (1 - (w + b)) * _, n[1] = (v + R) * _, n[2] = (y - L) * _, n[3] = 0, n[4] = (v - R) * A, n[5] = (1 - (g + b)) * A, n[6] = (C + E) * A, n[7] = 0, n[8] = (y + L) * I, n[9] = (C - E) * I, n[10] = (1 - (g + w)) * I, n[11] = 0, n[12] = t[0], n[13] = t[1], n[14] = t[2], n[15] = 1, n;
}
function r_(n, e) {
  var t = e[0], i = e[1], r = e[2], s = e[3], a = t + t, l = i + i, d = r + r, u = t * a, f = i * a, g = i * l, v = r * a, y = r * l, w = r * d, C = s * a, b = s * l, E = s * d;
  return n[0] = 1 - g - w, n[1] = f + E, n[2] = v - b, n[3] = 0, n[4] = f - E, n[5] = 1 - u - w, n[6] = y + C, n[7] = 0, n[8] = v + b, n[9] = y - C, n[10] = 1 - u - g, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, n;
}
function s_(n, e, t, i, r) {
  var s = 1 / Math.tan(e / 2), a;
  return n[0] = s / t, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = s, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[11] = -1, n[12] = 0, n[13] = 0, n[15] = 0, r != null && r !== 1 / 0 ? (a = 1 / (i - r), n[10] = (r + i) * a, n[14] = 2 * r * i * a) : (n[10] = -1, n[14] = -2 * i), n;
}
function GE(n, e, t, i, r, s, a) {
  var l = 1 / (e - t), d = 1 / (i - r), u = 1 / (s - a);
  return n[0] = -2 * l, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = -2 * d, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[10] = 2 * u, n[11] = 0, n[12] = (e + t) * l, n[13] = (r + i) * d, n[14] = (a + s) * u, n[15] = 1, n;
}
function _e() {
  var n = new Rn(3);
  return Rn != Float32Array && (n[0] = 0, n[1] = 0, n[2] = 0), n;
}
function Ig(n) {
  var e = new Rn(3);
  return e[0] = n[0], e[1] = n[1], e[2] = n[2], e;
}
function a_(n) {
  var e = n[0], t = n[1], i = n[2];
  return Math.hypot(e, t, i);
}
function St(n, e, t) {
  var i = new Rn(3);
  return i[0] = n, i[1] = e, i[2] = t, i;
}
function o_(n, e) {
  return n[0] = e[0], n[1] = e[1], n[2] = e[2], n;
}
function Lg(n, e, t, i) {
  return n[0] = e, n[1] = t, n[2] = i, n;
}
function $E(n, e, t) {
  return n[0] = e[0] + t[0], n[1] = e[1] + t[1], n[2] = e[2] + t[2], n;
}
function WE(n, e, t) {
  return n[0] = e[0] - t[0], n[1] = e[1] - t[1], n[2] = e[2] - t[2], n;
}
function HE(n, e, t) {
  return n[0] = e[0] * t[0], n[1] = e[1] * t[1], n[2] = e[2] * t[2], n;
}
function Dg(n, e, t) {
  return n[0] = e[0] / t[0], n[1] = e[1] / t[1], n[2] = e[2] / t[2], n;
}
function Ub(n, e) {
  return n[0] = Math.ceil(e[0]), n[1] = Math.ceil(e[1]), n[2] = Math.ceil(e[2]), n;
}
function Ev(n, e, t) {
  return n[0] = e[0] * t, n[1] = e[1] * t, n[2] = e[2] * t, n;
}
function wu(n, e) {
  var t = e[0], i = e[1], r = e[2], s = t * t + i * i + r * r;
  return s > 0 && (s = 1 / Math.sqrt(s)), n[0] = e[0] * s, n[1] = e[1] * s, n[2] = e[2] * s, n;
}
function Tv(n, e) {
  return n[0] * e[0] + n[1] * e[1] + n[2] * e[2];
}
function Tp(n, e, t) {
  var i = e[0], r = e[1], s = e[2], a = t[0], l = t[1], d = t[2];
  return n[0] = r * d - s * l, n[1] = s * a - i * d, n[2] = i * l - r * a, n;
}
function Si(n, e, t) {
  var i = e[0], r = e[1], s = e[2], a = t[3] * i + t[7] * r + t[11] * s + t[15];
  return a = a || 1, n[0] = (t[0] * i + t[4] * r + t[8] * s + t[12]) / a, n[1] = (t[1] * i + t[5] * r + t[9] * s + t[13]) / a, n[2] = (t[2] * i + t[6] * r + t[10] * s + t[14]) / a, n;
}
function po(n, e, t) {
  var i = t[0], r = t[1], s = t[2], a = t[3], l = e[0], d = e[1], u = e[2], f = r * u - s * d, g = s * l - i * u, v = i * d - r * l, y = r * v - s * g, w = s * f - i * v, C = i * g - r * f, b = a * 2;
  return f *= b, g *= b, v *= b, y *= 2, w *= 2, C *= 2, n[0] = l + f + y, n[1] = d + g + w, n[2] = u + v + C, n;
}
function Pg(n, e) {
  var t = n[0], i = n[1], r = n[2], s = e[0], a = e[1], l = e[2];
  return Math.abs(t - s) <= lu * Math.max(1, Math.abs(t), Math.abs(s)) && Math.abs(i - a) <= lu * Math.max(1, Math.abs(i), Math.abs(a)) && Math.abs(r - l) <= lu * Math.max(1, Math.abs(r), Math.abs(l));
}
var l_ = WE;
var c_ = a_;
(function() {
  var n = _e();
  return function(e, t, i, r, s, a) {
    var l, d;
    for (t || (t = 3), i || (i = 0), r ? d = Math.min(r * t + i, e.length) : d = e.length, l = i; l < d; l += t)
      n[0] = e[l], n[1] = e[l + 1], n[2] = e[l + 2], s(n, n, a), e[l] = n[0], e[l + 1] = n[1], e[l + 2] = n[2];
    return e;
  };
})();
function Th() {
  var n = new Rn(4);
  return Rn != Float32Array && (n[0] = 0, n[1] = 0, n[2] = 0, n[3] = 0), n;
}
function Nc(n, e, t, i) {
  var r = new Rn(4);
  return r[0] = n, r[1] = e, r[2] = t, r[3] = i, r;
}
function d_(n, e) {
  return n[0] = e[0], n[1] = e[1], n[2] = e[2], n[3] = e[3], n;
}
function u_(n, e) {
  var t = e[0], i = e[1], r = e[2], s = e[3], a = t * t + i * i + r * r + s * s;
  return a > 0 && (a = 1 / Math.sqrt(a)), n[0] = t * a, n[1] = i * a, n[2] = r * a, n[3] = s * a, n;
}
(function() {
  var n = Th();
  return function(e, t, i, r, s, a) {
    var l, d;
    for (t || (t = 4), i || (i = 0), r ? d = Math.min(r * t + i, e.length) : d = e.length, l = i; l < d; l += t)
      n[0] = e[l], n[1] = e[l + 1], n[2] = e[l + 2], n[3] = e[l + 3], s(n, n, a), e[l] = n[0], e[l + 1] = n[1], e[l + 2] = n[2], e[l + 3] = n[3];
    return e;
  };
})();
function $n() {
  var n = new Rn(4);
  return Rn != Float32Array && (n[0] = 0, n[1] = 0, n[2] = 0), n[3] = 1, n;
}
function zb(n) {
  return n[0] = 0, n[1] = 0, n[2] = 0, n[3] = 1, n;
}
function Ag(n, e, t) {
  t = t * 0.5;
  var i = Math.sin(t);
  return n[0] = i * e[0], n[1] = i * e[1], n[2] = i * e[2], n[3] = Math.cos(t), n;
}
function ys(n, e, t) {
  var i = e[0], r = e[1], s = e[2], a = e[3], l = t[0], d = t[1], u = t[2], f = t[3];
  return n[0] = i * f + a * l + r * u - s * d, n[1] = r * f + a * d + s * l - i * u, n[2] = s * f + a * u + i * d - r * l, n[3] = a * f - i * l - r * d - s * u, n;
}
function h_(n, e, t) {
  t *= 0.5;
  var i = e[0], r = e[1], s = e[2], a = e[3], l = Math.sin(t), d = Math.cos(t);
  return n[0] = i * d + a * l, n[1] = r * d + s * l, n[2] = s * d - r * l, n[3] = a * d - i * l, n;
}
function f_(n, e, t) {
  t *= 0.5;
  var i = e[0], r = e[1], s = e[2], a = e[3], l = Math.sin(t), d = Math.cos(t);
  return n[0] = i * d - s * l, n[1] = r * d + a * l, n[2] = s * d + i * l, n[3] = a * d - r * l, n;
}
function kp(n, e, t, i) {
  var r = e[0], s = e[1], a = e[2], l = e[3], d = t[0], u = t[1], f = t[2], g = t[3], v, y, w, C, b;
  return y = r * d + s * u + a * f + l * g, y < 0 && (y = -y, d = -d, u = -u, f = -f, g = -g), 1 - y > lu ? (v = Math.acos(y), w = Math.sin(v), C = Math.sin((1 - i) * v) / w, b = Math.sin(i * v) / w) : (C = 1 - i, b = i), n[0] = C * r + b * d, n[1] = C * s + b * u, n[2] = C * a + b * f, n[3] = C * l + b * g, n;
}
function xu(n, e) {
  var t = e[0], i = e[1], r = e[2], s = e[3], a = t * t + i * i + r * r + s * s, l = a ? 1 / a : 0;
  return n[0] = -t * l, n[1] = -i * l, n[2] = -r * l, n[3] = s * l, n;
}
function jE(n, e) {
  var t = e[0] + e[4] + e[8], i;
  if (t > 0)
    i = Math.sqrt(t + 1), n[3] = 0.5 * i, i = 0.5 / i, n[0] = (e[5] - e[7]) * i, n[1] = (e[6] - e[2]) * i, n[2] = (e[1] - e[3]) * i;
  else {
    var r = 0;
    e[4] > e[0] && (r = 1), e[8] > e[r * 3 + r] && (r = 2);
    var s = (r + 1) % 3, a = (r + 2) % 3;
    i = Math.sqrt(e[r * 3 + r] - e[s * 3 + s] - e[a * 3 + a] + 1), n[r] = 0.5 * i, i = 0.5 / i, n[3] = (e[s * 3 + a] - e[a * 3 + s]) * i, n[s] = (e[s * 3 + r] + e[r * 3 + s]) * i, n[a] = (e[a * 3 + r] + e[r * 3 + a]) * i;
  }
  return n;
}
var p_ = d_;
var dc = u_;
(function() {
  var n = _e(), e = St(1, 0, 0), t = St(0, 1, 0);
  return function(i, r, s) {
    var a = Tv(r, s);
    return a < -0.999999 ? (Tp(n, e, r), c_(n) < 1e-6 && Tp(n, t, r), wu(n, n), Ag(i, n, Math.PI), i) : a > 0.999999 ? (i[0] = 0, i[1] = 0, i[2] = 0, i[3] = 1, i) : (Tp(n, r, s), i[0] = n[0], i[1] = n[1], i[2] = n[2], i[3] = 1 + a, dc(i, i));
  };
})();
(function() {
  var n = $n(), e = $n();
  return function(t, i, r, s, a, l) {
    return kp(n, i, a, l), kp(e, r, s, l), kp(t, n, e, 2 * l * (1 - l)), t;
  };
})();
(function() {
  var n = Mc();
  return function(e, t, i, r) {
    return n[0] = i[0], n[3] = i[1], n[6] = i[2], n[1] = r[0], n[4] = r[1], n[7] = r[2], n[2] = -t[0], n[5] = -t[1], n[8] = -t[2], dc(e, jE(e, n));
  };
})();
function JE() {
  var n = new Rn(2);
  return Rn != Float32Array && (n[0] = 0, n[1] = 0), n;
}
function g_(n, e, t) {
  return n[0] = e, n[1] = t, n;
}
function m_(n, e, t) {
  return n[0] = e[0] + t[0], n[1] = e[1] + t[1], n;
}
(function() {
  var n = JE();
  return function(e, t, i, r, s, a) {
    var l, d;
    for (t || (t = 2), i || (i = 0), r ? d = Math.min(r * t + i, e.length) : d = e.length, l = i; l < d; l += t)
      n[0] = e[l], n[1] = e[l + 1], s(n, n, a), e[l] = n[0], e[l + 1] = n[1];
    return e;
  };
})();
var YE = et();
var v_ = ["x", "y", "z"];
var Xi = [St(1, 0, 0), St(0, 1, 0), St(0, 0, 1)];
St(0, 0, 0);
var Rg = Nc(0, 0, 0, 0);
var qE = St(1, 1, 1);
St(1 / 0, 1 / 0, 1 / 0);
$n();
function Mg(n) {
  return n[0] * n[1] * n[2];
}
function Ng(n) {
  return `${n[0]},${n[1]},${n[2]}`;
}
function y_(n, e, t) {
  let i = e[0], r = e[1], s = e[2];
  return n[0] = t[0] * i + t[4] * r + t[8] * s, n[1] = t[1] * i + t[5] * r + t[9] * s, n[2] = t[2] * i + t[6] * r + t[10] * s, n;
}
function KE(n, e, t) {
  let i = e[0], r = e[1], s = e[2];
  return n[0] = t[0] * i + t[1] * r + t[2] * s, n[1] = t[4] * i + t[5] * r + t[6] * s, n[2] = t[8] * i + t[9] * r + t[10] * s, n;
}
function S_(n, e, t) {
  const i = t.length;
  let r = 0;
  for (let a = 0; a < i; ++a)
    r += (n[a] - e[a]) ** 2;
  let s = 0;
  for (let a = 0; a < i; ++a) {
    const l = n[a];
    s -= (l - t[a]) * (e[a] - l);
  }
  return s / Math.max(r, 1e-6);
}
function ZE(n, e, t, i) {
  const r = n.length;
  let s = S_(e, t, i);
  s = Math.max(0, Math.min(1, s));
  for (let a = 0; a < r; ++a) {
    const l = e[a];
    n[a] = l + s * (t[a] - l);
  }
  return n;
}
function kh(n, e) {
  const t = e[0], i = e[1], r = e[2], s = e[4], a = e[5], l = e[6], d = e[8], u = e[9], f = e[10];
  return n[0] = t, n[1] = i, n[2] = r, n[3] = s, n[4] = a, n[5] = l, n[6] = d, n[7] = u, n[8] = f, n;
}
function Eu(n, e) {
  const t = e[0], i = e[1], r = e[2], s = e[3], a = e[4], l = e[5], d = e[6], u = e[7], f = e[8], g = e[9], v = e[10], y = e[11], w = e[12], C = e[13], b = e[14], E = e[15];
  n[0] = s + t, n[1] = u + a, n[2] = y + f, n[3] = E + w, n[4] = s - t, n[5] = u - a, n[6] = y - f, n[7] = E - w, n[8] = s + i, n[9] = u + l, n[10] = y + g, n[11] = E + C, n[12] = s - i, n[13] = u - l, n[14] = y - g, n[15] = E - C;
  const L = s + r, R = u + d, _ = y + v, A = E + b, I = s - r, P = u - d, N = y - v, O = E - b, B = Math.sqrt(L ** 2 + R ** 2 + _ ** 2);
  n[16] = L / B, n[17] = R / B, n[18] = _ / B, n[19] = A / B;
  const j = Math.sqrt(I ** 2 + P ** 2 + N ** 2);
  return n[20] = I / j, n[21] = P / j, n[22] = N / j, n[23] = O / j, n;
}
function XE(n, e, t, i, r, s, a) {
  for (let l = 0; l < 6; ++l) {
    const d = a[l * 4], u = a[l * 4 + 1], f = a[l * 4 + 2], g = a[l * 4 + 3];
    if (Math.max(d * n, d * i) + Math.max(u * e, u * r) + Math.max(f * t, f * s) + g < 0)
      return false;
  }
  return true;
}
function b_(n, e, t, i, r, s, a) {
  for (let l = 0; l < 4; ++l) {
    const d = a[l * 4], u = a[l * 4 + 1], f = a[l * 4 + 2], g = a[l * 4 + 3];
    if (Math.max(d * n, d * i) + Math.max(u * e, u * r) + Math.max(f * t, f * s) + g < 0)
      return false;
  }
  {
    const d = a[20], u = a[5 * 4 + 1], f = a[5 * 4 + 2], g = a[5 * 4 + 3], v = Math.max(d * n, d * i) + Math.max(u * e, u * r) + Math.max(f * t, f * s), y = Math.min(d * n, d * i) + Math.min(u * e, u * r) + Math.min(f * t, f * s), w = Math.abs(g) * 1e-6;
    if (y > -g + w || v < -g - w)
      return false;
  }
  return true;
}
function Ih(n, e, t, i = false) {
  const r = t.length, s = [], a = i ? 1 : e + 1, l = i ? e + 1 : 1;
  for (let d = 0; d < r; ++d) {
    const u = t[d];
    for (let f = 0; f < e; ++f)
      n[f * a + u * l] !== 0 && (s[f] = true);
  }
  return mN(s, true);
}
function QE(n, e, t) {
  for (let i = 0; i < 3; ++i) {
    const r = t[i];
    for (let s = 0; s < 3; ++s)
      n[i + s * 3] = r * e[i + s * 3];
  }
  return n;
}
function C_(n) {
  if (n[15] === 1) {
    const a = 2 / Math.abs(n[10]), l = 2 / Math.abs(n[0]), d = 2 / Math.abs(n[5]);
    return l * d * a;
  }
  const e = n[10], i = 2 * n[14] / (2 * e - 2), r = (e - 1) * i / (e + 1);
  return 4 / (n[0] * n[5]) / 3 * (Math.abs(r) ** 3 - Math.abs(i) ** 3);
}
function e1(n) {
  if (n[15] === 1)
    return 2 / Math.abs(n[10]);
  const e = n[10], i = 2 * n[14] / (2 * e - 2), r = (e - 1) * i / (e + 1);
  return Math.abs(r - i);
}
function w_(n) {
  return n[2] = 0, n[6] = 0, n[10] = 0, n[14] = 0, n;
}
var eo = _e();
function x_(n, e) {
  e[0] = e[1] = e[2] = Number.POSITIVE_INFINITY, e[3] = e[4] = e[5] = Number.NEGATIVE_INFINITY;
  for (let t = 0; t < 8; ++t) {
    eo[0] = 2 * (t & 1) - 1, eo[1] = 2 * (t >>> 1 & 1) - 1, eo[2] = 2 * (t >>> 2 & 1) - 1, Si(eo, eo, n);
    for (let i = 0; i < 3; ++i) {
      const r = eo[i];
      e[i] = Math.min(e[i], r), e[i + 3] = Math.max(e[i + 3], r);
    }
  }
}
function t1(n) {
  return ("0" + n.toString(16)).slice(-2);
}
function E_(n) {
  return Array.prototype.map.call(n, t1).join("");
}
function T_(n) {
  if (!/^(?:[0-9a-fA-F]{2})*$/.test(n))
    throw new Error("Invalid hex-encoded string");
  const e = n.length / 2, t = new Uint8Array(e);
  for (let i = 0; i < e; ++i)
    t[i] = parseInt(n.substr(i * 2, 2), 16);
  return t;
}
function n1(n) {
  const e = /^rgba\(([0-9]+), ([0-9]+), ([0-9]+), (0(?:\.[0-9]+)?)\)$/;
  {
    const i = n.match(e);
    if (i !== null)
      return [parseInt(i[1], 10), parseInt(i[2], 10), parseInt(i[3], 10), parseFloat(i[4])];
  }
  const t = /^#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/;
  {
    const i = n.match(t);
    if (i !== null)
      return [parseInt(i[1], 16), parseInt(i[2], 16), parseInt(i[3], 16), 1];
  }
  throw new Error(`Invalid serialized color: ${se(n)}.`);
}
function kv(n) {
  try {
    if (typeof n != "string")
      throw new Error(`Expected string, but received ${se(n)}.`);
    const e = document.createElement("canvas").getContext("2d");
    e.fillStyle = n;
    const t = n1(e.fillStyle);
    return Nc(t[0] / 255, t[1] / 255, t[2] / 255, t[3]);
  } catch (e) {
    throw new Error(`Failed to parse color specification: ${e.message}`);
  }
}
function va(n) {
  return kv(n).subarray(0, 3);
}
function Tu(n) {
  const e = n[3] === void 0 ? 3 : 4;
  let t = 0;
  for (let i = 0; i < e; i++)
    t = (t << 8 >>> 0) + Math.min(255, Math.max(0, Math.round(n[e - 1 - i] * 255)));
  return t;
}
function ia(n) {
  return St((n >>> 0 & 255) / 255, (n >>> 8 & 255) / 255, (n >>> 16 & 255) / 255);
}
function Lh(n) {
  return Nc((n >>> 0 & 255) / 255, (n >>> 8 & 255) / 255, (n >>> 16 & 255) / 255, (n >>> 24 & 255) / 255);
}
function Wn(n) {
  if (n[3] === void 0 || n[3] === 1) {
    let e = "#";
    for (let t = 0; t < 3; ++t)
      e += t1(Math.min(255, Math.max(0, Math.round(n[t] * 255))));
    return e;
  } else {
    let e = "rgba(";
    for (let t = 0; t < 3; ++t)
      t !== 0 && (e += ", "), e += Math.min(255, Math.max(0, Math.round(n[t] * 255)));
    return e += `, ${ZN(n[3])})`, e;
  }
}
function cu(n) {
  return n <= 0.03928 ? n / 12.92 : ((n + 0.055) / 1.055) ** 2.4;
}
function i1(n) {
  var e = ce(n, 3);
  const t = e[0], i = e[1], r = e[2];
  return 0.2126 * cu(t) + 0.7152 * cu(i) + 0.0722 * cu(r);
}
function ku(n) {
  return i1(n) <= 0.179;
}
var uc = class extends gt {
  constructor(e) {
    super(Ig(e)), this.defaultValue = e;
  }
  toString() {
    return Wn(this.value);
  }
  toJSON() {
    if (!Pg(this.value, this.defaultValue))
      return Wn(this.value);
  }
  reset() {
    this.value = Ig(this.defaultValue);
  }
  restoreState(e) {
    if (e === void 0) {
      this.reset();
      return;
    }
    const t = this.value, i = va(e);
    Pg(t, i) || (this.value = i);
  }
};
var r1 = class extends gt {
  constructor() {
    super(void 0);
  }
  toJSON() {
    const e = this.value;
    if (e !== void 0)
      return Wn(e);
  }
  reset() {
    this.value = void 0;
  }
  restoreState(e) {
    if (e === void 0) {
      this.reset();
      return;
    }
    const t = this.value, i = va(e);
    (t === void 0 || !Pg(t, i)) && (this.value = i);
  }
};
var k_ = Object.freeze(Object.defineProperty({
  __proto__: null,
  TrackableOptionalRGB: r1,
  TrackableRGB: uc,
  getRelativeLuminance: i1,
  packColor: Tu,
  parseColorSerialization: n1,
  parseRGBAColorSpecification: kv,
  parseRGBColorSpecification: va,
  serializeColor: Wn,
  srgbGammaExpand: cu,
  unpackRGB: ia,
  unpackRGBA: Lh,
  useWhiteBackground: ku
}, Symbol.toStringTag, { value: "Module" }));
var J;
(function(n) {
  n[n.UINT8 = 0] = "UINT8", n[n.INT8 = 1] = "INT8", n[n.UINT16 = 2] = "UINT16", n[n.INT16 = 3] = "INT16", n[n.UINT32 = 4] = "UINT32", n[n.INT32 = 5] = "INT32", n[n.UINT64 = 6] = "UINT64", n[n.FLOAT32 = 7] = "FLOAT32";
})(J || (J = {}));
var s1 = {
  [J.UINT8]: false,
  [J.INT8]: true,
  [J.UINT16]: false,
  [J.INT16]: true,
  [J.UINT32]: false,
  [J.INT32]: true,
  [J.UINT64]: false,
  [J.FLOAT32]: void 0
};
var I_ = {
  [J.UINT8]: 1,
  [J.INT8]: 1,
  [J.UINT16]: 2,
  [J.INT16]: 2,
  [J.UINT32]: 4,
  [J.INT32]: 4,
  [J.UINT64]: 8,
  [J.FLOAT32]: 4
};
var L_ = {
  [J.UINT8]: Uint8Array,
  [J.INT8]: Int8Array,
  [J.UINT16]: Uint16Array,
  [J.INT16]: Int16Array,
  [J.UINT32]: Uint32Array,
  [J.INT32]: Int32Array,
  [J.UINT64]: Uint32Array,
  [J.FLOAT32]: Float32Array
};
J.UINT8 + "", J.INT8 + "", J.UINT16 + "", J.INT16 + "", J.UINT32 + "", J.INT32 + "", J.UINT64 + "", J.FLOAT32 + "";
var ai;
(function(n) {
  n[n.LITTLE = 0] = "LITTLE", n[n.BIG = 1] = "BIG";
})(ai || (ai = {}));
function D_() {
  const n = Uint16Array.of(4386);
  return new Uint8Array(n.buffer)[0] === 17 ? ai.BIG : ai.LITTLE;
}
var _c = D_();
var Ip;
var Gb;
function P_2() {
  if (Gb)
    return Ip;
  Gb = 1;
  var n = X_, e = Math.floor;
  return Ip = function(i) {
    return !n(i) && isFinite(i) && e(i) === i;
  }, Ip;
}
var $b = Y_;
$b($b.S, "Number", { isInteger: P_2() });
var A_ = xv.Number.isInteger;
var R_ = { default: A_, __esModule: true };
var jn = Gs(R_);
var Wb = Y_;
var M_ = fw.isFinite;
Wb(Wb.S, "Number", {
  isFinite: function(e) {
    return typeof e == "number" && M_(e);
  }
});
var N_ = xv.Number.isFinite;
var __ = { default: N_, __esModule: true };
var kt = Gs(__);
var Hb = Y_;
Hb(Hb.S, "Number", {
  isNaN: function(e) {
    return e != e;
  }
});
var O_ = xv.Number.isNaN;
var V_ = { default: O_, __esModule: true };
var nr = Gs(V_);
function Jo(n) {
  let e = typeof n;
  if (e === "number" || e === "string") {
    let t = parseFloat("" + n);
    if (!nr(t))
      return t;
  }
  throw new Error(`Expected floating-point number, but received: ${se(n)}.`);
}
function Lt(n) {
  let e = Jo(n);
  if (kt(e))
    return e;
  throw new Error(`Expected finite floating-point number, but received: ${e}.`);
}
function Iv(n) {
  let e = Jo(n);
  if (kt(e) && e >= 0)
    return e;
  throw new Error(`Expected finite non-negative floating-point number, but received: ${e}.`);
}
function vn(n) {
  let e = Lt(n);
  if (e > 0)
    return e;
  throw new Error(`Expected positive finite floating-point number, but received: ${e}.`);
}
function hc(n, e, t = Jo) {
  pe(e), n[0] = n[1] = n[2] = 0;
  for (const i of un(e))
    switch (i) {
      case "x":
        n[0] = t(e[i]);
        break;
      case "y":
        n[1] = t(e[i]);
        break;
      case "z":
        n[2] = t(e[i]);
        break;
      default:
        throw new Error(`Expected object to have keys ['x', 'y', 'z'], but received: ${se(e)}.`);
    }
  return n;
}
function go(n, e) {
  let t = n.length;
  if (!Array.isArray(e) || e.length !== t)
    throw new Error("Incompatible sizes");
  for (let i = 0; i < t; ++i)
    if (!kt(parseFloat(e[i])))
      throw new Error("Non-finite value.");
  for (let i = 0; i < t; ++i)
    n[i] = parseFloat(e[i]);
  return n;
}
function Qs(n, e) {
  let t = n.length;
  if (!Array.isArray(e) || e.length !== t)
    throw new Error("Incompatible sizes.");
  for (let i = 0; i < t; ++i) {
    let r = parseInt(e[i], void 0);
    if (!jn(r))
      throw new Error("Non-integer value.");
  }
  for (let i = 0; i < t; ++i)
    n[i] = parseInt(e[i], void 0);
  return n;
}
function ri(n) {
  if (typeof n == "object") {
    if (n === null)
      return "null";
    if (Array.isArray(n)) {
      let s = "[", a = n.length, l = 0;
      if (l < a)
        for (s += ri(n[l]); ++l < a; )
          s += ",", s += ri(n[l]);
      return s += "]", s;
    }
    let e = "{", t = un(n).sort(), i = 0, r = t.length;
    if (i < r) {
      let s = t[i];
      for (e += se(s), e += ":", e += ri(n[s]); ++i < r; )
        e += ",", s = t[i], e += se(s), e += ":", e += ri(n[s]);
    }
    return e += "}", e;
  }
  return se(n);
}
function jb(n) {
  return n.replace(/['"]/g, (e) => e === '"' ? "'" : '"');
}
function _g(n) {
  return jb(se(jb(n)));
}
var Jb = "_";
function Zl(n) {
  if (typeof n == "object") {
    if (n === null)
      return "null";
    let e = n.toJSON;
    if (typeof e == "function")
      return Zl(e.call(n));
    if (Array.isArray(n)) {
      let s = "[", a = n.length, l = 0;
      if (l < a)
        for (s += Zl(n[l]); ++l < a; )
          s += Jb, s += Zl(n[l]);
      return s += "]", s;
    }
    let t = "{", i = un(n), r = true;
    for (let s of i) {
      let a = n[s];
      if (a === void 0)
        continue;
      let l = Zl(a);
      l && (r ? r = false : t += Jb, t += _g(s), t += ":", t += l);
    }
    return t += "}", t;
  }
  return typeof n == "string" ? _g(n) : se(n);
}
var a1 = /('(?:[^'\\]|(?:\\.))*')/;
var o1 = /("(?:[^"\\]|(?:\\.))*")/;
var l1 = new RegExp(`${a1.source}|${o1.source}`);
var B_ = new RegExp(`${o1.source}|${a1.source}`);
var c1 = /^((?:[^"'\\]|(?:\\[^']))*)("|\\')/;
var F_ = /^((?:[^"'\\]|(?:\\.))*)'/;
function d1(n, e, t, i) {
  if (n.length >= 2 && n.charAt(0) === e && n.charAt(n.length - 1) === e) {
    let r = n.substr(1, n.length - 2), s = t;
    for (; r.length > 0; ) {
      let a = r.match(i);
      if (a === null) {
        s += r;
        break;
      }
      s += a[1], a[2] === t ? (s += "\\", s += t) : s += e, r = r.substr(a.index + a[0].length);
    }
    return s += t, s;
  }
  return n;
}
function u1(n) {
  return d1(n, "'", '"', c1);
}
function h1(n, e, t) {
  const i = /[&_,]/g;
  let r, s, a;
  t === '"' ? (r = "'", s = c1, a = l1) : (r = '"', s = F_, a = B_);
  let l = "";
  for (; n.length > 0; ) {
    let d = n.match(a), u, f;
    if (d === null)
      u = n, n = "", f = "";
    else {
      u = n.substr(0, d.index), n = n.substr(d.index + d[0].length);
      let g = d[1];
      g !== void 0 ? f = d1(g, r, t, s) : f = d[2];
    }
    l += u.replace(i, e), l += f;
  }
  return l;
}
function f1(n) {
  return h1(n, ",", '"');
}
function U_(n) {
  return h1(n, "_", "'");
}
function Iu(n) {
  return JSON.parse(f1(n));
}
function p1(n) {
  let e = "";
  for (; n.length > 0; ) {
    let t = n.match(l1), i, r;
    if (t === null)
      i = n, n = "", r = "";
    else {
      i = n.substr(0, t.index), n = n.substr(t.index + t[0].length);
      let s = t[1];
      s !== void 0 ? r = u1(s) : r = t[2];
    }
    e += i.replace(/\(/g, "[").replace(/\)/g, "]").replace("True", "true").replace("False", "false").replace(/,\s*([\}\]])/g, "$1"), e += r;
  }
  return e;
}
function z_2(n) {
  return JSON.parse(p1(n));
}
function Bi(n, e) {
  if (!Array.isArray(n))
    throw new Error(`Expected array, but received: ${se(n)}.`);
  if (e !== void 0 && n.length !== e)
    throw new Error(`Expected array of length ${e}, but received: ${se(n)}.`);
  return n;
}
function Je(n, e) {
  if (!Array.isArray(n))
    throw new Error(`Expected array, but received: ${se(n)}.`);
  return n.map(e);
}
function at(n, e, t) {
  const i = n.length;
  if (!Array.isArray(e) || e.length !== i)
    throw new Error(`Expected length ${i} array, but received: ${se(e)}.`);
  for (let r = 0; r < i; ++r)
    n[r] = t(e[r], r);
  return n;
}
function pe(n) {
  if (typeof n != "object" || n == null || Array.isArray(n))
    throw new Error(`Expected JSON object, but received: ${se(n)}.`);
  return n;
}
function pn(n) {
  let e = parseInt(n, 10);
  if (!jn(e))
    throw new Error(`Expected integer, but received: ${se(n)}.`);
  return e;
}
function dn(n) {
  let e = pn(n);
  if (e <= 0)
    throw new Error(`Expected positive integer, but received: ${e}.`);
  return e;
}
function g1(n) {
  const e = pn(n);
  if (e < 0)
    throw new Error(`Expected non-negative integer, but received: ${e}.`);
  return e;
}
function Lv(n, e) {
  let t = e.get(n);
  if (t === void 0)
    throw new Error(`Expected one of ${se(De(e.keys()))}, but received: ${se(n)}.`);
  return t;
}
function Le(n) {
  if (typeof n != "string")
    throw new Error(`Expected string, but received: ${se(n)}.`);
  return n;
}
function xi(n) {
  if (n !== void 0)
    return Le(n);
}
function G_(n) {
  if (n !== void 0)
    return pn(n);
}
function $_(n) {
  if (n !== void 0) {
    if (typeof n == "boolean")
      return n;
    if (n === "true")
      return true;
    if (n === "false")
      return false;
    throw new Error(`Expected string or boolean but received: ${se(n)}`);
  }
}
function W_(n, e) {
  return n === void 0 ? e : n;
}
function K(n, e, t) {
  let i = Object.prototype.hasOwnProperty.call(n, e) ? n[e] : void 0;
  try {
    return t(i);
  } catch (r) {
    throw new Error(`Error parsing ${se(e)} property: ${r.message}`);
  }
}
function Ce(n, e, t, i) {
  return K(n, e, (r) => r === void 0 ? i : t(r));
}
function Dh(n, e) {
  pe(n);
  let t = new de();
  for (let i of un(n))
    try {
      t.set(i, e(n[i]));
    } catch (r) {
      throw new Error(`Error parsing value associated with key ${se(i)}: ${r.message}`);
    }
  return t;
}
function Dv(n) {
  if (typeof n != "number" || !kt(n) || n < 0 || n > 1)
    throw new Error(`Expected floating point number in [0,1], but received: ${se(n)}.`);
  return n;
}
function Yo(n) {
  if (n === "")
    return {};
  if (n.startsWith("{"))
    return Iu(n);
  {
    let e = {}, t = n.split(/[&;]/);
    for (let i of t) {
      let r = i.match(/^([^=&;]+)=([^&;]*)$/);
      if (r === null)
        throw new Error(`Invalid query string part: ${se(i)}.`);
      e[r[1]] = decodeURIComponent(r[2]);
    }
    return e;
  }
}
function m1(n) {
  if (n === void 0)
    return "";
  const e = un(n);
  return e.length === 0 ? "" : e.some((t) => typeof n[t] != "string") ? se(n) : e.map((t) => `${encodeURIComponent(t)}=${encodeURIComponent(n[t])}`).join("&");
}
function Pn(n, e) {
  if (typeof n == "string" && n.match(/^[a-zA-Z]/) !== null && (n = n.toUpperCase(), e.hasOwnProperty(n)))
    return e[n];
  throw new Error(`Invalid enum value: ${se(n)}.`);
}
function v1(n) {
  return at(_e(), n, Lt);
}
function H_(n) {
  return at(_e(), n, vn);
}
function j_(n) {
  return at(_e(), n, dn);
}
function Ci(n) {
  if (!Array.isArray(n))
    throw new Error(`Expected array, received: ${se(n)}.`);
  for (let e of n)
    if (typeof e != "string")
      throw new Error(`Expected string, received: ${se(e)}.`);
  return n;
}
function y1(n) {
  if (!Array.isArray(n))
    throw new Error(`Expected array, received: ${se(n)}.`);
  for (let e of n)
    if (!jn(e))
      throw new Error(`Expected integer, received: ${se(e)}.`);
  return n;
}
function la(n) {
  if (typeof n != "boolean")
    throw new Error(`Expected boolean, received: ${se(n)}`);
  return n;
}
function ya(n) {
  for (const e in n)
    return n;
}
var J_ = Object.freeze(Object.defineProperty({
  __proto__: null,
  emptyToUndefined: ya,
  expectArray: Bi,
  jsonToUrlSafe: U_,
  normalizeStringLiteral: u1,
  parseArray: Je,
  parseFiniteVec: go,
  parseFixedLengthArray: at,
  parseIntVec: Qs,
  parseQueryStringParameters: Yo,
  parseXYZ: hc,
  pythonLiteralParse: z_2,
  pythonLiteralToJSON: p1,
  stableStringify: ri,
  unparseQueryStringParameters: m1,
  urlSafeParse: Iu,
  urlSafeStringify: Zl,
  urlSafeStringifyString: _g,
  urlSafeToJSON: f1,
  valueOr: W_,
  verify3dDimensions: j_,
  verify3dScale: H_,
  verify3dVec: v1,
  verifyBoolean: la,
  verifyEnumString: Pn,
  verifyFiniteFloat: Lt,
  verifyFiniteNonNegativeFloat: Iv,
  verifyFinitePositiveFloat: vn,
  verifyFloat: Jo,
  verifyFloat01: Dv,
  verifyInt: pn,
  verifyIntegerArray: y1,
  verifyMapKey: Lv,
  verifyNonnegativeInt: g1,
  verifyObject: pe,
  verifyObjectAsMap: Dh,
  verifyObjectProperty: K,
  verifyOptionalBoolean: $_,
  verifyOptionalInt: G_,
  verifyOptionalObjectProperty: Ce,
  verifyOptionalString: xi,
  verifyPositiveInt: dn,
  verifyString: Le,
  verifyStringArray: Ci
}, Symbol.toStringTag, { value: "Module" }));
var Yb = 2 ** -1074;
var Og = new Float64Array(1);
var us = new Uint32Array(Og.buffer);
function Y_2(n, e) {
  if (isNaN(n) || isNaN(e))
    return NaN;
  if (n === e)
    return e;
  if (n === 0)
    return e < 0 ? -Yb : Yb;
  Og[0] = n;
  const t = _c === ai.LITTLE ? 0 : 1, i = 1 - t;
  return e > n == n > 0 ? us[t] === 4294967295 ? (us[t] = 0, us[i] += 1) : us[t] += 1 : us[t] === 0 ? (us[t] = 4294967295, us[i] -= 1) : us[t] -= 1, Og[0];
}
var Lp = Y_;
var qb = Math.imul;
Lp(Lp.S + Lp.F * k5(function() {
  return qb(4294967295, 5) != -5 || qb.length != 2;
}), "Math", {
  imul: function(e, t) {
    var i = 65535, r = +e, s = +t, a = i & r, l = i & s;
    return 0 | a * l + ((i & r >>> 16) * l + a * (i & s >>> 16) << 16 >>> 0);
  }
});
var q_ = xv.Math.imul;
var K_2 = { default: q_, __esModule: true };
var ir = Gs(K_2);
var Kb = Y_;
Kb(Kb.S, "Math", {
  log2: function(e) {
    return Math.log(e) / Math.LN2;
  }
});
var Z_ = xv.Math.log2;
var X_2 = { default: Z_, __esModule: true };
var Zn = Gs(X_2);
var Dp = new Uint32Array(2);
var Gl = 4294967296;
var Vg = [];
for (let n = 2; n <= 36; ++n) {
  let e = Math.floor(32 / Zn(n)), t = Math.pow(n, e), i = `^[0-${String.fromCharCode("0".charCodeAt(0) + Math.min(9, n - 1))}`;
  n > 10 && (i += `a-${String.fromCharCode("a".charCodeAt(0) + n - 11)}`, i += `A-${String.fromCharCode("A".charCodeAt(0) + n - 11)}`);
  let r = Math.ceil(64 / Zn(n));
  i += `]{1,${r}}$`;
  let s = new RegExp(i);
  Vg[n] = { lowDigits: e, lowBase: t, pattern: s };
}
function Zb(n, e) {
  n >>>= 0, e >>>= 0;
  const t = n & 65535, i = n >>> 16, r = e & 65535, s = e >>> 16;
  let l = (t * r >>> 16) + i * r, d = l >>> 16;
  l = (l & 65535) + t * s, d += l >>> 16;
  let u = d >>> 16;
  return d = (d & 65535) + i * s, u += d >>> 16, ((u & 65535) << 16 | d & 65535) >>> 0;
}
var re = class _re {
  constructor(e = 0, t = 0) {
    this.low = e, this.high = t;
  }
  clone() {
    return new _re(this.low, this.high);
  }
  assign(e) {
    this.low = e.low, this.high = e.high;
  }
  toString(e = 10) {
    let t = this.low, i = this.high;
    if (i === 0)
      return t.toString(e);
    i *= Gl;
    var r = Vg[e];
    let s = r.lowBase, a = r.lowDigits, l = i % s;
    i = Math.floor(i / s), t += l, i += Math.floor(t / s), t = t % s;
    let d = t.toString(e);
    return i.toString(e) + "0".repeat(a - d.length) + d;
  }
  /**
   * Returns true if a is strictly less than b.
   */
  static less(e, t) {
    return e.high < t.high || e.high === t.high && e.low < t.low;
  }
  /**
   * Returns a negative number if a is strictly less than b, 0 if a is equal to b, or a positive
   * number if a is strictly greater than b.
   */
  static compare(e, t) {
    return e.high - t.high || e.low - t.low;
  }
  static equal(e, t) {
    return e.low === t.low && e.high === t.high;
  }
  static min(e, t) {
    return _re.less(e, t) ? e : t;
  }
  static max(e, t) {
    return _re.less(e, t) ? t : e;
  }
  static random() {
    return crypto.getRandomValues(Dp), new _re(Dp[0], Dp[1]);
  }
  tryParseString(e, t = 10) {
    var i = Vg[t];
    const r = i.lowDigits, s = i.lowBase;
    if (!i.pattern.test(e))
      return false;
    if (e.length <= r)
      return this.low = parseInt(e, t), this.high = 0, true;
    const l = e.length - r, d = parseInt(e.substr(l), t), u = parseInt(e.substr(0, l), t);
    let f, g;
    if (s === Gl)
      f = u, g = d;
    else {
      const v = ir(u, s) >>> 0;
      f = Zb(u, s) + (ir(Math.floor(u / Gl), s) >>> 0), g = d + v, g >= Gl && (++f, g -= Gl);
    }
    return g >>> 0 !== g || f >>> 0 !== f ? false : (this.low = g, this.high = f, true);
  }
  parseString(e, t = 10) {
    if (!this.tryParseString(e, t))
      throw new Error(`Failed to parse string as uint64 value: ${se(e)}.`);
    return this;
  }
  static parseString(e, t = 10) {
    return new _re().parseString(e, t);
  }
  valid() {
    let e = this.low, t = this.high;
    return e >>> 0 === e && t >>> 0 === t;
  }
  toJSON() {
    return this.toString();
  }
  static lshift(e, t, i) {
    const r = t.low, s = t.high;
    return i === 0 ? (e.low = r, e.high = s) : i < 32 ? (e.low = r << i, e.high = s << i | r >>> 32 - i) : (e.low = 0, e.high = r << i - 32), e;
  }
  static rshift(e, t, i) {
    const r = t.low, s = t.high;
    return i === 0 ? (e.low = r, e.high = s) : i < 32 ? (e.low = r >>> i | s << 32 - i, e.high = s >>> i) : (e.low = s >>> i - 32, e.high = 0), e;
  }
  static or(e, t, i) {
    return e.low = t.low | i.low, e.high = t.high | i.high, e;
  }
  static xor(e, t, i) {
    return e.low = t.low ^ i.low, e.high = t.high ^ i.high, e;
  }
  static and(e, t, i) {
    return e.low = t.low & i.low, e.high = t.high & i.high, e;
  }
  static add(e, t, i) {
    let r = t.low + i.low, s = t.high + i.high;
    const a = r >>> 0;
    return a !== r && (s += 1), e.low = a, e.high = s >>> 0, e;
  }
  static addUint32(e, t, i) {
    let r = t.low + i, s = t.high;
    const a = r >>> 0;
    return a !== r && (s += 1), e.low = a, e.high = s >>> 0, e;
  }
  static decrement(e, t) {
    let i = t.low, r = t.high;
    return i === 0 && (r -= 1), e.low = i - 1 >>> 0, e.high = r >>> 0, e;
  }
  static increment(e, t) {
    let i = t.low, r = t.high;
    return i === 4294967295 && (r += 1), e.low = i + 1 >>> 0, e.high = r >>> 0, e;
  }
  static subtract(e, t, i) {
    let r = t.low - i.low, s = t.high - i.high;
    const a = r >>> 0;
    return a !== r && (s -= 1), e.low = a, e.high = s >>> 0, e;
  }
  static absDifference(e, t, i) {
    return _re.less(t, i) ? _re.subtract(e, i, t) : _re.subtract(e, t, i);
  }
  static multiplyUint32(e, t, i) {
    const r = t.low, s = t.high;
    return e.low = ir(r, i) >>> 0, e.high = ir(s, i) + Zb(r, i) >>> 0, e;
  }
  static lowMask(e, t) {
    return t === 0 ? e.high = e.low = 0 : t <= 32 ? (e.high = 0, e.low = 4294967295 >>> 32 - t) : (e.high = 4294967295 >>> t - 32, e.low = 4294967295), e;
  }
  toNumber() {
    return this.low + this.high * 4294967296;
  }
  setFromNumber(e) {
    e = Math.round(e), e < 0 ? this.low = this.high = 0 : e >= 18446744073709552e3 ? this.low = this.high = 4294967295 : (this.low = e % 4294967296, this.high = Math.floor(e / 4294967296));
  }
};
re.ZERO = new re(0, 0);
re.ONE = new re(1, 0);
var Q_ = Object.freeze(Object.defineProperty({
  __proto__: null,
  Uint64: re
}, Symbol.toStringTag, { value: "Module" }));
var Oc = {
  [J.UINT8]: [0, 255],
  [J.INT8]: [-128, 127],
  [J.UINT16]: [0, 65535],
  [J.INT16]: [-32768, 32767],
  [J.UINT32]: [0, 4294967295],
  [J.INT32]: [-2147483648, 2147483647],
  [J.UINT64]: [re.ZERO, new re(4294967295, 4294967295)],
  [J.FLOAT32]: [0, 1]
};
function gi(n, e) {
  if (typeof e == "number") {
    const t = n[0], i = n[1];
    return (e - t) / (i - t);
  } else {
    const t = n[0], i = n[1];
    let r;
    re.compare(e, t) < 0 ? r = -re.subtract(ii, t, e).toNumber() : r = re.subtract(ii, e, t).toNumber();
    let s = re.absDifference(ii, i, t).toNumber();
    return re.compare(t, i) > 0 && (s *= -1), r / s;
  }
}
function Rr(n, e, t) {
  if (typeof n[0] == "number") {
    const r = n[0], s = n[1];
    let a = r * (1 - t) + s * t;
    if (e !== J.FLOAT32) {
      const l = Oc[e];
      a = Math.round(a), a = Math.max(l[0], a), a = Math.min(l[1], a);
    }
    return a;
  } else {
    let r = n[0], s = n[1];
    if (re.compare(r, s) > 0) {
      var i = [s, r];
      r = i[0], s = i[1], t = 1 - t;
    }
    const a = re.subtract(ii, s, r).toNumber(), l = new re();
    return t <= 0 ? (ii.setFromNumber(a * -t), re.subtract(l, r, re.min(ii, r))) : t >= 1 ? (ii.setFromNumber(a * (t - 1)), re.add(l, s, ii), re.less(l, s) && (l.low = l.high = 4294967295)) : (ii.setFromNumber(a * t), re.add(l, r, ii), re.less(l, r) && (l.low = l.high = 4294967295)), l;
  }
}
function fc(n, e) {
  return typeof e == "number" ? Math.min(Math.max(n[0], e), n[1]) : re.min(re.max(n[0], e), n[1]);
}
function nc(n, e) {
  return [fc(n, e[0]), fc(n, e[1])];
}
function S1(n) {
  if (Ei(n[0], n[1]) <= 0)
    return n;
  throw new Error(`Invalid interval: [${n[0]}, ${n[1]}]`);
}
function e2(n) {
  return Ei(n[0], n[1]) <= 0 ? n : [n[1], n[0]];
}
function Ei(n, e) {
  return typeof n == "number" ? n - e : re.compare(n, e);
}
var ii = new re();
var t2 = new re();
function n2(n, e) {
  return typeof e == "number" ? Math.abs(e - n[0]) < Math.abs(e - n[1]) ? 0 : 1 : re.less(re.absDifference(ii, n[0], e), re.absDifference(t2, n[1], e)) ? 0 : 1;
}
function Vc(n, e) {
  let t;
  switch (typeof e != "string" ? t = "" + e : t = e, n) {
    case J.UINT64:
      return re.parseString(t);
    case J.FLOAT32: {
      const i = parseFloat(t);
      if (!kt(i))
        throw new Error(`Invalid float32 value: ${se(t)}`);
      return i;
    }
    default: {
      const i = parseInt(t), r = Oc[n];
      if (!jn(i) || i < r[0] || i > r[1])
        throw new Error(`Invalid ${J[n].toLowerCase()} value: ${se(t)}`);
      return i;
    }
  }
}
function Lu(n, e) {
  return at(new Array(2), n, (t) => Vc(e, t));
}
function Mr(n, e, t) {
  return n === J.UINT64 ? re.equal(e[0], t[0]) && re.equal(e[1], t[1]) : e[0] === t[0] && e[1] === t[1];
}
function Xb(n, e, t = Oc[e]) {
  if (!Mr(e, n, t))
    return e === J.UINT64 ? [n[0].toString(), n[1].toString()] : n;
}
function Du(n, e, t) {
  switch (n) {
    case J.FLOAT32:
      return Y_2(e, t * (1 / 0));
    case J.UINT64:
      const i = e;
      return t === -1 ? i.low === 0 && i.high === 0 ? i : re.decrement(new re(), i) : i.low === 4294967295 && i.high === 4294967295 ? i : re.increment(new re(), i);
    default: {
      const r = Oc[n];
      return Math.max(r[0], Math.min(r[1], e + t));
    }
  }
}
function i2(n, e) {
  switch (n) {
    case J.FLOAT32:
      return 0;
    case J.UINT64:
      return 0.5 / re.absDifference(ii, e[0], e[1]).toNumber();
    default:
      return 0.5 / Math.abs(e[0] - e[1]);
  }
}
function Pu(n, e) {
  switch (n) {
    case J.FLOAT32:
      return 1;
    case J.UINT64: {
      const t = re.absDifference(ii, e[0], e[1]).toNumber();
      return t / (t + 1);
    }
    default: {
      const t = Math.abs(e[0] - e[1]);
      return t / (t + 1);
    }
  }
}
function Au(n = 128) {
  const e = Math.ceil(n / 32), t = new Uint32Array(e);
  crypto.getRandomValues(t);
  let i = "";
  for (let r = 0; r < e; ++r)
    i += ("00000000" + t[r].toString(16)).slice(-8);
  return i;
}
function r2(n) {
  let e = new Uint8Array(n.buffer, n.byteOffset, n.byteLength);
  const t = 65536;
  for (let i = 0, r = e.length; i < r; i += t)
    crypto.getRandomValues(e.subarray(i, Math.min(r, i + t)));
  return n;
}
function Qb() {
  const n = new Uint32Array(1);
  return crypto.getRandomValues(n), n[0];
}
var du = class extends Z {
  constructor(e) {
    super(), this.id = e, this.changed = new Ee();
  }
  addRef() {
    return super.addRef();
  }
  dispose() {
    super.dispose();
  }
};
var Me;
(function(n) {
  n[n.POINT = 0] = "POINT", n[n.LINE = 1] = "LINE", n[n.AXIS_ALIGNED_BOUNDING_BOX = 2] = "AXIS_ALIGNED_BOUNDING_BOX", n[n.ELLIPSOID = 3] = "ELLIPSOID", n[n.SPHERE = 4] = "SPHERE";
})(Me || (Me = {}));
var Br = [Me.POINT, Me.LINE, Me.AXIS_ALIGNED_BOUNDING_BOX, Me.ELLIPSOID, Me.SPHERE];
var Es = {
  rgb: {
    serializedBytes() {
      return 3;
    },
    alignment() {
      return 1;
    },
    serializeCode(n, e) {
      return `dv.setUint16(${e}, ${n}, true);dv.setUint8(${e} + 2, ${n} >>> 16);`;
    },
    deserializeCode(n, e) {
      return `${n} = dv.getUint16(${e}, true) | (dv.getUint8(${e} + 2) << 16);`;
    },
    deserializeJson(n) {
      return Tu(va(n));
    },
    serializeJson(n) {
      return Wn(ia(n));
    }
  },
  rgba: {
    serializedBytes() {
      return 4;
    },
    alignment() {
      return 1;
    },
    serializeCode(n, e) {
      return `dv.setUint32(${e}, ${n}, true);`;
    },
    deserializeCode(n, e) {
      return `${n} = dv.getUint32(${e}, true);`;
    },
    deserializeJson(n) {
      return Tu(kv(n));
    },
    serializeJson(n) {
      return Wn(Lh(n));
    }
  },
  float32: {
    serializedBytes() {
      return 4;
    },
    alignment() {
      return 4;
    },
    serializeCode(n, e) {
      return `dv.setFloat32(${e}, ${n}, isLittleEndian);`;
    },
    deserializeCode(n, e) {
      return `${n} = dv.getFloat32(${e}, isLittleEndian);`;
    },
    deserializeJson(n) {
      return Jo(n);
    },
    serializeJson(n) {
      return n;
    }
  },
  uint32: {
    serializedBytes() {
      return 4;
    },
    alignment() {
      return 4;
    },
    serializeCode(n, e) {
      return `dv.setUint32(${e}, ${n}, isLittleEndian);`;
    },
    deserializeCode(n, e) {
      return `${n} = dv.getUint32(${e}, isLittleEndian);`;
    },
    deserializeJson(n) {
      return pn(n);
    },
    serializeJson(n) {
      return n;
    }
  },
  int32: {
    serializedBytes() {
      return 4;
    },
    alignment() {
      return 4;
    },
    serializeCode(n, e) {
      return `dv.setInt32(${e}, ${n}, isLittleEndian);`;
    },
    deserializeCode(n, e) {
      return `${n} = dv.getInt32(${e}, isLittleEndian);`;
    },
    deserializeJson(n) {
      return pn(n);
    },
    serializeJson(n) {
      return n;
    }
  },
  uint16: {
    serializedBytes() {
      return 2;
    },
    alignment() {
      return 2;
    },
    serializeCode(n, e) {
      return `dv.setUint16(${e}, ${n}, isLittleEndian);`;
    },
    deserializeCode(n, e) {
      return `${n} = dv.getUint16(${e}, isLittleEndian);`;
    },
    deserializeJson(n) {
      return pn(n);
    },
    serializeJson(n) {
      return n;
    }
  },
  int16: {
    serializedBytes() {
      return 2;
    },
    alignment() {
      return 2;
    },
    serializeCode(n, e) {
      return `dv.setInt16(${e}, ${n}, isLittleEndian);`;
    },
    deserializeCode(n, e) {
      return `${n} = dv.getInt16(${e}, isLittleEndian);`;
    },
    deserializeJson(n) {
      return pn(n);
    },
    serializeJson(n) {
      return n;
    }
  },
  uint8: {
    serializedBytes() {
      return 1;
    },
    alignment() {
      return 1;
    },
    serializeCode(n, e) {
      return `dv.setUint8(${e}, ${n});`;
    },
    deserializeCode(n, e) {
      return `${n} = dv.getUint8(${e});`;
    },
    deserializeJson(n) {
      return pn(n);
    },
    serializeJson(n) {
      return n;
    }
  },
  int8: {
    serializedBytes() {
      return 2;
    },
    alignment() {
      return 1;
    },
    serializeCode(n, e) {
      return `dv.setInt8(${e}, ${n});`;
    },
    deserializeCode(n, e) {
      return `${n} = dv.getInt8(${e});`;
    },
    deserializeJson(n) {
      return pn(n);
    },
    serializeJson(n) {
      return n;
    }
  }
};
var s2 = 255;
function b1(n, e, t) {
  let i = 0;
  const r = t.length, s = new Array(r), a = [];
  for (let v = 0; v < r; ++v)
    s[v] = v;
  const l = (v) => Es[t[v].type].alignment(n);
  s.sort((v, y) => l(y) - l(v));
  let d = 0;
  const u = new Array(r);
  let f = e;
  const g = () => {
    f += (4 - f % 4) % 4, i += f, a[d] = f, f = 0, ++d;
  };
  for (let v = 0; v < r; ++v) {
    const y = s[v], w = t[y], C = Es[w.type], b = C.serializedBytes(n), E = C.alignment(n), L = (E - f % E) % E, _ = f + L + b;
    _ + (4 - _ % 4) % 4 <= s2 ? f += L : g(), u[y] = { offset: f, group: d }, f += b;
  }
  return g(), { serializedBytes: i, offsets: u, propertyGroupBytes: a };
}
var C1 = class {
  constructor(e, t, i) {
    if (this.rank = e, this.firstGroupInitialOffset = t, this.propertySpecs = i, i.length === 0) {
      this.serializedBytes = t, this.serialize = this.deserialize = () => {
      }, this.propertyGroupBytes = [t];
      return;
    }
    var r = b1(e, t, i);
    const s = r.serializedBytes, a = r.offsets, l = r.propertyGroupBytes;
    this.propertyGroupBytes = l;
    let d = "let groupOffset0 = offset;";
    for (let y = 1; y < l.length; ++y)
      d += `let groupOffset${y} = groupOffset${y - 1} + ${l[y - 1]}*annotationCount;`;
    for (let y = 0; y < l.length; ++y)
      d += `groupOffset${y} += ${l[y]}*annotationIndex;`;
    let u = d, f = d;
    const g = i.length;
    for (let y = 0; y < g; ++y) {
      var v = a[y];
      const w = v.group, C = v.offset, b = i[y], E = Es[b.type], L = `properties[${y}]`, R = `groupOffset${w} + ${C}`;
      u += E.serializeCode(L, R, e), f += E.deserializeCode(L, R, e);
    }
    this.serializedBytes = s, this.serialize = new Function("dv", "offset", "annotationIndex", "annotationCount", "isLittleEndian", "properties", u), this.deserialize = new Function("dv", "offset", "annotationIndex", "annotationCount", "isLittleEndian", "properties", f);
  }
};
function Pv(n, e) {
  const t = [];
  for (const i of Br) {
    const r = Gn[i];
    t[i] = new C1(n, r.serializedBytes(n), e);
  }
  return t;
}
function w1(n, e) {
  const t = n.type === "float32" ? e.toPrecision(6) : e.toString(), i = n.enumValues, r = n.enumLabels;
  if (i !== void 0) {
    const s = i.indexOf(e);
    if (s !== -1)
      return `${r[s]} (${t})`;
  }
  return t;
}
function a2(n, e) {
  switch (n.type) {
    case "rgb":
      return Wn(ia(e));
    case "rgba":
      return Wn(Lh(e));
    default:
      return w1(n, e);
  }
}
function o2(n) {
  const e = Le(n);
  if (e.match(/^[a-z][a-zA-Z0-9_]*$/) === null)
    throw new Error(`Invalid property identifier: ${se(n)}`);
  return e;
}
function l2(n) {
  if (Le(n), !Object.prototype.hasOwnProperty.call(Es, n))
    throw new Error("Unsupported property type: $JSON.stringify(obj)}");
  return n;
}
function c2(n) {
  const e = new je();
  for (const t of n) {
    if (e.has(t.identifier))
      throw new Error(`Duplicate property identifier: ${t.identifier}`);
    e.add(t.identifier);
  }
}
function d2(n) {
  pe(n);
  const e = K(n, "id", o2), t = K(n, "type", l2), i = Ce(n, "description", Le);
  let r = Ce(n, "default", (l) => Es[t].deserializeJson(l), 0), s, a;
  switch (t) {
    case "rgb":
    case "rgba":
      break;
    default: {
      const l = J[t.toUpperCase()];
      s = Ce(n, "enum_values", (d) => Je(d, (u) => Vc(l, u))), s !== void 0 && (a = K(n, "enum_labels", (d) => at(new Array(s.length), d, Le)));
    }
  }
  return { type: t, identifier: e, description: i, default: r, enumValues: s, enumLabels: a };
}
function u2(n) {
  const e = n.default;
  return {
    id: n.identifier,
    description: n.description,
    type: n.type,
    default: e === 0 ? void 0 : Es[n.type].serializeJson(e)
  };
}
function h2(n) {
  if (!(n === void 0 || n.length === 0))
    return n.map(u2);
}
function x1(n) {
  if (n === void 0)
    return [];
  const e = Je(n, d2);
  return c2(e), e;
}
function Bg(n, e, t, i, r) {
  for (let s = 0; s < i; ++s)
    n.setFloat32(e, r[s], t), e += 4;
  return e;
}
function $d(n, e, t, i, r, s) {
  return e = Bg(n, e, t, i, r), e = Bg(n, e, t, i, s), e;
}
function Fg(n, e, t, i, r) {
  for (let s = 0; s < i; ++s)
    r[s] = n.getFloat32(e, t), e += 4;
  return e;
}
function Wd(n, e, t, i, r, s) {
  return e = Fg(n, e, t, i, r), e = Fg(n, e, t, i, s), e;
}
var Gn = {
  [Me.LINE]: {
    icon: "ꕹ",
    description: "Line",
    toJSON(n) {
      return {
        pointA: De(n.pointA),
        pointB: De(n.pointB)
      };
    },
    restoreState(n, e, t) {
      n.pointA = K(e, "pointA", (i) => at(new Float32Array(t), i, Lt)), n.pointB = K(e, "pointB", (i) => at(new Float32Array(t), i, Lt));
    },
    serializedBytes(n) {
      return 2 * 4 * n;
    },
    serialize(n, e, t, i, r) {
      $d(n, e, t, i, r.pointA, r.pointB);
    },
    deserialize: (n, e, t, i, r) => {
      const s = new Float32Array(i), a = new Float32Array(i);
      return Wd(n, e, t, i, s, a), { type: Me.LINE, pointA: s, pointB: a, id: r, properties: [] };
    },
    visitGeometry(n, e) {
      e(n.pointA, false), e(n.pointB, false);
    }
  },
  [Me.SPHERE]: {
    icon: "⊖",
    description: "Sphere",
    toJSON(n) {
      return {
        pointA: De(n.pointA),
        pointB: De(n.pointB)
      };
    },
    restoreState(n, e, t) {
      n.pointA = K(e, "pointA", (i) => at(new Float32Array(t), i, Lt)), n.pointB = K(e, "pointB", (i) => at(new Float32Array(t), i, Lt));
    },
    serializedBytes(n) {
      return 2 * 4 * n;
    },
    serialize(n, e, t, i, r) {
      $d(n, e, t, i, r.pointA, r.pointB);
    },
    deserialize: (n, e, t, i, r) => {
      const s = new Float32Array(i), a = new Float32Array(i);
      return Wd(n, e, t, i, s, a), { type: Me.SPHERE, pointA: s, pointB: a, id: r, properties: [] };
    },
    visitGeometry(n, e) {
      e(n.pointA, false), e(n.pointB, false);
    }
  },
  [Me.POINT]: {
    icon: "⚬",
    description: "Point",
    toJSON: (n) => ({
      point: De(n.point)
    }),
    restoreState: (n, e, t) => {
      n.point = K(e, "point", (i) => at(new Float32Array(t), i, Lt));
    },
    serializedBytes: (n) => n * 4,
    serialize: (n, e, t, i, r) => {
      Bg(n, e, t, i, r.point);
    },
    deserialize: (n, e, t, i, r) => {
      const s = new Float32Array(i);
      return Fg(n, e, t, i, s), { type: Me.POINT, point: s, id: r, properties: [] };
    },
    visitGeometry(n, e) {
      e(n.point, false);
    }
  },
  [Me.AXIS_ALIGNED_BOUNDING_BOX]: {
    icon: "❑",
    description: "Bounding Box",
    toJSON: (n) => ({
      pointA: De(n.pointA),
      pointB: De(n.pointB)
    }),
    restoreState: (n, e, t) => {
      n.pointA = K(e, "pointA", (i) => at(new Float32Array(t), i, Lt)), n.pointB = K(e, "pointB", (i) => at(new Float32Array(t), i, Lt));
    },
    serializedBytes: (n) => 2 * 4 * n,
    serialize(n, e, t, i, r) {
      $d(n, e, t, i, r.pointA, r.pointB);
    },
    deserialize: (n, e, t, i, r) => {
      const s = new Float32Array(i), a = new Float32Array(i);
      return Wd(n, e, t, i, s, a), { type: Me.AXIS_ALIGNED_BOUNDING_BOX, pointA: s, pointB: a, id: r, properties: [] };
    },
    visitGeometry(n, e) {
      e(n.pointA, false), e(n.pointB, false);
    }
  },
  [Me.ELLIPSOID]: {
    icon: "◎",
    description: "Ellipsoid",
    toJSON: (n) => ({
      center: De(n.center),
      radii: De(n.radii)
    }),
    restoreState: (n, e, t) => {
      n.center = K(e, "center", (i) => at(new Float32Array(t), i, Lt)), n.radii = K(e, "radii", (i) => at(new Float32Array(t), i, Iv));
    },
    serializedBytes: (n) => 2 * 4 * n,
    serialize(n, e, t, i, r) {
      $d(n, e, t, i, r.center, r.radii);
    },
    deserialize: (n, e, t, i, r) => {
      const s = new Float32Array(i), a = new Float32Array(i);
      return Wd(n, e, t, i, s, a), { type: Me.ELLIPSOID, center: s, radii: a, id: r, properties: [] };
    },
    visitGeometry(n, e) {
      e(n.center, false), e(n.radii, true);
    }
  }
};
function Ug(n, e) {
  const t = Gn[n.type].toJSON(n, e.rank);
  t.type = Me[n.type].toLowerCase(), t.id = n.id, t.description = n.description || void 0;
  const i = n.relatedSegments;
  if (i !== void 0 && i.some((r) => r.length !== 0) && (t.segments = i.map((r) => r.map((s) => s.toString()))), e.properties.length !== 0) {
    const r = e.properties;
    t.props = n.properties.map((s, a) => Es[r[a].type].serializeJson(s));
  }
  return t;
}
function f2(n, e, t = false) {
  pe(n);
  const i = K(n, "type", (d) => Pn(d, Me)), r = K(n, "id", t ? xi : Le) || Av(), s = K(n, "segments", (d) => {
    if (d === void 0)
      return e.relationships.map(() => []);
    const u = Bi(d);
    return u.length === 0 ? e.relationships.map(() => []) : e.relationships.length === 1 && !Array.isArray(u[0]) ? [Je(u, (f) => re.parseString(f))] : Je(Bi(d, e.relationships.length), (f) => Je(f, (g) => re.parseString(g)));
  }), a = K(n, "props", (d) => {
    const u = e.properties;
    return d === void 0 ? u.map((f) => f.default) : Je(Bi(d, e.properties.length), (f, g) => Es[u[g].type].deserializeJson(f));
  }), l = {
    id: r,
    description: K(n, "description", xi),
    relatedSegments: s,
    properties: a,
    type: i
  };
  return Gn[i].restoreState(l, n, e.rank), l;
}
var xo = class extends Z {
  constructor(e, t = [], i = []) {
    super(), this.relationships = t, this.properties = i, this.annotationMap = new de(), this.changed = new Ee(), this.readonly = false, this.childAdded = new ot(), this.childUpdated = new ot(), this.childDeleted = new ot(), this.childRefreshed = new Ee(), this.pending = new je(), this.references = new de(), this.rank_ = e, this.annotationPropertySerializers = Pv(e, i);
  }
  get rank() {
    return this.rank_;
  }
  hasNonSerializedProperties() {
    return true;
  }
  add(e, t = true) {
    if (this.ensureUpdated(), !e.id)
      e.id = Av();
    else if (this.annotationMap.has(e.id))
      throw new Error(`Annotation id already exists: ${se(e.id)}.`);
    return this.annotationMap.set(e.id, e), this.changed.dispatch(), this.childAdded.dispatch(e), t || this.pending.add(e.id), this.getReference(e.id);
  }
  commit(e) {
    this.ensureUpdated();
    const t = e.id;
    this.pending.delete(t), this.changed.dispatch();
  }
  update(e, t) {
    if (this.ensureUpdated(), e.value === null)
      throw new Error("Annotation already deleted.");
    e.value = t, this.annotationMap.set(t.id, t), e.changed.dispatch(), this.changed.dispatch(), this.childUpdated.dispatch(t);
  }
  [wZr]() {
    return this.ensureUpdated(), this.annotationMap.values();
  }
  get(e) {
    return this.ensureUpdated(), this.annotationMap.get(e);
  }
  delete(e) {
    e.value !== null && (e.value = null, this.annotationMap.delete(e.id), this.pending.delete(e.id), e.changed.dispatch(), this.changed.dispatch(), this.childDeleted.dispatch(e.id));
  }
  getReference(e) {
    let t = this.references.get(e);
    return t !== void 0 ? t.addRef() : (t = new du(e), t.value = this.annotationMap.get(e) || null, this.references.set(e, t), t.registerDisposer(() => {
      this.references.delete(e);
    }), t);
  }
  ensureUpdated() {
  }
  toJSON() {
    this.ensureUpdated();
    const e = [], t = this.pending;
    for (const i of this)
      t.has(i.id) || e.push(Ug(i, this));
    return e;
  }
  clear() {
    this.annotationMap.clear(), this.pending.clear(), this.changed.dispatch();
  }
  restoreState(e) {
    this.ensureUpdated();
    const t = this.annotationMap;
    t.clear(), this.pending.clear(), e !== void 0 && Je(e, (i) => {
      const r = f2(i, this);
      t.set(r.id, r);
    });
    for (const i of this.references.values()) {
      const r = i.id, s = t.get(r);
      i.value = s || null, i.changed.dispatch();
    }
    this.changed.dispatch();
  }
  reset() {
    this.clear();
  }
};
var p2 = class extends xo {
  constructor(e, t, i) {
    super(e.value.sourceRank, i, t), this.watchableTransform = e, this.curCoordinateTransform = e.value, this.registerDisposer(e.changed.add(() => this.ensureUpdated()));
  }
  get rank() {
    return this.ensureUpdated(), this.rank_;
  }
  ensureUpdated() {
    const e = this.watchableTransform.value, t = this.curCoordinateTransform;
    if (e === t)
      return;
    this.curCoordinateTransform = e;
    const i = e.sourceRank, r = t.sourceRank;
    if (r === i && (t.inputSpace === e.inputSpace || Fe(t.inputSpace.ids.slice(0, i), e.inputSpace.ids.slice(0, i))))
      return;
    const s = e.inputSpace.ids, a = t.inputSpace.ids, l = [];
    for (let u = 0; u < i; ++u) {
      let f = a.indexOf(s[u]);
      f >= r && (f = -1), l.push(f);
    }
    const d = (u) => {
      const f = new Float32Array(i);
      for (let g = 0; g < i; ++g) {
        const v = l[g];
        f[g] = v === -1 ? 0 : u[g];
      }
      return f;
    };
    for (const u of this.annotationMap.values())
      switch (u.type) {
        case Me.POINT:
          u.point = d(u.point);
          break;
        case Me.LINE:
        case Me.SPHERE:
        case Me.AXIS_ALIGNED_BOUNDING_BOX:
          u.pointA = d(u.pointA), u.pointB = d(u.pointB);
          break;
        case Me.ELLIPSOID:
          u.center = d(u.center), u.radii = d(u.radii);
          break;
      }
    this.rank_ !== i && (this.rank_ = i, this.annotationPropertySerializers = Pv(this.rank_, this.properties)), this.changed.dispatch();
  }
};
var g2 = "Data Bounds";
function Av() {
  return Au(160);
}
function m2(n) {
  return {
    type: Me.AXIS_ALIGNED_BOUNDING_BOX,
    id: "data-bounds",
    description: g2,
    pointA: new Float32Array(n.lowerBounds),
    pointB: new Float32Array(n.upperBounds),
    properties: []
  };
}
function Bc(n) {
  const e = new xo(n.lowerBounds.length);
  return e.readonly = true, e.add(m2(n)), e;
}
function v2(n, e) {
  let t = 0;
  const i = [];
  for (const u of Br) {
    const g = e[u].serializedBytes;
    i[u] = t;
    const y = n[u].length;
    t += g * y;
  }
  const r = [], s = [], a = new ArrayBuffer(t), l = new DataView(a), d = _c === ai.LITTLE;
  for (const u of Br) {
    const f = e[u], g = f.rank, v = f.serialize, y = n[u];
    r[u] = y.map((L) => L.id), s[u] = new de(y.map((L, R) => [L.id, R]));
    const C = Gn[u].serialize, b = i[u], E = f.propertyGroupBytes[0];
    for (let L = 0, R = y.length; L < R; ++L) {
      const _ = y[L];
      C(l, b + L * E, d, g, _), v(l, b, L, R, d, _.properties);
    }
  }
  return { data: new Uint8Array(a), typeToIds: r, typeToOffset: i, typeToIdMaps: s };
}
var y2 = class {
  constructor(e) {
    this.propertySerializers = e, this.annotations = [[], [], [], [], []];
  }
  add(e) {
    this.annotations[e.type].push(e);
  }
  serialize() {
    return v2(this.annotations, this.propertySerializers);
  }
};
function Rv(n) {
  if (n == null)
    return n;
  const e = n.relatedSegments;
  if (e !== void 0)
    for (let t = 0, i = e.length; t < i; ++t) {
      const r = e[t];
      r !== void 0 && (e[t] = r.map((s) => new re(s.low, s.high)));
    }
  return n;
}
function Ph(n, e, t, i, r, s, a, l, d) {
  for (let u = 0; u < a; ++u)
    for (let f = 0; f < d; ++f) {
      let g = 0;
      for (let v = 0; v < l; ++v)
        g += t[u + i * v] * r[v + s * f];
      n[u + e * f] = g;
    }
  return n;
}
function S2(n, e, t) {
  for (let i = 0; i < t; ++i) {
    const r = e * i;
    n.fill(0, r, r + t), n[r + i] = 1;
  }
  return n;
}
function Ds(n, e, t = e) {
  return S2(new n(e * t), e, Math.min(e, t));
}
function eC(n, e, t = true) {
  const i = e.length, r = t ? i + 1 : i, s = new n(r * (i + 1));
  t && (s[s.length - 1] = 1);
  for (let a = 0; a < i; ++a)
    s[(r + 1) * a] = e[a];
  return s;
}
function b2(n, e, t) {
  for (let i = 0; i < t; ++i)
    for (let r = 0; r < t; ++r)
      if (n[i * e + r] != (i === r ? 1 : 0))
        return false;
  return true;
}
function Mv(n, e, t, i, r, s) {
  for (let a = 0; a < s; ++a) {
    const l = a * i, d = a * e;
    for (let u = 0; u < r; ++u)
      n[d + u] = t[l + u];
  }
  return n;
}
function Nv(n, e, t, i) {
  Mv(n, e + 1, t, i + 1, i, i);
  for (let r = 0; r < i; ++r)
    n[(e + 1) * e + r] = t[(i + 1) * i + r];
  n[n.length - 1] = 1;
  for (let r = i; r < e; ++r)
    n[(e + 1) * r + r] = 1;
  return n;
}
var fi;
function C2(n, e, t) {
  let i = 1;
  (fi === void 0 || fi.length < t) && (fi = new Uint32Array(t));
  for (let r = 0; r < t; ++r)
    fi[r] = r;
  for (let r = 0; r < t; ++r) {
    const s = e * r;
    let a = r;
    {
      let u = Math.abs(n[s + r]);
      for (let f = r + 1; f < t; ++f) {
        const g = Math.abs(n[s + f]);
        g > u && (u = g, a = f);
      }
    }
    if (r !== a) {
      i *= -1;
      for (let u = 0; u < t; ++u) {
        const f = e * u, g = n[f + r];
        n[f + r] = n[f + a], n[f + a] = g;
      }
      {
        const u = fi[r];
        fi[r] = fi[a], fi[a] = u;
      }
    }
    const l = n[s + r], d = 1 / l;
    i *= l;
    for (let u = 0; u < t; ++u)
      n[e * u + r] *= d;
    n[s + r] = d;
    for (let u = 0; u < t; ++u) {
      if (u === r)
        continue;
      const f = -n[e * r + u];
      for (let g = 0; g < t; ++g) {
        const v = e * g;
        n[v + u] += f * n[v + r];
      }
      n[e * r + u] = f * d;
    }
  }
  for (let r = 0; r < t; ++r) {
    let s = fi[r];
    for (; s !== r; ) {
      const a = e * r, l = e * s;
      for (let u = 0; u < t; ++u) {
        const f = a + u, g = l + u, v = n[f];
        n[f] = n[g], n[g] = v;
      }
      const d = fi[r] = fi[s];
      fi[s] = s, s = d;
    }
  }
  return i;
}
function _v(n, e, t, i, r) {
  return Mv(n, e, t, i, r, r), C2(n, e, r);
}
function w2(n, e, t, i, r, s) {
  for (let a = 0; a < s; ++a) {
    const l = e * a, d = i * a;
    for (let u = 0; u < r; ++u)
      if (n[l + u] !== t[d + u])
        return false;
  }
  return true;
}
function _r(n, e, t, i, r) {
  for (let s = 0; s < r; ++s) {
    let a = e[t * r + s];
    for (let l = 0; l < r; ++l)
      a += e[t * l + s] * i[l];
    n[s] = a;
  }
  return n;
}
function E1(n, e, t, i, r) {
  for (let s = 0; s < r; ++s) {
    let a = 0;
    for (let l = 0; l < r; ++l)
      a += e[t * l + s] * i[l];
    n[s] = a;
  }
  return n;
}
var tC = Y_;
tC(tC.S, "Math", {
  log10: function(e) {
    return Math.log(e) * Math.LOG10E;
  }
});
var x2 = xv.Math.log10;
var E2 = { default: x2, __esModule: true };
var T1 = Gs(E2);
var uu = [
  { prefix: "Y", exponent: 24 },
  { prefix: "Z", exponent: 21 },
  { prefix: "E", exponent: 18 },
  { prefix: "P", exponent: 15 },
  { prefix: "T", exponent: 12 },
  { prefix: "G", exponent: 9 },
  { prefix: "M", exponent: 6 },
  { prefix: "k", exponent: 3 },
  // {prefix: 'h', exponent: 2},
  // {prefix: 'da', exponent: 1},
  { prefix: "", exponent: 0 },
  // {prefix: 'd', exponent: -1},
  // {prefix: 'c', exponent: -2},
  { prefix: "m", exponent: -3 },
  { prefix: "µ", exponent: -6 },
  { prefix: "n", exponent: -9 },
  { prefix: "p", exponent: -12 },
  { prefix: "f", exponent: -15 },
  { prefix: "a", exponent: -18 },
  { prefix: "z", exponent: -21 },
  { prefix: "y", exponent: -24 }
];
var T2 = [
  // Parse 'c' for centi, but don't pick it.
  { prefix: "c", exponent: -2 },
  { prefix: "u", exponent: -6 },
  ...uu
];
var Fc = new de();
Fc.set("", { unit: "", exponent: 0 });
var k2 = new de();
for (const n of T2) {
  const e = n.prefix, t = n.exponent;
  k2.set(t, e);
  for (const i of ["m", "s", "Hz", "rad/s"])
    Fc.set(`${e}${i}`, { unit: i, exponent: t });
}
function k1(n) {
  const e = T1(n), t = uu.length, i = gN(0, t, (r) => uu[r].exponent <= e);
  return uu[Math.min(i, t - 1)];
}
function I1(n, e, t = {}) {
  var i = t.precision;
  const r = i === void 0 ? 6 : i;
  var s = t.elide1;
  const a = s === void 0 ? true : s;
  let l = n, d = "";
  if (e !== "") {
    const f = k1(n);
    d = f.prefix, l = Ov(n, -f.exponent);
  }
  if (a && l === 1)
    return { scale: "", unit: e, prefix: d };
  let u;
  if (r != 0) {
    l < 1 || l >= 1e3 ? u = l.toPrecision(r) : u = l.toFixed(r);
    const f = u.indexOf("e");
    let g, v;
    f !== -1 ? (g = u.substring(0, f), v = u.substring(f)) : (g = u, v = "");
    const y = g.match(/.*\.(?:[0-9]*[1-9])?(0+)$/);
    y !== null && (g = g.substring(0, g.length - y[1].length), g.endsWith(".") && (g = g.substring(0, g.length - 1)), u = g + v);
  } else
    u = l.toString();
  return {
    scale: u,
    unit: e,
    prefix: d
  };
}
function ca(n, e, t) {
  var i = I1(n, e, t);
  const r = i.scale, s = i.unit, a = i.prefix;
  return `${r}${a}${s}`;
}
function pc(n) {
  if (n === "")
    return { scale: 1, unit: "" };
  const e = n.match(/^((?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)?([µa-zA-Z]+)?$/);
  if (e === null)
    return;
  const t = e[1];
  let i = t === void 0 ? 1 : Number(t);
  if (nr(i))
    return;
  let r = "";
  if (e[2] !== void 0) {
    const s = Fc.get(e[2]);
    if (s === void 0)
      return;
    r = s.unit, s.exponent > 0 ? i *= 10 ** s.exponent : i /= 10 ** -s.exponent;
  }
  if (!(i <= 0 || !kt(i)))
    return { scale: i, unit: r };
}
function nC(n) {
  const e = Fc.get(n);
  if (e === void 0)
    throw new Error(`Invalid unit: ${se(n)}`);
  return e;
}
function Ov(n, e) {
  return e >= 0 ? n * 10 ** e : n / 10 ** -e;
}
function L1(n, e, t) {
  const i = n.length;
  for (let r = 0; r < i; ++r)
    n[r] = e[r] + t[r];
  return n;
}
function zg(n, e, t) {
  const i = n.length;
  for (let r = 0; r < i; ++r)
    n[r] = e[r] - t[r];
  return n;
}
function I2(n, e, t, i) {
  const r = n.length;
  for (let s = 0; s < r; ++s)
    n[s] = e[s] + t[s] * i;
  return n;
}
function L2(n, e, t) {
  const i = n.length;
  for (let r = 0; r < i; ++r)
    n[r] = e[r] * t;
  return n;
}
function Vv2(n) {
  let e = 1;
  for (let t = 0, i = n.length; t < i; ++t)
    e *= n[t];
  return e;
}
function D2(n, e, t) {
  const i = n.length;
  for (let r = 0; r < i; ++r)
    n[r] = Math.min(e[r], t[r]);
  return n;
}
var Eo = new Float32Array(0);
var D1 = new Float64Array(0);
var P2 = 0;
function lo() {
  return ++P2;
}
function A2(n, e) {
  return Fe(n.lowerBounds, e.lowerBounds) && Fe(n.upperBounds, e.upperBounds);
}
function R2(n, e) {
  return n === void 0 ? e === void 0 : e === void 0 ? false : n.explicit === e.explicit && Fe(n.coordinates, e.coordinates) && Fe(n.labels, e.labels);
}
function M2(n, e) {
  const t = new de();
  for (let i = 0, r = n.length; i < r; ++i)
    t.set(n[i], e[i]);
  return n = De(t.keys()), n.sort((i, r) => i - r), e = De(n, (i) => t.get(i)), { coordinates: n, labels: e };
}
function P1(n) {
  if (n.length === 1)
    return n[0];
  const e = new de();
  let t = false;
  for (const s of n) {
    s.explicit && (t = true);
    const a = s.coordinates, l = s.labels;
    for (let d = 0, u = a.length; d < u; ++d)
      e.set(a[d], l[d]);
  }
  const i = De(e.keys());
  i.sort((s, a) => s - a);
  const r = De(i, (s) => e.get(s));
  return { explicit: t, coordinates: i, labels: r };
}
function iC(n) {
  if (n = n.filter((e) => e !== void 0), n.length !== 0)
    return P1(n);
}
function N2(n, e) {
  return Fe(n.transform, e.transform) && A2(n.box, e.box);
}
function Ru(n, e) {
  return n.valid === e.valid && n.rank === e.rank && Fe(n.names, e.names) && Fe(n.ids, e.ids) && Fe(n.timestamps, e.timestamps) && Fe(n.units, e.units) && Fe(n.scales, e.scales) && kg(n.boundingBoxes, e.boundingBoxes, N2) && kg(n.coordinateArrays, e.coordinateArrays, R2);
}
function mt(n) {
  const e = n.names, t = n.units, i = n.scales;
  var r = n.valid;
  const s = r === void 0 ? true : r;
  var a = n.rank;
  const l = a === void 0 ? e.length : a;
  var d = n.timestamps;
  const u = d === void 0 ? e.map(() => Number.NEGATIVE_INFINITY) : d;
  var f = n.ids;
  const g = f === void 0 ? e.map((L, R) => -R) : f;
  var v = n.boundingBoxes;
  const y = v === void 0 ? [] : v;
  var w = n.coordinateArrays;
  const C = w === void 0 ? new Array(l) : w;
  var b = n.bounds;
  const E = b === void 0 ? V2(y, l) : b;
  return {
    valid: s,
    rank: l,
    names: e,
    timestamps: u,
    ids: g,
    units: t,
    scales: i,
    boundingBoxes: y,
    bounds: E,
    coordinateArrays: C
  };
}
var zr = mt({
  valid: false,
  names: [],
  units: [],
  scales: D1,
  boundingBoxes: []
});
var To = mt({
  valid: true,
  names: [],
  units: [],
  scales: D1,
  boundingBoxes: []
});
function _2(n) {
  var e = Bi(n, 2), t = ce(e, 2);
  const i = t[0], r = t[1], s = vn(i), a = Le(r), l = Fc.get(a);
  if (l === void 0)
    throw new Error(`Invalid unit: ${se(a)}`);
  return { unit: l.unit, scale: Ov(s, l.exponent) };
}
function Mu(n, e = false) {
  if (n === void 0)
    return zr;
  pe(n);
  const t = zv(un(n), e), i = t.length, r = new Array(i), s = new Float64Array(i), a = new Array(i);
  for (let l = 0; l < i; ++l)
    K(n, t[l], (d) => {
      if (Array.isArray(d)) {
        var u = _2(d);
        const f = u.unit, g = u.scale;
        r[l] = f, s[l] = g;
      } else {
        pe(d);
        let f = K(d, "coordinates", y1), g = K(d, "labels", Ci), v = f.length;
        if (v !== g.length)
          throw new Error(`Length of coordinates array (${v}) does not match length of labels array (${g.length})`);
        r[l] = "", s[l] = 1, a[l] = RZr({ explicit: true }, M2(f, g));
      }
    });
  return mt({ valid: false, names: t, units: r, scales: s, coordinateArrays: a });
}
function Gg(n) {
  const e = n.rank;
  if (e === 0)
    return;
  const t = n.names, i = n.units, r = n.scales, s = n.coordinateArrays, a = {};
  for (let l = 0; l < e; ++l) {
    const d = t[l], u = s[l];
    (u == null ? void 0 : u.explicit) ? a[d] = {
      coordinates: De(u.coordinates),
      labels: u.labels
    } : a[d] = [r[l], i[l]];
  }
  return a;
}
var Bv = class extends gt {
  constructor() {
    super(zr);
  }
  toJSON() {
    return Gg(this.value);
  }
  reset() {
    this.value = zr;
  }
  restoreState(e) {
    this.value = Mu(e);
  }
};
function A1(n, e) {
  let t = (n + e) / 2;
  return kt(t) || (t = Math.min(Math.max(0, n), e)), t;
}
function O2(n, e) {
  const t = e.lowerBounds, i = e.upperBounds, r = n.length;
  for (let s = 0; s < r; ++s)
    n[s] = A1(t[s], i[s]);
  return n;
}
function Sa(n) {
  const e = n.lowerBounds.length;
  return { box: n, transform: Ds(Float64Array, e, e + 1) };
}
function R1(n, e, t) {
  var i = n.box;
  const r = i.lowerBounds, s = i.upperBounds, a = n.transform, l = r.length, d = t, u = a[d * l + e];
  let f = u, g = u, v = false;
  for (let y = 0; y < l; ++y) {
    let w = a[d * y + e];
    if (w === 0)
      continue;
    const C = w * r[y], b = w * s[y];
    f += Math.min(C, b), g += Math.max(C, b), v = true;
  }
  if (v)
    return { lower: f, upper: g };
}
function V2(n, e) {
  const t = new Float64Array(e), i = new Float64Array(e);
  t.fill(Number.NEGATIVE_INFINITY), i.fill(Number.POSITIVE_INFINITY);
  for (const r of n)
    for (let s = 0; s < e; ++s) {
      const a = R1(r, s, e);
      if (a === void 0)
        continue;
      const l = a.lower, d = a.upper;
      t[s] = t[s] === Number.NEGATIVE_INFINITY ? l : Math.min(t[s], l), i[s] = i[s] === Number.POSITIVE_INFINITY ? d : Math.max(i[s], d);
    }
  return { lowerBounds: t, upperBounds: i };
}
function B2(n, e, t) {
  const i = n.transform, r = n.box, s = t.length, a = r.lowerBounds.length, l = new Float64Array((a + 1) * e);
  for (let d = 0; d < s; ++d) {
    const u = t[d];
    if (u !== -1)
      for (let f = 0; f <= a; ++f)
        l[f * e + u] = i[f * s + d];
  }
  return {
    transform: l,
    box: r
  };
}
function M1(n, e) {
  const t = { lowerBounds: Float64Array.of(0), upperBounds: Float64Array.of(1) }, i = new Float64Array(2 * n);
  return i[e] = 1, { transform: i, box: t };
}
function N1(n, e, t) {
  if (e === t)
    return n;
  const i = n.box, r = i.lowerBounds.length, s = new Float64Array((r + 1) * t);
  return Mv(s, t, n.transform, e, e, r + 1), { box: i, transform: s };
}
function F2(n, e) {
  const t = n.rank, i = n.sourceRank;
  if (t !== e.rank || i !== e.sourceRank)
    return false;
  const r = n.inputSpace, s = e.inputSpace;
  return !Fe(s.scales, r.scales) || !Fe(s.units, r.units) || !Fe(e.outputSpace.names, n.outputSpace.names) ? false : V1(n.transform, t, n.outputSpace.scales, e.transform, t, e.outputSpace.scales);
}
function Qn(n) {
  return {
    rank: n.rank,
    sourceRank: n.rank,
    inputSpace: n,
    outputSpace: n,
    transform: Ds(Float64Array, n.rank + 1)
  };
}
function U2(n, e, t, i) {
  let r = n.transform, s = n.box;
  const a = n.box.lowerBounds.length, l = i.length, d = new Float64Array((a + 1) * l);
  for (let u = 0; u < l; ++u) {
    const f = i[u];
    for (let v = 0; v < a; ++v) {
      let y = 0;
      for (let w = 0; w < l; ++w) {
        const C = t[w];
        y += e[(l + 1) * w + u] * r[l * v + w] * (C / f);
      }
      d[l * v + u] = y;
    }
    let g = e[(l + 1) * l + u];
    for (let v = 0; v < l; ++v) {
      const y = t[v];
      g += e[(l + 1) * v + u] * r[l * a + v] * (y / f);
    }
    d[a * l + u] = g;
  }
  return {
    transform: d,
    box: s
  };
}
function _1(n, e, t) {
  return n.boundingBoxes.map((i) => U2(i, e, n.scales, t));
}
function $g(n, e, t) {
  const i = mt({
    valid: n.valid,
    rank: t.rank,
    ids: t.ids,
    names: t.names,
    timestamps: t.timestamps,
    scales: t.scales,
    units: t.units,
    boundingBoxes: _1(n, e, t.scales),
    coordinateArrays: t.coordinateArrays
  });
  return Ru(i, t) ? t : i;
}
function Fv(n, e = false) {
  if (e) {
    const t = Number(n);
    if (jn(t) && t >= 0)
      return true;
  }
  return n.match(/^[a-zA-Z][a-zA-Z_0-9]*['^]?$/) !== null;
}
function Ah(n, e = false) {
  const t = new je();
  for (const i of n) {
    if (!Fv(i, e) || t.has(i))
      return false;
    t.add(i);
  }
  return true;
}
function Uv(n) {
  const e = n.length, t = new Array(e);
  t.fill(true);
  for (let i = 0; i < e; ++i) {
    const r = n[i];
    if (!Fv(r)) {
      t[i] = false;
      continue;
    }
    const s = n.indexOf(r, i + 1);
    s !== -1 && (t[i] = false, t[s] = false);
  }
  return t;
}
function ic(n) {
  return n.endsWith("'");
}
function O1(n) {
  return n.endsWith("'") || n.endsWith("^");
}
function z2(n) {
  return n.endsWith("^");
}
function G2(n) {
  return !O1(n);
}
function $2(n, e, t) {
  const i = new Float64Array(n), r = e.length, s = (r + 1) * r;
  for (let a = 0; a < r; ++a)
    i[s + a] *= e[a] / t[a];
  return i;
}
function V1(n, e, t, i, r, s) {
  if (!w2(n, e + 1, i, r + 1, e, e))
    return false;
  for (let a = 0; a < e; ++a) {
    const l = n[(e + 1) * e + a], d = i[(r + 1) * r + a];
    if (l * (t[a] / s[a]) !== d)
      return false;
  }
  for (let a = e; a < r; ++a)
    if (i[(r + 1) * r + a] !== 0)
      return false;
  for (let a = e; a < r; ++a) {
    for (let l = 0; l < e; ++l)
      if (i[(r + 1) * l + a] !== 0)
        return false;
    for (let l = 0; l < r; ++l) {
      const d = i[(r + 1) * a + l];
      if (a === l) {
        if (d !== 1)
          return false;
      } else if (d !== 0)
        return false;
    }
  }
  return true;
}
function W2(n, e) {
  if (!e.includes(n))
    return n;
  var t = n.match(/^([^']*)('?)$/), i = ce(t, 3);
  const r = i[1], s = i[2];
  for (let a = 0; ; ++a) {
    const l = `${r}${a}${s}`;
    if (!e.includes(l))
      return l;
  }
}
function H2(n, e) {
  const t = n.inputSpace, i = n.transform, r = t.ids, s = t.rank, a = e.rank, l = e.names, d = e.units, u = e.scales, f = new Array(s);
  f.fill(true);
  const g = [], v = e.ids.map((G, F) => {
    const ue = r.indexOf(G);
    return ue !== -1 ? f[ue] = false : g.push(F), ue;
  }), y = n.outputSpace, w = y.names, C = y.units, b = y.scales, E = y.ids, L = y.timestamps, R = y.coordinateArrays, _ = f, A = [], I = [], P = new Float64Array(a), N = [], O = [], B = new Array(a);
  let j = 0;
  const U = new Float64Array((a + 1) ** 2);
  U[U.length - 1] = 1;
  for (let G = 0; G < s; ++G)
    if (!_[G]) {
      A[j] = w[G], N[j] = E[G], I[j] = C[G], P[j] = b[G], O[j] = L[G], B[j] = R[G];
      for (let F = 0; F < a; ++F) {
        const ue = v[F];
        ue !== -1 && (U[F * (a + 1) + j] = i[ue * (s + 1) + G]);
      }
      U[a * (a + 1) + j] = i[s * (s + 1) + G], ++j;
    }
  for (const G of g)
    N[j] = lo(), A[j] = W2(l[G], A), P[j] = u[G], I[j] = d[G], U[G * (a + 1) + j] = 1, ++j;
  const V = mt({
    valid: e.valid,
    rank: a,
    names: A,
    ids: N,
    timestamps: O,
    units: I,
    scales: P,
    boundingBoxes: _1(e, U, P),
    coordinateArrays: B
  });
  return {
    rank: a,
    sourceRank: n.sourceRank,
    inputSpace: e,
    outputSpace: V,
    transform: U
  };
}
function rC(n) {
  const e = $g(n.inputSpace, n.transform, n.outputSpace);
  return e === n.outputSpace ? n : {
    rank: n.rank,
    sourceRank: n.sourceRank,
    inputSpace: n.inputSpace,
    transform: n.transform,
    outputSpace: e
  };
}
var sC = class {
  constructor(e, t = false) {
    this.mutableSourceRank = t, this.value_ = void 0, this.changed = new Ee(), this.inputSpaceChanged = new Ee(), this.defaultTransform = rC(e);
    const i = this;
    this.outputSpace = {
      changed: i.changed,
      get value() {
        return i.value.outputSpace;
      },
      set value(r) {
        const s = i.value;
        if (Ru(s.outputSpace, r) || s.rank !== r.rank)
          return;
        const a = $2(s.transform, s.outputSpace.scales, r.scales);
        i.value_ = {
          sourceRank: s.sourceRank,
          rank: s.rank,
          inputSpace: s.inputSpace,
          outputSpace: $g(s.inputSpace, a, r),
          transform: a
        }, i.changed.dispatch();
      }
    }, this.inputSpace = {
      changed: i.inputSpaceChanged,
      get value() {
        return i.value.inputSpace;
      },
      set value(r) {
        const s = i.value;
        Ru(s.inputSpace, r) || (i.value_ = H2(s, r), i.inputSpaceChanged.dispatch(), i.changed.dispatch());
      }
    };
  }
  set value(e) {
    const t = this.value;
    e !== t && (this.value_ = rC(e), e.inputSpace !== t.inputSpace && this.inputSpaceChanged.dispatch(), this.changed.dispatch());
  }
  get value() {
    let e = this.value_;
    return e === void 0 && (e = this.value_ = this.defaultTransform), e;
  }
  reset() {
    this.value_ !== this.defaultTransform && (this.value_ = this.defaultTransform, this.inputSpaceChanged.dispatch(), this.changed.dispatch());
  }
  get defaultInputSpace() {
    return this.defaultTransform.inputSpace;
  }
  get spec() {
    const e = this.value, t = e.rank, i = e.transform, r = e.inputSpace, s = e.outputSpace, a = e.sourceRank, l = this.defaultTransform, d = this.mutableSourceRank, u = l.inputSpace, f = l.rank, g = l.transform, v = l.outputSpace, y = r.units, w = r.scales, C = a === t && Fe(w, d ? s.scales : u.scales) && Fe(y, d ? s.units : u.units), b = V1(g, f, v.scales, i, t, s.scales), E = Fe(v.names, s.names);
    if (!(b && E && C))
      return {
        sourceRank: a,
        transform: b ? void 0 : i,
        outputSpace: e.outputSpace,
        inputSpace: C ? void 0 : r
      };
  }
  set transform(e) {
    const t = this.value, i = t.inputSpace;
    this.value_ = {
      rank: t.rank,
      sourceRank: t.sourceRank,
      inputSpace: i,
      transform: e,
      outputSpace: $g(i, e, t.outputSpace)
    }, this.changed.dispatch();
  }
  set spec(e) {
    if (e === void 0) {
      this.reset();
      return;
    }
    if (this.mutableSourceRank) {
      const U = e.inputSpace || e.outputSpace, V = U.rank, G = mt({
        rank: V,
        names: U.names.map((F, ue) => `${ue}`),
        units: U.units,
        scales: U.scales,
        coordinateArrays: U.coordinateArrays
      });
      this.value = {
        rank: V,
        transform: e.transform || Ds(Float64Array, V + 1),
        sourceRank: e.sourceRank,
        outputSpace: e.outputSpace,
        inputSpace: G
      };
      return;
    }
    var t = this.defaultTransform;
    const i = t.inputSpace, r = t.sourceRank, s = t.outputSpace, a = t.transform, l = t.rank, d = e.inputSpace, u = e.sourceRank, f = e.outputSpace, g = e.transform, v = e.outputSpace.rank, y = i.names, w = d !== void 0 ? d.names : y, C = new Array(r);
    for (let U = 0; U < r; ++U) {
      let V = w.indexOf(y[U]);
      V >= u && (V = -1), C[U] = V;
    }
    const b = v - u + r;
    for (let U = u; U < v; ++U)
      C[r + U - u] = U;
    const E = new Float64Array(b), L = new Array(b), R = [];
    for (let U = 0; U < r; ++U) {
      const V = C[U];
      V === -1 || d === void 0 ? (E[U] = i.scales[U], R[U] = i.units[U], L[U] = i.coordinateArrays[U]) : (E[U] = d.scales[V], R[U] = d.units[V], L[U] = iC([i.coordinateArrays[U], d.coordinateArrays[V]]));
    }
    const _ = d || f, A = y.slice(0, r), I = s.names.slice(0, r), P = s.coordinateArrays.slice(0, r), N = new Float64Array(b), O = [];
    for (let U = 0; U < b; ++U) {
      const V = C[U];
      V === -1 ? (N[U] = s.scales[U], O[U] = s.units[U], P[U] = s.coordinateArrays[U]) : (I[U] = f.names[V], O[U] = f.units[V], N[U] = f.scales[V], P[U] = f.coordinateArrays[V]);
    }
    if (!Ah(I)) {
      this.reset();
      return;
    }
    for (let U = r; U < b; ++U) {
      const V = U - r + u;
      E[U] = _.scales[V], R[U] = _.units[V], A[U] = `${U}`;
    }
    const B = new Float64Array((b + 1) ** 2);
    B[B.length - 1] = 1;
    for (let U = 0; U < b; ++U) {
      const V = C[U];
      let G;
      V === -1 || g === void 0 ? U >= r ? G = 0 : G = a[l * (l + 1) + U] * (s.scales[U] / N[U]) : G = g[v * (v + 1) + V], B[b * (b + 1) + U] = G;
      for (let F = 0; F < b; ++F) {
        const ue = C[F];
        let ae;
        V === -1 != (ue === -1) ? ae = 0 : V === -1 || g === void 0 ? V >= r || ue >= r ? ae = V === ue ? 1 : 0 : ae = a[F * (l + 1) + U] : ae = g[ue * (v + 1) + V], B[F * (b + 1) + U] = ae;
      }
    }
    const j = i.boundingBoxes.map((U) => N1(U, l, b));
    for (let U = r; U < b; ++U)
      j.push(M1(b, U));
    for (let U = 0; U < b; ++U) {
      if (B[b * (b + 1) + U] !== 0)
        continue;
      let G;
      for (let ue = 0; ue < b; ++ue) {
        const ae = B[ue * (b + 1) + U];
        if (ae !== 0)
          if (ae === 1)
            if (G === void 0)
              G = ue;
            else {
              G = null;
              break;
            }
          else {
            G = null;
            break;
          }
      }
      if (G == null)
        continue;
      let F = L[G];
      F !== void 0 && (F.explicit && (F = RZr(RZr({}, F), { explicit: false })), P[U] = iC([F, P[U]]));
    }
    this.value = {
      rank: b,
      transform: B,
      sourceRank: r,
      outputSpace: mt({
        rank: b,
        names: I,
        scales: N,
        units: O,
        coordinateArrays: P
      }),
      inputSpace: mt({
        rank: b,
        names: A,
        scales: E,
        units: R,
        coordinateArrays: L,
        boundingBoxes: j
      })
    };
  }
  toJSON() {
    return U1(this.spec);
  }
  restoreState(e) {
    this.spec = F1(e);
  }
};
function j2(n, e = false) {
  const t = Le(n);
  if (!Fv(t, e))
    throw new Error(`Invalid dimension name: ${se(t)}`);
  return t;
}
function zv(n, e = false) {
  const t = Je(n, (i) => j2(i, e));
  if (!Ah(t, e))
    throw new Error(`Invalid dimensions: ${se(t)}`);
  return t;
}
var Gv2 = class {
  constructor(e, t) {
    this.combined = e, this.bindings = new je(), this.retainCount = 0, this.prevCombined = this.combined.value, this.dimensionRefCounts = new de(), this.handleCombinedChanged = () => {
      this.combined.value !== this.prevCombined && this.update();
    }, this.includeDimensionPredicate_ = t;
  }
  getRenameValidity(e) {
    const t = this.combined.value.names, i = Uv(e), r = e.length;
    for (let s = 0; s < r; ++s) {
      if (!i[s])
        continue;
      const a = e[s];
      if (t.includes(a))
        continue;
      let l = true;
      for (const d of this.bindings)
        if (d.space.value.names.includes(a)) {
          l = false;
          break;
        }
      i[s] = l;
    }
    return i;
  }
  get includeDimensionPredicate() {
    return this.includeDimensionPredicate_;
  }
  set includeDimensionPredicate(e) {
    this.includeDimensionPredicate_ = e, this.update();
  }
  update() {
    const e = this.combined, t = this.bindings, i = this.retainCount > 0 ? 1 : 0;
    if (t.size === 0 && !i) {
      e.value = zr;
      return;
    }
    const r = this.includeDimensionPredicate_, s = e.value;
    let a = De(s.names), l = De(s.units), d = De(s.scales), u = De(s.ids), f = De(s.timestamps), g = s.names.map(() => i ? 1 : 0);
    const v = [];
    let y = false;
    for (const A of t) {
      const I = A.space.value, P = A.prevValue, N = A.mappedDimensionIds;
      y = y || I.valid;
      const O = I.names, B = I.units, j = I.scales, U = I.ids, V = I.timestamps, G = [], F = [];
      v.push(F), A.mappedDimensionIds = G, A.prevValue = I;
      const ue = O.length;
      for (let ae = 0; ae < ue; ++ae) {
        const Ie = O[ae];
        if (!r(Ie))
          continue;
        if (P !== void 0) {
          const Ue = U[ae], Ye = P.ids.indexOf(Ue);
          if (Ye !== -1) {
            const Ze = N[Ye];
            if (Ze !== void 0) {
              const rt = u.indexOf(Ze);
              if (rt !== -1) {
                G[ae] = Ze, ++g[rt], F[ae] = rt;
                const Xe = V[ae];
                Xe !== void 0 && !(Xe <= f[rt]) && (a[rt] = Ie, d[rt] = j[ae], l[rt] = B[ae], f[rt] = Xe);
                continue;
              }
            }
          }
        }
        let le = a.indexOf(Ie);
        if (le !== -1) {
          G[ae] = u[le], ++g[le], F[ae] = le;
          continue;
        }
        le = a.length, F[ae] = le, g[le] = 1 + i, a[le] = Ie, l[le] = B[ae], d[le] = j[ae], f[le] = V[ae];
        const Te = lo();
        u[le] = Te, G[ae] = Te;
      }
    }
    const w = this.dimensionRefCounts;
    w.clear();
    let C = 0, b = a.length;
    for (const A of t) {
      const I = A.space.value, P = v[C++], N = I.rank, O = De(I.names), B = De(I.timestamps), j = Float64Array.from(I.scales), U = De(I.units);
      for (let V = 0; V < N; ++V) {
        const G = P[V];
        G !== void 0 && (U[V] = l[G], j[V] = d[G], B[V] = f[G], O[V] = a[G]);
      }
      for (const V of O) {
        let G = w.get(V);
        G === void 0 ? G = 1 : ++G, w.set(V, G);
      }
      if (!Fe(U, I.units) || !Fe(j, I.scales) || !Fe(O, I.names) || !Fe(B, I.timestamps)) {
        const V = mt({
          valid: I.valid,
          ids: I.ids,
          scales: j,
          units: U,
          names: O,
          timestamps: B,
          boundingBoxes: I.boundingBoxes,
          coordinateArrays: I.coordinateArrays
        });
        A.prevValue = V, A.space.value = V;
      }
    }
    {
      for (let I = 0; I < b; ++I)
        r(a[I]) || (g[I] = 0);
      const A = (I, P) => g[P] !== 0;
      a = a.filter(A), l = l.filter(A), d = d.filter(A), u = u.filter(A), f = f.filter(A), g = g.filter(A), b = a.length;
    }
    const E = [], L = new Array(b);
    for (let A = 0, I = s.rank; A < I; ++A) {
      const P = s.coordinateArrays[A];
      if (!(P == null ? void 0 : P.explicit))
        continue;
      const N = u.indexOf(s.ids[A]);
      N !== -1 && (L[N] = [P]);
    }
    for (const A of t) {
      const I = A.space.value, P = I.rank, N = I.boundingBoxes, O = I.coordinateArrays, B = I.names.map((j) => a.indexOf(j));
      for (const j of N)
        E.push(B2(j, b, B));
      for (let j = 0; j < P; ++j) {
        const U = O[j];
        if (U === void 0)
          continue;
        const V = B[j], G = L[V];
        G === void 0 ? L[V] = [U] : G.push(U);
      }
    }
    const R = new Array(b);
    for (let A = 0; A < b; ++A) {
      const I = L[A];
      I !== void 0 && (R[A] = P1(I));
    }
    const _ = mt({
      valid: y,
      ids: u,
      names: a,
      units: l,
      scales: new Float64Array(d),
      boundingBoxes: E,
      coordinateArrays: R
    });
    if (i)
      for (let A = 0; A < b; ++A)
        --g[A];
    Ru(s, _) || (this.prevCombined = _, e.value = _);
  }
  retain() {
    return ++this.retainCount, () => {
      --this.retainCount === 0 && this.update();
    };
  }
  bind(e) {
    const t = { space: e, mappedDimensionIds: [], prevValue: void 0 }, i = this.bindings;
    i.size === 0 && this.combined.changed.add(this.handleCombinedChanged), i.add(t);
    const r = e.changed.add(() => {
      e.value !== t.prevValue && this.update();
    }), s = () => {
      r();
      const a = this.bindings;
      a.delete(t), a.size === 0 && this.combined.changed.remove(this.handleCombinedChanged), this.update();
    };
    return this.update(), s;
  }
};
function B1(n, e, t, i, r) {
  const s = r.length, a = new n((s + 1) ** 2);
  a[a.length - 1] = 1;
  for (let l = 0; l < s; ++l) {
    const d = i[l];
    a[(s + 1) * s + l] = e[(t + 1) * t + d];
    for (let u = 0; u < s; ++u) {
      const f = r[u];
      a[(s + 1) * u + l] = e[(t + 1) * f + d];
    }
  }
  return a;
}
function J2(n) {
  if (n === void 0)
    return;
  const e = new Float64Array(16);
  if (Array.isArray(n))
    if (n.length === 16)
      for (let t = 0; t < 4; ++t)
        for (let i = 0; i < 4; ++i)
          e[t * 4 + i] = Lt(n[i * 4 + t]);
    else {
      Bi(n, 4);
      for (let t = 0; t < 4; ++t) {
        const i = Bi(n[t], 4);
        for (let r = 0; r < 4; ++r)
          e[r * 4 + t] = Lt(i[r]);
      }
    }
  else {
    pe(n);
    const t = $n(), i = _e(), r = St(1, 1, 1);
    Ce(n, "rotation", (a) => {
      go(t, a), dc(t, t);
    }), Ce(n, "translation", (a) => {
      go(i, a);
    }), Ce(n, "scale", (a) => {
      go(r, a);
    });
    const s = et();
    i_(s, t, i, r), e.set(s);
  }
  return {
    sourceRank: 3,
    transform: e,
    outputSpace: mt({
      valid: true,
      names: ["x", "y", "z"],
      units: ["m", "m", "m"],
      scales: Float64Array.of(1e-9, 1e-9, 1e-9)
    }),
    inputSpace: void 0
  };
}
function F1(n) {
  if (n === void 0)
    return;
  const e = pe(n), t = K(e, "outputDimensions", Mu), i = t.rank, r = K(e, "sourceRank", (l) => {
    if (l === void 0)
      return i;
    if (!jn(l) || l < 0 || l > i)
      throw new Error(`Expected integer in range [0, ${i}] but received: ${se(l)}`);
    return l;
  }), s = Ce(e, "inputDimensions", (l) => {
    const d = Mu(l, true);
    if (d.rank !== i)
      throw new Error(`Expected rank of ${i}, but received rank of: ${d.rank}`);
    return d;
  });
  return { transform: Ce(e, "matrix", (l) => {
    const d = new Float64Array((i + 1) ** 2), u = Bi(l, i);
    d[d.length - 1] = 1;
    for (let f = 0; f < i; ++f)
      try {
        const g = Bi(u[f], i + 1);
        for (let v = 0; v <= i; ++v)
          d[(i + 1) * v + f] = Lt(g[v]);
      } catch (g) {
        throw new Error(`Error in row ${f}: ${g.message}`);
      }
    return d;
  }), outputSpace: t, inputSpace: s, sourceRank: r };
}
function U1(n) {
  if (n === void 0)
    return;
  const e = n.transform, t = n.outputSpace, i = n.inputSpace, r = n.sourceRank;
  let s;
  const a = t.rank;
  if (e !== void 0) {
    s = [];
    for (let l = 0; l < a; ++l) {
      const d = [];
      s[l] = d;
      for (let u = 0; u <= a; ++u)
        d[u] = e[(a + 1) * u + l];
    }
  }
  return {
    sourceRank: r === a ? void 0 : r,
    matrix: s,
    outputDimensions: Gg(t),
    inputDimensions: i === void 0 ? void 0 : Gg(i)
  };
}
function Y2(n, e, t) {
  const i = n.box, r = n.transform, s = n.box.lowerBounds.length, a = e.length, l = new Float64Array((s + 1) * a);
  for (let d = 0; d < a; ++d)
    for (let u = 0; u <= s; ++u) {
      const f = e[d];
      l[d + u * a] = r[f + u * t];
    }
  if (!l.every((d) => d === 0))
    return {
      transform: l,
      box: i
    };
}
function Wg(n, e) {
  const t = n.ids, i = n.names, r = n.scales, s = n.units, a = n.timestamps, l = n.coordinateArrays;
  return mt({
    rank: e.length,
    valid: n.valid,
    ids: e.map((d) => t[d]),
    names: e.map((d) => i[d]),
    timestamps: e.map((d) => a[d]),
    scales: Float64Array.from(e, (d) => r[d]),
    units: e.map((d) => s[d]),
    coordinateArrays: e.map((d) => l[d]),
    boundingBoxes: n.boundingBoxes.map((d) => Y2(d, e, n.rank)).filter((d) => d !== void 0)
  });
}
function z1(n, e, t) {
  return e === t ? n : Wg(n, vN(n.rank, t, e));
}
function aC(n, e) {
  const t = n.transform, i = n.rank, r = Ih(t, i, [e]);
  if (r.length !== 1)
    return;
  var s = ce(r, 1);
  const a = s[0], l = Math.abs(t[(i + 1) * a + e]), d = n.inputSpace;
  return { scale: d.scales[a] * l, unit: d.units[a] };
}
function oC(n, e) {
  var t = n.defaultInputSpace;
  const i = t.scales, r = t.units;
  return e < i.length ? { scale: i[e], unit: r[e] } : void 0;
}
function q2(n) {
  const e = n.rank;
  var t = n.bounds;
  const i = t.lowerBounds, r = t.upperBounds;
  if (i.some((d) => d !== 0))
    throw new Error("Lower bounds of channel coordinate space must all be 0");
  if (r.some((d) => !jn(d) || d <= 0 || d >= 2 ** 32))
    throw new Error("Upper bounds of channel coordinate space must all be positive integers");
  const s = new Uint32Array(r), a = Vv2(s), l = new Uint32Array(a * e);
  for (let d = 0; d < a; ++d) {
    let u = d;
    for (let f = 0; f < e; ++f) {
      const g = u % s[f];
      u = (u - g) / s[f], l[d * e + f] = g;
    }
  }
  return { channelCoordinateSpace: n, shape: s, numChannels: a, coordinates: l };
}
function Pp(n, e, t, i, r, s) {
  const a = t.scales, l = r.scales, d = r.rank, u = e + 1;
  for (let f = 0; f < d; ++f) {
    const g = s[f];
    if (g === -1)
      continue;
    const v = l[f];
    for (let y = 0; y < e; ++y) {
      const w = i[y], C = a[w];
      n[u * y + g] *= C / v;
    }
  }
}
function K2(n, e, t, i, r = To) {
  const s = t.inputSpace, a = t.rank, l = t.sourceRank, d = t.outputSpace, u = t.transform, f = s.names, g = d.names;
  let v;
  if (i !== void 0)
    v = De(i.modelSubspaceDimensionIndices);
  else {
    v = [];
    for (let B = 0; B < l; ++B)
      v[B] = B;
  }
  const y = v.length;
  for (let B = l; B < a; ++B)
    v.push(B);
  const w = Ih(t.transform, a, v, true), C = v.length, b = v.map((B) => f[B] || `${B}`), E = w.map((B) => g[B]);
  if (C !== w.length)
    return {
      error: "Rank mismatch between model subspace dimensions (" + b.join(", ") + ") and corresponding layer/global dimensions (" + E.join(", ") + ")"
    };
  let L = B1(Float32Array, u, a, w, v);
  const R = w.map((B) => g[B]), _ = e.names.map((B) => R.indexOf(B)), A = n.names.map((B) => R.indexOf(B));
  Pp(L, C, s, v, n, A), Pp(L, C, s, v, e, _);
  const I = r.names.map((B) => R.indexOf(B));
  Pp(L, C, s, v, r, I);
  const P = [], N = r.rank;
  if (i !== void 0) {
    let B = i.subsourceToModelSubspaceTransform;
    y !== C && (B = Nv(new Float32Array((C + 1) ** 2), C, B, y)), L = Ph(new Float32Array((C + 1) ** 2), C + 1, L, C + 1, B, C + 1, C + 1, C + 1, C + 1);
  }
  const O = new Uint32Array(N);
  for (let B = 0; B < N; ++B) {
    const j = r.bounds.lowerBounds[B], U = r.bounds.upperBounds[B];
    if (j !== 0 || !jn(U) || U <= 0 || U >= 2 ** 32)
      return {
        error: `Channel dimension ${r.names[B]} must have lower bound of 0 and positive integer upper bound`
      };
    O[B] = U;
    const V = I[B];
    let G = -1;
    if (V !== -1)
      for (let F = 0; F < C; ++F) {
        const ue = L[V + F * (C + 1)];
        if (ue !== 0) {
          if (ue !== 1 || G !== -1)
            return {
              error: `Channel dimension ${E[V]} must map to a single source dimension`
            };
          G = F;
        }
      }
    P[B] = G;
  }
  return {
    rank: C,
    unpaddedRank: y,
    modelDimensionNames: b,
    layerDimensionNames: E,
    localToRenderLayerDimensions: _,
    globalToRenderLayerDimensions: A,
    channelToRenderLayerDimensions: I,
    modelToRenderLayerTransform: L,
    channelToModelDimensions: P,
    channelSpaceShape: O
  };
}
function Z2(n, e) {
  return n === e ? true : n.error !== void 0 || e.error !== void 0 ? false : Fe(n.modelDimensionNames, e.modelDimensionNames) && Fe(n.layerDimensionNames, e.layerDimensionNames) && Fe(n.globalToRenderLayerDimensions, e.globalToRenderLayerDimensions) && Fe(n.localToRenderLayerDimensions, e.localToRenderLayerDimensions) && Fe(n.channelToRenderLayerDimensions, e.channelToRenderLayerDimensions) && Fe(n.modelToRenderLayerTransform, e.modelToRenderLayerTransform) && Fe(n.channelSpaceShape, e.channelSpaceShape);
}
function G1(n, e, t, i, r) {
  return wi((s, a, l, d) => K2(s, a, l, i, d), [n, e, t, r === void 0 ? oa(void 0) : r], Z2);
}
function X2(n, e, t, i) {
  const r = t.globalToRenderLayerDimensions;
  for (let s = 0; s < 3; ++s) {
    let a = 0;
    const l = i[s];
    if (l !== -1) {
      const d = r[l];
      d !== -1 && (a = e[d]);
    }
    n[s] = a;
  }
}
function Q2(n, e, t, i) {
  const r = t.globalToRenderLayerDimensions;
  for (let s = 0; s < 3; ++s) {
    const a = i[s];
    if (a !== -1) {
      const l = r[a];
      l !== -1 && (n[l] = e[s]);
    }
  }
}
function $1(n, e) {
  const t = n.rank, i = n.unpaddedRank;
  let r;
  i !== t && e !== void 0 && (e = Nv(new Float32Array((t + 1) ** 2), t, e, i)), e !== void 0 ? (r = new Float32Array((t + 1) * (t + 1)), Ph(r, t + 1, n.modelToRenderLayerTransform, t + 1, e, t + 1, t + 1, t + 1, t + 1)) : r = n.modelToRenderLayerTransform;
  const s = new Float32Array((t + 1) * (t + 1)), a = _v(s, t + 1, r, t + 1, t + 1);
  if (a === 0)
    throw new Error("Transform is singular");
  const l = n.globalToRenderLayerDimensions, d = n.localToRenderLayerDimensions, u = n.channelToRenderLayerDimensions, f = l.length, g = d.length, v = f + g, y = new Float32Array((v + 1) * t);
  for (let A = 0; A < t; ++A) {
    for (let I = 0; I < f; ++I) {
      const P = l[I];
      P !== -1 && (y[A + I * t] = s[A + P * (t + 1)]);
    }
    for (let I = 0; I < g; ++I) {
      const P = d[I];
      P !== -1 && (y[A + (f + I) * t] = s[A + P * (t + 1)]);
    }
    y[A + v * t] = s[A + t * (t + 1)];
  }
  const w = u.length;
  let C = new Array(w);
  const b = [];
  for (let A = 0; A < w; ++A) {
    const I = u[A];
    let P = -1;
    if (I !== -1) {
      for (let N = 0; N < t; ++N) {
        const O = r[I + N * (t + 1)];
        if (O !== 0) {
          if (O !== 1 || P !== -1)
            throw new Error(`Channel dimension ${n.layerDimensionNames[I]} must map with stride 1 to a single data chunk dimensions`);
          P = N;
        }
      }
      if (P !== -1) {
        if (r[I + t * (t + 1)] !== 0)
          throw new Error(`Channel dimension ${n.layerDimensionNames[I]} must have an offset of 0 in the chunk coordinate space`);
        b.push(P);
      }
    }
    C[A] = P;
  }
  const E = n.channelSpaceShape, L = Vv2(E), R = b.length, _ = new Uint32Array(L * R);
  for (let A = 0; A < L; ++A) {
    let I = A, P = 0;
    for (let N = 0; N < w; ++N) {
      const O = I % E[N];
      I = (I - O) / E[N], C[N] !== -1 && (_[A * R + P] = O, ++P);
    }
  }
  return {
    layerRank: t,
    modelTransform: n,
    chunkToLayerTransform: r,
    layerToChunkTransform: s,
    chunkToLayerTransformDet: a,
    combinedGlobalLocalRank: v,
    combinedGlobalLocalToChunkTransform: y,
    channelToChunkDimensionIndices: C,
    chunkChannelDimensionIndices: b,
    numChannels: L,
    chunkChannelCoordinates: _,
    channelSpaceShape: E
  };
}
function W1(n, e) {
  const t = n.globalToRenderLayerDimensions, i = [], r = [];
  for (let s = 0; s < 3; ++s) {
    const a = e[s];
    if (a == -1)
      continue;
    const l = t[a];
    r.push(l), l !== -1 && i.push(l);
  }
  for (let s = r.length; s < 3; ++s)
    r[s] = -1;
  return { layerDisplayDimensionIndices: i, displayToLayerDimensionIndices: r };
}
function H1(n, e) {
  const t = n.chunkToLayerTransform, i = n.modelTransform, r = i.rank, s = e.layerDisplayDimensionIndices, a = e.displayToLayerDimensionIndices, l = s.length, d = Ih(t, r, s);
  if (d.length !== l) {
    const g = i.modelDimensionNames, v = i.layerDimensionNames;
    throw new Error(`Rank mismatch between displayed layer dimensions (${De(s, (y) => v[y]).join(", ")}) and corresponding chunk dimensions (${De(d, (y) => g[y]).join(", ")})`);
  }
  const u = et();
  for (let g = 0; g < 3; ++g) {
    const v = a[g];
    if (v !== -1) {
      for (let y = 0; y < l; ++y) {
        const w = d[y];
        u[y * 4 + g] = t[w * (r + 1) + v];
      }
      u[12 + g] = t[r * (r + 1) + v];
    }
  }
  const f = et();
  xs(f, u);
  for (let g = d.length; g < 3; ++g)
    d[g] = -1;
  return {
    modelTransform: n.modelTransform,
    chunkTransform: n,
    displaySubspaceModelMatrix: u,
    displaySubspaceInvModelMatrix: f,
    chunkDisplayDimensionIndices: d,
    numChunkDisplayDims: l
  };
}
function gc(n, e, t, i, r) {
  const s = e.length, a = t.length, l = n.length;
  let d = true;
  for (let u = 0; u < i; ++u) {
    let f = u, g = 0;
    for (let v = 0; v < s; ++v)
      g += r[f + v * i] * e[v];
    f += s * i;
    for (let v = 0; v < a; ++v)
      g += r[f + v * i] * t[v];
    g += r[f + a * i], u < l ? n[u] = g : (g < 0 || g >= 1) && (d = false);
  }
  return d;
}
function eO(n, e, t) {
  n.fill(0), n[15] = 1;
  let i = true;
  const r = e.displayDimensionIndices, s = t.globalToRenderLayerDimensions, a = t.modelToRenderLayerTransform, l = t.rank;
  for (let d = 0; d < 3; ++d) {
    const u = r[d];
    if (u === -1) {
      i = false;
      continue;
    }
    const f = s[u];
    if (f === -1) {
      i = false;
      continue;
    }
    n[d + 12] = a[f + l * (l + 1)];
    for (let g = 0; g < 3; ++g)
      n[d + 4 * g] = a[f + (l + 1) * g];
  }
  if (!i) {
    const d = e.globalDimensionNames, u = De(r.filter((f) => f !== -1), (f) => d[f]).join(", ");
    throw new Error(`Transform from model dimensions (${t.modelDimensionNames.join(", ")}) to display dimensions (${u}) does not have full rank`);
  }
}
var tO = xv.Object.getOwnPropertySymbols;
var nO = { default: tO, __esModule: true };
var lC = Gs(nO);
var iO = z_;
var rO = hRe.f;
vE("getOwnPropertyDescriptor", function() {
  return function(e, t) {
    return rO(iO(e), t);
  };
});
var sO = xv.Object;
var aO = function(e, t) {
  return sO.getOwnPropertyDescriptor(e, t);
};
var oO = { default: aO, __esModule: true };
var $i = Gs(oO);
var Et;
(function(n) {
  n[n.GPU_MEMORY = 0] = "GPU_MEMORY", n[n.SYSTEM_MEMORY = 1] = "SYSTEM_MEMORY", n[n.SYSTEM_MEMORY_WORKER = 2] = "SYSTEM_MEMORY_WORKER", n[n.DOWNLOADING = 3] = "DOWNLOADING", n[n.QUEUED = 4] = "QUEUED", n[n.NEW = 5] = "NEW", n[n.FAILED = 6] = "FAILED", n[n.EXPIRED = 7] = "EXPIRED";
})(Et || (Et = {}));
var j1 = 8;
var kr;
(function(n) {
  n[n.FIRST_TIER = 0] = "FIRST_TIER", n[n.FIRST_ORDERED_TIER = 0] = "FIRST_ORDERED_TIER", n[n.VISIBLE = 0] = "VISIBLE", n[n.PREFETCH = 1] = "PREFETCH", n[n.LAST_ORDERED_TIER = 1] = "LAST_ORDERED_TIER", n[n.RECENT = 2] = "RECENT", n[n.LAST_TIER = 2] = "LAST_TIER";
})(kr || (kr = {}));
var J1 = 3;
var Nu;
(function(n) {
  n[n.totalTime = 0] = "totalTime", n[n.totalChunks = 1] = "totalChunks";
})(Nu || (Nu = {}));
var Ir;
(function(n) {
  n[n.numChunks = 0] = "numChunks", n[n.systemMemoryBytes = 1] = "systemMemoryBytes", n[n.gpuMemoryBytes = 2] = "gpuMemoryBytes";
})(Ir || (Ir = {}));
var ps = 3;
function Js(n, e) {
  return n * J1 + e;
}
function cC(n) {
  return j1 * J1 * ps + n;
}
var lO = "ChunkQueueManager";
var cO = "ChunkManager";
var dO = "ChunkSource.invalidate";
var uO = "ChunkQueueManager.requestChunkStatistics";
var hO = "ChunkManager.chunkLayerStatistics";
var $v = class {
  constructor() {
    this.numVisibleChunksNeeded = 0, this.numVisibleChunksAvailable = 0, this.numPrefetchChunksNeeded = 0, this.numPrefetchChunksAvailable = 0;
  }
};
function Ct(n) {
  let e = -1;
  return RZr(() => {
    e === -1 && (e = requestAnimationFrame(() => {
      e = -1, n();
    }));
  }, { flush: () => {
    e !== -1 && (e = -1, n());
  }, cancel: () => {
    e !== -1 && (cancelAnimationFrame(e), e = -1);
  } });
}
var Y1 = class {
  constructor() {
    this.map = new de();
  }
  /**
   * If getter throws an exception, no value is added.
   */
  get(e, t) {
    let i = this.map, r = i.get(e);
    return r === void 0 ? (r = t(), r.registerDisposer(() => {
      i.delete(e);
    }), i.set(e, r)) : r.addRef(), r;
  }
};
var q1 = class extends Y1 {
  get(e, t) {
    return typeof e != "string" && (e = ri(e)), super.get(e, t);
  }
  getUncounted(e, t) {
    return this.get(e, () => new NE(t())).value;
  }
};
function fO(n) {
  let e = {
    antialias: false,
    stencil: true
  }, t = n.getContext("webgl2", e);
  if (t == null)
    throw new Error("WebGL not supported.");
  t.memoize = new Y1(), t.maxTextureSize = t.getParameter(t.MAX_TEXTURE_SIZE), t.max3dTextureSize = t.getParameter(t.MAX_3D_TEXTURE_SIZE), t.maxTextureImageUnits = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS), t.tempTextureUnit = t.maxTextureImageUnits - 1;
  for (const i of ["EXT_color_buffer_float"])
    if (!t.getExtension(i))
      throw new Error(`${i} extension not available`);
  for (const i of [
    // Some versions of Firefox 67.0 seem to require this extension being added in addition
    // to EXT_color_buffer_float, despite the note here indicating it is unnecessary:
    // https://developer.mozilla.org/en-US/docs/Web/API/EXT_float_blend
    //
    // See https://github.com/google/neuroglancer/issues/140
    "EXT_float_blend"
  ])
    t.getExtension(i);
  return t;
}
var Wv = class {
  constructor() {
    this.width = 0, this.height = 0, this.logicalWidth = 0, this.logicalHeight = 0, this.visibleLeftFraction = 0, this.visibleTopFraction = 0, this.visibleWidthFraction = 0, this.visibleHeightFraction = 0;
  }
};
function K1(n, e) {
  const t = 1 / n.visibleWidthFraction, i = 1 / n.visibleHeightFraction, r = -1 - (-1 + 2 * n.visibleLeftFraction) * t;
  let s = -1 - (-1 + 2 * n.visibleTopFraction) * i;
  s = -s, e[0] = e[0] * t + e[3] * r, e[4] = e[4] * t + e[7] * r, e[8] = e[8] * t + e[11] * r, e[12] = e[12] * t + e[15] * r, e[1] = e[1] * i + e[3] * s, e[5] = e[5] * i + e[7] * s, e[9] = e[9] * i + e[11] * s, e[13] = e[13] * i + e[15] * s;
}
function Z1(n, e) {
  return n.width === e.width && n.height === e.height && n.logicalWidth === e.logicalWidth && n.logicalHeight === e.logicalHeight && n.visibleLeftFraction === e.visibleLeftFraction && n.visibleTopFraction === e.visibleTopFraction;
}
var X1 = class extends Z {
  constructor(e, t, i) {
    super(), this.context = e, this.element = t, this.visibility = i, this.boundsGeneration = -1, this.canvasRelativeClippedLeft = 0, this.canvasRelativeClippedTop = 0, this.canvasRelativeLogicalLeft = 0, this.canvasRelativeLogicalTop = 0, this.renderViewport = new Wv(), this.boundsObserversRegistered = false, this.gl = e.gl, e.addPanel(this);
  }
  scheduleRedraw() {
    this.visible && this.context.scheduleRedraw();
  }
  ensureBoundsUpdated() {
    const e = this.context;
    e.ensureBoundsUpdated();
    const t = e.boundsGeneration;
    if (t === this.boundsGeneration)
      return;
    this.boundsGeneration = t;
    const i = this.element;
    !this.boundsObserversRegistered && e.monitorPanel(i) && (this.boundsObserversRegistered = true);
    const r = i.getBoundingClientRect(), s = e.container, a = e.canvasRect, l = e.canvas, d = l.width, u = l.height, f = d / a.width, g = u / a.height, v = a.left, y = a.top;
    let w = this.canvasRelativeLogicalLeft = Math.round((r.left - v) * f + i.clientLeft), C = this.canvasRelativeLogicalTop = Math.round((r.top - y) * g + i.clientTop), b = i.clientWidth, E = i.clientHeight, L = w + b, R = C + E, _ = C, A = w, I = L, P = R;
    for (let j = i.parentElement; j !== null && j !== s; j = j.parentElement) {
      const U = j.getBoundingClientRect();
      U.x === 0 && U.y === 0 && U.width === 0 && U.height === 0 || (A = Math.max(A, (U.left - v) * f), _ = Math.max(_, (U.top - y) * g), I = Math.min(I, (U.right - v) * f), P = Math.min(P, (U.bottom - y) * g));
    }
    _ = this.canvasRelativeClippedTop = Math.round(Math.max(_, 0)), A = this.canvasRelativeClippedLeft = Math.round(Math.max(A, 0)), I = Math.round(Math.min(I, d)), P = Math.round(Math.min(P, u));
    const N = this.renderViewport, O = N.width = Math.max(0, I - A), B = N.height = Math.max(0, P - _);
    N.logicalWidth = b, N.logicalHeight = E, N.visibleLeftFraction = (A - w) / b, N.visibleTopFraction = (_ - C) / E, N.visibleWidthFraction = O / b, N.visibleHeightFraction = B / E;
  }
  // Sets the viewport to the clipped viewport.  Any drawing must take
  // `visible{Left,Top,Width,Height}Fraction` into account.  setGLClippedViewport() {
  setGLClippedViewport() {
    const e = this.gl, t = this.canvasRelativeClippedTop, i = this.canvasRelativeClippedLeft;
    var r = this.renderViewport;
    const s = r.width, a = r.height, l = t + a;
    e.enable(WebGL2RenderingContext.SCISSOR_TEST);
    let d = this.context.canvas.height - l;
    e.viewport(i, d, s, a), e.scissor(i, d, s, a);
  }
  // Sets the viewport to the logical viewport, using the scissor test to constrain drawing to the
  // clipped viewport.  Drawing does not need to take `visible{Left,Top,Width,Height}Fraction` into
  // account.
  setGLLogicalViewport() {
    const e = this.gl;
    var t = this.renderViewport;
    const i = t.width, r = t.height, s = t.logicalWidth, a = t.logicalHeight, l = this.context.canvas.height;
    e.enable(WebGL2RenderingContext.SCISSOR_TEST), e.viewport(this.canvasRelativeLogicalLeft, l - (this.canvasRelativeLogicalTop + a), s, a), e.scissor(this.canvasRelativeClippedLeft, l - (this.canvasRelativeClippedTop + r), i, r);
  }
  disposed() {
    this.boundsObserversRegistered && this.context.unmonitorPanel(this.element), this.context.removePanel(this), super.disposed();
  }
  get visible() {
    return this.visibility.visible;
  }
  getDepthArray() {
  }
  get shouldDraw() {
    if (!this.visible)
      return false;
    const e = this.element;
    return !(e.clientWidth === 0 || e.clientHeight === 0 || e.offsetWidth === 0 || e.offsetHeight === 0);
  }
  // Returns a number that determine the order in which panels are drawn. This is used by CdfPanel
  // to ensure it is drawn after other panels that update the histogram.
  //
  // A higher number -> later draw.
  get drawOrder() {
    return 0;
  }
};
var Q1 = class extends X1 {
  constructor(e, t, i) {
    super(e, t, i), this.canvas = document.createElement("canvas"), this.canvasRenderingContext = this.canvas.getContext("2d");
    const r = this.canvas;
    t.appendChild(r), t.style.position = "relative", r.style.position = "absolute", r.style.left = "0", r.style.right = "0", r.style.top = "0", r.style.bottom = "0";
  }
  draw() {
    this.drawIndirect();
    const e = this.renderViewport, t = this.canvas, i = e.logicalWidth, r = e.logicalHeight;
    t.width = i, t.height = r;
    const s = this.canvasRenderingContext;
    s == null ? void 0 : s.drawImage(this.context.canvas, this.canvasRelativeLogicalLeft, this.canvasRelativeLogicalTop, i, r, 0, 0, i, r);
  }
};
var pO = class extends hn {
  constructor() {
    super(Float64Array.of(0, 0, 1, 1), (e) => at(new Float64Array(4), e, Dv));
  }
  toJSON() {
    const e = this.value;
    var t = ce(e, 4);
    const i = t[0], r = t[1], s = t[2], a = t[3];
    if (!(i === 0 && r == 0 && s === 1 && a === 1))
      return De(e);
  }
};
var gO = class extends Z {
  constructor(e) {
    super(), this.container = e, this.canvas = document.createElement("canvas"), this.updateStarted = new Ee(), this.updateFinished = new Ee(), this.changed = this.updateFinished, this.panels = new je(), this.resizeGeneration = 0, this.boundsGeneration = -1, this.orderedPanels = [], this.frameNumber = 0, this.panelAncestors = new de(), this.resizeCallback = () => {
      ++this.resizeGeneration, this.scheduleRedraw();
    }, this.resizeObserver = new ResizeObserver(this.resizeCallback), this.scheduleRedraw = this.registerCancellable(Ct(() => this.draw()));
    const t = this.canvas, i = this.resizeObserver;
    e.style.position = "relative", t.style.position = "absolute", t.style.top = "0px", t.style.left = "0px", t.style.width = "100%", t.style.height = "100%", t.style.zIndex = "0", i.observe(t), e.appendChild(t), this.registerEventListener(t, "webglcontextlost", (r) => {
      console.log(`Lost WebGL context: ${r.statusMessage}`), r.preventDefault();
    }), this.registerEventListener(t, "webglcontextrestored", () => {
      console.log("WebGL context restored"), window.location.reload();
    }), this.gl = fO(t);
  }
  monitorPanel(e) {
    const t = this.panelAncestors, i = this.container;
    if (!i.contains(e))
      return false;
    for (; e !== i; ) {
      let r = t.get(e);
      if (r !== void 0) {
        ++r.count;
        break;
      }
      const s = e.parentElement;
      r = { parent: s, count: 1 }, t.set(e, r), e.addEventListener("scroll", this.resizeCallback, { capture: true }), this.resizeObserver.observe(e), e = s;
    }
    return true;
  }
  unmonitorPanel(e) {
    const t = this.panelAncestors, i = this.container;
    for (; e !== i; ) {
      const r = t.get(e);
      if (r.count !== 1) {
        --r.count;
        break;
      }
      e.removeEventListener("scroll", this.resizeCallback, { capture: true }), this.resizeObserver.unobserve(e), t.delete(e), e = r.parent;
    }
  }
  applyWindowedViewportToElement(e, t) {
    var i = ce(t, 4);
    const r = i[0], s = i[1], a = i[2], l = i[3], d = 1 / a, u = 1 / l;
    e.style.position = "absolute", e.style.top = `${-u * s * 100}%`, e.style.left = `${-d * r * 100}%`, e.style.width = `${d * 100}%`, e.style.height = `${u * 100}%`, ++this.resizeGeneration, this.scheduleRedraw();
  }
  isReady() {
    for (const e of this.panels)
      if (e.visible && !e.isReady())
        return false;
    return true;
  }
  /**
   * Returns a child element that overlays the canvas.
   */
  makeCanvasOverlayElement() {
    const e = document.createElement("div");
    return e.style.position = "absolute", e.style.top = "0px", e.style.left = "0px", e.style.width = "100%", e.style.height = "100%", e.style.zIndex = "2", this.container.appendChild(e), e;
  }
  disposed() {
    this.orderedPanels.length = 0, this.resizeObserver.disconnect();
  }
  addPanel(e) {
    this.panels.add(e), this.orderedPanels.length = 0, ++this.resizeGeneration, this.scheduleRedraw();
  }
  removePanel(e) {
    this.panels.delete(e), this.orderedPanels.length = 0, ++this.resizeGeneration, this.scheduleRedraw();
  }
  ensureBoundsUpdated() {
    const e = this.resizeGeneration;
    if (this.boundsGeneration === e)
      return;
    const t = this.canvas;
    t.width = t.offsetWidth, t.height = t.offsetHeight, this.canvasRect = t.getBoundingClientRect(), this.boundsGeneration = e;
  }
  draw() {
    ++this.frameNumber, this.updateStarted.dispatch();
    let e = this.gl;
    this.ensureBoundsUpdated(), this.gl.clearColor(0, 0, 0, 0), e.clear(e.COLOR_BUFFER_BIT | e.DEPTH_BUFFER_BIT);
    const t = this.orderedPanels, i = this.panels;
    t.length !== i.size && (t.push(...i), t.sort((r, s) => r.drawOrder - s.drawOrder));
    for (const r of t) {
      if (!r.shouldDraw)
        continue;
      r.ensureBoundsUpdated();
      const s = r.renderViewport;
      s.width === 0 || s.height === 0 || r.draw();
    }
    e.disable(e.SCISSOR_TEST), this.gl.clearColor(1, 1, 1, 1), this.gl.colorMask(false, false, false, true), e.clear(e.COLOR_BUFFER_BIT), this.gl.colorMask(true, true, true, true), this.updateFinished.dispatch();
  }
  getDepthArray() {
    var e = this.canvas;
    const t = e.width, i = e.height, r = new Float32Array(t * i);
    for (const a of this.panels) {
      if (!a.shouldDraw)
        continue;
      const l = a.getDepthArray();
      if (l === void 0)
        continue;
      const d = a.canvasRelativeClippedTop, u = a.canvasRelativeClippedLeft;
      var s = a.renderViewport;
      const f = s.width, g = s.height;
      for (let v = 0; v < g; ++v) {
        const y = (g - 1 - v) * f;
        r.set(l.subarray(y, y + f), (d + v) * f + u);
      }
    }
    return r;
  }
};
var eT = class extends Wv {
  constructor() {
    super(...arguments), this.globalPosition = Eo, this.projectionMat = et(), this.viewMatrix = et(), this.invViewMatrix = et(), this.viewProjectionMat = et(), this.invViewProjectionMat = et();
  }
};
function mO(n, e) {
  return n.displayDimensionRenderInfo === e.displayDimensionRenderInfo && Z1(n, e) && Fe(n.globalPosition, e.globalPosition) && Fe(n.projectionMat, e.projectionMat) && Fe(n.viewMatrix, e.viewMatrix);
}
function tT(n) {
  const e = n.viewMatrix, t = n.viewProjectionMat;
  xs(e, n.invViewMatrix), mn(t, n.projectionMat, e), xs(n.invViewProjectionMat, t);
}
var vO = "rendered_view.addLayer";
var yO = "rendered_view.removeLayer";
var SO = "SharedProjectionParameters";
var bO = "SharedProjectionParameters.changed";
var cr;
(function(n) {
  n[n.info = 0] = "info", n[n.warning = 1] = "warning", n[n.error = 2] = "error";
})(cr || (cr = {}));
var qo = class {
  constructor() {
    this.changed = new Ee(), this.messages = [], this.children = [];
  }
  addMessage(e) {
    this.messages.push(e), this.changed.dispatch();
  }
  clearMessages() {
    const e = this.messages;
    e.length !== 0 && (e.length = 0, this.changed.dispatch());
  }
  isEmpty() {
    return this.messages.length === 0 && !this.children.some((e) => !e.isEmpty());
  }
  addChild(e) {
    return this.children.push(e), e.changed.add(this.changed.dispatch), e.isEmpty() || this.changed.dispatch(), () => {
      const t = this.children;
      t.splice(t.indexOf(e), 1), e.changed.remove(this.changed.dispatch), e.isEmpty() || this.changed.dispatch();
    };
  }
  *[wZr]() {
    yield* this.messages;
    for (const e of this.children)
      yield* e;
  }
};
var dC = W5;
var CO = gQn;
var wO = K_("species");
var nT = function(n, e) {
  var t = dC(n).constructor, i;
  return t === void 0 || (i = dC(t)[wO]) == null ? e : CO(i);
};
var xO = function(n, e, t) {
  var i = t === void 0;
  switch (e.length) {
    case 0:
      return i ? n() : n.call(t);
    case 1:
      return i ? n(e[0]) : n.call(t, e[0]);
    case 2:
      return i ? n(e[0], e[1]) : n.call(t, e[0], e[1]);
    case 3:
      return i ? n(e[0], e[1], e[2]) : n.call(t, e[0], e[1], e[2]);
    case 4:
      return i ? n(e[0], e[1], e[2], e[3]) : n.call(t, e[0], e[1], e[2], e[3]);
  }
  return n.apply(t, e);
};
var Hd = Edt;
var EO = xO;
var uC = yvn;
var hC = Sdt;
var Or = fw;
var fC = Or.process;
var Hg = Or.setImmediate;
var jg = Or.clearImmediate;
var pC = Or.MessageChannel;
var Ap = Or.Dispatch;
var Rp = 0;
var rc = {};
var gC = "onreadystatechange";
var Ys;
var Mp;
var Np;
var Xl = function() {
  var n = +this;
  if (rc.hasOwnProperty(n)) {
    var e = rc[n];
    delete rc[n], e();
  }
};
var mC = function(n) {
  Xl.call(n.data);
};
(!Hg || !jg) && (Hg = function(e) {
  for (var t = [], i = 1; arguments.length > i; )
    t.push(arguments[i++]);
  return rc[++Rp] = function() {
    EO(typeof e == "function" ? e : Function(e), t);
  }, Ys(Rp), Rp;
}, jg = function(e) {
  delete rc[e];
}, vdt(fC) == "process" ? Ys = function(n) {
  fC.nextTick(Hd(Xl, n, 1));
} : Ap && Ap.now ? Ys = function(n) {
  Ap.now(Hd(Xl, n, 1));
} : pC ? (Mp = new pC(), Np = Mp.port2, Mp.port1.onmessage = mC, Ys = Hd(Np.postMessage, Np, 1)) : Or.addEventListener && typeof postMessage == "function" && !Or.importScripts ? (Ys = function(n) {
  Or.postMessage(n + "", "*");
}, Or.addEventListener("message", mC, false)) : gC in hC("script") ? Ys = function(n) {
  uC.appendChild(hC("script"))[gC] = function() {
    uC.removeChild(this), Xl.call(n);
  };
} : Ys = function(n) {
  setTimeout(Hd(Xl, n, 1), 0);
});
var iT = {
  set: Hg,
  clear: jg
};
var ra = fw;
var TO = iT.set;
var vC = ra.MutationObserver || ra.WebKitMutationObserver;
var Jg = ra.process;
var _p = ra.Promise;
var yC = vdt(Jg) == "process";
var kO = function() {
  var n, e, t, i = function() {
    var l, d;
    for (yC && (l = Jg.domain) && l.exit(); n; ) {
      d = n.fn, n = n.next;
      try {
        d();
      } catch (u) {
        throw n ? t() : e = void 0, u;
      }
    }
    e = void 0, l && l.enter();
  };
  if (yC)
    t = function() {
      Jg.nextTick(i);
    };
  else if (vC && !(ra.navigator && ra.navigator.standalone)) {
    var r = true, s = document.createTextNode("");
    new vC(i).observe(s, { characterData: true }), t = function() {
      s.data = r = !r;
    };
  } else if (_p && _p.resolve) {
    var a = _p.resolve(void 0);
    t = function() {
      a.then(i);
    };
  } else
    t = function() {
      TO.call(ra, i);
    };
  return function(l) {
    var d = { fn: l, next: void 0 };
    e && (e.next = d), n || (n = d, t()), e = d;
  };
};
var Rh = {};
var SC = gQn;
function IO(n) {
  var e, t;
  this.promise = new n(function(i, r) {
    if (e !== void 0 || t !== void 0)
      throw TypeError("Bad Promise constructor");
    e = i, t = r;
  }), this.resolve = SC(e), this.reject = SC(t);
}
Rh.f = function(n) {
  return new IO(n);
};
var rT = function(n) {
  try {
    return { e: false, v: n() };
  } catch (e) {
    return { e: true, v: e };
  }
};
var LO = fw;
var bC = LO.navigator;
var DO = bC && bC.userAgent || "";
var PO = W5;
var AO = X_;
var RO = Rh;
var sT = function(n, e) {
  if (PO(n), AO(e) && e.constructor === n)
    return e;
  var t = RO.f(n), i = t.resolve;
  return i(e), t.promise;
};
var MO = ZQn;
var Ss = fw;
var co = Edt;
var NO = Sh;
var si = Y_;
var _O = X_;
var OO = gQn;
var VO = Ch;
var CC = jo;
var BO = nT;
var aT = iT.set;
var oT = kO();
var lT = Rh;
var Yg = rT;
var FO = DO;
var UO = sT;
var Ps = "Promise";
var cT = Ss.TypeError;
var ko = Ss.process;
var wC = ko && ko.versions;
var zO = wC && wC.v8 || "";
var er = Ss[Ps];
var mc = NO(ko) == "process";
var hu = function() {
};
var jd;
var dT;
var xC;
var Hv;
var vc = dT = lT.f;
var Mh = !!function() {
  try {
    var n = er.resolve(1), e = (n.constructor = {})[K_("species")] = function(t) {
      t(hu, hu);
    };
    return (mc || typeof PromiseRejectionEvent == "function") && n.then(hu) instanceof e && zO.indexOf("6.6") !== 0 && FO.indexOf("Chrome/66") === -1;
  } catch {
  }
}();
var uT = function(n) {
  var e;
  return _O(n) && typeof (e = n.then) == "function" ? e : false;
};
var jv = function(n, e) {
  if (!n._n) {
    n._n = true;
    var t = n._c;
    oT(function() {
      for (var i = n._v, r = n._s == 1, s = 0, a = function(l) {
        var d = r ? l.ok : l.fail, u = l.resolve, f = l.reject, g = l.domain, v, y, w;
        try {
          d ? (r || (n._h == 2 && $O(n), n._h = 1), d === true ? v = i : (g && g.enter(), v = d(i), g && (g.exit(), w = true)), v === l.promise ? f(cT("Promise-chain cycle")) : (y = uT(v)) ? y.call(v, u, f) : u(v)) : f(i);
        } catch (C) {
          g && !w && g.exit(), f(C);
        }
      }; t.length > s; )
        a(t[s++]);
      n._c = [], n._n = false, e && !n._h && GO(n);
    });
  }
};
var GO = function(n) {
  aT.call(Ss, function() {
    var e = n._v, t = EC(n), i, r, s;
    if (t && (i = Yg(function() {
      mc ? ko.emit("unhandledRejection", e, n) : (r = Ss.onunhandledrejection) ? r({ promise: n, reason: e }) : (s = Ss.console) && s.error && s.error("Unhandled promise rejection", e);
    }), n._h = mc || EC(n) ? 2 : 1), n._a = void 0, t && i.e)
      throw i.v;
  });
};
var EC = function(n) {
  return n._h !== 1 && (n._a || n._c).length === 0;
};
var $O = function(n) {
  aT.call(Ss, function() {
    var e;
    mc ? ko.emit("rejectionHandled", n) : (e = Ss.onrejectionhandled) && e({ promise: n, reason: n._v });
  });
};
var mo = function(n) {
  var e = this;
  e._d || (e._d = true, e = e._w || e, e._v = n, e._s = 2, e._a || (e._a = e._c.slice()), jv(e, true));
};
var qg = function(n) {
  var e = this, t;
  if (!e._d) {
    e._d = true, e = e._w || e;
    try {
      if (e === n)
        throw cT("Promise can't be resolved itself");
      (t = uT(n)) ? oT(function() {
        var i = { _w: e, _d: false };
        try {
          t.call(n, co(qg, i, 1), co(mo, i, 1));
        } catch (r) {
          mo.call(i, r);
        }
      }) : (e._v = n, e._s = 1, jv(e, false));
    } catch (i) {
      mo.call({ _w: e, _d: false }, i);
    }
  }
};
Mh || (er = function(e) {
  VO(this, er, Ps, "_h"), OO(e), jd.call(this);
  try {
    e(co(qg, this, 1), co(mo, this, 1));
  } catch (t) {
    mo.call(this, t);
  }
}, jd = function(e) {
  this._c = [], this._a = void 0, this._s = 0, this._d = false, this._v = void 0, this._h = 0, this._n = false;
}, jd.prototype = bh(er.prototype, {
  // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
  then: function(e, t) {
    var i = vc(BO(this, er));
    return i.ok = typeof e == "function" ? e : true, i.fail = typeof t == "function" && t, i.domain = mc ? ko.domain : void 0, this._c.push(i), this._a && this._a.push(i), this._s && jv(this, false), i.promise;
  },
  // 25.4.5.1 Promise.prototype.catch(onRejected)
  catch: function(n) {
    return this.then(void 0, n);
  }
}), xC = function() {
  var n = new jd();
  this.promise = n, this.resolve = co(qg, n, 1), this.reject = co(mo, n, 1);
}, lT.f = vc = function(n) {
  return n === er || n === Hv ? new xC(n) : dT(n);
});
si(si.G + si.W + si.F * !Mh, { Promise: er });
cRe(er, Ps);
EE(Ps);
Hv = xv[Ps];
si(si.S + si.F * !Mh, Ps, {
  // 25.4.4.5 Promise.reject(r)
  reject: function(e) {
    var t = vc(this), i = t.reject;
    return i(e), t.promise;
  }
});
si(si.S + si.F * MO, Ps, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function(e) {
    return UO(this === Hv ? er : this, e);
  }
});
si(si.S + si.F * !(Mh && DE()(function(n) {
  er.all(n).catch(hu);
})), Ps, {
  // 25.4.4.1 Promise.all(iterable)
  all: function(e) {
    var t = this, i = vc(t), r = i.resolve, s = i.reject, a = Yg(function() {
      var l = [], d = 0, u = 1;
      CC(e, false, function(f) {
        var g = d++, v = false;
        l.push(void 0), u++, t.resolve(f).then(function(y) {
          v || (v = true, l[g] = y, --u || r(l));
        }, s);
      }), --u || r(l);
    });
    return a.e && s(a.v), i.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function(e) {
    var t = this, i = vc(t), r = i.reject, s = Yg(function() {
      CC(e, false, function(a) {
        t.resolve(a).then(i.resolve, r);
      });
    });
    return s.e && r(s.v), i.promise;
  }
});
var Op = Y_;
var WO = xv;
var HO = fw;
var jO = nT;
var TC = sT;
Op(Op.P + Op.R, "Promise", { finally: function(n) {
  var e = jO(this, WO.Promise || HO.Promise), t = typeof n == "function";
  return this.then(
    t ? function(i) {
      return TC(e, n()).then(function() {
        return i;
      });
    } : n,
    t ? function(i) {
      return TC(e, n()).then(function() {
        throw i;
      });
    } : n
  );
} });
var kC = Y_;
var JO = Rh;
var YO = rT;
kC(kC.S, "Promise", { try: function(n) {
  var e = JO.f(this), t = YO(n);
  return (t.e ? e.reject : e.resolve)(t.v), e.promise;
} });
var qO = xv.Promise;
var KO = { default: qO, __esModule: true };
var Bt = Gs(KO);
var ZO = class {
  constructor() {
    this.name = "CancellationError", this.message = "CANCELED";
  }
  toString() {
    return "CANCELED";
  }
};
var Ts = new ZO();
function XO(n) {
  if (n.isCanceled === true)
    throw Ts;
}
var Kg = () => {
};
var Zt = {
  isCanceled: false,
  add: () => Kg,
  remove: Kg
};
var As = class {
  /**
   * Trigger cancellation.
   *
   * If this.isCanceled === false, then each registered cancellation handler is invoked
   * synchronously.
   */
  cancel() {
    const e = this.handlers;
    if (e !== null && (this.handlers = null, e !== void 0))
      for (let t of e)
        t();
  }
  get isCanceled() {
    return this.handlers === null;
  }
  add(e) {
    let t = this.handlers;
    return t === null ? (e(), Kg) : (t === void 0 && (t = this.handlers = new je()), t.add(e), () => {
      this.remove(e);
    });
  }
  remove(e) {
    const t = this.handlers;
    t == null ? void 0 : t.delete(e);
  }
};
var QO = class extends As {
  constructor() {
    super(...arguments), this.consumers = new je();
  }
  addConsumer(e = Zt) {
    const t = this.consumers;
    t.has(e) || e.isCanceled || (t.add(e), e.add(() => {
      t.delete(e), t.size === 0 && this.cancel();
    }));
  }
};
function eV(n, e) {
  return new Bt((t, i) => {
    if (n === Zt) {
      e(t, i, Zt);
      return;
    }
    const r = new As(), s = n.add(() => {
      r.cancel();
    });
    e((a) => {
      s(), t(a);
    }, (a) => {
      s(), i(a);
    }, r);
  });
}
var hT = !(typeof Window < "u" && self instanceof Window);
var Zg = "rpc.promise.response";
var fT = "rpc.promise.cancel";
var pT = new de();
function Ut(n, e) {
  pT.set(n, e);
}
var tV = class extends Error {
  constructor(e, t) {
    super(t), this.name = e, this.message = t;
  }
};
function gT(n, e) {
  Ut(n, function(t) {
    let i = t.id;
    const r = new As();
    let s = e.call(this, t, r);
    this.set(i, { promise: s, cancellationToken: r }), s.then(({ value: a, transfers: l }) => {
      this.delete(i), this.invoke(Zg, { id: i, value: a }, l);
    }, (a) => {
      this.delete(i), this.invoke(Zg, { id: i, error: a.message, errorName: a.name });
    });
  });
}
Ut(fT, function(n) {
  let e = n.id;
  const t = this.get(e);
  t !== void 0 && t.cancellationToken.cancel();
});
Ut(Zg, function(n) {
  let e = n.id;
  var t = this.get(e);
  let i = t.resolve, r = t.reject;
  this.delete(e), n.hasOwnProperty("value") ? i(n.value) : n.errorName === Ts.name ? r(Ts) : r(new tV(n.errorName, n.error));
});
var nV = hT ? -1 : 0;
var iV = class {
  constructor(e) {
    this.target = e, this.objects = new de(), this.nextId = nV, e.onmessage = (t) => {
      let i = t.data;
      pT.get(i.functionName).call(this, i);
    };
  }
  get numObjects() {
    return this.objects.size;
  }
  set(e, t) {
    this.objects.set(e, t);
  }
  delete(e) {
    this.objects.delete(e);
  }
  get(e) {
    return this.objects.get(e);
  }
  getRef(e) {
    let t = e.id, i = this.get(t);
    return i.referencedGeneration = e.gen, i.addRef(), i;
  }
  getOptionalRef(e) {
    if (e === void 0)
      return;
    let t = e.id, i = this.get(t);
    return i.referencedGeneration = e.gen, i.addRef(), i;
  }
  invoke(e, t, i) {
    t.functionName = e, this.target.postMessage(t, i);
  }
  promiseInvoke(e, t, i = Zt, r) {
    return eV(i, (s, a, l) => {
      const d = t.id = this.newId();
      this.set(d, { resolve: s, reject: a }), this.invoke(e, t, r), l.add(() => {
        this.invoke(fT, { id: d });
      });
    });
  }
  newId() {
    return hT ? this.nextId-- : this.nextId++;
  }
};
var hr = class extends Z {
  constructor() {
    super(...arguments), this.rpc = null, this.rpcId = null;
  }
  initializeSharedObject(e, t = e.newId()) {
    this.rpc = e, this.rpcId = t, this.isOwner = false, e.set(t, this);
  }
  initializeCounterpart(e, t = {}) {
    this.initializeSharedObject(e), this.unreferencedGeneration = 0, this.referencedGeneration = 0, this.isOwner = true, t.id = this.rpcId, t.type = this.RPC_TYPE_ID, e.invoke("SharedObject.new", t);
  }
  dispose() {
    super.dispose();
  }
  /**
   * Precondition: this.isOwner === true.
   */
  addCounterpartRef() {
    return { id: this.rpcId, gen: ++this.referencedGeneration };
  }
  refCountReachedZero() {
    this.isOwner === true ? this.referencedGeneration === this.unreferencedGeneration && this.ownerDispose() : this.isOwner === false ? this.rpc.invoke("SharedObject.refCountReachedZero", { id: this.rpcId, gen: this.referencedGeneration }) : super.refCountReachedZero();
  }
  /**
   * Precondition: this.isOwner === true.
   */
  ownerDispose() {
    let e = this.rpc, t = this.rpcId;
    super.refCountReachedZero(), e.delete(t), e.invoke("SharedObject.dispose", { id: t });
  }
  /**
   * Precondition: this.isOwner === true.
   *
   * This should be called when the counterpart's refCount is decremented and reaches zero.
   */
  counterpartRefCountReachedZero(e) {
    this.unreferencedGeneration = e, this.refCount === 0 && e === this.referencedGeneration && this.ownerDispose();
  }
};
function rV(n, e, t = {}) {
  e != null && n.initializeSharedObject(e, t.id);
}
var Nh = class extends hr {
  constructor(e, t = {}) {
    super(), rV(this, e, t);
  }
};
Ut("SharedObject.dispose", function(n) {
  let e = this.get(n.id);
  if (e.refCount !== 0)
    throw new Error("Attempted to dispose object with non-zero reference count.");
  e.disposed(), this.delete(e.rpcId), e.rpcId = null, e.rpc = null;
});
var sV = "Worker";
Ut(sV, function(n) {
  const e = n.port, t = n.path;
  new Worker(t).postMessage({ port: e }, [e]);
});
Ut("SharedObject.refCountReachedZero", function(n) {
  let e = this.get(n.id), t = n.gen;
  e.counterpartRefCountReachedZero(t);
});
var mT = new de();
function ki(n) {
  return (e) => {
    e.prototype.RPC_TYPE_ID = n;
  };
}
function _h(n) {
  return (e) => {
    if (n !== void 0)
      e.prototype.RPC_TYPE_ID = n;
    else if (n = e.prototype.RPC_TYPE_ID, n === void 0)
      throw new Error("RPC_TYPE_ID should have already been defined");
    mT.set(n, e);
  };
}
Ut("SharedObject.new", function(n) {
  let e = this, t = n.type, i = mT.get(t), r = new i(e, n);
  --r.refCount;
});
var aV = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, s = r < 3 ? e : i === null ? i = $i(e, t) : i, a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(n, e, t, i);
  else
    for (var l = n.length - 1; l >= 0; l--)
      (a = n[l]) && (s = (r < 3 ? a(s) : r > 3 ? a(e, t, s) : a(e, t)) || s);
  return r > 3 && s && UZr(e, t, s), s;
};
var fu;
var vT = "SharedWatchableValue.changed";
var An = fu = class extends Nh {
  constructor(e, t = {}) {
    super(e, t), this.updatingValue_ = false, e !== void 0 && (this.base = new gt(t.value), this.setupChangedHandler());
  }
  initializeCounterpart(e, t = {}) {
    t.value = this.value, super.initializeCounterpart(e, t);
  }
  setupChangedHandler() {
    this.registerDisposer(this.base.changed.add(() => {
      if (this.updatingValue_)
        this.updatingValue_ = false;
      else {
        const e = this.rpc;
        e !== null && e.invoke(vT, { id: this.rpcId, value: this.value });
      }
    }));
  }
  static makeFromExisting(e, t) {
    let i = new fu();
    return i.base = t, i.setupChangedHandler(), i.initializeCounterpart(e), i;
  }
  static make(e, t) {
    return fu.makeFromExisting(e, new gt(t));
  }
  get value() {
    return this.base.value;
  }
  set value(e) {
    this.base.value = e;
  }
  get changed() {
    return this.base.changed;
  }
};
An = fu = aV([_h("SharedWatchableValue")], An);
Ut(vT, function(n) {
  const e = this.get(n.id);
  e.updatingValue_ = true, e.base.value = n.value, e.updatingValue_ = false;
});
var Kt = class extends gt {
  constructor(e = Number.NEGATIVE_INFINITY) {
    super(e);
  }
  get visible() {
    return this.value === Number.POSITIVE_INFINITY;
  }
  get ignored() {
    return this.value === Number.NEGATIVE_INFINITY;
  }
};
Kt.VISIBLE = Number.POSITIVE_INFINITY;
Kt.IGNORED = Number.NEGATIVE_INFINITY;
var yc = class extends Kt {
  constructor() {
    super(...arguments), this.contributors = new de();
  }
  /**
   * Registers `x` to be included in the set of values to be aggregated.
   *
   * @returns A disposer function that unregisters the specified value.
   */
  add(e) {
    const t = this.contributors, i = e.changed.add(() => {
      this.update();
    }), r = () => {
      t.delete(r), i(), this.update();
    };
    return t.set(r, e), this.update(), r;
  }
  update() {
    let e = Number.NEGATIVE_INFINITY;
    for (const t of this.contributors.values())
      e = Math.max(e, t.value);
    this.value = e;
  }
};
function Oh(n) {
  return class extends n {
    constructor() {
      super(...arguments), this.visibility = new yc();
    }
    initializeCounterpart(e, t = {}) {
      t.visibility = this.registerDisposer(An.makeFromExisting(e, this.visibility)).rpcId, super.initializeCounterpart(e, t);
    }
  };
}
var oV = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, s = r < 3 ? e : i === null ? i = $i(e, t) : i, a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(n, e, t, i);
  else
    for (var l = n.length - 1; l >= 0; l--)
      (a = n[l]) && (s = (r < 3 ? a(s) : r > 3 ? a(e, t, s) : a(e, t)) || s);
  return r > 3 && s && UZr(e, t, s), s;
};
var lV = globalThis && globalThis.__rest || function(n, e) {
  var t = {};
  for (var i in n)
    Object.prototype.hasOwnProperty.call(n, i) && e.indexOf(i) < 0 && (t[i] = n[i]);
  if (n != null && typeof lC == "function")
    for (var r = 0, i = lC(n); r < i.length; r++)
      e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(n, i[r]) && (t[i[r]] = n[i[r]]);
  return t;
};
var Ti;
(function(n) {
  n[n.DATA = 0] = "DATA", n[n.ANNOTATION = 1] = "ANNOTATION", n[n.DEFAULT_ANNOTATION = 2] = "DEFAULT_ANNOTATION";
})(Ti || (Ti = {}));
function cV() {
  return new KN([Ti.DATA, Ti.ANNOTATION, Ti.DEFAULT_ANNOTATION]);
}
var yT = class extends Z {
  constructor() {
    super(...arguments), this.role = Ti.DATA, this.messages = new qo(), this.layerChanged = new Ee(), this.redrawNeeded = new Ee(), this.layerChunkProgressInfo = new $v();
  }
  handleAction(e) {
  }
  getValueAt(e) {
  }
  /**
   * Transform the stored pickedValue and offset associated with the retrieved pick ID into the
   * actual value.
   */
  transformPickedValue(e) {
    return e.pickedValue;
  }
  /**
   * Optionally updates the mouse state based on the retrived pick information.  This might snap the
   * 3-d position to the center of the picked point.
   */
  updateMouseState(e, t, i, r) {
  }
};
var ST = class extends yT {
  constructor() {
    super(...arguments), this.visibility = new yc();
  }
  attach(e) {
  }
};
function _u(n, e, t) {
  let i = t.state;
  if (i === void 0 || i.transform !== n || i.displayDimensionRenderInfo !== e) {
    if (t.messages.clearMessages(), i = t.state = { transform: n, displayDimensionRenderInfo: e, modelTransform: void 0 }, n.error !== void 0) {
      t.messages.addMessage({ severity: cr.error, message: n.error });
      return;
    }
    try {
      const r = et();
      eO(r, e, n), i.modelTransform = r;
    } catch (r) {
      t.messages.addMessage({ severity: cr.error, message: r.message });
    }
  }
  return i.modelTransform;
}
var bT = class extends Z {
  constructor(e) {
    super(), this.renderViewport = new Wv(), this.changed = new ot();
    var t = e.parametersConstructor;
    const i = t === void 0 ? eT : t, r = e.navigationState, s = e.update;
    var a = e.isEqual;
    const l = a === void 0 ? mO : a;
    this.oldValue_ = new i(), this.value_ = new i();
    const d = () => {
      const f = this.oldValue_, g = this.value_;
      f.displayDimensionRenderInfo = r.displayDimensionRenderInfo.value, RZr(f, this.renderViewport);
      let v = f.globalPosition;
      const y = r.position.value, w = y.length;
      v.length !== w && (f.globalPosition = v = new Float32Array(w)), v.set(y), s(f, r), !l(f, g) && (this.value_ = f, this.oldValue_ = g, this.changed.dispatch(g, f));
    }, u = this.update = this.registerCancellable(lt(d, 0));
    this.registerDisposer(r.changed.add(u)), d();
  }
  setViewport(e) {
    Z1(e, this.renderViewport) || (RZr(this.renderViewport, e), this.update());
  }
  get value() {
    return this.update.flush(), this.value_;
  }
};
var Ou = class extends hr {
  constructor(e, t, i = 10) {
    super(), this.base = t, this.updateInterval = i, this.prevDisplayDimensionRenderInfo = void 0, this.update = this.registerCancellable(lt((r, s) => {
      let a;
      s.displayDimensionRenderInfo !== this.prevDisplayDimensionRenderInfo ? (a = s, this.prevDisplayDimensionRenderInfo = s.displayDimensionRenderInfo) : (s.displayDimensionRenderInfo, a = lV(s, ["displayDimensionRenderInfo"])), this.rpc.invoke(bO, { id: this.rpcId, value: a });
    }, this.updateInterval)), this.initializeCounterpart(e, { value: t.value }), this.registerDisposer(t.changed.add(this.update));
  }
  flush() {
    this.update.flush();
  }
};
Ou = oV([ki(SO)], Ou);
var en = class {
  constructor(e, t = e) {
    this.value_ = e, this.defaultValue = t, this.changed = new Ee();
  }
  get value() {
    return this.value_;
  }
  set value(e) {
    e !== this.value_ && (this.value_ = e, this.changed.dispatch());
  }
  toggle() {
    this.value = !this.value;
  }
  toJSON() {
    if (this.value_ !== this.defaultValue)
      return this.value_;
  }
  restoreState(e) {
    if (e === true || e === false) {
      this.value = e;
      return;
    }
    this.value = this.defaultValue;
  }
  reset() {
    this.value = this.defaultValue;
  }
};
var Rs = class extends Z {
  constructor(e, t = {}) {
    super(), this.model = e, this.element = document.createElement("input");
    let i = this.element;
    i.type = "checkbox";
    const r = () => {
      var s;
      const a = this.model.value;
      this.element.checked = a, (t.enableTitle !== void 0 || t.disableTitle !== void 0) && (this.element.title = (s = a ? t.enableTitle : t.disableTitle) !== null && s !== void 0 ? s : "");
    };
    this.registerDisposer(e.changed.add(r)), r(), this.registerEventListener(i, "change", function(s) {
      e.value = this.checked;
    }), i.addEventListener("mousedown", (s) => {
      s.preventDefault();
    });
  }
  disposed() {
    let e = this.element, t = e.parentElement;
    t && t.removeChild(e), super.disposed();
  }
};
var pi = class extends Z {
  constructor(e, t) {
    super(), this.model = e, this.element = t, this.initialDisplay = this.element.style.display, this.updateVisibility(), this.registerDisposer(e.changed.add(this.registerCancellable(lt(() => this.updateVisibility(), 0))));
  }
  updateVisibility() {
    this.element.style.display = this.model.value ? this.initialDisplay : "none";
  }
};
function CT(n) {
  try {
    return n();
  } catch (e) {
    return { error: e.message };
  }
}
function dV(n) {
  if (n.error !== void 0)
    throw new Error(n.error);
  return n;
}
var Jv = class extends Z {
  constructor(e, t) {
    if (super(), this.register = e, this.changed = new Ee(), this.disposerMap = new de(), t === void 0)
      this.map = new de();
    else {
      const r = this.map = new de(t), s = this.disposerMap;
      for (const a of r) {
        var i = ce(a, 2);
        const l = i[0], d = i[1], u = new Z();
        s.set(l, u), e(u, d, l);
      }
    }
  }
  get value() {
    return this.map;
  }
  set(e, t) {
    const i = this.map, r = this.disposerMap;
    let s = r.get(e);
    return s !== void 0 && s.dispose(), s = new Z(), r.set(e, s), i.set(e, t), this.register(s, t, e), this.changed.dispatch(), this;
  }
  delete(e) {
    const t = this.map, i = this.disposerMap, r = i.get(e);
    return r !== void 0 ? (r.dispose(), i.delete(e), t.delete(e), this.changed.dispatch(), true) : false;
  }
  get(e) {
    return this.map.get(e);
  }
  has(e) {
    return this.map.has(e);
  }
  get size() {
    return this.map.size;
  }
  [wZr]() {
    return bv(this.map);
  }
  clear() {
    const e = this.map, t = this.disposerMap;
    if (e.size > 0) {
      for (const i of t.values())
        i.dispose();
      e.clear(), t.clear(), this.changed.dispatch();
    }
  }
  values() {
    return this.map.values();
  }
  keys() {
    return this.map.keys();
  }
  disposed() {
    const e = this.map, t = this.disposerMap;
    for (const i of t.values())
      i.dispose();
    e.clear(), t.clear(), super.disposed();
  }
};
var IC = NZr("objectId");
var uV = 0;
function xn(n) {
  if (n instanceof Object) {
    let e = n[IC];
    return e === void 0 && (e = n[IC] = uV++), `o${e}`;
  } else
    return "" + se(n);
}
var Xg;
(function(n) {
  n[n.VERTEX = WebGL2RenderingContext.VERTEX_SHADER] = "VERTEX", n[n.FRAGMENT = WebGL2RenderingContext.FRAGMENT_SHADER] = "FRAGMENT";
})(Xg || (Xg = {}));
function hV(n) {
  n = n.replace("\0", "");
  let e = [];
  for (let t of n.split(`
`)) {
    let i = t.match(/^ERROR:\s*(\d+):(\d+)\s*(.+)$/);
    i !== null ? e.push({ message: i[3].trim(), file: parseInt(i[1], 10), line: parseInt(i[2], 10) }) : (i = t.match(/^ERROR:\s*(.+)$/), i !== null ? e.push({ message: i[1] }) : (t = t.trim(), t && e.push({ message: t })));
  }
  return e;
}
var fV = class extends Error {
  constructor(e, t, i, r) {
    const s = `Error compiling ${Xg[e].toLowerCase()} shader: ${i}`;
    super(s), this.name = "ShaderCompilationError", this.log = i, this.message = s, this.shaderType = e, this.source = t, this.errorMessages = r;
  }
};
var pV = class extends Error {
  constructor(e, t, i) {
    const r = `Error linking shader: ${i}`;
    super(r), this.name = "ShaderLinkError", this.log = i, this.message = r, this.vertexSource = e, this.fragmentSource = t;
  }
};
function LC(n, e, t) {
  var i = n.createShader(t);
  if (n.shaderSource(i, e), n.compileShader(i), !n.getShaderParameter(i, n.COMPILE_STATUS)) {
    let r = n.getShaderInfoLog(i) || "";
    throw new fV(t, e, r, hV(r));
  }
  return i;
}
var gV = class extends Z {
  constructor(e, t, i, r, s, a) {
    super(), this.gl = e, this.vertexSource = t, this.fragmentSource = i, this.attributes = new de(), this.uniforms = new de(), this.vertexShaderInputBinders = {};
    let l = this.vertexShader = LC(e, t, e.VERTEX_SHADER), d = this.fragmentShader = LC(e, i, e.FRAGMENT_SHADER), u = e.createProgram();
    if (e.attachShader(u, l), e.attachShader(u, d), e.linkProgram(u), !e.getProgramParameter(u, e.LINK_STATUS)) {
      let v = e.getProgramInfoLog(u) || "";
      throw new pV(t, i, v);
    }
    this.program = u;
    let f = this.uniforms, g = this.attributes;
    if (r)
      for (let v of r)
        f.set(v, e.getUniformLocation(u, v));
    if (s)
      for (let v of s)
        g.set(v, e.getAttribLocation(u, v));
  }
  uniform(e) {
    return this.uniforms.get(e);
  }
  attribute(e) {
    return this.attributes.get(e);
  }
  textureUnit(e) {
    return this.textureUnits.get(e);
  }
  bind() {
    this.gl.useProgram(this.program);
  }
  disposed() {
    let e = this.gl;
    e.deleteShader(this.vertexShader), this.vertexShader = void 0, e.deleteShader(this.fragmentShader), this.fragmentShader = void 0, e.deleteProgram(this.program), this.program = void 0, this.gl = void 0, this.attributes = void 0, this.uniforms = void 0;
  }
};
function mV(n, e, t, i, r) {
  n.drawArraysInstanced(e, t, i, r);
}
var DC = class {
  constructor() {
    this.code = "", this.parts = new je();
  }
  add(e) {
    if (!this.parts.has(e))
      switch (this.parts.add(e), typeof e) {
        case "string":
          this.code += e;
          break;
        case "function":
          this.add(e());
          break;
        default:
          if (Array.isArray(e))
            for (let t of e)
              this.add(t);
          else
            throw console.log("Invalid code type", e), new Error("Invalid code type");
      }
  }
  toString() {
    return this.code;
  }
};
var Qg = {
  sampler2D: WebGL2RenderingContext.TEXTURE_2D,
  isampler2D: WebGL2RenderingContext.TEXTURE_2D,
  usampler2D: WebGL2RenderingContext.TEXTURE_2D,
  sampler3D: WebGL2RenderingContext.TEXTURE_3D,
  isampler3D: WebGL2RenderingContext.TEXTURE_3D,
  usampler3D: WebGL2RenderingContext.TEXTURE_3D
};
var da = class {
  constructor(e) {
    this.gl = e, this.nextSymbolID = 0, this.nextTextureUnit = 0, this.uniformsCode = "", this.attributesCode = "", this.varyingsCodeVS = "", this.varyingsCodeFS = "", this.fragmentExtensionsSet = new je(), this.fragmentExtensions = "", this.vertexCode = new DC(), this.vertexMain = "", this.fragmentCode = new DC(), this.outputBufferCode = "", this.fragmentMain = "", this.required = new je(), this.uniforms = new Array(), this.attributes = new Array(), this.initializers = [], this.textureUnits = new de(), this.vertexDebugOutputs = [];
  }
  addVertexPositionDebugOutput() {
    this.vertexDebugOutputs.push({ typeName: "vec4", name: "gl_Position" });
  }
  addVertexDebugOutput(e, t) {
    this.addVarying(e, t), this.vertexDebugOutputs.push({ typeName: e, name: t });
  }
  allocateTextureUnit(e, t = 1) {
    if (this.textureUnits.has(e))
      throw new Error("Duplicate texture unit symbol: " + e.toString());
    let i = this.nextTextureUnit;
    return this.nextTextureUnit += t, this.textureUnits.set(e, i), i;
  }
  addTextureSampler(e, t, i, r) {
    let s = this.allocateTextureUnit(i, r);
    return this.addUniform(`highp ${e}`, t, r), this.addInitializer((a) => {
      if (r) {
        let l = new Int32Array(r);
        for (let d = 0; d < r; ++d)
          l[d] = d + s;
        a.gl.uniform1iv(a.uniform(t), l);
      } else
        a.gl.uniform1i(a.uniform(t), s);
    }), s;
  }
  symbol(e) {
    return e + this.nextSymbolID++;
  }
  addAttribute(e, t, i) {
    return this.attributes.push(t), i !== void 0 && (this.attributesCode += `layout(location = ${i})`), this.attributesCode += `in ${e} ${t};
`, t;
  }
  addVarying(e, t, i = "") {
    this.varyingsCodeVS += `${i} out ${e} ${t};
`, this.varyingsCodeFS += `${i} in ${e} ${t};
`;
  }
  addOutputBuffer(e, t, i) {
    i !== null && (this.outputBufferCode += `layout(location = ${i}) `), this.outputBufferCode += `out ${e} ${t};
`;
  }
  addUniform(e, t, i) {
    return this.uniforms.push(t), i != null ? this.uniformsCode += `uniform ${e} ${t}[${i}];
` : this.uniformsCode += `uniform ${e} ${t};
`, t;
  }
  addFragmentExtension(e) {
    this.fragmentExtensionsSet.has(e) || (this.fragmentExtensionsSet.add(e), this.fragmentExtensions += `#extension ${e} : require
`);
  }
  addVertexCode(e) {
    this.vertexCode.add(e);
  }
  addFragmentCode(e) {
    this.fragmentCode.add(e);
  }
  setVertexMain(e) {
    this.vertexMain = e;
  }
  addVertexMain(e) {
    this.vertexMain = (this.vertexMain || "") + e;
  }
  setFragmentMain(e) {
    this.fragmentMain = `void main() {
${e}
}
`;
  }
  setFragmentMainFunction(e) {
    this.fragmentMain = e;
  }
  addInitializer(e) {
    this.initializers.push(e);
  }
  require(e) {
    this.required.has(e) || (this.required.add(e), e(this));
  }
  build() {
    let e = `#version 300 es
precision highp float;
precision highp int;
${this.uniformsCode}
${this.attributesCode}
${this.varyingsCodeVS}
${this.vertexCode}
void main() {
${this.vertexMain}
}
`, t = `#version 300 es
${this.fragmentExtensions}
precision highp float;
precision highp int;
${this.uniformsCode}
${this.varyingsCodeFS}
${this.outputBufferCode}
${this.fragmentCode}
${this.fragmentMain}
`, i = new gV(this.gl, e, t, this.uniforms, this.attributes, this.vertexDebugOutputs);
    i.textureUnits = this.textureUnits;
    let r = this.initializers;
    if (r.length > 0) {
      i.bind();
      for (let s of r)
        s(i);
    }
    return i;
  }
};
function Vh() {
  return new gt(void 0);
}
function Yv(n) {
  return new hn(n, Le);
}
function qv(n, e, t) {
  const i = new de(), r = t.parameters, s = t.fallbackParameters, a = t.shaderError;
  var l = t.encodeParameters;
  const d = l === void 0 ? (_) => _ : l;
  var u = t.extraParameters;
  const f = u === void 0 ? oa(void 0) : u;
  var g = t.encodeExtraParameters;
  const v = g === void 0 ? (_) => _ : g, y = t.getContextKey, w = t.defineShader;
  a !== void 0 && (a.value = void 0);
  var C = t.encodeContext;
  const b = C === void 0 ? y : C, E = ri(t.memoizeKey);
  function L(_, A, I) {
    const P = se({
      id: E,
      context: b(_),
      parameters: d(A),
      extraParameters: v(I)
    });
    return e.memoize.get(P, () => {
      const N = new da(e);
      return w(N, _, A, I), N.build();
    });
  }
  function R(_) {
    const A = y(_);
    let I = i.get(A);
    I === void 0 && (I = {
      parametersGeneration: -1,
      extraParametersGeneration: -1,
      shader: null,
      fallback: false,
      parameters: r.value,
      extraParameters: f.value
    }, i.set(A, I));
    const P = r.changed.count, N = f.changed.count;
    if (P === I.parametersGeneration && N === I.extraParametersGeneration)
      return I;
    const O = I.parameters = r.value, B = I.extraParameters = f.value, j = I.shader;
    I.parametersGeneration = P, I.extraParametersGeneration = N;
    let U = null;
    try {
      U = L(_, O, B), I.fallback = false, s !== void 0 && (s.value = O), a !== void 0 && (a.value = null);
    } catch (V) {
      if (a !== void 0 && (a.value = V), s !== void 0)
        try {
          const G = s.value;
          U = L(_, G, B), I.parameters = G, I.fallback = true;
        } catch {
        }
    }
    return j !== null && j.dispose(), I.shader = U, I;
  }
  return n.registerDisposer(() => {
    for (const _ of i.values()) {
      const A = _.shader;
      A !== null && A.dispose();
    }
  }), R;
}
function Io(n, e, t) {
  return qv(n, e, RZr(RZr({}, t), { getContextKey: (i) => i, encodeContext: (i) => xn(i), defineShader: (i, r, s, a) => (i.require(r), t.defineShader(i, s, a)) }));
}
function Sc(n, e = 1, t = 0) {
  return `
#line ${t} ${e}
` + n;
}
var Xn = class _Xn {
  constructor(e, t = WebGL2RenderingContext.ARRAY_BUFFER) {
    this.gl = e, this.bufferType = t, this.gl = e, this.buffer = e.createBuffer();
  }
  bind() {
    this.gl.bindBuffer(this.bufferType, this.buffer);
  }
  bindToVertexAttrib(e, t, i = WebGL2RenderingContext.FLOAT, r = false, s = 0, a = 0) {
    this.bind(), this.gl.enableVertexAttribArray(e), this.gl.vertexAttribPointer(e, t, i, r, s, a);
  }
  bindToVertexAttribI(e, t, i = WebGL2RenderingContext.UNSIGNED_INT, r = 0, s = 0) {
    this.bind(), this.gl.enableVertexAttribArray(e), this.gl.vertexAttribIPointer(e, t, i, r, s);
  }
  setData(e, t = WebGL2RenderingContext.STATIC_DRAW) {
    let i = this.gl;
    this.bind(), i.bufferData(this.bufferType, e, t);
  }
  dispose() {
    this.gl.deleteBuffer(this.buffer), this.buffer = void 0, this.gl = void 0;
  }
  static fromData(e, t, i, r) {
    let s = new _Xn(e, i);
    return s.setData(t, r), s;
  }
};
function bc(n, e, t, ...i) {
  return n.memoize.get(ri({ id: "getMemoizedBuffer", getter: xn(t), args: i }), () => {
    const r = new NE(Xn.fromData(n, t(...i), e, WebGL2RenderingContext.STATIC_DRAW));
    return r.registerDisposer(r.value), r;
  });
}
function vV(n = -1, e = -1, t = 1, i = 1, r = 1, s = 1) {
  return Tg(
    new Float32Array([n, e, n, i, t, i, t, e]),
    /*majorDimension=*/
    2,
    r,
    s
  );
}
function Cc(n, e = -1, t = -1, i = 1, r = 1, s = 1, a = 1) {
  return bc(n, WebGL2RenderingContext.ARRAY_BUFFER, vV, e, t, i, r, s, a).value;
}
function Lo(n) {
  n.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MIN_FILTER, WebGL2RenderingContext.NEAREST), n.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MAG_FILTER, WebGL2RenderingContext.NEAREST), n.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_WRAP_S, WebGL2RenderingContext.CLAMP_TO_EDGE), n.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_WRAP_T, WebGL2RenderingContext.CLAMP_TO_EDGE);
}
function yV(n) {
  n.texParameteri(WebGL2RenderingContext.TEXTURE_3D, WebGL2RenderingContext.TEXTURE_MIN_FILTER, WebGL2RenderingContext.NEAREST), n.texParameteri(WebGL2RenderingContext.TEXTURE_3D, WebGL2RenderingContext.TEXTURE_MAG_FILTER, WebGL2RenderingContext.NEAREST), n.texParameteri(WebGL2RenderingContext.TEXTURE_3D, WebGL2RenderingContext.TEXTURE_WRAP_S, WebGL2RenderingContext.CLAMP_TO_EDGE), n.texParameteri(WebGL2RenderingContext.TEXTURE_3D, WebGL2RenderingContext.TEXTURE_WRAP_T, WebGL2RenderingContext.CLAMP_TO_EDGE), n.texParameteri(WebGL2RenderingContext.TEXTURE_3D, WebGL2RenderingContext.TEXTURE_WRAP_R, WebGL2RenderingContext.CLAMP_TO_EDGE);
}
function SV(n, e, t, i, r = WebGL2RenderingContext.RGBA8, s = WebGL2RenderingContext.RGBA, a = WebGL2RenderingContext.UNSIGNED_BYTE) {
  n.activeTexture(WebGL2RenderingContext.TEXTURE0 + n.tempTextureUnit), n.bindTexture(WebGL2RenderingContext.TEXTURE_2D, e), Lo(n), n.texImage2D(
    WebGL2RenderingContext.TEXTURE_2D,
    0,
    /*internalformat=*/
    r,
    /*width=*/
    t,
    /*height=*/
    i,
    /*border=*/
    0,
    /*format=*/
    s,
    a,
    null
  ), n.bindTexture(WebGL2RenderingContext.TEXTURE_2D, null);
}
function bV(n, e, t) {
  n.activeTexture(WebGL2RenderingContext.TEXTURE0 + n.tempTextureUnit), n.bindTexture(WebGL2RenderingContext.TEXTURE_2D, e), n.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MIN_FILTER, WebGL2RenderingContext.LINEAR), n.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_MAG_FILTER, WebGL2RenderingContext.LINEAR), n.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_WRAP_S, WebGL2RenderingContext.CLAMP_TO_EDGE), n.texParameteri(WebGL2RenderingContext.TEXTURE_2D, WebGL2RenderingContext.TEXTURE_WRAP_T, WebGL2RenderingContext.CLAMP_TO_EDGE), n.pixelStorei(WebGL2RenderingContext.UNPACK_FLIP_Y_WEBGL, 1), n.pixelStorei(WebGL2RenderingContext.UNPACK_ALIGNMENT, 4), n.texImage2D(
    WebGL2RenderingContext.TEXTURE_2D,
    /*level=*/
    0,
    /*internalformat=*/
    WebGL2RenderingContext.RGBA8,
    /*format=*/
    WebGL2RenderingContext.RGBA,
    WebGL2RenderingContext.UNSIGNED_BYTE,
    t
  ), n.pixelStorei(WebGL2RenderingContext.UNPACK_FLIP_Y_WEBGL, 0), n.bindTexture(WebGL2RenderingContext.TEXTURE_2D, null);
}
function wT(n) {
  n.addOutputBuffer("vec4", "v4f_fragColor", null), n.setFragmentMain("v4f_fragColor = getValue0();");
}
function CV(n, e = wT, t = 1) {
  return n.memoize.get(`elementWiseTextureShader:${t}:${xn(e)}`, () => {
    let i = new da(n);
    i.addVarying("vec2", "vTexCoord"), i.addUniform("sampler2D", "uSampler", t), i.addInitializer((r) => {
      let s = [];
      for (let a = 0; a < t; ++a)
        s[a] = a;
      n.uniform1iv(r.uniform("uSampler"), s);
    });
    for (let r = 0; r < t; ++r)
      i.addFragmentCode(`
vec4 getValue${r}() {
  return texture(uSampler[${r}], vTexCoord);
}
`);
    return i.addUniform("mat4", "uProjectionMatrix"), i.require(e), i.addAttribute("vec4", "aVertexPosition"), i.addAttribute("vec2", "aTexCoord"), i.setVertexMain("vTexCoord = aTexCoord; gl_Position = uProjectionMatrix * aVertexPosition;"), i.build();
  });
}
function wV(n) {
  return n.memoize.get("trivialColorShader", () => {
    let e = new da(n);
    return e.addVarying("vec4", "vColor"), e.addOutputBuffer("vec4", "v4f_fragColor", null), e.setFragmentMain("v4f_fragColor = vColor;"), e.addAttribute("vec4", "aVertexPosition"), e.addAttribute("vec4", "aColor"), e.addUniform("mat4", "uProjectionMatrix"), e.setVertexMain("vColor = aColor; gl_Position = uProjectionMatrix * aVertexPosition;"), e.build();
  });
}
var xT = class extends Z {
  constructor() {
    super(...arguments), this.width = Number.NaN, this.height = Number.NaN;
  }
  hasSize(e, t) {
    return this.width === e && this.height === t;
  }
  resize(e, t) {
    this.hasSize(e, t) || (this.width = e, this.height = t, this.performResize());
  }
};
var xV = class extends xT {
  constructor(e, t) {
    super(), this.gl = e, this.internalformat = t, this.renderbuffer = null, this.renderbuffer = e.createRenderbuffer();
  }
  performResize() {
    let e = this.gl;
    e.bindRenderbuffer(e.RENDERBUFFER, this.renderbuffer), e.renderbufferStorage(e.RENDERBUFFER, this.internalformat, this.width, this.height), e.bindRenderbuffer(e.RENDERBUFFER, null);
  }
  disposed() {
    this.gl.deleteRenderbuffer(this.renderbuffer);
  }
  attachToFramebuffer(e) {
    let t = this.gl;
    t.framebufferRenderbuffer(t.FRAMEBUFFER, e, t.RENDERBUFFER, this.renderbuffer);
  }
};
var EV = class extends xV {
  constructor(e, t = false) {
    super(e, t ? e.DEPTH_STENCIL : e.DEPTH_COMPONENT16), this.gl = e, this.includeStencilBuffer = t;
  }
  attachToFramebuffer() {
    let e = this.gl;
    super.attachToFramebuffer(this.includeStencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT);
  }
};
var TV = class extends EV {
  constructor(e) {
    super(
      e,
      /*includeStencilBuffer=*/
      true
    );
  }
};
var kV = class extends Z {
  constructor(e) {
    super(), this.gl = e, this.framebuffer = this.gl.createFramebuffer();
  }
  disposed() {
    this.gl.deleteFramebuffer(this.framebuffer);
  }
  bind() {
    let e = this.gl;
    e.bindFramebuffer(e.FRAMEBUFFER, this.framebuffer);
  }
  unbind() {
    let e = this.gl;
    e.bindFramebuffer(e.FRAMEBUFFER, null);
  }
};
var sa = class extends xT {
  constructor(e, t, i, r) {
    super(), this.gl = e, this.internalFormat = t, this.format = i, this.dataType = r, this.texture = e.createTexture();
  }
  performResize() {
    SV(this.gl, this.texture, this.width, this.height, this.internalFormat, this.format, this.dataType);
  }
  disposed() {
    this.gl.deleteTexture(this.texture);
  }
  attachToFramebuffer(e) {
    let t = this.gl;
    t.framebufferTexture2D(
      t.FRAMEBUFFER,
      e,
      t.TEXTURE_2D,
      this.texture,
      /*level=*/
      0
    );
  }
};
var IV = class extends sa {
  constructor(e, t = WebGL2RenderingContext.DEPTH_COMPONENT16, i = WebGL2RenderingContext.DEPTH_COMPONENT, r = WebGL2RenderingContext.UNSIGNED_SHORT) {
    super(e, t, i, r);
  }
  attachToFramebuffer() {
    super.attachToFramebuffer(this.format === WebGL2RenderingContext.DEPTH_COMPONENT ? WebGL2RenderingContext.DEPTH_ATTACHMENT : WebGL2RenderingContext.DEPTH_STENCIL_ATTACHMENT);
  }
};
function Vu(n, e, t = WebGL2RenderingContext.RGBA8, i = WebGL2RenderingContext.RGBA, r = WebGL2RenderingContext.UNSIGNED_BYTE) {
  let s = new Array();
  for (let a = 0; a < e; ++a)
    s[a] = new sa(n, t, i, r);
  return s;
}
var Do = class extends Z {
  constructor(e, t) {
    super(), this.gl = e, this.width = Number.NaN, this.height = Number.NaN, this.fullAttachmentList = new Array(), this.attachmentVerified = false, this.singleAttachmentList = [this.gl.COLOR_ATTACHMENT0];
    var i = t.framebuffer;
    let r = i === void 0 ? new kV(e) : i, s = t.colorBuffers, a = t.depthBuffer;
    this.framebuffer = this.registerDisposer(r), this.colorBuffers = s, this.depthBuffer = a, a !== void 0 && this.registerDisposer(a);
    let l = this.fullAttachmentList;
    s.forEach((d, u) => {
      this.registerDisposer(d), l[u] = e.COLOR_ATTACHMENT0 + u;
    });
  }
  hasSize(e, t) {
    return this.width === e && this.height === t;
  }
  bind(e, t) {
    this.width = e, this.height = t, this.framebuffer.bind();
    let i = this.gl, r = this.depthBuffer;
    r !== void 0 ? (r.resize(e, t), r.attachToFramebuffer()) : i.framebufferRenderbuffer(WebGL2RenderingContext.FRAMEBUFFER, WebGL2RenderingContext.DEPTH_STENCIL_ATTACHMENT, WebGL2RenderingContext.RENDERBUFFER, null), this.colorBuffers.forEach((s, a) => {
      s.resize(e, t), s.attachToFramebuffer(i.COLOR_ATTACHMENT0 + a);
    }), i.drawBuffers(this.fullAttachmentList), this.verifyAttachment(), i.viewport(0, 0, e, t);
  }
  bindSingle(e) {
    let t = this.gl;
    this.framebuffer.bind(), e !== 0 && t.framebufferTexture2D(
      t.FRAMEBUFFER,
      t.COLOR_ATTACHMENT0 + e,
      t.TEXTURE_2D,
      null,
      /*level=*/
      0
    ), t.bindTexture(t.TEXTURE_2D, null), this.colorBuffers[e].attachToFramebuffer(t.COLOR_ATTACHMENT0), t.drawBuffers(this.singleAttachmentList);
  }
  unbind() {
    this.framebuffer.unbind();
  }
  readPixelFloat32IntoBuffer(e, t, i, r, s = 1, a = 1) {
    let l = this.gl;
    try {
      this.bindSingle(e), l.readPixels(t, i, s, a, WebGL2RenderingContext.RGBA, WebGL2RenderingContext.FLOAT, r);
    } finally {
      this.framebuffer.unbind();
    }
  }
  verifyAttachment() {
    if (this.attachmentVerified)
      return;
    let e = this.gl, t = e.checkFramebufferStatus(e.FRAMEBUFFER);
    if (t !== e.FRAMEBUFFER_COMPLETE)
      throw new Error(`Framebuffer configuration not supported: ${t}`);
    this.attachmentVerified = true;
  }
};
var Po = class _Po extends Z {
  constructor(e, t) {
    super(), this.gl = e, this.shader = t, this.copyVertexPositionsBuffer = Cc(this.gl), this.copyTexCoordsBuffer = Cc(this.gl, 0, 0, 1, 1), this.registerDisposer(t);
  }
  draw(...e) {
    let t = this.gl, i = this.shader;
    i.bind();
    let r = e.length;
    for (let l = 0; l < r; ++l)
      t.activeTexture(t.TEXTURE0 + l), t.bindTexture(t.TEXTURE_2D, e[l]);
    t.uniformMatrix4fv(i.uniform("uProjectionMatrix"), false, YE);
    let s = i.attribute("aVertexPosition");
    this.copyVertexPositionsBuffer.bindToVertexAttrib(
      s,
      /*components=*/
      2
    );
    let a = i.attribute("aTexCoord");
    this.copyTexCoordsBuffer.bindToVertexAttrib(
      a,
      /*components=*/
      2
    ), t.drawArrays(t.TRIANGLE_FAN, 0, 4), t.disableVertexAttribArray(s), t.disableVertexAttribArray(a);
    for (let l = 0; l < r; ++l)
      t.activeTexture(t.TEXTURE0 + l), t.bindTexture(t.TEXTURE_2D, null);
  }
  static get(e, t = wT, i = 1) {
    return e.memoize.get(`OffscreenCopyHelper:${i}:${xn(t)}`, () => new _Po(e, CV(e, t, i)));
  }
};
var LV = `
float mixLinear(float x, float y, float a) { return mix(x, y, a); }
`;
var DV = `
vec3 hueToRgb(float hue) {
  float hue6 = hue * 6.0;
  float r = abs(hue6 - 3.0) - 1.0;
  float g = 2.0 - abs(hue6 - 2.0);
  float b = 2.0 - abs(hue6 - 4.0);
  return clamp(vec3(r, g, b), 0.0, 1.0);
}
vec3 hsvToRgb(vec3 c) {
  vec3 hueRgb = hueToRgb(c.x);
  return c.z * ((hueRgb - 1.0) * c.y + 1.0);
}
`;
var Ht = `
struct uint64_t {
  highp uvec2 value;
};
struct uint64x2_t {
  highp uvec4 value;
};
uint64_t mixLinear(uint64_t x, uint64_t y, float a) {
  return x;
}
uint64_t toUint64(uint64_t x) { return x; }
`;
var PV = [Ht, `
uint64_t unpackUint64leFromUint32(highp uvec2 x) {
  uint64_t result;
  result.value = x;
  return result;
}
uint64x2_t unpackUint64leFromUint32(highp uvec4 x) {
  uint64x2_t result;
  result.value = x;
  return result;
}
`];
var ET = [Ht, `
bool equals(uint64_t a, uint64_t b) {
  return a.value == b.value;
}
`];
var Bh = [Ht, `
bool compareLessThan(uint64_t a, uint64_t b) {
  return (a.value[1] < b.value[1])||
         (a.value[1] == b.value[1] && a.value[0] < b.value[0]);
}
`];
var TT = [Ht, `
uint64_t subtract(uint64_t a, uint64_t b) {
  if (a.value[0] < b.value[0]) {
    --a.value[1];
  }
  a.value -= b.value;
  return a;
}
`];
var AV = [Ht, `
uint64_t add(uint64_t a, uint64_t b) {
  a.value[0] += b.value[0];
  if (a.value[0] < b.value[0]) {
    ++a.value[1];
  }
  a.value[1] += b.value[1];
  return a;
}
`];
var RV = [AV, Bh, `
uint64_t addSaturate(uint64_t a, uint64_t b) {
  a = add(a, b);
  if (compareLessThan(a, b)) {
    a.value = uvec2(0xffffffffu, 0xffffffffu);
  }
  return a;
}
`];
var MV = [TT, Bh, `
uint64_t subtractSaturate(uint64_t a, uint64_t b) {
  b = subtract(a, b);
  if (compareLessThan(a, b)) {
    b.value = uvec2(0u, 0u);
  }
  return b;
}
`];
var kT = [Ht, `
uint64_t shiftRight(uint64_t a, int shift) {
  if (shift >= 32) {
    return uint64_t(uvec2(a.value[1] >> (shift - 32), 0u));
  } else if (shift == 0) {
    return a;
  } else {
    return uint64_t(uvec2((a.value[0] >> shift) | (a.value[1] << (32 - shift)), a.value[1] >> shift));
  }
}
`];
var NV = [Ht, `
uint64_t shiftLeft(uint64_t a, int shift) {
  if (shift >= 32) {
    return uint64_t(uvec2(0u, a.value[0] << (shift - 32)));
  } else if (shift == 0) {
    return a;
  } else {
    return uint64_t(uvec2(a.value[0] << shift, (a.value[1] << shift) | (a.value[0] >> (32 - shift))));
  }
}
`];
var IT = [Ht, `
struct uint8_t {
  highp uint value;
};
struct uint8x2_t {
  highp uvec2 value;
};
struct uint8x3_t {
  highp uvec3 value;
};
struct uint8x4_t {
  highp uvec4 value;
};
uint8_t mixLinear(uint8_t x, uint8_t y, highp float a) {
  return uint8_t(uint(round(mix(float(x.value), float(y.value), a))));
}
highp uint toRaw(uint8_t x) { return x.value; }
highp float toNormalized(uint8_t x) { return float(x.value) / 255.0; }
highp uvec2 toRaw(uint8x2_t x) { return x.value; }
highp vec2 toNormalized(uint8x2_t x) { return vec2(x.value) / 255.0; }
highp uvec3 toRaw(uint8x3_t x) { return x.value; }
vec3 toNormalized(uint8x3_t x) { return vec3(x.value) / 255.0; }
highp uvec4 toRaw(uint8x4_t x) { return x.value; }
vec4 toNormalized(uint8x4_t x) { return vec4(x.value) / 255.0; }
uint64_t toUint64(uint8_t x) {
  uint64_t result;
  result.value[0] = x.value;
  result.value[1] = 0u;
  return result;
}
uint8_t uint8FromFloat(highp float x) {
  return uint8_t(uint(clamp(x, 0.0, 255.0)));
}
`];
var LT = [Ht, `
struct int8_t {
  highp int value;
};
struct int8x2_t {
  highp ivec2 value;
};
struct int8x3_t {
  highp ivec3 value;
};
struct int8x4_t {
  highp ivec4 value;
};
int8_t mixLinear(int8_t x, int8_t y, highp float a) {
  return int8_t(int(round(mix(float(x.value), float(y.value), a))));
}
highp int toRaw(int8_t x) { return x.value; }
highp ivec2 toRaw(int8x2_t x) { return x.value; }
highp ivec3 toRaw(int8x3_t x) { return x.value; }
highp ivec4 toRaw(int8x4_t x) { return x.value; }
uint64_t toUint64(int8_t x) {
  uint64_t result;
  result.value[0] = uint(x.value);
  result.value[1] = uint(x.value >> 31);
  return result;
}
int8_t int8FromFloat(highp float x) {
  return int8_t(int(clamp(x, -128.0, 127.0)));
}
`];
var Kv = `
highp float toRaw(highp float x) { return x; }
highp float toNormalized(highp float x) { return x; }
vec2 toRaw(vec2 x) { return x; }
vec2 toNormalized(vec2 x) { return x; }
vec3 toRaw(vec3 x) { return x; }
vec3 toNormalized(vec3 x) { return x; }
vec4 toRaw(vec4 x) { return x; }
vec4 toNormalized(vec4 x) { return x; }
`;
var DT = [Ht, `
struct uint16_t {
  highp uint value;
};
struct uint16x2_t {
  highp uvec2 value;
};
uint16_t mixLinear(uint16_t x, uint16_t y, highp float a) {
  return uint16_t(uint(round(mix(float(x.value), float(y.value), a))));
}
highp uint toRaw(uint16_t x) { return x.value; }
highp float toNormalized(uint16_t x) { return float(toRaw(x)) / 65535.0; }
highp uvec2 toRaw(uint16x2_t x) { return x.value; }
highp vec2 toNormalized(uint16x2_t x) { return vec2(toRaw(x)) / 65535.0; }
uint64_t toUint64(uint16_t x) {
  uint64_t result;
  result.value[0] = x.value;
  result.value[1] = 0u;
  return result;
}
uint16_t uint16FromFloat(highp float x) {
  return uint16_t(uint(clamp(x, 0.0, 65535.0)));
}
`];
var PT = [Ht, `
struct int16_t {
  highp int value;
};
struct int16x2_t {
  highp ivec2 value;
};
int16_t mixLinear(int16_t x, int16_t y, highp float a) {
  return int16_t(int(round(mix(float(x.value), float(y.value), a))));
}
highp int toRaw(int16_t x) { return x.value; }
highp ivec2 toRaw(int16x2_t x) { return x.value; }
uint64_t toUint64(int16_t x) {
  uint64_t result;
  result.value[0] = uint(x.value);
  result.value[1] = uint(x.value >> 31);
  return result;
}
int16_t int16FromFloat(highp float x) {
  return int16_t(int(clamp(x, -32768.0, 32767.0)));
}
`];
var Zv = [Ht, `
struct uint32_t {
  highp uint value;
};
uint32_t mixLinear(uint32_t x, uint32_t y, highp float a) {
  return uint32_t(uint(round(mix(float(x.value), float(y.value), a))));
}
highp float toNormalized(uint32_t x) { return float(x.value) / 4294967295.0; }
highp uint toRaw(uint32_t x) { return x.value; }
uint64_t toUint64(uint32_t x) {
  uint64_t result;
  result.value[0] = x.value;
  result.value[1] = 0u;
  return result;
}
uint32_t uint32FromFloat(highp float x) {
  return uint32_t(uint(clamp(x, 0.0, 4294967295.0)));
}
`];
var AT = [Ht, `
struct int32_t {
  highp int value;
};
int32_t mixLinear(int32_t x, int32_t y, highp float a) {
  return int32_t(int(round(mix(float(x.value), float(y.value), a))));
}
highp int toRaw(int32_t x) { return x.value; }
uint64_t toUint64(int32_t x) {
  uint64_t result;
  result.value[0] = uint(x.value);
  result.value[1] = uint(x.value >> 31);
  return result;
}
int32_t int32FromFloat(highp float x) {
  return int32_t(int(clamp(x, 2147483648.0, 2147483647.0)));
}
`];
var _V = `
highp int getFortranOrderIndex(ivec3 subscripts, ivec3 size) {
  return subscripts.x + size.x * (subscripts.y + size.y * subscripts.z);
}
`;
var OV = `
highp uint log2Exact(highp uint i) {
  highp uint r;
  r = uint((i & 0xAAAAAAAAu) != 0u);
  r |= uint((i & 0xFFFF0000u) != 0u) << 4;
  r |= uint((i & 0xFF00FF00u) != 0u) << 3;
  r |= uint((i & 0xF0F0F0F0u) != 0u) << 2;
  r |= uint((i & 0xCCCCCCCCu) != 0u) << 1;
  return r;
}
`;
var VV = `
bool clipLineToDepthRange(inout highp vec4 a, inout highp vec4 b) {
  highp float tmin = 0.0, tmax = 1.0;
  highp float k1 = b.w - a.w + a.z - b.z;
  highp float k2 = a.w - b.w + a.z - b.z;
  highp float q1 = (a.z - a.w) / k1;
  highp float q2 = (a.z + a.w) / k2;
  if (k1 > 0.0) tmin = max(tmin, q1);
  else if (k1 < 0.0) tmax = min(tmax, q1);
  if (k2 > 0.0) tmax = min(tmax, q2);
  else if (k2 < 0.0) tmin = max(tmin, q2);
  if (tmin <= tmax) {
    highp vec4 tempA = a;
    highp vec4 tempB = b;
    a = mix(tempA, tempB, tmin);
    b = mix(tempA, tempB, tmax);
    return true;
  }
  return false;
}
`;
var BV = `
highp float simpleFloatHash(highp vec2 co) {
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}
`;
var FV = `
highp uint shiftLeftSaturate(highp uint x, int shiftAmount) {
  highp uint result = x << shiftAmount;
  if ((result >> shiftAmount) != x) return 0xffffffffu;
  return result;
}
`;
var Xv = `
highp uint addSaturate(highp uint x, highp uint y) {
  highp uint result = x + y;
  if (result < x) return 0xffffffffu;
  return result;
}
`;
var UV = `
highp uint subtractSaturate(highp uint x, highp uint y) {
  highp uint result = x - y;
  if (result > x) return 0u;
  return result;
}
`;
var zV = [Xv, `
highp int addSaturate(highp int x, highp uint y) {
  if (x >= 0) {
    return int(min(addSaturate(y, uint(x)), 0x7fffffffu));
  } else if (y >= uint(-x)) {
    return int(min(y - uint(-x), 0x7fffffffu));
  } else {
    return -int(min(uint(-x) - y, 0x80000000u));
  }
}
`];
var GV = [Xv, `
highp int subtractSaturate(highp int x, highp uint y) {
  if (x < 0) {
    return -int(min(addSaturate(uint(-x), uint(y)), 0x80000000u));
  } else if (uint(x) >= y) {
    return x - int(y);
  } else {
    return -int(min(y - uint(x), 0x80000000u));
  }
}
`];
function wn(n, e = 1) {
  switch (n) {
    case J.FLOAT32:
      if (e === 1)
        return "float";
      if (e > 1 && e <= 4)
        return `vec${e}`;
      break;
    case J.UINT8:
    case J.INT8:
    case J.UINT16:
    case J.INT16:
    case J.UINT32:
    case J.INT32:
    case J.UINT64: {
      const t = s1[n] ? "" : "u", i = I_[n] * 8;
      if (e === 1)
        return `${t}int${i}_t`;
      if (e > 1 && e * i <= 32)
        return `${t}int${i}x${e}_t`;
      break;
    }
  }
  throw new Error(`No shader type for ${J[n]}[${e}].`);
}
var Ko = {
  [J.UINT8]: IT,
  [J.INT8]: LT,
  [J.UINT16]: DT,
  [J.INT16]: PT,
  [J.UINT32]: Zv,
  [J.INT32]: AT,
  [J.UINT64]: Ht,
  [J.FLOAT32]: Kv
};
function $V(n, e) {
  return e === 1 ? n : n === "float" ? `vec${e}` : `${n[0]}vec${e}`;
}
var WV = {
  [WebGL2RenderingContext.UNSIGNED_BYTE]: 1,
  [WebGL2RenderingContext.BYTE]: 1,
  [WebGL2RenderingContext.UNSIGNED_SHORT]: 2,
  [WebGL2RenderingContext.SHORT]: 2,
  [WebGL2RenderingContext.FLOAT]: 4,
  [WebGL2RenderingContext.INT]: 4,
  [WebGL2RenderingContext.UNSIGNED_INT]: 4
};
function Uc(n, e, t, i, r, s, a = 1) {
  let l = 0, d = s * a;
  for (; d > 0; ) {
    const g = Math.min(4, d), v = $V(e, g);
    d -= g, n.addAttribute("highp " + v, `a${r}${l}`), ++l;
  }
  d = s * a;
  let u = "";
  for (let g = 0; g < a; ++g) {
    u += `highp ${e}[${s}] get${r}${g}() {
  highp ${e}[${s}] result;
`;
    for (let v = 0; v < s; ++v) {
      const y = g * s + v, w = Math.floor(y / 4), C = y % 4;
      u += `  result[${v}] = a${r}${w}`, (C !== 0 || y !== d - 1) && (u += `[${C}]`), u += `;
`;
    }
    u += `  return result;
`, u += `}
`;
  }
  n.addVertexCode(u);
  const f = WV[t];
  n.addInitializer((g) => {
    const v = [];
    for (let y = 0; y < l; ++y)
      v[y] = g.attribute(`a${r}${y}`);
    g.vertexShaderInputBinders[r] = {
      enable(y) {
        const w = g.gl;
        for (let C = 0; C < l; ++C) {
          const b = v[C];
          w.enableVertexAttribArray(b), w.vertexAttribDivisor(b, y);
        }
      },
      disable() {
        const y = g.gl;
        for (let w = 0; w < l; ++w) {
          const C = v[w];
          y.vertexAttribDivisor(C, 0), y.disableVertexAttribArray(C);
        }
      },
      bind(y, w) {
        const C = g.gl;
        for (let b = 0; b < l; ++b) {
          const E = v[b], L = Math.min(4, d - 4 * b);
          e === "float" ? C.vertexAttribPointer(
            E,
            /*size=*/
            L,
            t,
            i,
            y,
            w
          ) : C.vertexAttribIPointer(
            E,
            /*size=*/
            Math.min(4, d - 4 * b),
            t,
            y,
            w
          ), w += f * L;
        }
      }
    };
  });
}
var RT = class extends Z {
  constructor(e, t, i = new yc()) {
    super(), this.channels = e, this.bounds = t, this.visibility = i, this.framebuffers = [], this.producerVisibility = new yc(), this.frameNumber = -1;
  }
  getFramebuffers(e) {
    const t = this.framebuffers;
    for (; t.length < this.channels.value.length; ) {
      const i = new Do(e, {
        colorBuffers: Vu(e, 1, WebGL2RenderingContext.R32F, WebGL2RenderingContext.RED, WebGL2RenderingContext.FLOAT)
      });
      t.push(i);
    }
    return t;
  }
  disposed() {
    for (const e of this.framebuffers)
      e.dispose();
    this.framebuffers.length = 0;
  }
};
var PC = NZr("histogramDataSamplerTextureUnit");
var AC = NZr("histogramDepthTextureUnit");
var Vp = 4096;
var HV = 2 ** 14;
var Qv = class _Qv extends Z {
  constructor(e) {
    super(), this.gl = e, this.shader = this.registerDisposer((() => {
      const t = new da(this.gl);
      return t.addOutputBuffer("vec4", "outputValue", 0), t.addAttribute("float", "aInput1"), t.addTextureSampler("sampler2D", "uDataSampler", PC), t.addTextureSampler("sampler2D", "uDepthSampler", AC), t.addVertexCode(BV), t.setVertexMain(`
float uRandomSeed = 0.0;
vec2 p = vec2(simpleFloatHash(vec2(aInput1 + float(gl_VertexID), uRandomSeed + float(gl_InstanceID))),
              simpleFloatHash(vec2(aInput1 + float(gl_VertexID) + 10.0, 5.0 + uRandomSeed + float(gl_InstanceID))));
float dataValue = texture(uDataSampler, p).x;
float stencilValue = texture(uDepthSampler, p).x;
if (stencilValue == 1.0) {
  gl_Position = vec4(2.0, 2.0, 2.0, 1.0);
} else {
  gl_Position = vec4(2.0 * (dataValue * 255.0 + 0.5) / 256.0 - 1.0, 0.0, 0.0, 1.0);
}
gl_PointSize = 1.0;
`), t.setFragmentMain(`
outputValue = vec4(1.0, 1.0, 1.0, 1.0);
`), t.build();
    })()), this.inputIndexBuffer = this.registerDisposer(bc(this.gl, WebGL2RenderingContext.ARRAY_BUFFER, () => new Uint8Array(Vp)));
  }
  static get(e) {
    return e.memoize.get("textureHistogramGeneration", () => new _Qv(e));
  }
  compute(e, t, i, r, s) {
    const a = this.gl, l = this.shader, d = r.getFramebuffers(a);
    l.bind(), a.enable(WebGL2RenderingContext.BLEND), a.disable(WebGL2RenderingContext.SCISSOR_TEST), a.disable(WebGL2RenderingContext.DEPTH_TEST), a.blendFunc(WebGL2RenderingContext.ONE, WebGL2RenderingContext.ONE), this.inputIndexBuffer.value.bindToVertexAttrib(
      l.attribute("aInput1"),
      1,
      WebGL2RenderingContext.UNSIGNED_BYTE,
      /*normalized=*/
      true
    );
    const u = l.textureUnit(PC), f = l.textureUnit(AC);
    a.activeTexture(WebGL2RenderingContext.TEXTURE0 + f), a.bindTexture(WebGL2RenderingContext.TEXTURE_2D, t), Lo(a), a.activeTexture(WebGL2RenderingContext.TEXTURE0 + u);
    const g = r.frameNumber;
    r.frameNumber = s;
    for (let v = 0; v < e; ++v)
      a.bindTexture(WebGL2RenderingContext.TEXTURE_2D, i[v].texture), Lo(a), d[v].bind(256, 1), s !== g && (a.clearColor(0, 0, 0, 0), a.clear(WebGL2RenderingContext.COLOR_BUFFER_BIT)), a.drawArraysInstanced(WebGL2RenderingContext.POINTS, 0, Vp, HV / Vp);
    a.disable(WebGL2RenderingContext.BLEND);
  }
};
var ey = {
  [J.UINT8]: "vec2",
  [J.INT8]: "vec2",
  [J.UINT16]: "vec2",
  [J.INT16]: "vec2",
  [J.FLOAT32]: "vec2",
  [J.UINT32]: "Uint32LerpParameters",
  [J.INT32]: "Int32LerpParameters",
  [J.UINT64]: "Uint64LerpParameters"
};
var zc = {
  [J.UINT8]: "",
  [J.INT8]: "",
  [J.UINT16]: "",
  [J.INT16]: "",
  [J.FLOAT32]: "",
  [J.UINT32]: `
struct Uint32LerpParameters {
  uint offset;
  int shift;
  float multiplier;
};
`,
  [J.INT32]: `
struct Int32LerpParameters {
  int offset;
  int shift;
  float multiplier;
};
`,
  [J.UINT64]: [Ht, `
struct Uint64LerpParameters {
  uint64_t offset;
  int shift;
  float multiplier;
};
`]
};
function $l(n) {
  let t = `
float computeInvlerp(${wn(n)} inputValue, vec2 p) {
  float outputValue = float(toRaw(inputValue));
  outputValue = (outputValue - p[0]) * p[1];
  return outputValue;
}
`;
  return [Ko[n], t];
}
function RC(n) {
  const e = wn(n);
  let t = n === J.INT32 ? "int" : "uint", i = ey[n];
  return [Ko[n], zc[n], `
float computeInvlerp(${e} inputValue, ${i} p) {
  ${t} v = toRaw(inputValue);
  uint x;
  if (v >= p.offset) {
    x = uint(v - p.offset);
  } else {
    x = uint(p.offset - v);
    p.multiplier = -p.multiplier;
  }
  x >>= p.shift;
  return float(x) * p.multiplier;
}
`];
}
var jV = {
  [J.UINT8]: $l(J.UINT8),
  [J.INT8]: $l(J.INT8),
  [J.UINT16]: $l(J.UINT16),
  [J.INT16]: $l(J.INT16),
  [J.FLOAT32]: $l(J.FLOAT32),
  [J.UINT32]: RC(J.UINT32),
  [J.INT32]: RC(J.INT32),
  [J.UINT64]: [Ht, Bh, TT, kT, zc[J.UINT64], `
float computeInvlerp(uint64_t inputValue, Uint64LerpParameters p) {
  if (compareLessThan(inputValue, p.offset)) {
    inputValue = subtract(p.offset, inputValue);
    p.multiplier = -p.multiplier;
  } else {
    inputValue = subtract(inputValue, p.offset);
  }
  uint shifted = shiftRight(inputValue, p.shift).value[0];
  return float(shifted) * p.multiplier;
}
`]
};
function Wl(n) {
  let t = `
${wn(n)} computeLerp(float inputValue, vec2 p) {
  inputValue = inputValue / p[1] + p[0];
`;
  return n === J.FLOAT32 ? t += `return inputValue;
` : t += `return ${J[n].toLowerCase()}FromFloat(round(inputValue));
`, t += `
}
`, [Ko[n], t];
}
function MC(n) {
  const e = wn(n);
  let t = ey[n];
  return [Ko[n], zc[n], FV, n === J.UINT32 ? Xv : zV, n === J.UINT32 ? UV : GV, `
${e} computeLerp(float inputValue, ${t} p) {
  inputValue = inputValue / p.multiplier;
  uint x = uint(clamp(round(abs(inputValue)), 0.0, 4294967295.0));
  uint xShifted = shiftLeftSaturate(x, p.shift);
  if (inputValue >= 0.0) {
    return ${e}(addSaturate(p.offset, xShifted));
  } else {
    return ${e}(subtractSaturate(p.offset, xShifted));
  }
}
`];
}
var JV = {
  [J.UINT8]: Wl(J.UINT8),
  [J.INT8]: Wl(J.INT8),
  [J.UINT16]: Wl(J.UINT16),
  [J.INT16]: Wl(J.INT16),
  [J.FLOAT32]: Wl(J.FLOAT32),
  [J.UINT32]: MC(J.UINT32),
  [J.INT32]: MC(J.INT32),
  [J.UINT64]: [Ht, Bh, ET, RV, MV, kT, NV, zc[J.UINT64], `
uint64_t computeLerp(float inputValue, Uint64LerpParameters p) {
  inputValue = inputValue / p.multiplier;
  uint64_t x = uint64_t(uvec2(uint(clamp(round(abs(inputValue)), 0.0, 4294967295.0)), 0u));
  uint64_t shifted = shiftLeft(x, p.shift);
  if (!equals(shiftRight(shifted, p.shift), x)) {
    return uint64_t(uvec2(0xffffffffu, 0xffffffffu));
  }
  if (inputValue >= 0.0) {
    return addSaturate(p.offset, shifted);
  } else {
    return subtractSaturate(p.offset, shifted);
  }
}
`]
};
function MT(n, e, t) {
  const i = `uLerpParams_${e}`, r = `uLerpBounds_${e}`, s = `uLerpScalar_${e}`;
  let a = "";
  switch (t) {
    case J.INT8:
    case J.UINT8:
    case J.INT16:
    case J.UINT16:
    case J.FLOAT32:
      n.addUniform("vec2", i);
      break;
    case J.INT32:
    case J.UINT32: {
      const l = ey[t];
      n.addUniform(`${t === J.INT32 ? "i" : "u"}vec2`, r), n.addUniform("float", s), a += `
#define ${i} ${l}(${r}[0], int(${r}[1]), ${s})
`;
      break;
    }
    case J.UINT64: {
      n.addUniform("uvec3", r), n.addUniform("float", s), a += `
#define ${i} Uint64LerpParameters(uint64_t(${r}.xy), int(${r}[2]), ${s})
`;
      break;
    }
  }
  return [zc[t], a];
}
function NT(n, e, t, i = false) {
  return [Ko[t], MT(n, e, t), jV[t], `
float ${e}(${wn(t)} inputValue) {
  float v = computeInvlerp(inputValue, uLerpParams_${e});
  ${i ? "v = clamp(v, 0.0, 1.0);" : ""}
  return v;
}
`];
}
function YV(n, e, t) {
  return [Ko[t], MT(n, e, t), JV[t], `
${wn(t)} ${e}(float inputValue) {
  return computeLerp(inputValue, uLerpParams_${e});
}
`];
}
var qs = new re();
function ty(n, e, t, i) {
  const r = n.gl;
  switch (t) {
    case J.INT8:
    case J.UINT8:
    case J.INT16:
    case J.UINT16:
    case J.FLOAT32:
      r.uniform2f(n.uniform(`uLerpParams_${e}`), i[0], 1 / (i[1] - i[0]));
      break;
    case J.INT32:
    case J.UINT32: {
      const s = i[0], a = i[1] - s, l = Math.max(0, Math.ceil(Zn(Math.abs(a))) - 24), d = Math.pow(2, l) / a, u = n.uniform(`uLerpBounds_${e}`);
      t === J.UINT32 ? r.uniform2ui(u, s, l) : r.uniform2i(u, s, l), r.uniform1f(n.uniform(`uLerpScalar_${e}`), d);
      break;
    }
    case J.UINT64: {
      const s = i[0], a = i[1];
      re.absDifference(qs, a, s);
      const l = qs.high > 0 ? 32 + Math.ceil(Zn(qs.high)) : Math.ceil(Zn(qs.low)), d = Math.max(0, l - 24);
      re.rshift(qs, qs, d);
      let u = 1 / qs.low;
      re.compare(s, a) > 0 && (u *= -1);
      const f = n.uniform(`uLerpBounds_${e}`);
      r.uniform3ui(f, s.low, s.high, d), r.uniform1f(n.uniform(`uLerpScalar_${e}`), u);
    }
  }
}
function qV(n) {
  const e = /\/\/.*?$|\/\*(?:.|\n)*?\*\/|'(?:\\.|[^\\'])*'|"(?:\\.|[^\\"])*"/mg;
  return n.replace(e, (t) => t.startsWith("/") ? t.replace(/[^\s]/g, " ") : t);
}
function KV(n) {
  const e = /^(?:-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?|"(?:\\.|[^\\"])*"|true|false|:|\s+|,|\[|\]|\{|\})/;
  let t = 0, i = n;
  e:
    for (; n.length; ) {
      const r = n.match(e);
      if (r === null)
        break;
      const s = r[0];
      switch (s.charAt(0)) {
        case "[":
        case "{":
          ++t;
          break;
        case "]":
        case "}":
          if (--t < 0)
            return -1;
          break;
        case ",":
          if (t === 0)
            break e;
          break;
        default:
          if (t === 0) {
            n = n.substring(s.length);
            break e;
          }
          break;
      }
      n = n.substring(s.length);
    }
  return t !== 0 ? -1 : i.length - n.length;
}
function ZV(n) {
  let e = [], t = new de();
  if (n === void 0)
    return { errors: e, parameters: t };
  const i = /^([_a-z][_a-zA-Z0-9]*)[ \t]*=/;
  for (; n = n.trim(), n.length != 0; ) {
    const r = n.match(i);
    if (r === null) {
      e.push("Invalid #uicontrol parameter syntax, expected: <param>=<value>, ...");
      break;
    }
    const s = r[1];
    n = n.substring(r[0].length);
    let a = KV(n);
    if (a <= 0) {
      e.push("Invalid #uicontrol parameter syntax, expected: <param>=<value>, ...");
      break;
    }
    let l;
    try {
      l = JSON.parse(n.substring(0, a));
    } catch {
      e.push(`Invalid #uicontrol parameter value for ${s}: ${l}`);
      break;
    }
    t.has(s) ? e.push(`Duplicate #uicontrol parameter: ${s}`) : t.set(s, l), n = n.substring(a), n = n.trim(), n.length > 0 && !n.startsWith(",") && e.push("Invalid #uicontrol parameter syntax, expected: <param>=<value>, ..."), n = n.substring(1);
  }
  return { parameters: t, errors: e };
}
function XV(n, e) {
  let t, i, r, s, a = [];
  n !== "float" && n !== "uint" && n !== "int" && a.push("type must be float, int, or uint");
  for (const d of e) {
    var l = ce(d, 2);
    const u = l[0], f = l[1], g = () => {
      if (typeof f != "number") {
        a.push(`Expected ${u} argument to be a number`);
        return;
      }
      return (n === "int" || n === "uint") && (jn(f) || a.push(`Expected ${u} argument to be an integer`), n === "uint" && f < 0 && a.push(`Expected ${u} argument to be an unsigned integer`)), f;
    };
    u === "min" ? t = g() : u === "max" ? i = g() : u === "default" ? s = g() : u === "step" ? r = g() : a.push(`Invalid parameter: ${u}`);
  }
  return t === void 0 && a.push("min must be specified"), i === void 0 && a.push("max must be specified"), t !== void 0 && i !== void 0 && (t > i && a.push("min must be less than max"), r === void 0 && (n === "float" ? r = (i - t) / 100 : r = 1), s !== void 0 ? (s < t || s > i) && a.push("default must be within valid range") : n === "float" ? s = (t + i) / 2 : s = t), a.length > 0 ? { errors: a } : {
    control: { type: "slider", valueType: n, min: t, max: i, step: r, default: s },
    errors: void 0
  };
}
function QV(n, e) {
  let t = false, i = [];
  n !== "bool" && i.push("type must be bool");
  for (const s of e) {
    var r = ce(s, 2);
    const a = r[0], l = r[1];
    if (a === "default") {
      if (typeof l != "boolean") {
        i.push(`Expected ${a} argument to be a boolean`);
        continue;
      }
      t = l;
    } else
      i.push(`Invalid parameter: ${a}`);
  }
  return i.length > 0 ? { errors: i } : {
    control: { type: "checkbox", valueType: n, default: t },
    errors: void 0
  };
}
function eB(n, e) {
  let t = "white", i = [];
  n !== "vec3" && i.push("type must be vec3");
  for (const s of e) {
    var r = ce(s, 2);
    const a = r[0], l = r[1];
    a === "default" ? typeof l != "string" ? i.push("Expected default argument to be a string") : t = l : i.push(`Invalid parameter: ${a}`);
  }
  return i.length > 0 ? { errors: i } : {
    control: {
      type: "color",
      valueType: n,
      defaultString: t,
      default: va(t)
    },
    errors: void 0
  };
}
function _T(n, e) {
  typeof n == "number" && (n = [n]);
  const t = new Array(e);
  return at(t, n, (i) => {
    if (!jn(i) || i < 0)
      throw new Error(`Expected non-negative integer, but received: ${se(i)}`);
    return i;
  }), t;
}
function tB(n, e, t) {
  let i = [];
  const r = t.imageData;
  if (r === void 0)
    return i.push("invlerp control not supported"), { errors: i };
  n !== "invlerp" && i.push("type must be invlerp");
  let s = new Array(r.channelRank).fill(0);
  const a = r.dataType;
  let l = true, d = Oc[a], u;
  for (let g of e) {
    var f = ce(g, 2);
    let v = f[0], y = f[1];
    try {
      switch (v) {
        case "range": {
          d = Lu(y, a);
          break;
        }
        case "window": {
          u = S1(Lu(y, a));
          break;
        }
        case "clamp": {
          typeof y != "boolean" ? i.push(`Invalid clamp value: ${se(y)}`) : l = y;
          break;
        }
        case "channel": {
          s = _T(y, s.length);
          break;
        }
        default:
          i.push(`Invalid parameter: ${v}`);
          break;
      }
    } catch (w) {
      i.push(`Invalid ${v} value: ${w.message}`);
    }
  }
  return i.length > 0 ? { errors: i } : {
    control: {
      type: "invlerp",
      dataType: a,
      clamp: l,
      default: { range: d, window: u ?? e2(d), channel: s }
    },
    errors: void 0
  };
}
var nB = new de([["slider", XV], ["color", eB], ["invlerp", tB], ["checkbox", QV]]);
function Fh(n, e = {}) {
  n = qV(n);
  const t = /^[ \t]*#[ \t]*uicontrol[ \t]+(.*)$/mg, i = /^([_a-zA-Z][_a-zA-Z0-9]*)[ \t]+([a-z][a-zA-Z0-9_]*)(?:[ \t]+([a-z]+))?[ \t]*(?:\([ \t]*(.*)\)[ \t]*)?/;
  let r = [];
  const s = new de(), a = n.replace(t, (l, d, u) => {
    var f;
    const g = d.match(i), v = () => Math.max(0, n.substring(0, u).split(`
`).length - 1);
    if (g === null)
      return r.push({
        line: v(),
        message: "Invalid #uicontrol syntax, expected: #uicontrol <type> <name> <control>(<param>=<value>, ...)"
      }), "";
    const y = g[1], w = g[2], C = (f = g[3]) !== null && f !== void 0 ? f : y, b = g[4];
    var E = ZV(b);
    const L = E.parameters, R = E.errors;
    for (const I of R)
      r.push({ line: v(), message: I });
    if (s.has(w) && r.push({ line: v(), message: `Duplicate definition for control ${w}` }), R.length > 0)
      return "";
    const _ = nB.get(C);
    if (_ === void 0)
      return r.push({ line: v(), message: `Invalid control type ${C}` }), "";
    const A = _(y, L, e);
    if (A.errors !== void 0) {
      for (const I of A.errors)
        r.push({ line: v(), message: I });
      return "";
    }
    return s.set(w, A.control), "";
  });
  return { source: n, code: a, errors: r, controls: s };
}
function OT(n) {
  return `u_shaderControl_${n}`;
}
function wc(n, e) {
  const t = n.builderValues;
  for (const r of n.parseResult.controls) {
    var i = ce(r, 2);
    const s = i[0], a = i[1], l = OT(s), d = t[s];
    switch (a.type) {
      case "invlerp": {
        const u = [NT(e, l, a.dataType, a.clamp), `
float ${l}() {
  return ${l}(getDataValue(${d.channel.join(",")}));
}
`];
        e.addFragmentCode(u), e.addFragmentCode(`#define ${s} ${l}
`);
        break;
      }
      case "checkbox": {
        const u = `#define ${s} ${d.value}
`;
        e.addFragmentCode(u), e.addVertexCode(u);
        break;
      }
      default: {
        e.addUniform(`highp ${a.valueType}`, l), e.addVertexCode(`#define ${s} ${l}
`), e.addFragmentCode(`#define ${s} ${l}
`);
        break;
      }
    }
  }
}
function iB(n) {
  const e = {};
  for (const i of n) {
    var t = ce(i, 2);
    const r = t[0], s = t[1];
    e[r] = s;
  }
  return e;
}
function NC(n) {
  if (n !== void 0)
    return se(iB(n));
}
var rB = class {
  constructor() {
    this.changed = new Ee(), this.controls = void 0;
  }
  get value() {
    return this.controls;
  }
  set value(e) {
    NC(e) !== NC(this.controls) && (this.controls = e, this.changed.dispatch());
  }
};
function sB(n, e, t) {
  return n === void 0 ? t : (pe(n), {
    range: Ce(n, "range", (i) => Lu(i, e), t.range),
    window: Ce(n, "window", (i) => S1(Lu(i, e)), t.window),
    channel: Ce(n, "channel", (i) => _T(i, t.channel.length), t.channel)
  });
}
var aB = class extends hn {
  constructor(e, t) {
    super(t, (i) => sB(i, e, t)), this.dataType = e, this.defaultValue = t;
  }
  toJSON() {
    var e = this.value;
    const t = e.range, i = e.window, r = e.channel, s = this.dataType, a = this.defaultValue, l = Xb(t, s, a.range), d = Xb(i, s, a.window), u = Fe(a.channel, r) ? void 0 : r;
    if (!(l === void 0 && d === void 0 && u === void 0))
      return { range: l, window: d, channel: u };
  }
};
function VT(n) {
  switch (n.type) {
    case "slider":
      return {
        trackable: new hn(n.default, (e) => {
          let t;
          if (n.valueType === "float" ? t = Lt(e) : t = pn(e), t < n.min || t > n.max)
            throw new Error(`${se(e)} is outside valid range [${n.min}, ${n.max}]`);
          return t;
        }),
        getBuilderValue: () => null
      };
    case "color":
      return { trackable: new uc(n.default), getBuilderValue: () => null };
    case "invlerp":
      return {
        trackable: new aB(n.dataType, n.default),
        getBuilderValue: (e) => ({ channel: e.channel, dataType: n.dataType })
      };
    case "checkbox":
      return {
        trackable: new en(n.default),
        getBuilderValue: (e) => ({ value: e })
      };
  }
}
function BT(n, e) {
  return se(n) + "\0" + e.source;
}
function ny(n) {
  const e = {};
  for (const r of n.controls) {
    var t = ce(r, 2);
    const s = t[0], a = t[1];
    var i = VT(a);
    const l = i.trackable, d = i.getBuilderValue;
    e[s] = d(l.value);
  }
  return { builderValues: e, parseResult: n, key: BT(e, n) };
}
var iy = class extends Z {
  constructor(e, t = oa({}), i) {
    super(), this.fragmentMain = e, this.dataContext = t, this.channelCoordinateSpaceCombiner = i, this.changed = new Ee(), this.controls = new rB(), this.fragmentMainGeneration = -1, this.dataContextGeneration = -1, this.parseErrors_ = [], this.processedFragmentMain_ = "", this.controlsGeneration = -1, this.parseResultChanged = new Ee(), this.state_ = new de(), this.unparsedJson = void 0, this.registerDisposer(e.changed.add(() => this.handleFragmentMainChanged())), this.registerDisposer(this.controls.changed.add(() => this.handleControlsChanged())), this.registerDisposer(this.dataContext.changed.add(() => this.handleFragmentMainChanged())), this.handleFragmentMainChanged();
    const r = this;
    this.parseErrors = {
      changed: this.parseResultChanged,
      get value() {
        return r.handleFragmentMainChanged(), r.parseErrors_;
      }
    }, this.processedFragmentMain = {
      changed: this.parseResultChanged,
      get value() {
        return r.handleFragmentMainChanged(), r.processedFragmentMain_;
      }
    }, this.parseResult = {
      changed: this.parseResultChanged,
      get value() {
        return r.parseResult_;
      }
    }, this.builderState = wi((l, d) => {
      const u = {};
      for (const v of d) {
        var f = ce(v, 2);
        const y = f[0];
        var g = f[1];
        const w = g.trackable, C = g.getBuilderValue, b = C(w.value);
        u[y] = b;
      }
      return {
        key: BT(u, l),
        parseResult: l,
        builderValues: u
      };
    }, [this.parseResult, this], (l, d) => l.key === d.key);
    const s = wi((l) => {
      const d = [];
      for (const u of l.values()) {
        const f = u.control, g = u.trackable;
        f.type === "invlerp" && d.push({ channel: g.value.channel });
      }
      return d;
    }, [this], (l, d) => kg(l, d, (u, f) => Fe(u.channel, f.channel))), a = rr((l) => {
      const d = [];
      for (const u of l.values()) {
        const f = u.control, g = u.trackable;
        f.type === "invlerp" && d.push(g.value.window);
      }
      return d;
    }, this);
    this.histogramSpecifications = this.registerDisposer(new RT(s, a));
  }
  handleFragmentMainChanged() {
    const e = this.fragmentMain.changed.count, t = this.dataContext.changed.count;
    if (e === this.fragmentMainGeneration && t === this.dataContextGeneration)
      return;
    this.fragmentMainGeneration = e, this.dataContextGeneration = t;
    const i = this.dataContext.value;
    if (i === null)
      this.parseResult_ = {
        source: "",
        code: "",
        controls: new de(),
        errors: [{ line: 0, message: "Loading" }]
      }, this.parseErrors_ = [], this.processedFragmentMain_ = "", this.controls.value = void 0;
    else {
      const r = this.parseResult_ = Fh(this.fragmentMain.value, i);
      this.parseErrors_ = r.errors, this.processedFragmentMain_ = r.code, r.errors.length === 0 && (this.controls.value = r.controls);
    }
    this.parseResultChanged.dispatch();
  }
  handleControlsChanged() {
    const e = this.controls.changed.count;
    if (e === this.controlsGeneration)
      return;
    this.controlsGeneration = e;
    const t = this.controls.value;
    if (t === void 0)
      return;
    let i = false;
    const r = this.state_, s = this.unparsedJson;
    for (const u of r) {
      var a = ce(u, 2);
      const f = a[0], g = a[1];
      if (t.get(f) === void 0) {
        g.trackable.changed.remove(this.changed.dispatch), r.delete(f), i = true;
        continue;
      }
    }
    for (const u of t) {
      var l = ce(u, 2);
      const f = l[0], g = l[1];
      let v = r.get(f);
      if (v !== void 0 && se(v.control) !== se(g) && (v.trackable.changed.remove(this.changed.dispatch), v = void 0), v === void 0) {
        var d = VT(g);
        const y = d.trackable, w = d.getBuilderValue;
        v = { control: g, trackable: y, getBuilderValue: w }, v.trackable.changed.add(this.changed.dispatch), r.set(f, v), i = true;
      }
      if (s !== void 0 && s.hasOwnProperty(f)) {
        i = true;
        try {
          v.trackable.restoreState(s[f]);
        } catch {
        }
      }
    }
    s !== void 0 && (i = true), this.unparsedJson = void 0, i && this.changed.dispatch();
  }
  get state() {
    return this.controls.changed.count !== this.controlsGeneration && this.handleControlsChanged(), this.state_;
  }
  get value() {
    return this.state;
  }
  restoreState(e) {
    if (e === void 0)
      return;
    const t = this.state;
    if (pe(e), this.controls.value === void 0) {
      this.unparsedJson = e, this.changed.dispatch();
      return;
    }
    for (const s of t) {
      var r = ce(s, 2);
      const a = r[0], d = r[1].trackable;
      if (d.reset(), e.hasOwnProperty(a))
        try {
          d.restoreState(e[a]);
        } catch {
        }
    }
    this.unparsedJson = void 0;
  }
  reset() {
    for (const e of this.state.values())
      e.trackable.reset();
    this.unparsedJson !== void 0 && (this.unparsedJson = void 0, this.changed.dispatch());
  }
  toJSON() {
    const e = this.state, t = this.unparsedJson;
    if (t !== void 0)
      return t;
    const i = {};
    let r = true;
    for (const a of e) {
      var s = ce(a, 2);
      const l = s[0], u = s[1].trackable.toJSON();
      u !== void 0 && (i[l] = u, r = false);
    }
    if (!r)
      return i;
  }
};
function _C(n, e, t, i, r) {
  const s = OT(t), a = e.uniform(s);
  switch (i.type) {
    case "slider":
      switch (i.valueType) {
        case "int":
        case "uint":
          n.uniform1i(a, r);
          break;
        case "float":
          n.uniform1f(a, r);
      }
      break;
    case "color":
      n.uniform3fv(a, r);
      break;
    case "invlerp":
      ty(e, s, i.dataType, r.range);
      break;
  }
}
function Ao(n, e, t, i) {
  const r = t.state;
  if (t.controls.value === i)
    for (const l of r) {
      var s = ce(l, 2);
      const d = s[0], u = s[1];
      _C(n, e, d, u.control, u.trackable.value);
    }
  else
    for (const l of i) {
      var a = ce(l, 2);
      const d = a[0], u = a[1], f = r.get(d), g = f !== void 0 && se(f.control) === se(u) ? f.trackable.value : u.default;
      _C(n, e, d, u, g);
    }
}
var oB = class extends gt {
};
var lB = class extends Jv {
  constructor() {
    super((e, { showMatches: t, segmentationState: i }) => {
      e.registerDisposer(t.changed.add(this.changed.dispatch)), e.registerDisposer(i.changed.add(this.changed.dispatch)), e.registerDisposer(Ur((r, s) => {
        if (s == null)
          return;
        const a = s.segmentationGroupState;
        r.registerDisposer(a.changed.add(this.changed.dispatch)), r.registerDisposer(Ur((l, d) => {
          const u = d.visibleSegments;
          let f = u.size === 0;
          l.registerDisposer(u.changed.add(() => {
            const g = u.size === 0;
            g !== f && (f = g, this.changed.dispatch());
          }));
        }, a));
      }, i));
    });
  }
  get(e) {
    let t = super.get(e);
    return t === void 0 && (t = {
      segmentationState: new gt(void 0),
      showMatches: new en(false)
    }, super.set(e, t)), t;
  }
};
var OC = `
void main() {
  setColor(defaultColor());
}
`;
var cB = class extends Z {
  constructor() {
    super(...arguments), this.shader = Yv(OC), this.shaderControls = new iy(this.shader), this.fallbackShaderControls = new gt(ny(Fh(OC))), this.shaderError = Vh(), this.color = new uc(St(1, 1, 0)), this.relationshipStates = this.registerDisposer(new lB()), this.ignoreNullSegmentFilter = new en(true), this.displayUnfiltered = rr((e, t) => {
      for (const i of e.values())
        if (i.showMatches.value) {
          if (!t)
            return false;
          const r = i.segmentationState.value;
          if (r != null && r.segmentationGroupState.value.visibleSegments.size > 0)
            return false;
        }
      return true;
    }, this.relationshipStates, this.ignoreNullSegmentFilter), this.hoverState = new oB(void 0);
  }
};
var em = class extends Z {
  constructor(e) {
    super();
    const t = e.transform, i = e.localPosition, r = e.source;
    var s = e.role;
    const a = s === void 0 ? Ti.ANNOTATION : s;
    this.transform = t, this.localPosition = i, this.source = this.registerDisposer(r), this.role = a, this.displayState = e.displayState, this.chunkTransform = this.registerDisposer(rr((l) => CT(() => $1(dV(l))), this.transform)), this.dataSource = e.dataSource, this.subsourceId = e.subsourceId, this.subsourceIndex = e.subsourceIndex;
  }
  get sourceIndex() {
    const e = this.dataSource;
    return e.layer.dataSources.indexOf(e);
  }
};
var Uh = class _Uh {
  constructor(e, t, i) {
    this.size = Ig(e), this.transform = e_(t), this.finiteRank = i;
    const r = et(), s = _v(r, 4, t, 4, 4);
    if (s === 0)
      throw new Error("Transform is singular");
    this.invTransform = r, this.detTransform = s;
  }
  toObject() {
    return { size: this.size, transform: this.transform, finiteRank: this.finiteRank };
  }
  static fromObject(e) {
    return new _Uh(e.size, e.transform, e.finiteRank);
  }
  /**
   * Transform global spatial coordinates to local spatial coordinates.
   */
  globalToLocalSpatial(e, t) {
    return Si(e, t, this.invTransform);
  }
  localSpatialVectorToGlobal(e, t) {
    return y_(e, t, this.transform);
  }
  /**
   * Returns the unnormalized normal vector.
   */
  globalToLocalNormal(e, t) {
    return KE(e, t, this.transform);
  }
};
var dB = et();
function uB(n, e) {
  let t = 0, i = Math.abs(n.detTransform);
  const r = n.transform, s = n.size;
  for (let a = 0; a < 3; ++a) {
    let l = 0;
    for (let u = 0; u < 3; ++u)
      l += e[u * 4 + 2] * r[4 * a + u];
    const d = s[a];
    t += Math.abs(l) * d, i *= d;
  }
  return i / t;
}
function FT(n, e, t) {
  const i = n.curPositionInChunks, r = n.fixedPositionWithinChunk, s = n.nonDisplayLowerClipBound, a = n.nonDisplayUpperClipBound;
  var l = n.source.spec;
  const d = l.rank, u = l.chunkDataSize;
  if (!gc(i, e, t, n.layerRank, n.fixedLayerToChunkTransform))
    return false;
  for (let f = 0; f < d; ++f) {
    const g = i[f];
    if (g < s[f] || g >= a[f])
      return false;
    const v = u[f], y = i[f] = Math.floor(g / v);
    r[f] = g - y * v;
  }
  return true;
}
function hB(n, e) {
  let t = e.length, i = 0;
  if (t > 1) {
    let r = 0;
    for (let s = 0; s < t; ++s) {
      const l = e[s].chunkLayout;
      let d = uB(l, n);
      d > r && (r = d, i = s);
    }
  }
  return i;
}
var to = new Uh(_e(), et(), 0);
var fB = class extends eT {
  constructor() {
    super(...arguments), this.viewportNormalInGlobalCoordinates = _e(), this.viewportNormalInCanonicalCoordinates = _e(), this.centerDataPosition = _e(), this.pixelSize = 0;
  }
};
function pB(n, e) {
  if (n.displayDimensionRenderInfo !== e.displayDimensionRenderInfo || n.pixelSize !== e.pixelSize)
    return true;
  const t = n.viewMatrix, i = e.viewMatrix;
  for (let r = 0; r < 12; ++r)
    if (t[r] !== i[r])
      return true;
  return false;
}
var gB = class extends hr {
  constructor(e) {
    super(), this.projectionParameters = e, this.visibleLayers = new de(), this.visibleSourcesStale = true, this.registerDisposer(e.changed.add((t, i) => {
      pB(t, i) && this.invalidateVisibleSources(), this.invalidateVisibleChunks();
    }));
  }
  invalidateVisibleSources() {
    this.visibleSourcesStale = true;
  }
  invalidateVisibleChunks() {
  }
  /**
   * Computes the list of sources to use for each visible layer, based on the
   * current pixelSize.
   */
  updateVisibleSources() {
    if (!this.visibleSourcesStale)
      return;
    this.visibleSourcesStale = false;
    const e = this.projectionParameters.value.displayDimensionRenderInfo, t = this.visibleLayers;
    for (const s of t) {
      var i = ce(s, 2);
      const a = i[0];
      var r = i[1];
      const l = r.allSources, d = r.visibleSources, u = r.displayDimensionRenderInfo;
      if (d.length = 0, u !== e || l.length === 0)
        continue;
      const f = hB(this.projectionParameters.value.viewMatrix, l.map((v) => v[0])), g = l[f];
      for (const v of a.filterVisibleSources(this, g))
        d.push(v);
      d.reverse();
    }
  }
};
var mB = 18;
function Bu(n) {
  let e = n.rank, t = n.upperVoxelBound;
  var i = n.maxVoxelsPerChunkLog2;
  let r = i === void 0 ? mB : i, s = n.chunkToViewTransform, a = n.displayRank, l = n.minBlockSize, d = n.maxBlockSize;
  var u = n.lowerVoxelBound;
  const f = u === void 0 ? new Uint32Array(e) : u, g = new Float32Array(e);
  for (let C = 0; C < e; ++C) {
    let b = 0;
    for (let E = 0; E < a; ++E) {
      const L = s[C * a + E];
      b += L * L;
    }
    g[C] = Math.sqrt(b);
  }
  const v = new Uint32Array(e);
  l !== void 0 ? v.set(l) : v.fill(1);
  const y = new Array(e);
  for (let C = 0; C < e; ++C) {
    let b = Number.POSITIVE_INFINITY;
    g[C] === 0 ? b = v[C] : (t !== void 0 && (b = Math.pow(2, Math.floor(Zn(t[C] - f[C])))), d !== void 0 && (b = Math.min(b, d[C]))), y[C] = b;
  }
  function w() {
    let C = 1 / 0, b = -1;
    for (let E = 0; E < e; ++E) {
      if (v[E] >= y[E])
        continue;
      let L = v[E] * g[E];
      L < C && (C = L, b = E);
    }
    return b;
  }
  r -= Zn(Vv2(v));
  for (let C = 0; C < r; ++C) {
    let b = w();
    if (b === -1)
      break;
    v[b] *= 2;
  }
  return v;
}
function vB(n) {
  const e = [], t = n.displayRank, i = n.chunkToViewTransform, r = n.rank;
  if (t > 3)
    throw new Error("Unsupported view transform");
  if (t < 3)
    return [Bu(n)];
  for (let s = 0; s < 3; ++s) {
    const a = (s + 2) % 3, l = new Float32Array(i);
    for (let d = 0; d < r; ++d)
      l[d * t + a] = 0;
    e[s] = Bu(RZr(RZr({}, n), { chunkToViewTransform: l }));
  }
  return e;
}
var vo;
(function(n) {
  n[n.ISOTROPIC = 0] = "ISOTROPIC", n[n.FLAT = 1] = "FLAT";
})(vo || (vo = {}));
function yB(n) {
  if (n.chunkDataSizes !== void 0)
    return n.chunkDataSizes;
  var e = n.chunkLayoutPreference;
  switch (e === void 0 ? vo.ISOTROPIC : e) {
    case vo.ISOTROPIC:
      return [Bu(n)];
    case vo.FLAT:
      return vB(n);
  }
}
function Gc(n) {
  const e = n.rank, t = n.chunkDataSize, i = n.upperVoxelBound;
  var r = n.lowerVoxelBound;
  const s = r === void 0 ? new Float32Array(e) : r, a = new Float32Array(e), l = new Float32Array(e);
  for (let d = 0; d < e; ++d)
    a[d] = Math.floor(s[d] / t[d]), l[d] = Math.floor((i[d] - 1) / t[d] + 1);
  return {
    rank: e,
    chunkDataSize: t,
    lowerChunkBound: a,
    upperChunkBound: l,
    lowerVoxelBound: s,
    upperVoxelBound: i
  };
}
function* SB(n, e, t) {
  const i = n.projectionParameters.value.pixelSize * 1.1, r = t[0].effectiveVoxelSize, s = e.renderScaleTarget.value, a = (f) => {
    const g = i * s;
    for (let v = 0; v < 3; ++v) {
      const y = f[v];
      if (y > g && y > 1.01 * r[v])
        return true;
    }
    return false;
  }, l = (f, g) => {
    const v = i * s;
    for (let y = 0; y < 3; ++y) {
      const w = f[y], C = g[y];
      if (Math.abs(v - w) < Math.abs(v - C) && w < 1.01 * C)
        return true;
    }
    return false;
  };
  let d = t.length - 1, u;
  for (; ; ) {
    const f = t[d];
    if (u !== void 0 && !l(f.effectiveVoxelSize, u) || (yield f, d === 0 || !a(f.effectiveVoxelSize)))
      break;
    u = f.effectiveVoxelSize, --d;
  }
}
var bB = "SliceView";
var CB = "sliceview/RenderLayer";
var wB = "SliceView.addVisibleLayer";
var xB = "SliceView.removeVisibleLayer";
var ry = new Float32Array(3);
var sy = new Float32Array(3);
var UT = et();
var zT = new Float32Array(24);
function GT(n, e, t, i) {
  const r = ry, s = sy, a = e.lowerChunkDisplayBound, l = e.upperChunkDisplayBound;
  for (let g = 0; g < 3; ++g)
    r[g] = Math.max(r[g], a[g]), s[g] = Math.min(s[g], l[g]);
  const d = e.curPositionInChunks, u = e.chunkDisplayDimensionIndices;
  function f() {
    if (!i(r[0], r[1], r[2], s[0], s[1], s[2], n))
      return;
    let g = 0, v = Math.max(0, s[0] - r[0]), y = v;
    for (let E = 1; E < 3; ++E) {
      const L = Math.max(0, s[E] - r[E]);
      y *= L, L > v && (v = L, g = E);
    }
    if (y === 0)
      return;
    if (y === 1) {
      d[u[0]] = r[0], d[u[1]] = r[1], d[u[2]] = r[2], t(r, n);
      return;
    }
    const w = r[g], C = s[g], b = Math.floor(0.5 * (w + C));
    s[g] = b, f(), s[g] = C, r[g] = b, f(), r[g] = w;
  }
  f();
}
function $T(n, e, t, i) {
  if (!FT(t, n.globalPosition, e))
    return;
  const r = t.chunkLayout.size, s = mn(UT, n.viewProjectionMat, t.chunkLayout.transform);
  for (let u = 0; u < 3; ++u) {
    const f = r[u];
    for (let g = 0; g < 4; ++g)
      s[4 * u + g] *= f;
  }
  const a = zT;
  Eu(a, s);
  const l = ry, d = sy;
  l.fill(Number.NEGATIVE_INFINITY), d.fill(Number.POSITIVE_INFINITY), GT(a, t, i, XE);
}
function EB(n, e, t, i, r) {
  if (!FT(t, n.globalPosition, e))
    return;
  const s = i.size, a = mn(UT, n.viewProjectionMat, i.transform);
  for (let v = 0; v < 3; ++v) {
    const y = s[v];
    for (let w = 0; w < 4; ++w)
      a[4 * v + w] *= y;
  }
  const l = dB;
  xs(l, a);
  const d = ry, u = sy, f = 1e-3;
  for (let v = 0; v < 3; ++v) {
    const y = l[12 + v] + f / s[v], w = Math.abs(l[v]), C = Math.abs(l[4 + v]);
    d[v] = Math.floor(y - w - C), u[v] = Math.floor(y + w + C + 1);
  }
  const g = zT;
  for (let v = 0; v < 3; ++v) {
    const y = a[4 * v], w = a[4 * v + 1], C = a[4 * v + 2];
    g[v] = y, g[4 + v] = -y, g[8 + v] = +w, g[12 + v] = -w, g[16 + v] = +C, g[20 + v] = -C;
  }
  {
    const y = a[12], w = a[4 * 3 + 1], C = a[4 * 3 + 2];
    g[3] = 1 + y, g[4 + 3] = 1 - y, g[8 + 3] = 1 + w, g[12 + 3] = 1 - w, g[16 + 3] = C, g[20 + 3] = -C;
  }
  GT(g, t, r, b_);
}
function ay(n, e) {
  const t = e.finiteRank;
  if (t === 3)
    return e;
  to.finiteRank = t, o_(to.size, e.size);
  const i = Cu(to.transform, e.transform), r = Cu(to.invTransform, e.invTransform);
  to.detTransform = e.detTransform;
  const s = n.invViewMatrix, a = n.width, l = n.height, d = e1(n.projectionMat);
  for (let u = t; u < 3; ++u) {
    const f = s[12 + u];
    let g = f, v = f;
    const y = Math.abs(s[u] * a);
    g -= y, v += y;
    const w = Math.abs(s[u + 4] * l);
    g -= w, v += w;
    const C = Math.abs(s[u + 8] * d);
    g -= C, v += C;
    const b = Math.max(1, v - g);
    i[12 + u] = g, i[5 * u] = b;
  }
  return xs(r, i), to;
}
var TB = "annotation.MetadataChunkSource";
var kB = "annotation.GeometryChunkSource";
var IB = "annotation.SubsetGeometryChunkSource";
var LB = "annotation.reference.add";
var DB = "annotation.reference.delete";
var PB = "annotation.commit";
var AB = "annotation.commit";
var RB = "annotation/SpatiallyIndexedRenderLayer";
var MB = "annotation/PerspectiveRenderLayer:updateSources";
var NB = "annotation/RenderLayer";
var _B = "annotation/RenderLayer.updateSegmentation";
var OB = Mc();
function VB(n, e, t, i, r, s) {
  const a = n.displayDimensionRenderInfo, l = n.viewMatrix, d = n.projectionMat, u = n.width, f = n.height, g = a.voxelPhysicalScales, v = Math.abs(wv(kh(OB, l))), y = Mg(g), w = C_(d) / v * y;
  if (i.length === 0)
    return;
  const C = i[0];
  let b = Math.abs(C.chunkLayout.detTransform) * y;
  const E = C.lowerClipDisplayBound, L = C.upperClipDisplayBound;
  for (let N = 0; N < 3; ++N)
    b *= L[N] - E[N];
  const R = Math.min(b, w), _ = u * f, I = _ / t ** 2 / R;
  let P = 0;
  for (let N = i.length - 1; N >= 0 && P < I; --N) {
    const O = i[N], B = O.source.spec, j = O.chunkLayout, U = Mg(j.size) * Math.abs(j.detTransform) * y, V = B.limit, G = B.rank, F = O.nonDisplayLowerClipBound, ue = O.nonDisplayUpperClipBound;
    let ae = 1;
    for (let Xe = 0; Xe < G; ++Xe) {
      const Be = ue[Xe] - F[Xe];
      kt(Be) && (ae /= Be);
    }
    const Ie = V * ae / U;
    let le = true;
    const Te = P + Ie, Ue = Math.pow(1 / Te, 1 / 3), Ye = Math.sqrt(_ / (Te * R)), Ze = (I - P) * U / ae, rt = Math.min(1, Ze / B.limit);
    $T(n, e, O, () => {
      le && (r(O, N), le = false), s(O, N, rt, Ue, Ye);
    }), P = Te;
  }
}
var xc = `vec3 colormapJet(float x) {
  vec3 result;
  result.r = x < 0.89 ? ((x - 0.35) / 0.31) : (1.0 - (x - 0.89) / 0.11 * 0.5);
  result.g = x < 0.64 ? ((x - 0.125) * 4.0) : (1.0 - (x - 0.64) / 0.27);
  result.b = x < 0.34 ? (0.5 + x * 0.5 / 0.11) : (1.0 - (x - 0.34) / 0.31);
  return clamp(result, 0.0, 1.0);
}
vec3 colormapCubehelix(float x) {
  float xclamp = clamp(x, 0.0, 1.0);
  float angle = 2.0 * 3.1415926 * (4.0 / 3.0 + xclamp);
  float amp = xclamp * (1.0 - xclamp) / 2.0;
  vec3 result;
  float cosangle = cos(angle);
  float sinangle = sin(angle);
  result.r = -0.14861 * cosangle + 1.78277 * sinangle;
  result.g = -0.29227 * cosangle + -0.90649 * sinangle;
  result.b = 1.97294 * cosangle;
  result = clamp(xclamp + amp * result, 0.0, 1.0);
  return result;
}
`;
function WT(n, e) {
  return {
    defineShader(t, i) {
      const r = `prop_${i}`, s = `a_${r}`;
      t.addAttribute(`${n}`, s), t.addVertexCode(`${n} ${r}() { return ${s}; }`), t.addInitializer((a) => {
        const l = a.attribute(s), d = a.gl;
        a.vertexShaderInputBinders[r] = l === -1 ? {
          enable() {
          },
          disable() {
          },
          bind() {
          }
        } : {
          enable(u) {
            d.enableVertexAttribArray(l), d.vertexAttribDivisor(l, u);
          },
          disable() {
            d.vertexAttribDivisor(l, 0), d.disableVertexAttribArray(l);
          },
          bind(u, f) {
            e(d, l, u, f);
          }
        };
      });
    }
  };
}
function Bp(n, e, t, i) {
  return WT(n, (r, s, a, l) => {
    r.vertexAttribPointer(
      s,
      /*size=*/
      e,
      /*type=*/
      t,
      /*normalized=*/
      i,
      a,
      l
    );
  });
}
function no(n, e, t) {
  return WT(n, (i, r, s, a) => {
    i.vertexAttribIPointer(
      r,
      /*size=*/
      e,
      /*type=*/
      t,
      s,
      a
    );
  });
}
var BB = {
  rgb: Bp(
    "highp vec3",
    3,
    WebGL2RenderingContext.UNSIGNED_BYTE,
    /*normalized=*/
    true
  ),
  rgba: Bp(
    "highp vec4",
    4,
    WebGL2RenderingContext.UNSIGNED_BYTE,
    /*normalized=*/
    true
  ),
  float32: Bp(
    "highp float",
    1,
    WebGL2RenderingContext.FLOAT,
    /*normalized=*/
    false
  ),
  uint32: no("highp uint", 1, WebGL2RenderingContext.UNSIGNED_INT),
  int32: no("highp int", 1, WebGL2RenderingContext.INT),
  uint16: no("highp uint", 1, WebGL2RenderingContext.UNSIGNED_SHORT),
  int16: no("highp int", 1, WebGL2RenderingContext.SHORT),
  uint8: no("highp uint", 1, WebGL2RenderingContext.UNSIGNED_BYTE),
  int8: no("highp int", 1, WebGL2RenderingContext.BYTE)
};
var $c = class extends Z {
  constructor(e, t, i, r, s, a, l) {
    super(), this.gl = e, this.annotationType = t, this.rank = i, this.properties = r, this.shaderControlState = s, this.fallbackShaderParameters = a, this.shaderError = l;
    const d = this.serializedGeometryBytesPerAnnotation = Gn[t].serializedBytes(i);
    var u = b1(i, d, r);
    const f = u.offsets, g = u.serializedBytes, v = u.propertyGroupBytes;
    this.serializedBytesPerAnnotation = g, this.propertyOffsets = f, this.propertyGroupBytes = v, this.geometryDataStride = v[0];
  }
  getDependentShader(e, t) {
    return Io(this, this.gl, {
      memoizeKey: {
        t: "annotation",
        targetIsSliceView: this.targetIsSliceView,
        type: this.annotationType,
        subType: e,
        properties: this.properties,
        rank: this.rank
      },
      fallbackParameters: this.fallbackShaderParameters,
      parameters: this.shaderControlState.builderState,
      shaderError: this.shaderError,
      defineShader: (i, r) => {
        const s = this.rank, a = this.properties, l = [], d = r.parseResult.code;
        for (let w = 0, C = a.length; w < C; ++w) {
          const b = a[w], E = `prop_${b.identifier}`;
          if (!d.match(new RegExp(`\\b${E}\\b`)))
            continue;
          l.push(w), BB[b.type].defineShader(i, b.identifier, s);
        }
        const u = this.propertyOffsets, f = this.propertyGroupBytes, g = new Array(f.length);
        g[0] = 0;
        for (let w = 1; w < f.length; ++w)
          g[w] = g[w - 1] + f[w - 1];
        i.addInitializer((w) => {
          const C = l.map((E) => w.vertexShaderInputBinders[`prop_${a[E].identifier}`]), b = C.length;
          w.vertexShaderInputBinders.properties = {
            enable(E) {
              for (let L = 0; L < b; ++L)
                C[L].enable(E);
            },
            bind(E, L) {
              for (let _ = 0; _ < b; ++_) {
                var R = u[l[_]];
                let A = R.group, I = R.offset;
                C[_].bind(
                  /*stride=*/
                  f[A],
                  /*offset=*/
                  L + I + g[A] * E
                );
              }
            },
            disable() {
              for (let E = 0; E < b; ++E)
                C[E].disable();
            }
          };
        }), i.addUniform("highp vec3", "uColor"), i.addUniform("highp uint", "uSelectedIndex"), i.addVarying("highp vec4", "vColor"), i.addUniform("highp vec3", "uSubspaceMatrix", s), i.addUniform("highp mat4", "uModelViewProjection"), i.addUniform("highp float", "uModelClipBounds", s * 2), i.addUniform("highp uint", "uPickID"), i.addVarying("highp uint", "vPickID", "flat"), i.addVertexCode(xc), i.addVertexCode(`
vec3 defaultColor() { return uColor; }
highp uint getPickBaseOffset() { return uint(gl_InstanceID) * ${this.pickIdsPerInstance}u; }
`), i.addFragmentCode(`
void emitAnnotation(vec4 color) {
  emit(color, vPickID);
}
`);
        const v = `
float getSubspaceClipCoefficient(float modelPoint[${this.rank}]) {
  float coefficient = 1.0;
  for (int i = 0; i < ${s}; ++i) {
    float d = abs(modelPoint[i] - uModelClipBounds[i]) * uModelClipBounds[${s} + i];
    coefficient *= max(0.0, 1.0 - d);
  }
  return coefficient;
}
`;
        i.addVertexCode(v), i.addFragmentCode(v), i.addVertexCode(`
vec3 projectModelVectorToSubspace(float modelPoint[${this.rank}]) {
  vec3 result = vec3(0.0, 0.0, 0.0);
  for (int i = 0; i < ${s}; ++i) {
    result += uSubspaceMatrix[i] * modelPoint[i];
  }
  return result;
}

float getMaxEndpointSubspaceClipCoefficient(float modelPointA[${this.rank}],  float modelPointB[${this.rank}]) {
  float coefficient = 1.0;
  for (int i = 0; i < ${s}; ++i) {
    float dA = abs(modelPointA[i] - uModelClipBounds[i]) * uModelClipBounds[${s} + i];
    float dB = abs(modelPointB[i] - uModelClipBounds[i]) * uModelClipBounds[${s} + i];
    coefficient *= max(0.0, 1.0 - min(dA, dB));
  }
  return coefficient;
}

float getMaxSubspaceClipCoefficient(float modelPointA[${this.rank}],  float modelPointB[${this.rank}]) {
  float coefficient = 1.0;
  for (int i = 0; i < ${s}; ++i) {
    float a = modelPointA[i];
    float b = modelPointB[i];
    float c = uModelClipBounds[i];
    float x = clamp(c, min(a, b), max(a, b));
    float d = abs(x - c) * uModelClipBounds[${s} + i];
    coefficient *= max(0.0, 1.0 - d);
  }
  return coefficient;
}

`), wc(r, i), i.addVertexCode(`
const bool PROJECTION_VIEW = ${!this.targetIsSliceView};
bool ng_discardValue;
#define discard ng_discard()
void ng_discard() {
  ng_discardValue = true;
}
void setLineColor(vec4 startColor, vec4 endColor);
void setLineWidth(float width);

void setAxisColor(vec4 startColor, vec4 endColor);
void setAxisWidth(float width);
void setSphereColor(vec4 color);

void setEndpointMarkerColor(vec4 startColor, vec4 endColor);
void setEndpointMarkerBorderColor(vec4 startColor, vec4 endColor);
void setEndpointMarkerSize(float startSize, float endSize);
void setEndpointMarkerBorderWidth(float startSize, float endSize);

void setPointMarkerColor(vec4 color);
void setPointMarkerBorderColor(vec4 color);
void setPointMarkerSize(float size);
void setPointMarkerBorderWidth(float size);
void setPointMarkerBorderColor(vec3 color) { setPointMarkerBorderColor(vec4(color, 1.0)); }

void setAxisEndpointMarkerColor(vec4 startColor, vec4 endColor);
void setAxisEndpointMarkerBorderColor(vec4 startColor, vec4 endColor);
void setAxisEndpointMarkerSize(float startSize, float endSize);
void setAxisEndpointMarkerBorderWidth(float startSize, float endSize);

void setAxisPointMarkerColor(vec4 color);
void setAxisPointMarkerBorderColor(vec4 color);
void setAxisPointMarkerSize(float size);
void setAxisPointMarkerBorderWidth(float size);

void setEllipsoidFillColor(vec4 color);

void setBoundingBoxBorderColor(vec4 color);
void setBoundingBoxBorderWidth(float size);
void setBoundingBoxFillColor(vec4 color);

void setEndpointMarkerColor(vec3 startColor, vec3 endColor) {
  setEndpointMarkerColor(vec4(startColor, 1.0), vec4(endColor, 1.0));
}
void setEndpointMarkerBorderColor(vec3 startColor, vec3 endColor) {
  setEndpointMarkerBorderColor(vec4(startColor, 1.0), vec4(endColor, 1.0));
}
void setEndpointMarkerColor(vec3 color) { setEndpointMarkerColor(color, color); }
void setEndpointMarkerColor(vec4 color) { setEndpointMarkerColor(color, color); }
void setEndpointMarkerBorderColor(vec3 color) { setEndpointMarkerBorderColor(color, color); }
void setEndpointMarkerBorderColor(vec4 color) { setEndpointMarkerBorderColor(color, color); }
void setEndpointMarkerSize(float size) { setEndpointMarkerSize(size, size); }
void setEndpointMarkerBorderWidth(float size) { setEndpointMarkerBorderWidth(size, size); }
void setLineColor(vec4 color) { setLineColor(color, color); }
void setLineColor(vec3 color) { setLineColor(vec4(color, 1.0)); }
void setLineColor(vec3 startColor, vec3 endColor) { setLineColor(vec4(startColor, 1.0), vec4(endColor, 1.0)); }
void setAxisColor(vec4 color) { setAxisColor(color, color); }
void setAxisColor(vec3 color) { setAxisColor(vec4(color, 1.0)); }
void setAxisColor(vec3 startColor, vec3 endColor) { setAxisColor(vec4(startColor, 1.0), vec4(endColor, 1.0)); }
void setAxisEndpointMarkerColor(vec3 startColor, vec3 endColor) {
  setAxisEndpointMarkerColor(vec4(startColor, 1.0), vec4(endColor, 1.0));
}
void setAxisEndpointMarkerBorderColor(vec3 startColor, vec3 endColor) {
  setAxisEndpointMarkerBorderColor(vec4(startColor, 1.0), vec4(endColor, 1.0));
}
void setAxisEndpointMarkerColor(vec3 color) { setAxisEndpointMarkerColor(color, color); }
void setAxisEndpointMarkerColor(vec4 color) { setAxisEndpointMarkerColor(color, color); }
void setAxisEndpointMarkerBorderColor(vec3 color) { setAxisEndpointMarkerBorderColor(color, color); }
void setAxisEndpointMarkerBorderColor(vec4 color) { setAxisEndpointMarkerBorderColor(color, color); }
void setAxisEndpointMarkerSize(float size) { setAxisEndpointMarkerSize(size, size); }
void setAxisEndpointMarkerBorderWidth(float size) { setAxisEndpointMarkerBorderWidth(size, size); }
void setColor(vec4 color) {
  setPointMarkerColor(color);
  setLineColor(color);
  setEndpointMarkerColor(color);
  setBoundingBoxBorderColor(color);
  setEllipsoidFillColor(vec4(color.rgb, color.a * (PROJECTION_VIEW ? 1.0 : 0.5)));
  setAxisColor(color);
  setAxisEndpointMarkerColor(color);
  setSphereColor(color);
}
void setEllipsoidFillColor(vec3 color) { setEllipsoidFillColor(vec4(color, 1.0)); }

void setBoundingBoxFillColor(vec3 color) { setBoundingBoxFillColor(vec4(color, 1.0)); }
void setBoundingBoxBorderColor(vec3 color) { setBoundingBoxBorderColor(vec4(color, 1.0)); }

void setColor(vec3 color) { setColor(vec4(color, 1.0)); }
void userMain();
`);
        for (const w of oy) {
          var y = ce(w, 2);
          const C = y[0], b = y[1];
          C !== this.annotationType && b.defineShaderNoOpSetters(i);
        }
        t(i), i.addVertexCode(`
#define main userMain
` + Sc(r.parseResult.code) + `
#undef main
`);
      }
    });
  }
  setPartIndex(e, ...t) {
    let i = `
void setPartIndex(${t.map((r, s) => `highp uint partIndex${s}`).join()}) {
  highp uint pickID = uPickID;
  highp uint pickBaseOffset = getPickBaseOffset();
${t.map((r, s) => `highp uint pickOffset${s} = pickBaseOffset + partIndex${s};`).join(`
`)}
`;
    return t.length === 0 && (i += `
  highp uint pickOffset0 = pickBaseOffset;
`), i += `
  vPickID = pickID + pickOffset0;
  highp uint selectedIndex = uSelectedIndex;
if (selectedIndex == pickBaseOffset${t.map((r, s) => ` || selectedIndex == pickOffset${s}`).join("")}) {
    vColor = vec4(mix(vColor.rgb, vec3(1.0, 1.0, 1.0), 0.75), vColor.a);
  }
}
`, e.addVertexCode(i), `setPartIndex(${t.join()})`;
  }
  get invokeUserMain() {
    return `
ng_discardValue = false;
userMain();
if (ng_discardValue) {
  gl_Position = vec4(2.0, 0.0, 0.0, 1.0);
  return;
}
`;
  }
  getCrossSectionFadeFactor() {
    return this.targetIsSliceView ? "(clamp(1.0 - 2.0 * abs(0.5 - gl_FragCoord.z), 0.0, 1.0))" : "(1.0)";
  }
  enable(e, t, i) {
    var r = e(t.renderContext.emitter);
    const s = r.shader, a = r.parameters;
    if (s === null)
      return;
    s.bind();
    const l = this.gl, d = t.renderContext, u = t.annotationLayer;
    if (Ao(l, s, this.shaderControlState, a.parseResult.controls), l.uniform3fv(s.uniform("uSubspaceMatrix"), t.subspaceMatrix), l.uniform1fv(s.uniform("uModelClipBounds"), t.modelClipBounds), l.uniformMatrix4fv(s.uniform("uModelViewProjection"), false, t.modelViewProjectionMatrix), d.emitPickID && l.uniform1ui(s.uniform("uPickID"), t.basePickId), d.emitColor) {
      const g = u.state.displayState.color.value;
      l.uniform3f(s.uniform("uColor"), g[0], g[1], g[2]), l.uniform1ui(s.uniform("uSelectedIndex"), t.selectedIndex);
    }
    const f = s.vertexShaderInputBinders.properties;
    f.enable(1), l.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, t.buffer.buffer), f.bind(
      /*stride=*/
      t.count,
      t.bufferOffset
    ), i(s), f.disable();
  }
};
var oy = new de();
function Wc(n, e) {
  oy.set(n, e);
}
function sc(n) {
  return oy.get(n);
}
var ly = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, s = r < 3 ? e : i === null ? i = $i(e, t) : i, a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(n, e, t, i);
  else
    for (var l = n.length - 1; l >= 0; l--)
      (a = n[l]) && (s = (r < 3 ? a(s) : r > 3 ? a(e, t, s) : a(e, t)) || s);
  return r > 3 && s && UZr(e, t, s), s;
};
var Ms = class {
  constructor(e) {
    this.source = e, this.state = Et.SYSTEM_MEMORY;
  }
  get gl() {
    return this.source.gl;
  }
  copyToGPU(e) {
    this.state = Et.GPU_MEMORY;
  }
  freeGPUMemory(e) {
    this.state = Et.SYSTEM_MEMORY;
  }
};
function VC(n) {
  if (typeof n != "number" || n < 0)
    throw new Error(`Expected non-negative number as limit, but received: ${se(n)}`);
  return n;
}
var Jd = class {
  constructor({ defaultItemLimit: e = Number.POSITIVE_INFINITY, defaultSizeLimit: t = Number.POSITIVE_INFINITY } = {}) {
    this.sizeLimit = new hn(t, VC), this.itemLimit = new hn(e, VC);
  }
};
var tm = class extends hr {
  constructor(e, t, i, r) {
    super(), this.gl = t, this.frameNumberCounter = i, this.capacities = r, this.visibleChunksChanged = new Ee(), this.pendingChunkUpdates = null, this.pendingChunkUpdatesTail = null, this.chunkUpdateDeadline = null, this.chunkUpdateDelay = 30, this.enablePrefetch = new en(true, true);
    const s = (a) => ({
      itemLimit: this.registerDisposer(An.makeFromExisting(e, a.itemLimit)).rpcId,
      sizeLimit: this.registerDisposer(An.makeFromExisting(e, a.sizeLimit)).rpcId
    });
    this.initializeCounterpart(e, {
      gpuMemoryCapacity: s(r.gpuMemory),
      systemMemoryCapacity: s(r.systemMemory),
      downloadCapacity: s(r.download),
      computeCapacity: s(r.compute),
      enablePrefetch: this.registerDisposer(An.makeFromExisting(e, this.enablePrefetch)).rpcId
    });
  }
  scheduleChunkUpdate() {
    let e = this.chunkUpdateDeadline, t;
    e === null || Date.now() < e ? t = 0 : t = this.chunkUpdateDelay, setTimeout(this.processPendingChunkUpdates.bind(this), t);
  }
  processPendingChunkUpdates(e = false) {
    let t = this.chunkUpdateDeadline;
    !e && t === null && (t = Date.now() + 30);
    let i = false, r = 0;
    for (; ; ) {
      if (!e && Date.now() > t) {
        this.chunkUpdateDeadline = null, setTimeout(() => this.processPendingChunkUpdates(), this.chunkUpdateDelay);
        break;
      }
      let s = this.pendingChunkUpdates;
      if (s == null)
        break;
      if (this.applyChunkUpdate(s) && (i = true), ++r, (this.pendingChunkUpdates = s.nextUpdate) == null) {
        this.pendingChunkUpdatesTail = null;
        break;
      }
    }
    return i && this.visibleChunksChanged.dispatch(), r;
  }
  handleFetch_(e, t) {
    var i = t.promise;
    const r = i.resolve, s = i.reject;
    if (i.cancellationToken.isCanceled) {
      s(Ts);
      return;
    }
    const l = t.key, d = e.chunks.get(l);
    if (!d) {
      s(new Error(`No chunk found at ${l} for source ${e.constructor.name}`));
      return;
    }
    const u = d.data;
    if (!u) {
      s(new Error(`At ${l} for source ${e.constructor.name}: chunk has no data`));
      return;
    }
    r({ value: u });
  }
  applyChunkUpdate(e) {
    let t = false;
    const r = this.rpc.get(e.source);
    if (e.promise !== void 0)
      this.handleFetch_(r, e);
    else if (e.id === void 0) {
      for (const s of r.chunks.keys())
        r.deleteChunk(s);
      t = true;
    } else {
      let s = e.state;
      if (s === Et.EXPIRED)
        r.deleteChunk(e.id);
      else {
        let a, l = e.id;
        e.new ? (a = r.getChunk(e), r.addChunk(l, a)) : a = r.chunks.get(l);
        let d = a.state;
        if (s !== d)
          switch (s) {
            case Et.GPU_MEMORY:
              a.copyToGPU(this.gl), t = true;
              break;
            case Et.SYSTEM_MEMORY:
              a.freeGPUMemory(this.gl);
              break;
            default:
              throw new Error(`INTERNAL ERROR: Invalid chunk state: ${Et[s]}`);
          }
      }
    }
    return t;
  }
  flushPendingChunkUpdates() {
    return this.processPendingChunkUpdates(true);
  }
  async getStatistics() {
    const e = this.rpc, t = await e.promiseInvoke(uO, { queue: this.rpcId }), i = new de();
    for (const s of t) {
      var r = ce(s, 2);
      const a = r[0], l = r[1], d = e.get(a);
      d !== void 0 && i.set(d, l);
    }
    return i;
  }
};
tm = ly([ki(lO)], tm);
function HT(n, e) {
  let t = n.get(e.source), i = t.chunkManager.chunkQueueManager;
  if (t.immediateChunkUpdates) {
    i.applyChunkUpdate(e) && i.visibleChunksChanged.dispatch();
    return;
  }
  let r = i.pendingChunkUpdatesTail;
  r == null ? (i.pendingChunkUpdates = e, i.pendingChunkUpdatesTail = e, i.scheduleChunkUpdate()) : (r.nextUpdate = e, i.pendingChunkUpdatesTail = e);
}
Ut("Chunk.update", function(n) {
  HT(this, n);
});
gT("Chunk.retrieve", function(n, e) {
  return new Bt((t, i) => {
    n.promise = { resolve: t, reject: i, cancellationToken: e }, HT(this, n);
  });
});
Ut(hO, function(n) {
  const e = this.get(n.id);
  for (const t of e.prevStatisticsLayers)
    t.numVisibleChunksNeeded = 0, t.numVisibleChunksAvailable = 0, t.numPrefetchChunksNeeded = 0, t.numPrefetchChunksAvailable = 0;
  e.prevStatisticsLayers.length = 0;
  for (const t of n.layers) {
    const i = this.get(t.id);
    if (i === void 0)
      continue;
    const r = i.layerChunkProgressInfo;
    r.numVisibleChunksAvailable = t.numVisibleChunksAvailable, r.numVisibleChunksNeeded = t.numVisibleChunksNeeded, r.numPrefetchChunksAvailable = t.numPrefetchChunksAvailable, r.numPrefetchChunksNeeded = t.numPrefetchChunksNeeded, e.prevStatisticsLayers.push(r);
  }
  e.layerChunkStatisticsUpdated.dispatch();
});
var nm = class extends hr {
  constructor(e) {
    super(), this.chunkQueueManager = e, this.memoize = new q1(), this.prevStatisticsLayers = [], this.layerChunkStatisticsUpdated = new Ee(), this.registerDisposer(e.addRef()), this.initializeCounterpart(e.rpc, { chunkQueueManager: e.rpcId });
  }
  get gl() {
    return this.chunkQueueManager.gl;
  }
  getChunkSource(e, t) {
    const i = e.encodeOptions(t);
    i.constructorId = xn(e);
    const r = ri(i);
    return this.memoize.get(r, () => {
      const s = new e(this, t);
      return s.initializeCounterpart(this.rpc, {}), s.key = i, s;
    });
  }
};
nm = ly([ki(cO)], nm);
var Yr = class extends hr {
  constructor(e, t = {}) {
    super(), this.chunkManager = e, this.chunks = new de(), this.immediateChunkUpdates = false;
  }
  initializeCounterpart(e, t) {
    t.chunkManager = this.chunkManager.rpcId, super.initializeCounterpart(e, t);
  }
  get gl() {
    return this.chunkManager.chunkQueueManager.gl;
  }
  deleteChunk(e) {
    const t = this.chunks.get(e);
    t.state === Et.GPU_MEMORY && t.freeGPUMemory(this.gl), this.chunks.delete(e);
  }
  addChunk(e, t) {
    this.chunks.set(e, t);
  }
  /**
   * Default implementation for use with backendOnly chunk sources.
   */
  getChunk(e) {
    throw new Error("Not implemented.");
  }
  /**
   * Invalidates the chunk cache.  Operates asynchronously.
   */
  invalidateCache() {
    this.rpc.invoke(dO, { id: this.rpcId });
  }
  static encodeOptions(e) {
    return {};
  }
};
function jt(n, e) {
  let t = class extends n {
    constructor(...r) {
      super(...r);
      const s = r[1];
      this.parameters = s.parameters;
    }
    initializeCounterpart(r, s) {
      s.parameters = this.parameters, super.initializeCounterpart(r, s);
    }
    static encodeOptions(r) {
      return RZr({ parameters: r.parameters }, super.encodeOptions(r));
    }
  };
  return t = ly([ki(e.RPC_ID)], t), t;
}
var Hc = class extends hr {
  constructor(e) {
    super(), this.layerChunkProgressInfo = e;
  }
};
var Fi;
(function(n) {
  n[n.MIN_REPRESENTATIVE = 0] = "MIN_REPRESENTATIVE", n[n.MAX_REPRESENTATIVE = 1] = "MAX_REPRESENTATIVE", n[n.REPRESENTATIVE_EXCLUDED = 2] = "REPRESENTATIVE_EXCLUDED", n[n.NONREPRESENTATIVE_EXCLUDED = 4] = "NONREPRESENTATIVE_EXCLUDED";
})(Fi || (Fi = {}));
var FB = class {
};
var UB = class extends Z {
  constructor(e, t, i) {
    super(), this.graph = e, this.segmentsState = t, this.transform = i;
  }
  createRenderLayers(e, t, i) {
    return [];
  }
};
function zB(n) {
  return !(n.high >>> 31);
}
var GB = ["visibleSegments", "segmentEquivalences", "temporaryVisibleSegments", "temporarySegmentEquivalences", "useTemporaryVisibleSegments", "useTemporarySegmentEquivalences"];
function $B(n, e, t) {
  n.registerDisposer(e.visibleSegments.changed.add(t)), n.registerDisposer(e.segmentEquivalences.changed.add(t));
}
function WB(n, e, t) {
  n.registerDisposer(e.temporaryVisibleSegments.changed.add(t)), n.registerDisposer(e.temporarySegmentEquivalences.changed.add(t)), n.registerDisposer(e.useTemporaryVisibleSegments.changed.add(t)), n.registerDisposer(e.useTemporarySegmentEquivalences.changed.add(t));
}
function sr(n) {
  return `${n.low},${n.high}`;
}
function HB(n) {
  return !!(n.high >>> 31);
}
function jT(n) {
  return n.useTemporaryVisibleSegments.value ? n.temporaryVisibleSegments : n.visibleSegments;
}
function jB(n) {
  return n.useTemporarySegmentEquivalences.value ? n.temporarySegmentEquivalences : n.segmentEquivalences;
}
function Zo(n, e) {
  const t = jT(n), i = jB(n);
  if (i.disjointSets) {
    const r = i.disjointSets.visibleSegmentEquivalencePolicy.value;
    for (let s of t.unsafeKeys())
      if (r & Fi.NONREPRESENTATIVE_EXCLUDED) {
        const a = i.get(s);
        e(s, a);
      } else {
        if (i.disjointSets === void 0 || !i.disjointSets.isMinElement(s))
          continue;
        for (let a of i.setElements(s))
          r & Fi.REPRESENTATIVE_EXCLUDED && r & Fi.MAX_REPRESENTATIVE && HB(a) || e(a, s);
      }
  }
}
var cn = 40;
var JT = 0.5;
var YT = -4;
function pu(n) {
  return (Zn(n) - YT) / JT;
}
function JB(n) {
  return 2 ** (n * JT + YT);
}
function ua(n) {
  return new hn(n, vn);
}
var Ro = class {
  constructor() {
    this.visibility = new yc(), this.changed = new Ee(), this.frameNumber = -1, this.spatialScales = new de(), this.numHistogramRows = 1, this.value = new Uint32Array(cn * this.numHistogramRows * 2);
  }
  begin(e) {
    e !== this.frameNumber && (this.value.fill(0), this.frameNumber = e, this.spatialScales.clear(), this.changed.dispatch());
  }
  /**
   * Adds a count to the histogram.
   *
   * @param spatialScale Spatial resolution of data in nanometers.
   * @param renderScale Rendered scale of data in screen pixels.
   * @param presentCount Number of present chunks.
   * @param notPresentCount Number of desired but not-present chunks.
   */
  add(e, t, i, r) {
    let s = this.spatialScales, a = this.numHistogramRows, l = this.value, d = s.get(e);
    if (d === void 0 && (d = s.size, s.set(e, d)), d >= a) {
      this.numHistogramRows = a *= 2;
      const f = new Uint32Array(a * cn * 2);
      f.set(l), this.value = l = f;
    }
    const u = d * cn * 2 + Math.min(Math.max(0, Math.round(pu(t))), cn - 1);
    l[u] += i, l[u + cn] += r;
  }
};
var cy = class extends yT {
  constructor(e, t, i) {
    var r;
    super(), this.chunkManager = e, this.multiscaleSource = t, this.rpcId = null, this.rpcTransfer = {}, this.visibleSources = new de(), this.visibleSourcesList_ = [];
    var s = i.renderScaleTarget;
    const a = s === void 0 ? ua(1) : s;
    this.renderScaleTarget = a, this.renderScaleHistogram = i.renderScaleHistogram, this.transform = i.transform, this.localPosition = i.localPosition, this.rpcTransfer = i.rpcTransfer || {}, this.dataHistogramSpecifications = this.registerDisposer((r = i.dataHistogramSpecifications) !== null && r !== void 0 ? r : new RT(oa([]), oa([]))), this.registerDisposer(this.dataHistogramSpecifications.visibility.changed.add(this.redrawNeeded.dispatch));
  }
  getDataHistogramCount() {
    const e = this.dataHistogramSpecifications;
    return e.visibility.visible ? e.bounds.value.length : 0;
  }
  getSources(e) {
    return this.multiscaleSource.getSources(e);
  }
  addSource(e, t) {
    const i = this.visibleSources, r = i.get(e);
    r !== void 0 ? (++r.refCount, r.chunkTransform = t) : (i.set(e, { source: e, refCount: 1, chunkTransform: t }), this.visibleSourcesList_.length = 0);
  }
  removeSource(e) {
    const t = this.visibleSources, i = t.get(e);
    i.refCount !== 1 ? --i.refCount : (t.delete(e), this.visibleSourcesList_.length = 0);
  }
  get visibleSourcesList() {
    const e = this.visibleSources, t = this.visibleSourcesList_;
    if (t.length === 0 && e.size !== 0) {
      for (const i of e.values())
        t.push(i);
      t.sort((i, r) => i.chunkTransform.chunkToLayerTransformDet - r.chunkTransform.chunkToLayerTransformDet);
    }
    return t;
  }
  initializeCounterpart() {
    const e = this.registerDisposer(new Hc(this.layerChunkProgressInfo)), t = this.chunkManager.rpc;
    e.RPC_TYPE_ID = this.RPC_TYPE_ID, e.initializeCounterpart(t, RZr({ localPosition: this.registerDisposer(An.makeFromExisting(t, this.localPosition)).rpcId, renderScaleTarget: this.registerDisposer(An.makeFromExisting(t, this.renderScaleTarget)).rpcId }, this.rpcTransfer)), this.rpcId = e.rpcId;
  }
  get gl() {
    return this.chunkManager.chunkQueueManager.gl;
  }
  setGLBlendMode(e, t) {
    t > 0 ? (e.enable(WebGL2RenderingContext.BLEND), e.blendFunc(WebGL2RenderingContext.SRC_ALPHA, WebGL2RenderingContext.ONE_MINUS_SRC_ALPHA)) : e.disable(WebGL2RenderingContext.BLEND);
  }
  filterVisibleSources(e, t) {
    return SB(e, this, t);
  }
};
cy.prototype.RPC_TYPE_ID = CB;
var Mo = class extends ST {
  draw(e, t) {
  }
  isReady(e, t) {
    return true;
  }
};
var YB = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, s = r < 3 ? e : i === null ? i = $i(e, t) : i, a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(n, e, t, i);
  else
    for (var l = n.length - 1; l >= 0; l--)
      (a = n[l]) && (s = (r < 3 ? a(s) : r > 3 ? a(e, t, s) : a(e, t)) || s);
  return r > 3 && s && UZr(e, t, s), s;
};
var qB = class extends gB {
};
var KB = Oh(qB);
function ZB(n) {
  return {
    source: n.source.addCounterpartRef(),
    effectiveVoxelSize: n.effectiveVoxelSize,
    layerRank: n.layerRank,
    nonDisplayLowerClipBound: n.nonDisplayLowerClipBound,
    nonDisplayUpperClipBound: n.nonDisplayUpperClipBound,
    lowerClipBound: n.lowerClipBound,
    upperClipBound: n.upperClipBound,
    lowerClipDisplayBound: n.lowerClipDisplayBound,
    upperClipDisplayBound: n.upperClipDisplayBound,
    chunkDisplayDimensionIndices: n.chunkDisplayDimensionIndices,
    lowerChunkDisplayBound: n.lowerChunkDisplayBound,
    upperChunkDisplayBound: n.upperChunkDisplayBound,
    fixedLayerToChunkTransform: n.fixedLayerToChunkTransform,
    combinedGlobalLocalToChunkTransform: n.combinedGlobalLocalToChunkTransform,
    chunkLayout: n.chunkLayout.toObject()
  };
}
function dy(n) {
  return n.map((e) => e.map(ZB));
}
function Fp(n, e) {
  for (const t of e)
    for (const i of t) {
      const r = i.source;
      n.removeSource(r), r.dispose();
    }
}
var Fu = class extends KB {
  constructor(e, t, i, r) {
    super(new bT({
      parametersConstructor: fB,
      navigationState: i,
      update: (l, d) => {
        const u = l.invViewMatrix, f = l.centerDataPosition;
        d.toMat4(u);
        var g = l.displayDimensionRenderInfo;
        const v = g.canonicalVoxelFactors, y = g.voxelPhysicalScales;
        for (let I = 0; I < 3; ++I)
          f[I] = u[12 + I];
        const w = l.logicalWidth, C = l.logicalHeight, b = l.projectionMat, E = l.viewportNormalInGlobalCoordinates, L = l.viewportNormalInCanonicalCoordinates, R = d.relativeDepthRange;
        GE(b, -w / 2, w / 2, C / 2, -C / 2, -R, R), K1(l, b), tT(l);
        const _ = l.viewMatrix;
        for (let I = 0; I < 3; ++I) {
          const P = E[I] = _[I * 4 + 2];
          L[I] = P / v[I];
        }
        wu(E, E), wu(L, L);
        let A = 0;
        for (let I = 0; I < 3; ++I) {
          const P = y[I], N = u[I];
          A += (P * N) ** 2;
        }
        A = Math.sqrt(A), l.pixelSize = A;
      }
    })), this.chunkManager = e, this.layerManager = t, this.navigationState = i, this.wireFrame = r, this.gl = this.chunkManager.gl, this.viewChanged = new Ee(), this.renderingStale = true, this.visibleChunksStale = true, this.visibleLayerList = new Array(), this.offscreenFramebuffer = this.registerDisposer(new Do(this.gl, {
      colorBuffers: Vu(this.gl, 1),
      depthBuffer: new IV(this.gl)
    })), this.histogramInputTextures = [], this.offscreenFramebuffersWithHistograms = [this.offscreenFramebuffer], this.histogramGenerator = Qv.get(this.gl), this.updateVisibleLayers = this.registerCancellable(lt(() => {
      this.updateVisibleLayersNow();
    }, 0)), this.registerDisposer(i), this.registerDisposer(this.projectionParameters), this.registerDisposer(this.projectionParameters.changed.add((l, d) => {
      l.displayDimensionRenderInfo !== d.displayDimensionRenderInfo && this.updateVisibleLayers();
    }));
    const s = this.chunkManager.rpc, a = this.sharedProjectionParameters = this.registerDisposer(new Ou(s, this.projectionParameters));
    this.initializeCounterpart(s, {
      chunkManager: e.rpcId,
      projectionParameters: a.rpcId
    }), this.registerDisposer(t.layersChanged.add(() => {
      this.updateVisibleLayers();
    })), this.wireFrame.changed.add(this.viewChanged.dispatch), this.viewChanged.add(() => {
      this.renderingStale = true;
    }), this.registerDisposer(e.chunkQueueManager.visibleChunksChanged.add(this.viewChanged.dispatch)), this.updateVisibleLayers();
  }
  get displayDimensionRenderInfo() {
    return this.navigationState.displayDimensionRenderInfo;
  }
  computeHistograms(e, t) {
    this.histogramGenerator.compute(e, this.offscreenFramebuffer.depthBuffer.texture, this.histogramInputTextures, t, this.chunkManager.chunkQueueManager.frameNumberCounter.frameNumber);
  }
  flushBackendProjectionParameters() {
    this.sharedProjectionParameters.flush();
  }
  forEachVisibleChunk(e, t, i) {
    EB(this.projectionParameters.value, e.renderLayer.localPosition.value, e, t, () => {
      i(e.curPositionInChunks.join());
    });
  }
  isReady() {
    if (!this.navigationState.valid)
      return false;
    this.updateVisibleLayers.flush(), this.updateVisibleSources();
    let e = 0, t = 0;
    for (const i of this.visibleLayers.values()) {
      const r = i.visibleSources;
      for (const s of r) {
        const a = ay(this.projectionParameters.value, s.chunkLayout), d = s.source.chunks;
        this.forEachVisibleChunk(s, a, (u) => {
          const f = d.get(u);
          ++t, f && f.state === Et.GPU_MEMORY && ++e;
        });
      }
    }
    return e === t;
  }
  invalidateVisibleSources() {
    super.invalidateVisibleSources(), this.viewChanged.dispatch();
  }
  bindVisibleRenderLayer(e, t) {
    t.push(e.localPosition.changed.add(() => this.invalidateVisibleChunks())), t.push(e.redrawNeeded.add(this.viewChanged.dispatch)), t.push(e.transform.changed.add(this.updateVisibleLayers)), t.push(e.renderScaleTarget.changed.add(() => this.invalidateVisibleSources()));
    const i = e.renderScaleHistogram;
    i !== void 0 && t.push(i.visibility.add(this.visibility)), t.push(e.dataHistogramSpecifications.producerVisibility.add(this.visibility));
  }
  updateVisibleLayersNow() {
    if (this.wasDisposed || !this.navigationState.valid)
      return false;
    const e = Date.now(), t = this.visibleLayers, i = this.visibleLayerList, r = this.projectionParameters.value.displayDimensionRenderInfo;
    let s = this.rpc, a = { id: this.rpcId }, l = false;
    i.length = 0;
    for (let u of this.layerManager.readyRenderLayers())
      if (u instanceof cy) {
        i.push(u);
        let f = t.get(u);
        if (f === void 0) {
          const g = [], v = new qo();
          f = {
            messages: v,
            allSources: this.getTransformedSources(u, v),
            transformGeneration: u.transform.changed.count,
            visibleSources: [],
            disposers: g,
            lastSeenGeneration: e,
            displayDimensionRenderInfo: r
          }, g.push(u.messages.addChild(f.messages)), t.set(u.addRef(), f), this.bindVisibleRenderLayer(u, g);
        } else {
          f.lastSeenGeneration = e;
          const g = u.transform.changed.count;
          if (f.transformGeneration === g && f.displayDimensionRenderInfo === r)
            continue;
          const v = f.allSources;
          f.allSources = this.getTransformedSources(u, f.messages), Fp(u, v), f.visibleSources.length = 0, f.displayDimensionRenderInfo = r, f.transformGeneration = g;
        }
        a.layerId = u.rpcId, a.sources = dy(f.allSources), this.flushBackendProjectionParameters(), s.invoke(wB, a), l = true;
      }
    for (const u of t) {
      var d = ce(u, 2);
      const f = d[0], g = d[1];
      g.lastSeenGeneration !== e && (a.layerId = f.rpcId, s.invoke(xB, a), t.delete(f), Fp(f, g.allSources), Co(g.disposers), f.dispose(), l = true);
    }
    return l && (this.visibleSourcesStale = true), this.viewChanged.dispatch(), l;
  }
  invalidateVisibleChunks() {
    super.invalidateVisibleChunks(), this.viewChanged.dispatch();
  }
  get valid() {
    return this.navigationState.valid;
  }
  getOffscreenFramebufferWithHistograms(e) {
    const t = this.offscreenFramebuffersWithHistograms;
    let i = t[e];
    if (i === void 0) {
      const r = this.gl, s = this.histogramInputTextures, a = this.offscreenFramebuffer;
      s.length < e && s.push(...Vu(r, e - s.length, WebGL2RenderingContext.R8, WebGL2RenderingContext.RED));
      let l = [a.colorBuffers[0].addRef()];
      for (let d = 0; d < e; ++d)
        l.push(s[d].addRef());
      i = this.registerDisposer(new Do(r, { colorBuffers: l, depthBuffer: a.depthBuffer.addRef() })), t[e] = i;
    }
    return i;
  }
  updateRendering() {
    const e = this.projectionParameters.value, t = e.width, i = e.height;
    if (!this.renderingStale || !this.valid || t === 0 || i === 0)
      return;
    this.renderingStale = false, this.updateVisibleLayers.flush(), this.updateVisibleSources();
    let r = this.gl, s = this.offscreenFramebuffer;
    s.bind(t, i), r.disable(r.SCISSOR_TEST), r.clearColor(0, 0, 0, 0), r.colorMask(true, true, true, true), r.clear(WebGL2RenderingContext.COLOR_BUFFER_BIT);
    let a = 0;
    const l = this.wireFrame.value, d = { sliceView: this, projectionParameters: e, wireFrame: l };
    for (let u of this.visibleLayerList) {
      const f = l ? 0 : u.getDataHistogramCount();
      this.getOffscreenFramebufferWithHistograms(f).bind(t, i);
      for (let v = 0; v < f; ++v)
        r.clearBufferfv(WebGL2RenderingContext.COLOR, 1 + v, Rg);
      r.enable(WebGL2RenderingContext.DEPTH_TEST), r.depthFunc(WebGL2RenderingContext.LESS), r.clearDepth(1), r.clear(WebGL2RenderingContext.DEPTH_BUFFER_BIT), u.setGLBlendMode(r, a), u.draw(d), ++a;
    }
    r.disable(WebGL2RenderingContext.BLEND), r.disable(WebGL2RenderingContext.DEPTH_TEST), s.unbind();
  }
  disposed() {
    for (const t of this.visibleLayers) {
      var e = ce(t, 2);
      const i = e[0], r = e[1];
      Fp(i, r.allSources), Co(r.disposers), i.dispose();
    }
    this.visibleLayers.clear(), this.visibleLayerList.length = 0;
  }
  getTransformedSources(e, t) {
    const i = uy(this.projectionParameters.value.displayDimensionRenderInfo, e.transform.value, (r) => e.getSources(r), t, e);
    for (const r of i)
      for (const s of r)
        e.addSource(s.source, s.chunkTransform);
    return i;
  }
};
Fu = YB([ki(bB)], Fu);
var qT = class extends Yr {
  constructor(e, t) {
    super(e, t), this.spec = t.spec;
  }
  static encodeSpec(e) {
    return {
      chunkDataSize: De(e.chunkDataSize),
      lowerVoxelBound: De(e.lowerVoxelBound),
      upperVoxelBound: De(e.upperVoxelBound)
    };
  }
  static encodeOptions(e) {
    const t = super.encodeOptions(e);
    return t.spec = this.encodeSpec(e.spec), t;
  }
  initializeCounterpart(e, t) {
    t.spec = this.spec, super.initializeCounterpart(e, t);
  }
};
var KT = class extends Ms {
  constructor(e, t) {
    super(e), this.chunkGridPosition = t.chunkGridPosition, this.state = Et.SYSTEM_MEMORY;
  }
};
var ZT = class XT extends Z {
  constructor(e, t) {
    super(), this.gl = e, this.copyVertexPositionsBuffer = Cc(this.gl), this.textureCoordinateAdjustment = new Float32Array(4);
    let i = new da(e);
    i.addVarying("vec2", "vTexCoord"), i.addUniform("sampler2D", "uSampler"), i.addInitializer((r) => {
      e.uniform1i(r.uniform("uSampler"), 0);
    }), i.addUniform("vec4", "uColorFactor"), i.addUniform("vec4", "uBackgroundColor"), i.addUniform("mat4", "uProjectionMatrix"), i.addUniform("vec4", "uTextureCoordinateAdjustment"), i.require(t), i.setFragmentMain(`
vec4 sampledColor = texture(uSampler, vTexCoord);
if (sampledColor.a == 0.0) {
  sampledColor = uBackgroundColor;
}
emit(sampledColor * uColorFactor, 0u);
`), i.addAttribute("vec4", "aVertexPosition"), i.setVertexMain(`
vTexCoord = uTextureCoordinateAdjustment.xy + 0.5 * (aVertexPosition.xy + 1.0) * uTextureCoordinateAdjustment.zw;
gl_Position = uProjectionMatrix * aVertexPosition;
`), this.shader = this.registerDisposer(i.build());
  }
  draw(e, t, i, r, s, a, l, d) {
    let u = this.gl, f = this.shader, g = this.textureCoordinateAdjustment;
    g[0] = s, g[1] = a, g[2] = l - s, g[3] = d - a, f.bind(), u.activeTexture(u.TEXTURE0), u.bindTexture(u.TEXTURE_2D, e), u.disable(WebGL2RenderingContext.BLEND), u.uniformMatrix4fv(f.uniform("uProjectionMatrix"), false, t), u.uniform4fv(f.uniform("uColorFactor"), i), u.uniform4fv(f.uniform("uBackgroundColor"), r), u.uniform4fv(f.uniform("uTextureCoordinateAdjustment"), g);
    let v = f.attribute("aVertexPosition");
    this.copyVertexPositionsBuffer.bindToVertexAttrib(
      v,
      /*components=*/
      2
    ), u.drawArrays(u.TRIANGLE_FAN, 0, 4), u.disableVertexAttribArray(v), u.bindTexture(u.TEXTURE_2D, null);
  }
  static get(e, t) {
    return e.memoize.get(`sliceview/SliceViewRenderHelper:${xn(t)}`, () => new XT(e, t));
  }
};
var XB = class {
  constructor(e) {
    this.chunkManager = e;
  }
};
function uy(n, e, t, i, r) {
  i.clearMessages();
  const s = (E) => (i.addMessage({
    severity: cr.error,
    message: E
  }), []);
  if (e.error !== void 0)
    return s(e.error);
  const a = e.rank, l = e.unpaddedRank, d = n.displayDimensionIndices, u = n.displayRank, f = n.canonicalVoxelFactors, g = W1(e, d), v = g.displayToLayerDimensionIndices, y = new Float32Array(u * l), w = e.modelToRenderLayerTransform;
  for (let E = 0; E < u; ++E) {
    const L = v[E];
    if (L === -1)
      continue;
    const R = f[E];
    for (let _ = 0; _ < l; ++_)
      y[u * _ + E] = w[(a + 1) * _ + L] * R;
  }
  const C = t({
    displayRank: u,
    multiscaleToViewTransform: y,
    modelChannelDimensionIndices: e.channelToRenderLayerDimensions
  }), b = n.voxelPhysicalScales;
  try {
    const E = (L) => {
      const R = L.chunkSource, _ = R.spec;
      var A = L.lowerClipBound;
      const I = A === void 0 ? _.lowerVoxelBound : A;
      var P = L.upperClipBound;
      const N = P === void 0 ? _.upperVoxelBound : P, O = $1(e, L.chunkToMultiscaleTransform), B = _.chunkDataSize, j = O.channelToChunkDimensionIndices, U = new Float32Array(l), V = new Float32Array(l);
      U.set(I), V.set(N);
      const G = j.length, F = e.channelSpaceShape;
      for (let $e = 0; $e < G; ++$e) {
        const Pe = j[$e];
        if (Pe === -1)
          continue;
        const bt = F[$e];
        if (B[Pe] !== bt)
          throw new Error("Channel dimension " + e.layerDimensionNames[e.channelToRenderLayerDimensions[$e]] + ` has extent ${bt} but corresponding chunk dimension has extent ${B[Pe]}`);
        U[Pe] = Number.NEGATIVE_INFINITY, V[Pe] = Number.POSITIVE_INFINITY;
      }
      const ue = H1(O, g), ae = _e(), Ie = _e(), le = _e(), Te = _e(), Ue = _e(), Ye = ue.numChunkDisplayDims, Ze = ue.chunkDisplayDimensionIndices, rt = O.combinedGlobalLocalToChunkTransform, Xe = O.layerRank, Be = O.combinedGlobalLocalRank, Ae = new Float32Array(rt);
      for (let $e = 0; $e < Ye; ++$e) {
        const Pe = Ze[$e];
        for (let bt = 0; bt <= Be; ++bt)
          Ae[Pe + bt * Xe] = 0;
        Pe < l ? (Ue[$e] = _.chunkDataSize[Pe], ae[$e] = _.lowerChunkBound[Pe], Ie[$e] = _.upperChunkBound[Pe], le[$e] = I[Pe], Te[$e] = N[Pe], U[Pe] = Number.NEGATIVE_INFINITY, V[Pe] = Number.POSITIVE_INFINITY) : (Ue[$e] = 1, ae[$e] = 0, Ie[$e] = 1, le[$e] = 0, Te[$e] = 1);
      }
      Ue.fill(1, Ye), ae.fill(0, Ye), Ie.fill(1, Ye), le.fill(0, Ye), Te.fill(1, Ye);
      const ze = new Uh(Ue, ue.displaySubspaceModelMatrix, Ye), We = ze.localSpatialVectorToGlobal(
        _e(),
        /*baseVoxelSize=*/
        qE
      );
      for (let $e = 0; $e < u; ++$e)
        We[$e] = Math.abs(We[$e] * b[$e]);
      return We.fill(1, u), {
        layerRank: Xe,
        lowerClipBound: I,
        upperClipBound: N,
        nonDisplayLowerClipBound: U,
        nonDisplayUpperClipBound: V,
        renderLayer: r,
        source: R,
        lowerChunkDisplayBound: ae,
        upperChunkDisplayBound: Ie,
        lowerClipDisplayBound: le,
        upperClipDisplayBound: Te,
        effectiveVoxelSize: We,
        chunkLayout: ze,
        chunkDisplayDimensionIndices: Ze,
        fixedLayerToChunkTransform: Ae,
        curPositionInChunks: new Float32Array(l),
        combinedGlobalLocalToChunkTransform: O.combinedGlobalLocalToChunkTransform,
        fixedPositionWithinChunk: new Uint32Array(l),
        chunkTransform: O,
        chunkDisplayTransform: ue
      };
    };
    return C.map((L) => L.map((R) => E(R)));
  } catch (E) {
    for (const A of C)
      for (const I of A)
        I.chunkSource.dispose();
    const L = n.globalDimensionNames, _ = `Cannot render (${De(n.displayDimensionIndices.filter((A) => A !== -1), (A) => L[A]).join(", ")}) cross section: ${E.message}`;
    return s(_);
  }
}
var Ks = null;
var QB = 200;
var nt = class _nt {
  constructor(e = false) {
    if (Ks === null) {
      Ks = document.createElement("ul"), Ks.id = "statusContainer";
      const i = document.getElementById("neuroglancer-container");
      i ? i.appendChild(Ks) : document.body.appendChild(Ks);
    }
    let t = document.createElement("li");
    this.element = t, e === true && (e = QB), e !== false ? (this.setVisible(false), this.timer = window.setTimeout(this.setVisible.bind(this, true), e)) : this.timer = null, Ks.appendChild(t);
  }
  dispose() {
    Ks.removeChild(this.element), this.element = void 0, this.timer !== null && clearTimeout(this.timer);
  }
  setText(e, t) {
    this.element.textContent = e, t && this.setVisible(true);
  }
  setHTML(e, t) {
    this.element.innerHTML = e, t && this.setVisible(true);
  }
  setVisible(e) {
    this.timer !== null && (clearTimeout(this.timer), this.timer = null), this.element.style.display = e ? "block" : "none";
  }
  static forPromise(e, t) {
    let i = new _nt(t.delay);
    i.setText(t.initialMessage);
    let r = i.dispose.bind(i);
    return e.then(r, (s) => {
      let a;
      s instanceof Error ? a = s.message : a = "" + s;
      var l = t.errorPrefix;
      let d = l === void 0 ? "" : l;
      i.setErrorMessage(d + a), i.setVisible(true);
    }), e;
  }
  setErrorMessage(e) {
    this.element.textContent = e + " ";
    let t = document.createElement("button");
    t.textContent = "Dismiss", t.addEventListener("click", () => {
      this.dispose();
    }), this.element.appendChild(t);
  }
  static showMessage(e) {
    const t = new _nt();
    return t.element.textContent = e, t.setVisible(true), t;
  }
  static showTemporaryMessage(e, t = 2e3) {
    const i = this.showMessage(e);
    return window.setTimeout(() => i.dispose(), t), i;
  }
};
var hy = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, s = r < 3 ? e : i === null ? i = $i(e, t) : i, a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(n, e, t, i);
  else
    for (var l = n.length - 1; l >= 0; l--)
      (a = n[l]) && (s = (r < 3 ? a(s) : r > 3 ? a(e, t, s) : a(e, t)) || s);
  return r > 3 && s && UZr(e, t, s), s;
};
function QT(n) {
  let e = 0;
  const t = n.typeToIds;
  for (const i of Br)
    e += sc(i).pickIdsPerInstance * t[i].length;
  return e;
}
var ek = class {
  constructor(e) {
    this.bufferValid = false, this.numPickIds = 0, this.serializedAnnotations = {
      data: e.data,
      typeToIds: e.typeToIds,
      typeToOffset: e.typeToOffset,
      typeToIdMaps: e.typeToIdMaps
    };
  }
  freeGPUMemory(e) {
    const t = this.buffer;
    t !== void 0 && (t.dispose(), this.bufferValid = false, this.buffer = void 0);
  }
};
var eF = class extends Ms {
  constructor(e, t) {
    super(e), t.data !== void 0 && (this.data = new ek(t));
  }
  freeGPUMemory(e) {
    super.freeGPUMemory(e);
    const t = this.data;
    t !== void 0 && t.freeGPUMemory(e);
  }
  dispose() {
    this.data = void 0;
  }
};
var tk = class extends KT {
  constructor(e, t) {
    super(e, t), t.data !== void 0 && (this.data = new ek(t));
  }
  freeGPUMemory(e) {
    super.freeGPUMemory(e);
    const t = this.data;
    t !== void 0 && t.freeGPUMemory(e);
  }
  dispose() {
    this.data = void 0;
  }
};
var No = class extends qT {
  constructor(e, t) {
    super(e, t), this.immediateChunkUpdates = true, (this.parent = t.parent).spatiallyIndexedSources.add(this);
    var r = this.spec;
    const s = r.rank, a = r.chunkDataSize, l = this.multiscaleToChunkTransform = new Float32Array((s + 1) ** 2);
    _v(l, s + 1, this.spec.chunkToMultiscaleTransform, s + 1, s + 1);
    for (let d = 0; d < s; ++d)
      for (let u = 0; u < s + 1; ++u)
        l[(s + 1) * u + d] /= a[d];
  }
  disposed() {
    this.parent.spatiallyIndexedSources.delete(this), super.disposed();
  }
  initializeCounterpart(e, t) {
    t.parent = this.parent.rpcId, super.initializeCounterpart(e, t);
  }
  addChunk(e, t) {
    super.addChunk(e, t);
  }
  getChunk(e) {
    return new tk(this, e);
  }
};
No = hy([ki(kB)], No);
var im = class extends Yr {
  constructor(e, t, i) {
    super(e, {}), this.parent = t, this.relationshipIndex = i, this.immediateChunkUpdates = true;
  }
  addChunk(e, t) {
    super.addChunk(e, t);
  }
  getChunk(e) {
    return new eF(this, e);
  }
};
im = hy([ki(IB)], im);
var tF = class extends Ms {
  constructor(e, t) {
    super(e), this.annotation = Rv(t.annotation);
  }
};
var rm = class extends Yr {
  constructor(e, t) {
    super(e), this.parent = t;
  }
  getChunk(e) {
    return new tF(this, e);
  }
  addChunk(e, t) {
    super.addChunk(e, t);
    const r = this.parent.references.get(e);
    r !== void 0 && (r.value = t.annotation, r.changed.dispatch());
  }
  deleteChunk(e) {
    const i = this.parent.references.get(e);
    i !== void 0 && (i.value = void 0, i.changed.dispatch());
  }
};
rm = hy([ki(TB)], rm);
function nk(n, e, t, i) {
  const r = new Uint8Array(n.data.length + i);
  for (const s of Br) {
    if (s === t)
      continue;
    let a = n.typeToOffset[s], l = a;
    s > t && (l += i, n.typeToOffset[s] = l), r.set(n.data.subarray(a, a + n.typeToIds[s].length * e[s].serializedBytes), l);
  }
  return r;
}
function sm(n, e, t, i, r, s, a, l) {
  const d = n.typeToOffset[t];
  let u = d, f = d;
  const g = e[t].propertyGroupBytes, v = g.length, y = n.typeToIds[t].length;
  for (let w = 0; w < v; ++w) {
    const C = g[w];
    i.set(n.data.subarray(u + r * C, u + s * C), f + a * C), u += C * y, f += C * l;
  }
}
function Yd(n, e, t) {
  const i = e.type, r = t[i].rank, s = n.serializedAnnotations, a = s.typeToIds[i], l = s.typeToIdMaps[i], d = Gn[i], u = t[i].serializedBytes;
  let f = l.get(e.id);
  if (f === void 0) {
    f = l.size, l.set(e.id, f);
    const C = nk(s, t, i, u);
    sm(
      s,
      t,
      i,
      C,
      /*sourceBeginIndex=*/
      0,
      /*sourceEndIndex=*/
      f,
      /*destBeginIndex=*/
      0,
      /*destCount=*/
      f + 1
    ), a.push(e.id), s.data = C;
  }
  const g = s.typeToOffset[i], v = new DataView(s.data.buffer, s.data.byteOffset, s.data.byteLength), y = _c === ai.LITTLE, w = t[i];
  d.serialize(v, g + w.propertyGroupBytes[0] * f, y, r, e), w.serialize(v, g, f, a.length, y, e.properties), n.bufferValid = false;
}
function qd(n, e, t, i) {
  const r = n.serializedAnnotations, s = r.typeToIdMaps[e], a = s.get(t);
  if (a === void 0)
    return false;
  const l = r.typeToIds[e], d = i[e].serializedBytes, u = nk(r, i, e, -d);
  sm(
    r,
    i,
    e,
    u,
    /*sourceBeginIndex=*/
    0,
    /*sourceEndIndex=*/
    a,
    /*destBeginIndex=*/
    0,
    /*destCount=*/
    l.length - 1
  ), sm(
    r,
    i,
    e,
    u,
    /*sourceBeginIndex=*/
    a + 1,
    /*sourceEndIndex=*/
    l.length,
    /*destBeginIndex=*/
    a,
    /*destCount=*/
    l.length - 1
  ), l.splice(a, 1), s.delete(t);
  for (let f = a, g = l.length; f < g; ++f)
    s.set(l[f], f);
  return r.data = u, n.bufferValid = false, true;
}
function nF() {
  const n = [], e = [], t = [];
  for (const i of Br)
    n[i] = [], e[i] = 0, t[i] = new de();
  return new tk(void 0, { data: new Uint8Array(0), numPickIds: 0, typeToOffset: e, typeToIds: n, typeToIdMaps: t });
}
var Ui = class extends hr {
  constructor(e, t) {
    super(), this.chunkManager = e, this.metadataChunkSource = this.registerDisposer(new rm(this.chunkManager, this)), this.spatiallyIndexedSources = new je(), this.temporary = nF(), this.references = new de(), this.localUpdates = new de(), this.numCommitsInProgress = 0, this.changed = new Ee(), this.referencesChanged = new ot(), this.readonly = false, this.childRefreshed = new Ee(), this.rank = t.rank, this.properties = t.properties, this.annotationPropertySerializers = Pv(this.rank, this.properties);
    const i = this.segmentFilteredSources = [], r = t.relationships;
    this.relationships = r;
    for (let s = 0, a = r.length; s < a; ++s)
      i.push(this.registerDisposer(new im(e, this, s)));
  }
  hasNonSerializedProperties() {
    return this.relationships.length > 0;
  }
  getSources(e) {
    throw new Error("not implemented");
  }
  initializeCounterpart(e, t) {
    this.metadataChunkSource.initializeCounterpart(e, {});
    for (const i of this.segmentFilteredSources)
      i.initializeCounterpart(e, {});
    t.segmentFilteredSource = this.segmentFilteredSources.map((i) => i.addCounterpartRef()), t.metadataChunkSource = this.metadataChunkSource.addCounterpartRef(), t.chunkManager = this.chunkManager.rpcId, super.initializeCounterpart(e, t);
  }
  add(e, t = true) {
    e.id = Av();
    const i = new du(e.id);
    return i.value = e, this.references.set(i.id, i), this.referencesChanged.dispatch({ action: "adding", id: i.id }), i.registerDisposer(() => {
      this.references.delete(i.id), this.referencesChanged.dispatch({ action: "deref", id: i.id });
    }), this.applyLocalUpdate(
      i,
      /*existing=*/
      false,
      /*commit=*/
      t,
      /*newAnnotation=*/
      e
    ), i;
  }
  applyLocalUpdate(e, t, i, r) {
    const s = this.localUpdates, a = e.id;
    let l = this.localUpdates.get(a);
    const d = e.value;
    if (d == null)
      throw new Error("Cannot create local update from null annotation");
    if (l === void 0 ? (l = {
      type: d.type,
      reference: e.addRef(),
      existingAnnotation: t ? d : void 0,
      pendingCommit: void 0,
      commitInProgress: void 0
    }, s.set(a, l), this.forEachPossibleChunk(d, (u) => {
      const f = u.data;
      if (f === void 0)
        return;
      const g = d.type;
      qd(f, g, a, this.annotationPropertySerializers);
    }), r !== null && Yd(this.temporary.data, r, this.annotationPropertySerializers)) : (r === null ? qd(this.temporary.data, d.type, d.id, this.annotationPropertySerializers) : Yd(this.temporary.data, r, this.annotationPropertySerializers), e.value = r), i)
      if (l.commitInProgress !== void 0)
        l.pendingCommit = r;
      else {
        if (r === null && l.existingAnnotation === void 0) {
          s.delete(a), l.reference.dispose();
          return;
        }
        this.sendCommitRequest(l, r);
      }
    this.notifyChanged(e.id, r || void 0);
  }
  sendCommitRequest(e, t) {
    this.updateCommitsInProgress(1), e.commitInProgress = t, this.rpc.invoke(PB, {
      id: this.rpcId,
      annotationId: e.existingAnnotation && e.reference.id,
      newAnnotation: t
    });
  }
  delete(e) {
    this.applyLocalUpdate(
      e,
      /*existing=*/
      true,
      /*commit=*/
      true,
      /*newAnnotation=*/
      null
    );
  }
  update(e, t) {
    this.applyLocalUpdate(
      e,
      /*existing=*/
      true,
      /*commit=*/
      false,
      /*newAnnotation=*/
      t
    );
  }
  notifyChanged(e, t) {
    const i = this.references.get(e), r = this.metadataChunkSource.chunks.get(e);
    r !== void 0 && (r.annotation = t || null), i !== void 0 && (i.value = t || null, i.changed.dispatch(), this.referencesChanged.dispatch({ action: "changed", id: e })), this.chunkManager.chunkQueueManager.visibleChunksChanged.dispatch();
  }
  /**
   * Must be called after `add` or `update` to commit the result.
   */
  commit(e) {
    this.applyLocalUpdate(
      e,
      /*existing=*/
      true,
      /*commit=*/
      true,
      e.value
    );
  }
  updateReference(e) {
    let t = this.references.get(e.id);
    if (t !== void 0)
      t.value = e;
    else {
      let i = new du(e.id);
      this.references.set(e.id, i), i.value = e, this.referencesChanged.dispatch({ action: "update", id: i.id }), i.registerDisposer(() => {
        this.references.delete(i.id), this.referencesChanged.dispatch({ action: "deref", id: i.id });
      });
    }
  }
  hasReference(e) {
    return this.references.has(e);
  }
  getReference(e) {
    let t = this.references.get(e);
    if (t !== void 0)
      return t.addRef();
    t = new du(e), this.references.set(e, t), this.referencesChanged.dispatch({ action: "get", id: e }), this.rpc.invoke(LB, { id: this.rpcId, annotation: e }), t.registerDisposer(() => {
      this.references.delete(e), this.referencesChanged.dispatch({ action: "deref", id: e }), this.rpc.invoke(DB, { id: this.rpcId, annotation: e });
    });
    const i = this.metadataChunkSource.chunks.get(e);
    return i !== void 0 && i.annotation !== null && (t.value = i.annotation), t;
  }
  forEachPossibleChunk(e, t) {
    const i = e.relatedSegments;
    if (i !== void 0) {
      const d = i.length, u = this.segmentFilteredSources;
      for (let f = 0; f < d; ++f) {
        const g = i[f];
        if (g === void 0)
          return;
        const v = u[f];
        for (const y of g) {
          const w = v.chunks.get(sr(y));
          w !== void 0 && t(w);
        }
      }
    }
    const r = this.rank, s = new Float32Array(r), a = new Float32Array(r), l = new Float32Array(r);
    for (const d of this.spatiallyIndexedSources) {
      switch (e.type) {
        case Me.POINT:
          _r(s, d.multiscaleToChunkTransform, r + 1, e.point, r), a.set(s);
          break;
        case Me.LINE:
        case Me.SPHERE:
        case Me.AXIS_ALIGNED_BOUNDING_BOX:
          _r(s, d.multiscaleToChunkTransform, r + 1, e.pointA, r), _r(a, d.multiscaleToChunkTransform, r + 1, e.pointB, r);
          break;
        case Me.ELLIPSOID:
          _r(s, d.multiscaleToChunkTransform, r + 1, e.center, r), E1(a, d.multiscaleToChunkTransform, r + 1, e.radii, r);
          for (let g = 0; g < r; ++g) {
            const v = s[g], y = a[g];
            s[g] = v - y, a[g] = v + y;
          }
          break;
      }
      let u = 1;
      for (let g = 0; g < r; ++g) {
        const v = s[g], y = a[g], w = Math.min(v, y), C = Math.max(v, y);
        s[g] = Math.ceil(w - 1), a[g] = Math.floor(C + 1), u *= a[g] - s[g];
      }
      const f = d.chunks;
      for (let g = 0; g < u; ++g) {
        let v = g;
        for (let w = 0; w < r; ++w) {
          const C = s[w], E = a[w] - C, L = l[w] = v % E;
          v = (v - L) / E;
        }
        const y = f.get(l.join());
        y !== void 0 && t(y);
      }
    }
  }
  static encodeOptions(e) {
    return {};
  }
  handleSuccessfulUpdate(e, t) {
    const i = this.localUpdates.get(e);
    if (i === void 0 || i.commitInProgress === void 0)
      throw new Error("Received invalid successful update notification");
    if (this.updateCommitsInProgress(-1), t !== null && i.reference.id !== t.id) {
      if (i.commitInProgress === null)
        throw new Error("Received invalid successful update notification");
      i.reference.id = t.id, this.references.delete(e), this.references.set(t.id, i.reference.addRef()), this.localUpdates.delete(e), this.localUpdates.set(t.id, i), i.reference.value !== null && (i.reference.value.id = t.id, qd(this.temporary.data, i.type, e, this.annotationPropertySerializers), Yd(this.temporary.data, i.reference.value, this.annotationPropertySerializers)), i.reference.changed.dispatch();
    }
    let r = i.existingAnnotation === void 0;
    i.existingAnnotation = t || void 0, i.commitInProgress = void 0;
    let s = i.pendingCommit;
    i.pendingCommit = void 0, t === null && (s = void 0), s !== void 0 ? (s !== null && (s.id = t.id), this.sendCommitRequest(i, s)) : (this.revertLocalUpdate(i), r ? (this.childAdded.dispatch(t), this.referencesChanged.dispatch({ action: "added", id: t.id })) : t === null ? (this.references.get(e).dispose(), this.childDeleted.dispatch(e), this.referencesChanged.dispatch({ action: "deleted", id: e })) : (this.childUpdated.dispatch(t), this.referencesChanged.dispatch({ action: "updated", id: t.id })));
  }
  disposed() {
    const e = this.commitStatus;
    e !== void 0 && e.dispose();
  }
  updateCommitsInProgress(e) {
    this.numCommitsInProgress += e, this.numCommitsInProgress === 0 ? this.commitStatus !== void 0 && (this.commitStatus.dispose(), this.commitStatus = void 0) : this.commitStatus === void 0 && (this.commitStatus = new nt(
      /*delay=*/
      true
    )).setText("Commiting annotations");
  }
  handleFailedUpdate(e, t) {
    const i = this.localUpdates.get(e);
    if (i === void 0 || i.commitInProgress === void 0)
      throw new Error("Received invalid update notification");
    new nt().setErrorMessage(`Error commiting annotation update: ${t}`), this.revertLocalUpdate(i), this.updateCommitsInProgress(-1);
  }
  revertLocalUpdate(e) {
    qd(this.temporary.data, e.type, e.reference.id, this.annotationPropertySerializers);
    const t = e.existingAnnotation;
    t !== void 0 && this.forEachPossibleChunk(t, (s) => {
      const a = s.data;
      a !== void 0 && Yd(a, t, this.annotationPropertySerializers);
    });
    const i = e.reference, r = i.id;
    i.value = t || null, i.changed.dispatch(), i.dispose(), this.localUpdates.delete(r);
  }
  *[wZr]() {
  }
};
Ut(AB, function(n) {
  const e = this.get(n.id), t = n.annotationId, i = n.error;
  if (i !== void 0)
    e.handleFailedUpdate(t, i);
  else {
    const r = Rv(n.newAnnotation);
    e.handleSuccessfulUpdate(t, r);
  }
});
function jc(n, e) {
  return n < e ? -1 : n > e ? 1 : 0;
}
var ik = {
  offset: 0,
  completions: []
};
function Xo(n, e) {
  return e.offset += n, e;
}
function Up(n, e) {
  let t = [];
  for (let i of e)
    i.startsWith(n) && t.push({ value: i });
  return t.sort((i, r) => jc(i.value, r.value)), t;
}
function Qo(n, e, t, i) {
  let r = [];
  for (let s of e) {
    let a = t(s);
    a.startsWith(n) && r.push({ value: a, description: i(s) });
  }
  return r.sort((s, a) => jc(s.value, a.value)), r;
}
async function iF(n, e, t) {
  if (n.startsWith("{"))
    return ik;
  const r = n.match(/^(?:(.*)[&;])?([^&;]*)$/)[2];
  let s = n.length - r.length;
  const a = r.indexOf("=");
  if (a === -1) {
    const l = await e(r);
    return {
      offset: l.offset + s,
      completions: l.completions.map((d) => RZr(RZr({}, d), { value: `${d.value}=` }))
    };
  }
  return Xo(s + a + 1, await t(r.substring(0, a), r.substring(a + 1)));
}
async function rk(n, e) {
  return iF(n, async (t) => {
    const i = [];
    for (const r of e) {
      const s = r.key;
      s.value.startsWith(t) && i.push(s);
    }
    return { offset: 0, completions: i };
  }, async (t, i) => {
    for (const r of e)
      if (r.key.value === t)
        return { offset: 0, completions: r.values.filter((s) => s.value.startsWith(i)) };
    return ik;
  });
}
var sk = class extends Error {
  constructor(e) {
    super(`Redirected to: ${e}`), this.redirectTarget = e;
  }
};
function ak(n, e) {
  e === void 0 && (n.indexOf("/") === -1 ? e = ":" : e = "/");
  let t = n.lastIndexOf(e);
  return t === -1 ? 0 : t + 1;
}
function rF(n, e) {
  let t = ak(n, e);
  return n.substring(t);
}
var Gr;
(function(n) {
  n[n.annotations = 0] = "annotations", n[n.equivalences = 1] = "equivalences";
})(Gr || (Gr = {}));
function ok() {
  return { url: "", transform: void 0, enableDefaultSubsources: true, subsources: new de() };
}
var ba = class extends Z {
  normalizeUrl(e) {
    return e.url;
  }
  convertLegacyUrl(e) {
    return e.url;
  }
  async completeUrl(e) {
    throw null;
  }
};
var lk = "local://annotations";
var am = "local://equivalences";
var sF = class extends ba {
  get description() {
    return "Local in-memory";
  }
  async get(e) {
    switch (e.url) {
      case lk: {
        const t = e.transform;
        let i;
        if (t === void 0) {
          const r = e.globalCoordinateSpace.value, s = r.rank, a = r.names, l = r.scales, d = r.units, u = mt({
            rank: s,
            scales: l,
            units: d,
            names: a.map((g, v) => `${v}`)
          }), f = mt({ rank: s, scales: l, units: d, names: a });
          i = {
            rank: s,
            sourceRank: s,
            inputSpace: u,
            outputSpace: f,
            transform: Ds(Float64Array, s + 1)
          };
        } else
          i = Qn(To);
        return {
          modelTransform: i,
          canChangeModelSpaceRank: true,
          subsources: [{
            id: "default",
            default: true,
            subsource: {
              local: Gr.annotations
            }
          }]
        };
      }
      case am:
        return {
          modelTransform: Qn(To),
          canChangeModelSpaceRank: false,
          subsources: [{
            id: "default",
            default: true,
            subsource: {
              local: Gr.equivalences
            }
          }]
        };
    }
    throw new Error("Invalid local data source URL");
  }
  async completeUrl(e) {
    return {
      offset: 0,
      completions: Qo(e.providerUrl, [{
        value: "annotations",
        description: "Annotations stored in the JSON state"
      }, {
        value: "equivalences",
        description: "Segmentation equivalence graph stored in the JSON state"
      }], (t) => t.value, (t) => t.description)
    };
  }
};
var BC = /^(?:([a-zA-Z][a-zA-Z0-9-+_]*):\/\/)?(.*)$/;
var aF = class extends Z {
  constructor(e) {
    super(), this.credentialsManager = e, this.dataSources = new de([["local", new sF()]]);
  }
  register(e, t) {
    this.dataSources.set(e, this.registerDisposer(t));
  }
  getProvider(e) {
    const t = e.match(BC);
    if (t === null || t[1] === void 0)
      throw new Error('Data source URL must have the form "<protocol>://<path>".');
    var i = ce(t, 3);
    const r = i[1], s = i[2], a = this.dataSources.get(r);
    if (a === void 0)
      throw new Error(`Unsupported data source: ${se(r)}.`);
    return [a, s, r];
  }
  async get(e) {
    const t = new je();
    var i = e.cancellationToken;
    const r = i === void 0 ? Zt : i;
    let s = e.url;
    for (; ; ) {
      var a = this.getProvider(e.url), l = ce(a, 3);
      const d = l[0], u = l[1], f = l[2];
      t.add(e.url);
      try {
        return d.get(RZr(RZr({}, e), {
          url: s,
          providerProtocol: f,
          providerUrl: u,
          registry: this,
          cancellationToken: r,
          credentialsManager: this.credentialsManager
        }));
      } catch (g) {
        if (g instanceof sk) {
          const v = g.redirectTarget;
          if (t.has(v))
            throw Error(`Layer source redirection contains loop: ${se(De(t))}`);
          if (t.size >= 10)
            throw Error(`Too many layer source redirections: ${se(De(t))}`);
          s = v;
          continue;
        }
        throw g;
      }
    }
  }
  convertLegacyUrl(e) {
    try {
      var t = this.getProvider(e.url), i = ce(t, 3);
      const r = i[0], s = i[1], a = i[2];
      return r.convertLegacyUrl(RZr(RZr({}, e), { providerUrl: s, providerProtocol: a, registry: this }));
    } catch {
      return e.url;
    }
  }
  normalizeUrl(e) {
    try {
      var t = this.getProvider(e.url), i = ce(t, 3);
      const r = i[0], s = i[1], a = i[2];
      return r.normalizeUrl(RZr(RZr({}, e), { providerUrl: s, providerProtocol: a, registry: this }));
    } catch {
      return e.url;
    }
  }
  async completeUrl(e) {
    const t = e.url;
    var i = e.cancellationToken;
    const r = i === void 0 ? Zt : i;
    let s = t.match(BC), a = s[1];
    if (a === void 0)
      return Bt.resolve({
        offset: 0,
        completions: Qo(t, this.dataSources, ([l]) => `${l}://`, ([, l]) => l.description)
      });
    {
      const l = this.dataSources.get(a);
      if (l !== void 0) {
        const d = await l.completeUrl({
          registry: this,
          url: t,
          providerUrl: s[2],
          chunkManager: e.chunkManager,
          cancellationToken: r,
          credentialsManager: this.credentialsManager
        });
        return Xo(a.length + 3, d);
      }
      throw null;
    }
  }
  suggestLayerName(e) {
    var t = this.getProvider(e), i = ce(t, 2);
    let r = i[0], s = i[1];
    s.endsWith("/") && (s = s.substring(0, s.length - 1));
    let a = r.suggestLayerName;
    return a !== void 0 ? a(s) : rF(s);
  }
  findSourceGroup(e) {
    var t = this.getProvider(e), i = ce(t, 3);
    let r = i[0], s = i[1], a = i[2];
    return (r.findSourceGroup || ak)(s) + a.length + 3;
  }
};
var oF = Vv;
var lF = cie;
var cF = z_;
var dF = L5.f;
var ck = function(n) {
  return function(e) {
    for (var t = cF(e), i = lF(t), r = i.length, s = 0, a = [], l; r > s; )
      l = i[s++], (!oF || dF.call(t, l)) && a.push(n ? [l, t[l]] : t[l]);
    return a;
  };
};
var FC = Y_;
var uF = ck(true);
FC(FC.S, "Object", {
  entries: function(e) {
    return uF(e);
  }
});
var hF = xv.Object.entries;
var fF = { default: hF, __esModule: true };
var Jc = Gs(fF);
var pF = bh;
var zp = rFn.getWeak;
var gF = W5;
var UC = X_;
var mF = Ch;
var vF = jo;
var dk = Cv;
var zC = pw;
var GC = ma;
var yF = dk(5);
var SF = dk(6);
var bF = 0;
var Kd = function(n) {
  return n._l || (n._l = new uk());
};
var uk = function() {
  this.a = [];
};
var Gp = function(n, e) {
  return yF(n.a, function(t) {
    return t[0] === e;
  });
};
uk.prototype = {
  get: function(n) {
    var e = Gp(this, n);
    if (e)
      return e[1];
  },
  has: function(n) {
    return !!Gp(this, n);
  },
  set: function(n, e) {
    var t = Gp(this, n);
    t ? t[1] = e : this.a.push([n, e]);
  },
  delete: function(n) {
    var e = SF(this.a, function(t) {
      return t[0] === n;
    });
    return ~e && this.a.splice(e, 1), !!~e;
  }
};
var hk = {
  getConstructor: function(n, e, t, i) {
    var r = n(function(s, a) {
      mF(s, r, e, "_i"), s._t = e, s._i = bF++, s._l = void 0, a != null && vF(a, t, s[i], s);
    });
    return pF(r.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      delete: function(s) {
        if (!UC(s))
          return false;
        var a = zp(s);
        return a === true ? Kd(GC(this, e)).delete(s) : a && zC(a, this._i) && delete a[this._i];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function(a) {
        if (!UC(a))
          return false;
        var l = zp(a);
        return l === true ? Kd(GC(this, e)).has(a) : l && zC(l, this._i);
      }
    }), r;
  },
  def: function(n, e, t) {
    var i = zp(gF(e), true);
    return i === true ? Kd(n).set(e, t) : i[n._i] = t, n;
  },
  ufstore: Kd
};
var $C = hk;
var CF = ma;
var WC = "WeakSet";
wh(WC, function(n) {
  return function() {
    return n(this, arguments.length > 0 ? arguments[0] : void 0);
  };
}, {
  // 23.4.3.1 WeakSet.prototype.add(value)
  add: function(e) {
    return $C.def(CF(this, WC), e, true);
  }
}, $C, false, true);
xh("WeakSet");
Eh("WeakSet");
var wF = xv.WeakSet;
var xF = { default: wF, __esModule: true };
var EF = Gs(xF);
var TF = RE;
var kF = Nct;
var IF = "Expected a function";
function LF(n, e, t) {
  var i = true, r = true;
  if (typeof n != "function")
    throw new TypeError(IF);
  return kF(t) && (i = "leading" in t ? !!t.leading : i, r = "trailing" in t ? !!t.trailing : r), TF(n, e, {
    leading: i,
    maxWait: e,
    trailing: r
  });
}
var DF = LF;
var zh = Gs(DF);
function PF(n) {
  return typeof n == "boolean" ? { enabled: n } : (pe(n), { enabled: Ce(n, "enabled", la) });
}
function ac(n, e = void 0) {
  return typeof n == "string" ? {
    url: n,
    transform: e,
    enableDefaultSubsources: true,
    subsources: new de()
  } : (pe(n), {
    url: K(n, "url", Le),
    transform: K(n, "transform", F1) || e,
    enableDefaultSubsources: Ce(n, "enableDefaultSubsources", la, true),
    subsources: Ce(n, "subsources", (t) => Dh(t, PF), new de())
  });
}
function AF(n) {
  return n.enabled;
}
function HC(n) {
  const e = U1(n.transform), t = {};
  let i = true;
  for (const s of n.subsources) {
    var r = ce(s, 2);
    const a = r[0], l = r[1], d = AF(l);
    d !== void 0 && (t[a] = d, i = false);
  }
  return e === void 0 && i && n.enableDefaultSubsources === true ? n.url : {
    url: n.url,
    transform: e,
    subsources: i ? void 0 : t,
    enableDefaultSubsources: n.enableDefaultSubsources === true ? void 0 : false
  };
}
var RF = class {
  constructor(e, t, i, r, s) {
    this.loadedDataSource = e, this.subsourceEntry = t, this.subsourceSpec = i, this.subsourceIndex = r, this.activated = void 0, this.guardValues = [], this.messages = new qo(), this.isActiveChanged = new Ee();
    let a;
    i === void 0 || i.enabled === void 0 ? a = t.default && s : a = i.enabled;
    const l = e.dataSource.modelTransform.sourceRank;
    let d = t.modelSubspaceDimensionIndices;
    if (d === void 0) {
      d = new Array(l);
      for (let g = 0; g < l; ++g)
        d[g] = g;
    }
    var u = t.subsourceToModelSubspaceTransform;
    const f = u === void 0 ? Ds(Float32Array, d.length + 1) : u;
    this.enabled = a, this.subsourceToModelSubspaceTransform = f, this.modelSubspaceDimensionIndices = d, this.isActiveChanged.add(e.activatedSubsourcesChanged.dispatch);
  }
  activate(e, ...t) {
    if (this.messages.clearMessages(), this.activated !== void 0) {
      if (Fe(t, this.guardValues))
        return;
      this.activated.dispose();
    }
    this.guardValues = t;
    const i = this.activated = new Z();
    e(i), this.isActiveChanged.dispatch();
  }
  deactivate(e) {
    this.messages.clearMessages(), this.messages.addMessage({ severity: cr.error, message: e });
    const t = this.activated;
    t !== void 0 && (this.activated = void 0, t.dispose(), this.isActiveChanged.dispatch());
  }
  addRenderLayer(e) {
    const t = this.activated;
    t.registerDisposer(this.loadedDataSource.layer.addRenderLayer(e)), t.registerDisposer(this.messages.addChild(e.messages));
  }
  getRenderLayerTransform(e) {
    const t = this.activated;
    var i = this.loadedDataSource;
    const r = i.layer, s = i.transform;
    return t.registerDisposer(G1(r.manager.root.coordinateSpace, r.localPosition.coordinateSpace, s, this, e));
  }
};
var fy = class extends Z {
  constructor(e, t, i) {
    super(), this.layerDataSource = e, this.dataSource = t, this.error = void 0, this.enabledSubsourcesChanged = new Ee(), this.activatedSubsourcesChanged = new Ee(), this.messages = new qo(), t.canChangeModelSpaceRank ? (this.transform = new sC(Qn(mt({ rank: 0, scales: new Float64Array(0), units: [], names: [] })), true), this.transform.value = t.modelTransform) : this.transform = new sC(t.modelTransform), i.transform !== void 0 && (this.transform.spec = i.transform);
    const r = i.subsources;
    this.enableDefaultSubsources = i.enableDefaultSubsources, this.subsources = t.subsources.map((s, a) => new RF(this, s, r.get(s.id), a, this.enableDefaultSubsources));
  }
  get enabledSubsources() {
    return this.subsources.filter((e) => e.enabled);
  }
  get layer() {
    return this.layerDataSource.layer;
  }
  disposed() {
    for (const e of this.subsources) {
      const t = e.activated;
      t !== void 0 && (e.activated = void 0, t.dispose());
    }
  }
};
var MF = class extends Z {
  constructor(e, t = void 0) {
    super(), this.layer = e, this.changed = new Ee(), this.messages = new qo(), this.loadState_ = void 0, this.specGeneration = -1, this.refCounted_ = void 0, this.registerDisposer(this.changed.add(e.dataSourcesChanged.dispatch)), t === void 0 ? this.spec_ = ok() : this.spec = t;
  }
  get spec() {
    const e = this.loadState;
    if (e !== void 0 && e.error === void 0) {
      const t = this.changed.count;
      t !== this.specGeneration && (this.specGeneration = t, this.spec_ = {
        url: this.spec.url,
        transform: e.transform.spec,
        enableDefaultSubsources: e.enableDefaultSubsources,
        subsources: new de(De(e.subsources, (i) => {
          const r = e.enableDefaultSubsources && i.subsourceEntry.default;
          return [i.subsourceEntry.id, {
            enabled: i.enabled !== r ? i.enabled : void 0
          }];
        }))
      });
    }
    return this.spec_;
  }
  get loadState() {
    return this.loadState_;
  }
  set spec(e) {
    const t = this.layer;
    if (this.messages.clearMessages(), e.url.length === 0) {
      if (t.dataSources.length !== 1) {
        const d = t.dataSources.indexOf(this);
        if (d !== -1) {
          t.dataSources.splice(d, 1), t.dataSourcesChanged.dispatch(), this.dispose();
          return;
        }
      }
      this.spec_ = e, this.refCounted_ !== void 0 && (this.refCounted_.dispose(), this.refCounted_ = void 0, this.loadState_ = void 0, this.changed.dispatch());
      return;
    }
    const i = new Z(), r = i.registerDisposer(_E(t.markLoading()));
    this.refCounted_ !== void 0 && (this.refCounted_.dispose(), this.loadState_ = void 0), this.refCounted_ = i, this.spec_ = e;
    const s = t.manager.chunkManager, a = t.manager.dataSourceProviderRegistry, l = new As();
    this.messages.addMessage({ severity: cr.info, message: "Loading data source" }), a.get({
      chunkManager: s,
      url: e.url,
      cancellationToken: l,
      globalCoordinateSpace: t.manager.root.coordinateSpace,
      transform: e.transform
    }).then((d) => {
      if (i.wasDisposed)
        return;
      this.messages.clearMessages();
      const u = i.registerDisposer(new fy(this, d, e));
      u.registerDisposer(t.addCoordinateSpace(u.transform.outputSpace)), u.registerDisposer(u.transform.changed.add(this.changed.dispatch)), this.loadState_ = u, u.registerDisposer(u.enabledSubsourcesChanged.add(this.changed.dispatch)), this.changed.dispatch(), r();
    }).catch((d) => {
      this.wasDisposed || (this.loadState_ = { error: d }, this.messages.clearMessages(), this.messages.addMessage({ severity: cr.error, message: d.message }), this.changed.dispatch());
    }), i.registerDisposer(() => {
      l.cancel();
    }), this.changed.dispatch();
  }
  disposed() {
    const e = this.refCounted_;
    e !== void 0 && e.dispose();
  }
  toJSON() {
    const e = this.loadState;
    return e === void 0 || e.error !== void 0 ? HC(this.spec) : HC({
      url: this.spec.url,
      transform: e.transform.spec,
      enableDefaultSubsources: e.enableDefaultSubsources,
      subsources: new de(De(e.subsources, (t) => {
        const i = e.enableDefaultSubsources && t.subsourceEntry.default;
        return [t.subsourceEntry.id, {
          enabled: t.enabled !== i ? t.enabled : void 0
        }];
      }))
    });
  }
};
var $p;
var jC;
function NF() {
  return jC || (jC = 1, $p = Object.is || function(e, t) {
    return e === t ? e !== 0 || 1 / e === 1 / t : e != e && t != t;
  }), $p;
}
var JC = Y_;
JC(JC.S, "Object", { is: NF() });
var _F = xv.Object.is;
var OF = { default: _F, __esModule: true };
var YC = Gs(OF);
var Wp;
var qC;
function VF() {
  return qC || (qC = 1, Wp = Math.sign || function(e) {
    return (e = +e) == 0 || e != e ? e : e < 0 ? -1 : 1;
  }), Wp;
}
var KC = Y_;
KC(KC.S, "Math", { sign: VF() });
var BF = xv.Math.sign;
var FF = { default: BF, __esModule: true };
var Ec = Gs(FF);
var ZC = fw;
var UF = Cv(0);
var zF = Ndt;
var fk = rFn;
var GF = tvn;
var Gh = hk;
var pk = X_;
var XC = ma;
var $F = ma;
var WF = !ZC.ActiveXObject && "ActiveXObject" in ZC;
var Uu = "WeakMap";
var HF = fk.getWeak;
var jF = Object.isExtensible;
var JF = Gh.ufstore;
var Hp;
var gk = function(n) {
  return function() {
    return n(this, arguments.length > 0 ? arguments[0] : void 0);
  };
};
var mk = {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function(e) {
    if (pk(e)) {
      var t = HF(e);
      return t === true ? JF(XC(this, Uu)).get(e) : t ? t[this._i] : void 0;
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function(e, t) {
    return Gh.def(XC(this, Uu), e, t);
  }
};
var YF = wh(Uu, gk, mk, Gh, true, true);
$F && WF && (Hp = Gh.getConstructor(gk, Uu), GF(Hp.prototype, mk), fk.NEED = true, UF(["delete", "has", "get", "set"], function(n) {
  var e = YF.prototype, t = e[n];
  zF(e, n, function(i, r) {
    if (pk(i) && !jF(i)) {
      this._f || (this._f = new Hp());
      var s = this._f[n](i, r);
      return n == "set" ? this : s;
    }
    return t.call(this, i, r);
  });
}));
xh("WeakMap");
Eh("WeakMap");
var qF = xv.WeakMap;
var KF = { default: qF, __esModule: true };
var vk = Gs(KF);
function In(n, e, t) {
  Ce(n, e, (i) => t.restoreState(i));
}
var $h = class extends Z {
  constructor() {
    super(...arguments), this.children = new de(), this.changed = new Ee();
  }
  add(e, t) {
    if (this.children.has(e))
      throw new Error(`Key ${se(e)} already registered.`);
    return this.children.set(e, t), t.changed.add(this.changed.dispatch), this.changed.dispatch(), () => {
      this.remove(e);
    };
  }
  remove(e) {
    const t = this.children;
    if (t.has(e))
      throw new Error(`Key ${se(e)} not registered.`);
    const i = t.get(e);
    this.children.delete(e), i.changed.remove(this.changed.dispatch), this.changed.dispatch();
  }
  disposed() {
    const e = this.changed;
    for (let t of this.children.values())
      t.changed.remove(e.dispatch);
    this.children = void 0, super.disposed();
  }
  toJSON() {
    const e = this.baseJSON();
    for (let i of this.children) {
      var t = ce(i, 2);
      let r = t[0], s = t[1];
      e[r] = s.toJSON();
    }
    return e;
  }
  baseJSON() {
    return {};
  }
  reset() {
    for (let e of this.children.values())
      e.reset();
  }
  restoreState(e) {
    pe(e);
    for (let i of this.children) {
      var t = ce(i, 2);
      let r = t[0], s = t[1];
      try {
        if (e.hasOwnProperty(r)) {
          const a = e[r];
          if (a === void 0)
            continue;
          s.restoreState(a);
        }
      } catch (a) {
        throw new Error(`Error restoring property ${se(r)}: ${a.message}`);
      }
    }
  }
};
var QC = new vk();
function Wh(n) {
  let e = QC.get(n);
  const t = n.changed.count;
  if (e !== void 0 && e.generation === t)
    return e;
  let i;
  if (n instanceof $h) {
    i = n.baseJSON();
    for (let s of n.children) {
      var r = ce(s, 2);
      let a = r[0], l = r[1];
      i[a] = Wh(l).value;
    }
  } else
    i = n.toJSON();
  return e === void 0 ? (e = { generation: t, value: i }, QC.set(n, e)) : (e.generation = t, e.value = i), e;
}
var Hh = class {
  constructor(e, t, i = t) {
    this.enumType = e, this.value_ = t, this.defaultValue = i, this.changed = new Ee();
  }
  set value(e) {
    this.value_ !== e && (this.value_ = e, this.changed.dispatch());
  }
  get value() {
    return this.value_;
  }
  reset() {
    this.value = this.defaultValue;
  }
  restoreState(e) {
    this.value = Pn(e, this.enumType);
  }
  toJSON() {
    if (this.value_ !== this.defaultValue)
      return this.enumType[this.value_].toLowerCase();
  }
};
var Wt;
(function(n) {
  n[n.LINKED = 0] = "LINKED", n[n.RELATIVE = 1] = "RELATIVE", n[n.UNLINKED = 2] = "UNLINKED";
})(Wt || (Wt = {}));
var zu;
(function(n) {
  n[n.LINKED = 0] = "LINKED", n[n.UNLINKED = 2] = "UNLINKED";
})(zu || (zu = {}));
var ZF = class extends Hh {
  constructor(e = Wt.LINKED) {
    super(Wt, e);
  }
};
var XF = class extends Hh {
  constructor(e = zu.LINKED) {
    super(zu, e);
  }
};
var Zd = _e();
var yk = $n();
function Yc(n, e, t, i) {
  let r = false, s;
  n.registerDisposer(e);
  const a = () => {
    switch (r = true, t.value) {
      case Wt.UNLINKED:
        if (i.isValid(n))
          break;
      case Wt.LINKED:
        i.assign(n, e);
        break;
      case Wt.RELATIVE:
        i.add(n, e, s);
        break;
    }
    r = false;
  }, l = () => {
    if (!r)
      switch (t.value) {
        case Wt.UNLINKED:
          break;
        case Wt.LINKED:
          i.assign(e, n);
          break;
        case Wt.RELATIVE:
          i.subtract(e, n, s);
          break;
      }
  };
  let d = Wt.UNLINKED;
  const u = () => {
    const f = t.value;
    if (f !== d)
      switch (f) {
        case Wt.UNLINKED:
          s = void 0;
          break;
        case Wt.LINKED:
          s = void 0, i.assign(n, e);
          break;
        case Wt.RELATIVE:
          s = i.difference(n, e);
          break;
      }
    d = f, n.changed.dispatch();
  };
  return n.registerDisposer(n.changed.add(l)), n.registerDisposer(e.changed.add(a)), n.registerDisposer(t.changed.add(u)), u(), n;
}
function Sk(n, e, t, i) {
  return Yc(n, e, t, i);
}
var ea = class extends Z {
  constructor(e) {
    super(), this.coordinateSpace = e, this.coordinates_ = Eo, this.changed = new Ee(), this.registerDisposer(e.changed.add(() => {
      this.handleCoordinateSpaceChanged();
    }));
  }
  get valid() {
    return this.coordinateSpace.value.valid;
  }
  /**
   * Returns the position in voxels.
   */
  get value() {
    return this.handleCoordinateSpaceChanged(), this.coordinates_;
  }
  reset() {
    this.curCoordinateSpace = void 0, this.coordinates_ = Eo, this.changed.dispatch();
  }
  set value(e) {
    const t = this.curCoordinateSpace;
    if (t === void 0 || !t.valid || t.rank !== e.length)
      return;
    this.coordinates_.set(e), this.changed.dispatch();
  }
  handleCoordinateSpaceChanged() {
    const e = this.coordinateSpace.value, t = this.curCoordinateSpace;
    if (e === t)
      return;
    this.curCoordinateSpace = e;
    const i = e.rank;
    if (!e.valid)
      return;
    if (t === void 0 || !t.valid) {
      let f = this.coordinates_;
      if (!(f !== void 0 && f.length === i)) {
        f = this.coordinates_ = new Float32Array(i), O2(f, e.bounds);
        for (let g = 0; g < i; ++g)
          f[g] = Math.floor(f[g]) + 0.5;
      }
      this.changed.dispatch();
      return;
    }
    const r = new Float32Array(i), s = this.coordinates_, a = e.ids, l = e.scales, d = t.ids, u = t.scales;
    for (let f = 0; f < i; ++f) {
      const g = a[f], v = d.indexOf(g);
      v === -1 ? r[f] = A1(e.bounds.lowerBounds[f], e.bounds.upperBounds[f]) : r[f] = s[v] * (u[v] / l[f]);
    }
    this.coordinates_ = r, this.changed.dispatch();
  }
  toJSON() {
    if (!this.valid && this.coordinates_.length === 0)
      return;
    this.handleCoordinateSpaceChanged();
    const e = this.value;
    if (e.length !== 0)
      return De(e);
  }
  restoreState(e) {
    if (e === void 0) {
      this.reset();
      return;
    }
    this.curCoordinateSpace = void 0, this.coordinates_ = Float32Array.from(Je(e, Lt)), this.handleCoordinateSpaceChanged(), this.changed.dispatch();
  }
  snapToVoxel() {
    this.handleCoordinateSpaceChanged();
    const e = this.coordinates_, t = e.length;
    for (let i = 0; i < t; ++i)
      e[i] = Math.floor(e[i]) + 0.5;
    this.changed.dispatch();
  }
  assign(e) {
    e.handleCoordinateSpaceChanged();
    const t = e.curCoordinateSpace, i = e.coordinates_;
    this.curCoordinateSpace = t, this.coordinates_ = Float32Array.from(i), this.changed.dispatch();
  }
  /**
   * Get the offset of `a` relative to `b`.
   */
  static getOffset(e, t) {
    const i = e.coordinates_, r = t.coordinates_;
    if (i.length === r.length)
      return zg(new Float32Array(i.length), i, r);
  }
  static addOffset(e, t, i, r = 1) {
    e.handleCoordinateSpaceChanged();
    const s = t.value;
    i !== void 0 && s.length === i.length && (I2(e.value, s, i, r), e.changed.dispatch());
  }
  get legacyJsonView() {
    const e = this;
    return {
      changed: e.changed,
      toJSON() {
        return e.toJSON();
      },
      reset() {
        e.reset();
      },
      restoreState(t) {
        if (t === void 0 || Array.isArray(t)) {
          e.restoreState(t);
          return;
        }
        pe(t), In(t, "voxelCoordinates", e);
      }
    };
  }
};
function bk(n, e, t) {
  if (t === void 0 || un(t).length === 0) {
    n.value = Wt.LINKED;
    return;
  }
  pe(t), n.value = Wt.UNLINKED, K(t, "value", (i) => {
    i !== void 0 && e.restoreState(i);
  }), K(t, "link", (i) => n.restoreState(i));
}
var qc = class {
  constructor(e, t = new ZF()) {
    this.peer = e, this.link = t;
  }
  get changed() {
    return this.value.changed;
  }
  toJSON() {
    const e = this.link;
    if (e.value !== Wt.LINKED)
      return { link: e.toJSON(), value: this.getValueJson() };
  }
  getValueJson() {
    return this.value.toJSON();
  }
  reset() {
    this.link.value = Wt.LINKED;
  }
  restoreState(e) {
    bk(this.link, this.value, e);
  }
  copyToPeer() {
    this.link.value !== Wt.LINKED && (this.link.value = Wt.UNLINKED, this.peer.assign(this.value), this.link.value = Wt.LINKED);
  }
};
var Ck = class extends qc {
  constructor(e, t = new XF()) {
    super(e, t);
  }
};
var wk = class extends qc {
  constructor() {
    super(...arguments), this.value = Yc(new ea(this.peer.coordinateSpace), this.peer, this.link, {
      assign: (e, t) => e.assign(t),
      isValid: (e) => e.valid,
      difference: ea.getOffset,
      add: ea.addOffset,
      subtract: (e, t, i) => {
        ea.addOffset(e, t, i, -1);
      }
    });
  }
};
function QF(n) {
  return n[0] === 0 && n[1] === 0 && n[2] === 0 && n[3] === 1;
}
var _o = class __o extends Z {
  constructor(e) {
    super(), this.changed = new Ee(), e == null && (e = $n()), this.orientation = e;
  }
  toJSON() {
    let e = this.orientation;
    if (dc(this.orientation, this.orientation), !QF(e))
      return Array.prototype.slice.call(this.orientation);
  }
  restoreState(e) {
    try {
      go(this.orientation, e), dc(this.orientation, this.orientation);
    } catch {
      zb(this.orientation);
    }
    this.changed.dispatch();
  }
  reset() {
    zb(this.orientation), this.changed.dispatch();
  }
  snap() {
    let e = Mc();
    UE(e, this.orientation);
    let t = [false, false, false];
    for (let i = 0; i < 3; ++i) {
      let r = 0, s = 0;
      for (let a = 0; a < 3; ++a) {
        let l = e[i * 3 + a];
        e[i * 3 + a] = 0, !t[a] && Math.abs(l) > Math.abs(r) && (r = l, s = a);
      }
      e[i * 3 + s] = Ec(r), t[s] = true;
    }
    jE(this.orientation, e), this.changed.dispatch();
  }
  /**
   * Returns a new OrientationState with orientation fixed to peerToSelf * peer.orientation.  Any
   * changes to the returned OrientationState will cause a corresponding change in peer, and vice
   * versa.
   */
  static makeRelative(e, t) {
    let i = new __o(ys($n(), e.orientation, t)), r = false;
    i.registerDisposer(e.changed.add(() => {
      r || (s = true, ys(i.orientation, e.orientation, t), i.changed.dispatch(), s = false);
    }));
    let s = false;
    const a = xu($n(), t);
    return i.registerDisposer(i.changed.add(() => {
      s || (r = true, ys(e.orientation, i.orientation, a), e.changed.dispatch(), r = false);
    })), i;
  }
  assign(e) {
    p_(this.orientation, e.orientation), this.changed.dispatch();
  }
};
var om = class extends qc {
  constructor() {
    super(...arguments), this.value = Yc(new _o(), this.peer, this.link, {
      assign: (e, t) => e.assign(t),
      isValid: () => true,
      difference: (e, t) => {
        const i = $n();
        return ys(i, xu(i, t.orientation), e.orientation);
      },
      add: (e, t, i) => {
        ys(e.orientation, t.orientation, i), e.changed.dispatch();
      },
      subtract: (e, t, i) => {
        ys(e.orientation, t.orientation, xu(yk, i)), e.changed.dispatch();
      }
    });
  }
};
var xk = class extends Z {
  constructor(e) {
    super(), this.coordinateSpace = e, this.changed = new Ee(), this.curCoordinateSpace = zr, this.value_ = { factors: new Float64Array(0) }, this.registerDisposer(e.changed.add(() => this.update())), this.update();
  }
  get value() {
    return this.update();
  }
  reset() {
    this.value_ = { factors: new Float64Array(0) }, this.curCoordinateSpace = zr, this.changed.dispatch();
  }
  toJSON() {
    const e = {};
    let t = false;
    const r = this.value.factors;
    var s = this.curCoordinateSpace;
    const a = s.names, l = s.rank;
    for (let d = 0; d < l; ++d) {
      const u = r[d];
      u !== 1 && (e[a[d]] = u, t = true);
    }
    if (t)
      return e;
  }
  restoreState(e) {
    const t = this.coordinateSpace.value, i = t.names, r = t.rank, s = new Float64Array(r);
    if (s.fill(-1), e !== void 0) {
      const a = pe(e);
      for (let l = 0; l < r; ++l)
        s[l] = K(a, i[l], (d) => d === void 0 ? 1 : vn(d));
    }
    this.value_ = { factors: s }, this.curCoordinateSpace = t, this.changed.dispatch();
  }
  setFactors(e) {
    const t = this.coordinateSpace.value;
    e.length === t.rank && (this.value_ = { factors: e }, this.curCoordinateSpace = t, this.changed.dispatch());
  }
  update() {
    const e = this.coordinateSpace.value;
    let t = this.value_;
    const i = this.curCoordinateSpace;
    if (i === e)
      return t;
    const r = i.ids, s = e.ids, a = e.rank, l = t.factors, d = new Float64Array(a);
    d.fill(1);
    for (let u = 0; u < a; ++u) {
      const f = s[u], g = r.indexOf(f);
      g !== -1 && (d[u] = l[g]);
    }
    return Fe(d, l) || (t = this.value_ = { factors: d }, this.curCoordinateSpace = e, this.changed.dispatch()), t;
  }
  assign(e) {
    this.setFactors(e.value.factors);
  }
};
function ew(n, e, t, i, r) {
  if (t === i)
    return e;
  const s = t.ids, a = i.rank, l = i.ids, d = new n(a);
  for (let u = 0; u < a; ++u) {
    const f = l[u], g = s.indexOf(f);
    d[u] = g === -1 ? r(u) : e[g];
  }
  return d;
}
var e3 = class extends qc {
  constructor() {
    super(...arguments), this.value = Yc(new xk(this.peer.coordinateSpace), this.peer, this.link, {
      assign: (e, t) => e.assign(t),
      difference: (e, t) => {
        const i = e.value.factors, r = e.coordinateSpace.value, s = t.value.factors;
        return {
          coordinateSpace: r,
          offsets: zg(new Float64Array(i.length), i, s)
        };
      },
      add: (e, t, i) => {
        const r = ew(Float64Array, i.offsets, i.coordinateSpace, e.coordinateSpace.value, () => 0);
        e.setFactors(L1(new Float64Array(r.length), r, t.value.factors));
      },
      subtract: (e, t, i) => {
        const r = ew(Float64Array, i.offsets, i.coordinateSpace, e.coordinateSpace.value, () => 0);
        e.setFactors(zg(new Float64Array(r.length), t.value.factors, r));
      },
      isValid: () => true
    });
  }
};
function tw(n, e, t) {
  const i = n.rank, r = n.names, s = n.units, a = e.displayRank, l = e.displayDimensionIndices, d = new Float64Array(3);
  let u = new Float64Array(3), f;
  const g = t.factors, v = new Array(3), y = new Float64Array(3);
  if (d.fill(1), u.fill(1), y.fill(1), v.fill(""), a === 0)
    f = 1;
  else {
    f = Number.POSITIVE_INFINITY;
    const w = n.scales;
    for (let C = 0; C < a; ++C) {
      const b = l[C], E = u[C] = g[b] * w[b];
      f = Math.min(f, E), v[C] = s[b], y[C] = w[b];
    }
    for (let C = 0; C < a; ++C)
      d[C] = u[C] / f;
  }
  return {
    globalRank: i,
    globalDimensionNames: r,
    displayRank: a,
    displayDimensionIndices: l,
    displayDimensionUnits: v,
    displayDimensionScales: y,
    canonicalVoxelFactors: d,
    voxelPhysicalScales: u,
    canonicalVoxelPhysicalSize: f
  };
}
function t3(n, e) {
  return Fe(n.globalDimensionNames, e.globalDimensionNames) && Fe(n.displayDimensionIndices, e.displayDimensionIndices) && Fe(n.canonicalVoxelFactors, e.canonicalVoxelFactors) && Fe(n.voxelPhysicalScales, e.voxelPhysicalScales) && n.canonicalVoxelPhysicalSize === e.canonicalVoxelPhysicalSize && Fe(n.displayDimensionUnits, e.displayDimensionUnits) && Fe(n.displayDimensionScales, e.displayDimensionScales);
}
var Ek = class extends Z {
  constructor(e, t) {
    super(), this.relativeDisplayScales = e, this.displayDimensions = t, this.changed = new Ee(), this.curRelativeDisplayScales = this.relativeDisplayScales.value, this.curDisplayDimensions = this.displayDimensions.value, this.curCoordinateSpace = this.relativeDisplayScales.coordinateSpace.value, this.value_ = tw(this.curCoordinateSpace, this.curDisplayDimensions, this.curRelativeDisplayScales), this.registerDisposer(e), this.registerDisposer(t);
    const i = () => {
      this.value;
    };
    this.registerDisposer(e.changed.add(i)), this.registerDisposer(t.changed.add(i));
  }
  get value() {
    var e = this.relativeDisplayScales;
    const t = e.value, i = e.coordinateSpace.value, r = this.displayDimensions.value, s = this.curRelativeDisplayScales, a = this.curDisplayDimensions, l = this.curCoordinateSpace;
    let d = this.value_;
    if (s !== t || a !== r || l !== i) {
      this.curRelativeDisplayScales = t, this.curDisplayDimensions = r, this.curCoordinateSpace = i;
      const u = tw(i, r, t);
      t3(d, u) || (this.value_ = d = u, this.changed.dispatch());
    }
    return d;
  }
};
var Tk = class extends Z {
  constructor(e) {
    super(), this.coordinateSpace = e, this.changed = new Ee(), this.default_ = true, this.value_ = void 0, this.registerDisposer(this.coordinateSpace.changed.add(this.changed.dispatch)), this.update();
  }
  get value() {
    return this.update(), this.value_;
  }
  update() {
    const e = this.coordinateSpace.value, t = this.value_;
    if (t !== void 0 && t.coordinateSpace === e)
      return;
    if (t === void 0 || this.default_) {
      this.setToDefault(e);
      return;
    }
    const i = new Int32Array(3), r = t.coordinateSpace.ids, s = e.ids, a = t.displayDimensionIndices, l = t.displayRank;
    let d = 0;
    for (let u = 0; u < l; ++u) {
      const f = s.indexOf(r[a[u]]);
      f !== -1 && (i[d] = f, ++d);
    }
    if (i.fill(-1, d), d === 0) {
      this.default_ = true, this.setToDefault(e);
      return;
    }
    this.assignValue(e, d, i), this.changed.dispatch();
  }
  setToDefault(e) {
    const t = Math.min(e.rank, 3), i = new Int32Array(3);
    i.fill(-1);
    for (let r = 0; r < t; ++r)
      i[r] = r;
    this.assignValue(e, t, i);
  }
  assignValue(e, t, i) {
    this.value_ = {
      coordinateSpace: e,
      displayRank: t,
      displayDimensionIndices: i
    }, this.changed.dispatch();
  }
  reset() {
    this.default_ = true, this.value_ = void 0, this.changed.dispatch();
  }
  restoreState(e) {
    if (e === void 0) {
      this.reset();
      return;
    }
    const t = zv(e);
    if (t.length > 3)
      throw new Error("Number of spatial dimensions must be <= 3");
    const i = this.coordinateSpace.value, r = new Int32Array(3);
    r.fill(-1);
    const s = i.names;
    let a = 0;
    for (const l of t) {
      const d = s.indexOf(l);
      d !== -1 && (r[a++] = d);
    }
    if (a === 0) {
      this.reset();
      return;
    }
    this.default_ = false, this.assignValue(i, a, r);
  }
  get default() {
    return this.update(), this.default_;
  }
  set default(e) {
    this.default_ !== e && (e ? (this.default_ = true, this.setToDefault(this.coordinateSpace.value)) : (this.default_ = false, this.changed.dispatch()));
  }
  setDimensionIndices(e, t) {
    this.default_ = false, this.assignValue(this.coordinateSpace.value, e, t);
  }
  toJSON() {
    if (this.default_)
      return;
    const e = this.value, t = [], i = e.displayRank, r = e.displayDimensionIndices, s = e.coordinateSpace.names;
    if (i !== 0) {
      for (let a = 0; a < i; ++a)
        t[a] = s[r[a]];
      return t;
    }
  }
  assign(e) {
    if (e.default)
      this.default = true;
    else {
      var t = e.value;
      const i = t.displayRank, r = t.displayDimensionIndices;
      this.setDimensionIndices(i, r);
    }
  }
};
var n3 = class extends Ck {
  constructor(e) {
    super(e), this.value = Sk(new Tk(this.peer.coordinateSpace), this.peer, this.link, {
      assign: (t, i) => t.assign(i),
      isValid: () => true
    });
  }
};
var Oo = class extends Z {
  constructor(e, t, i) {
    super(), this.position = e, this.displayDimensionRenderInfo = t, this.orientation = i, this.changed = new Ee(), this.registerDisposer(e), this.registerDisposer(i), this.registerDisposer(t), this.registerDisposer(e.changed.add(this.changed.dispatch)), this.registerDisposer(i.changed.add(this.changed.dispatch)), this.registerDisposer(t.changed.add(this.changed.dispatch));
  }
  get displayDimensions() {
    return this.displayDimensionRenderInfo.displayDimensions;
  }
  get relativeDisplayScales() {
    return this.displayDimensionRenderInfo.relativeDisplayScales;
  }
  get valid() {
    return this.position.valid;
  }
  /**
   * Resets everything.
   */
  reset() {
    this.position.reset(), this.orientation.reset(), this.displayDimensions.reset();
  }
  updateDisplayPosition(e, t = Zd) {
    var i = this.position;
    const r = i.coordinateSpace.value, s = i.value;
    var a = this.displayDimensions.value;
    const l = a.displayDimensionIndices, d = a.displayRank;
    if (r === void 0)
      return false;
    t.fill(0);
    for (let u = 0; u < d; ++u) {
      const f = l[u];
      t[u] = s[f];
    }
    if (e(t) !== false) {
      for (let u = 0; u < d; ++u) {
        const f = l[u];
        s[f] = t[u];
      }
      return this.position.changed.dispatch(), true;
    }
    return false;
  }
  // Transform from view coordinates to global spatial coordinates.
  toMat4(e, t) {
    r_(e, this.orientation.orientation);
    const i = this.position.value;
    var r = this.displayDimensionRenderInfo.value;
    const s = r.canonicalVoxelFactors, a = r.displayDimensionIndices;
    for (let l = 0; l < 3; ++l) {
      const d = a[l], u = t / s[l];
      e[l] *= u, e[4 + l] *= u, e[8 + l] *= u, e[12 + l] = i[d] || 0;
    }
  }
  toMat3(e, t) {
    UE(e, this.orientation.orientation);
    var i = this.displayDimensionRenderInfo.value;
    const r = i.canonicalVoxelFactors, s = i.displayRank;
    for (let a = 0; a < s; ++a) {
      const l = t / r[a];
      e[a] *= l, e[3 + a] *= l, e[6 + a] *= l;
    }
  }
  /**
   * Snaps the orientation to the nearest axis-aligned orientation, and
   * snaps the position to the nearest voxel.
   */
  snap() {
    this.orientation.snap(), this.position.snapToVoxel(), this.changed.dispatch();
  }
  translateDimensionRelative(e, t) {
    if (!this.valid)
      return;
    const i = this.position, r = i.value;
    var s = i.coordinateSpace.value.bounds;
    const a = s.lowerBounds, l = s.upperBounds;
    let d = r[e] + t;
    if (t > 0) {
      const u = l[e];
      kt(u) && (d = Math.min(d, Math.ceil(u - 1)));
    } else {
      const u = a[e];
      kt(u) && (d = Math.max(d, Math.floor(u)));
    }
    r[e] = d, i.changed.dispatch();
  }
  translateVoxelsRelative(e, t = false) {
    if (!this.valid)
      return;
    const i = po(Zd, e, this.orientation.orientation), r = this.position, s = r.value;
    var a = this.displayDimensions.value;
    const l = a.displayDimensionIndices, d = a.displayRank;
    var u = r.coordinateSpace.value.bounds;
    const f = u.lowerBounds, g = u.upperBounds;
    for (let v = 0; v < d; ++v) {
      const y = l[v], w = i[v];
      if (w === 0)
        continue;
      let C = s[y] + w;
      if (w > 0) {
        const b = g[y];
        kt(b) && (C = Math.min(C, Math.ceil(b - 1)));
      } else {
        const b = f[y];
        kt(b) && (C = Math.max(C, Math.floor(b)));
      }
      t && (C = Math.floor(C) + 0.5), s[y] = C;
    }
    this.position.changed.dispatch();
  }
  rotateRelative(e, t) {
    var i = $n();
    Ag(i, e, t);
    var r = this.orientation.orientation;
    ys(r, r, i), this.orientation.changed.dispatch();
  }
  rotateAbsolute(e, t, i) {
    var r = this.position;
    const s = r.coordinateSpace.value, a = r.value;
    if (s === void 0)
      return;
    const l = this.relativeDisplayScales.value.factors;
    var d = this.displayDimensions.value;
    const u = d.displayDimensionIndices, f = d.displayRank, g = s.scales, v = $n();
    Ag(v, e, t);
    const y = this.orientation.orientation, w = Zd;
    Zd.fill(0);
    for (let b = 0; b < f; ++b) {
      const E = u[b], L = i[E] - a[E];
      w[b] = L * g[E] * l[E];
    }
    const C = xu(yk, y);
    po(w, w, C), ys(y, v, y), po(w, w, y);
    for (let b = 0; b < f; ++b) {
      const E = u[b];
      a[E] = i[E] - w[b] / (g[E] * l[E]);
    }
    this.position.changed.dispatch(), this.orientation.changed.dispatch();
  }
  translateNonDisplayDimension(e, t) {
    if (!this.valid)
      return;
    const i = this.displayDimensions.value.displayDimensionIndices, s = this.position.coordinateSpace.value.rank;
    for (let a = 0; a < s; ++a)
      if (i.indexOf(a) === -1 && e-- === 0) {
        this.translateDimensionRelative(a, t);
        return;
      }
  }
};
var lm = class extends qc {
  constructor(e, t) {
    super(e), this.value = (() => {
      const i = new e.constructor(t), r = (u, f) => {
        u.assign(f);
      }, s = (u, f) => u.value / f.value * (u.canonicalVoxelPhysicalSize / f.canonicalVoxelPhysicalSize), a = (u, f, g) => {
        u.setPhysicalScale(f.value * g, f.canonicalVoxelPhysicalSize);
      }, l = (u, f, g) => {
        u.setPhysicalScale(f.value / g, f.canonicalVoxelPhysicalSize);
      }, d = (u) => u.coordinateSpaceValue.valid && u.canonicalVoxelPhysicalSize !== 0;
      return Yc(i, this.peer, this.link, { assign: r, isValid: d, difference: s, add: a, subtract: l }), i;
    })();
  }
};
function Tc(n) {
  return {
    changed: n.changed,
    toJSON() {
      return n.toJSON();
    },
    restoreState(e) {
      bk(n.link, n.value.legacyJsonView, e);
    },
    reset() {
      n.reset();
    }
  };
}
var kk = class extends Z {
  constructor(e) {
    super(), this.displayDimensionRenderInfo = e, this.changed = new Ee(), this.curCanonicalVoxelPhysicalSize = 0, this.value_ = Number.NaN, this.legacyValue_ = Number.NaN, this.registerDisposer(e), this.registerDisposer(e.changed.add(() => this.handleCoordinateSpaceChanged())), this.registerDisposer(e.relativeDisplayScales.coordinateSpace.changed.add(() => this.handleCoordinateSpaceChanged())), this.handleCoordinateSpaceChanged();
  }
  /**
   * Zoom factor.  For cross section views, in canonical voxels per viewport pixel.  For projection
   * views, in canonical voxels per viewport height (for orthographic projection).
   */
  get value() {
    return this.handleCoordinateSpaceChanged(), this.value_;
  }
  set value(e) {
    const t = this.canonicalVoxelPhysicalSize;
    YC(e, this.value_) && t === this.curCanonicalVoxelPhysicalSize || (this.curCanonicalVoxelPhysicalSize = t, this.legacyValue_ = Number.NaN, this.value_ = e, this.changed.dispatch());
  }
  get canonicalVoxelPhysicalSize() {
    return this.displayDimensionRenderInfo.value.canonicalVoxelPhysicalSize;
  }
  get coordinateSpaceValue() {
    return this.displayDimensionRenderInfo.relativeDisplayScales.coordinateSpace.value;
  }
  /**
   * Sets the zoom factor in the legacy units.  For cross section views, `1e-9` spatial units per
   * viewport pixel.  For projection views, `2 * 100 * Math.tan(Math.PI / 8) * 1e-9` spatial units
   * per viewport height (for orthographic projection).
   */
  set legacyValue(e) {
    YC(e, this.legacyValue_) || (this.value_ = Number.NaN, this.legacyValue_ = e, this.curCanonicalVoxelPhysicalSize = 0, this.changed.dispatch());
  }
  get legacyValue() {
    return this.legacyValue_;
  }
  handleCoordinateSpaceChanged() {
    const e = this.value_;
    var t = this.displayDimensionRenderInfo;
    const i = t.value.canonicalVoxelPhysicalSize, r = t.relativeDisplayScales.coordinateSpace.value, s = this.curCanonicalVoxelPhysicalSize;
    if (!(!nr(e) && i === s)) {
      if (!nr(e)) {
        s !== 0 && (this.value_ = e * (s / i), this.curCanonicalVoxelPhysicalSize = i, this.changed.dispatch());
        return;
      }
      !r.valid || i === 0 || (this.curCanonicalVoxelPhysicalSize = i, this.value_ = this.getDefaultValue(), this.changed.dispatch());
    }
  }
  toJSON() {
    const e = this.value;
    return nr(e) ? void 0 : e;
  }
  restoreState(e) {
    this.curCanonicalVoxelPhysicalSize = 0, this.legacyValue_ = Number.NaN, e === void 0 ? this.value_ = Number.NaN : this.value_ = vn(e), this.changed.dispatch();
  }
  reset() {
    this.curCanonicalVoxelPhysicalSize = 0, this.value_ = Number.NaN, this.legacyValue_ = Number.NaN, this.changed.dispatch();
  }
  get legacyJsonView() {
    const e = this;
    return {
      changed: e.changed,
      toJSON() {
        return e.toJSON();
      },
      reset() {
        return e.reset();
      },
      restoreState(t) {
        e.legacyValue = vn(t);
      }
    };
  }
  setPhysicalScale(e, t) {
    const i = this.curCanonicalVoxelPhysicalSize = this.canonicalVoxelPhysicalSize;
    this.value = e * (t / i);
  }
  assign(e) {
    const t = e.legacyValue;
    nr(t) ? this.setPhysicalScale(e.value, e.canonicalVoxelPhysicalSize) : this.legacyValue = t;
  }
};
var i3 = class extends kk {
  getDefaultValue() {
    const e = this.legacyValue_;
    if (nr(e))
      return 1;
    const t = this.canonicalVoxelPhysicalSize;
    return this.legacyValue_ * 1e-9 / t;
  }
};
var r3 = class extends kk {
  getDefaultValue() {
    const e = this.legacyValue_;
    if (!nr(e)) {
      this.legacyValue_ = Number.NaN;
      const u = this.canonicalVoxelPhysicalSize;
      return 2 * 100 * Math.tan(Math.PI / 8) * 1e-9 * e / u;
    }
    var t = this.coordinateSpaceValue.bounds;
    const i = t.lowerBounds, r = t.upperBounds;
    var s = this.displayDimensionRenderInfo.value;
    const a = s.canonicalVoxelFactors, l = s.displayDimensionIndices;
    let d = a.reduce((u, f, g) => {
      const v = l[g], y = (r[v] - i[v]) * f;
      return Math.max(u, y);
    }, 0);
    return kt(d) ? d = 2 ** Math.ceil(Zn(d)) : d = 1024, d;
  }
};
var cm = class extends Z {
  constructor(e, t) {
    super(), this.defaultValue = e, this.displayDimensionRenderInfo = t, this.changed = new Ee(), this.value_ = e, this.canonicalVoxelPhysicalSize = t.value.canonicalVoxelPhysicalSize, this.registerDisposer(t.changed.add(() => {
      this.value;
    }));
  }
  get value() {
    let e = this.value_;
    if (e > 0) {
      const t = this.displayDimensionRenderInfo.value.canonicalVoxelPhysicalSize, i = this.canonicalVoxelPhysicalSize;
      t !== i && (this.canonicalVoxelPhysicalSize = t, e = this.value_ = e = i / t, this.changed.dispatch());
    }
    return e;
  }
  set value(e) {
    if (e === this.value)
      return;
    this.value_ = e;
    const t = this.displayDimensionRenderInfo.value.canonicalVoxelPhysicalSize;
    this.canonicalVoxelPhysicalSize = t, this.changed.dispatch();
  }
  toJSON() {
    const e = this.value;
    if (e !== this.defaultValue)
      return e;
  }
  reset() {
    this.value = this.defaultValue;
  }
  restoreState(e) {
    typeof e != "number" || !kt(e) || e === 0 ? this.value = this.defaultValue : this.value = e;
  }
  setValueAbsolute(e, t) {
    if (e > 0) {
      const i = this.displayDimensionRenderInfo.value.canonicalVoxelPhysicalSize;
      e = e * (t / i);
    }
    this.value = e;
  }
  assign(e) {
    this.setValueAbsolute(e.value, e.canonicalVoxelPhysicalSize);
  }
};
var nw = class extends Ck {
  constructor(e, t) {
    super(e), this.value = Sk(new cm(e.defaultValue, t), this.peer, this.link, {
      assign: (i, r) => i.assign(r),
      isValid: () => true
    });
  }
};
var Vo = class extends Z {
  constructor(e, t, i) {
    super(), this.pose = e, this.zoomFactor = t, this.depthRange = i, this.changed = new Ee(), this.registerDisposer(e), this.registerDisposer(t), this.registerDisposer(i), this.registerDisposer(this.pose.changed.add(this.changed.dispatch)), this.registerDisposer(this.zoomFactor.changed.add(this.changed.dispatch)), this.registerDisposer(this.depthRange.changed.add(this.changed.dispatch));
  }
  get coordinateSpace() {
    return this.pose.position.coordinateSpace;
  }
  /**
   * Resets everything.
   */
  reset() {
    this.pose.reset(), this.zoomFactor.reset();
  }
  get position() {
    return this.pose.position;
  }
  get displayDimensions() {
    return this.pose.displayDimensions;
  }
  get relativeDisplayScales() {
    return this.pose.relativeDisplayScales;
  }
  get displayDimensionRenderInfo() {
    return this.pose.displayDimensionRenderInfo;
  }
  toMat4(e) {
    this.pose.toMat4(e, this.zoomFactor.value);
  }
  toMat3(e) {
    this.pose.toMat3(e, this.zoomFactor.value);
  }
  get relativeDepthRange() {
    let e = this.depthRange.value;
    return e > 0 ? e /= this.zoomFactor.value : e *= -1, e;
  }
  get valid() {
    return this.pose.valid && !nr(this.zoomFactor.value);
  }
  zoomBy(e) {
    this.zoomFactor.value *= e;
  }
};
var s3 = "mesh/MeshLayer";
var a3 = "mesh/MultiscaleMeshLayer";
var o3 = "mesh/FragmentSource";
var l3 = "mesh/MultiscaleFragmentSource";
var Fr;
(function(n) {
  n[n.float32 = 0] = "float32", n[n.uint10 = 1] = "uint10", n[n.uint16 = 2] = "uint16";
})(Fr || (Fr = {}));
function c3(n, e, t) {
  return n & 1 | e << 1 & 2 | t << 2 & 4;
}
function d3(n, e, t, i, r, s, a) {
  const l = n.octree, d = n.lodScales, u = n.chunkGridSpatialOrigin, f = n.chunkShape, g = d.length - 1, v = e[0], y = e[4], w = e[8], C = e[1], b = e[5], E = e[9], L = e[3], R = e[7], _ = e[11], A = e[15], I = L > 0 ? 0 : 1, P = R > 0 ? 0 : 1, N = _ > 0 ? 0 : 1, O = t[4 * 4], B = t[4 * 4 + 1], j = t[4 * 4 + 2], U = t[4 * 4 + 3];
  function V(Ae, ze, We) {
    return L * Ae + R * ze + _ * We + A;
  }
  function G(Ae, ze, We, $e, Pe, bt) {
    return V(Ae + I * ($e - Ae), ze + P * (Pe - ze), We + N * (bt - We));
  }
  const F = V(-U * O, -U * B, -U * j), ue = n.clipLowerBound[0], ae = n.clipLowerBound[1], Ie = n.clipLowerBound[2], le = n.clipUpperBound[0], Te = n.clipUpperBound[1], Ue = n.clipUpperBound[2], Ye = Math.sqrt((v * r) ** 2 + (C * s) ** 2), Ze = Math.sqrt((y * r) ** 2 + (b * s) ** 2), rt = Math.sqrt((w * r) ** 2 + (E * s) ** 2), Xe = Math.max(Ye, Ze, rt);
  function Be(Ae, ze, We) {
    const $e = 1 << Ae, Pe = ze * 5, bt = l[Pe], ci = l[Pe + 1], tn = l[Pe + 2], X = l[Pe + 3], ne = l[Pe + 4];
    let te = bt * $e * f[0] + u[0], ge = ci * $e * f[1] + u[1], we = tn * $e * f[2] + u[2], me = te + $e * f[0], Ge = ge + $e * f[1], tt = we + $e * f[2];
    if (te = Math.max(te, ue), ge = Math.max(ge, ae), we = Math.max(we, Ie), me = Math.min(me, le), Ge = Math.min(Ge, Te), tt = Math.min(tt, Ue), XE(te, ge, we, me, Ge, tt, t)) {
      const ft = Math.max(F, G(te, ge, we, me, Ge, tt)) / Xe;
      if (We === 0 || ft * i < We) {
        const st = d[Ae];
        if (st !== 0 && a(Ae, ze, st / ft, ne >>> 31), Ae > 0 && (st === 0 || ft * i < st)) {
          const zt = st === 0 ? We : st, pt = (ne & 2147483647) >>> 0;
          for (let Dt = X; Dt < pt; ++Dt)
            Be(Ae - 1, Dt, zt);
        }
      }
    }
  }
  Be(g, l.length / 5 - 1, 0);
}
function iw(n, e, t, i, r, s, a, l) {
  const d = n.lodScales;
  let u = 0;
  for (; u + 1 < d.length && d[u + 1] !== 0; )
    ++u;
  const f = 3, g = [];
  let v = 0, y = 0;
  function w(E, L) {
    for (; ; ) {
      if (v === 0)
        return;
      const R = v - 1, _ = u - R, A = g[R * f], I = _ === 0 ? 1 : 8, P = g[R * f + 1], N = g[R * f + 2];
      if (E === v) {
        const O = L & I - 1;
        y !== O && A !== -1 && l(_, A, y, O, N), y = O + 1;
        return;
      }
      y !== I && A !== -1 && l(_, A, y, I, N), y = P + 1, --v;
    }
  }
  let C = 0;
  const b = n.octree;
  d3(n, e, t, i, r, s, (E, L, R, _) => {
    if (!_ && !a(E, L, R)) {
      C = Math.max(E, C);
      return;
    }
    if (E < C)
      return;
    C = 0;
    const A = L * 5, I = b[A], P = b[A + 1], N = b[A + 2], O = c3(I, P, N), B = u - E;
    w(B, O);
    const j = B * f;
    g[j] = _ ? -1 : L, g[j + 1] = O, g[j + 2] = R, y = 0, v = B + 1;
  }), w(0, 0);
}
function Ik(n, e, t) {
  return `${n}/${e}:${t}`;
}
var el = class extends ST {
  draw(e, t) {
  }
  isReady(e, t) {
    return true;
  }
  get transparentPickEnabled() {
    return true;
  }
};
var u3 = 3432918353;
var h3 = 461845907;
function Gu(n, e) {
  return e >>>= 0, n >>>= 0, e = ir(e, u3) >>> 0, e = (e << 15 | e >>> 17) >>> 0, e = ir(e, h3) >>> 0, n = (n ^ e) >>> 0, n = (n << 13 | n >>> 19) >>> 0, n = n * 5 + 3864292196 >>> 0, n;
}
var f3 = xv.Symbol.for;
var p3 = { default: f3, __esModule: true };
var g3 = Gs(p3);
var dm = 3;
var m3 = 0.8;
var Lr = 0;
var Dr = 0;
var rw = 0;
var sw = 0;
var kc = class _kc {
  constructor(e = _kc.generateHashSeeds(dm)) {
    this.hashSeeds = e, this.loadFactor = m3, this.size = 0, this.emptyLow = 4294967295, this.emptyHigh = 4294967295, this.maxRehashAttempts = 5, this.maxAttempts = 5, this.generation = 0, this.mungedEmptyKey = -1;
    let t = 8;
    for (; t < 2 * e.length; )
      t *= 2;
    this.allocate(t);
  }
  updateHashFunctions(e) {
    this.hashSeeds = _kc.generateHashSeeds(e), this.mungedEmptyKey = -1;
  }
  /**
   * Invokes callback with a modified version of the hash table data array.
   *
   * Replaces all slots that appear to be valid entries for (emptyLow, emptyHigh), i.e. slots that
   * contain (emptyLow, emptyHigh) and to which (emptyLow, emptyHigh) hashes, with (mungedEmptyKey,
   * mungedEmptyKey).
   *
   * mungedEmptyKey is chosen to be a 32-bit value with the property that the 64-bit value
   * (mungedEmptyKey, mungedEmptyKey) does not hash to any of the same slots as (emptyLow,
   * emptyHigh).
   *
   * This allows the modified data array to be used for lookups without special casing the empty
   * key.
   */
  tableWithMungedEmptyKey(e) {
    const t = this.hashSeeds.length, i = new Array(t);
    for (let d = 0; d < t; ++d)
      i[d] = this.getHash(d, this.emptyLow, this.emptyHigh);
    let r = this.mungedEmptyKey;
    if (r === -1)
      e:
        for (; ; ) {
          r = Math.random() * 16777216 >>> 0;
          for (let d = 0; d < t; ++d) {
            let u = this.getHash(d, r, r);
            for (let f = 0; f < t; ++f)
              if (i[f] === u)
                continue e;
          }
          this.mungedEmptyKey = r;
          break;
        }
    let s = this.table, a = this.emptyLow, l = this.emptyHigh;
    for (let d = 0; d < t; ++d) {
      let u = i[d];
      s[u] === a && s[u + 1] === l && (s[u] = r, s[u + 1] = r);
    }
    try {
      e(s);
    } finally {
      for (let d = 0; d < t; ++d) {
        let u = i[d];
        s[u] === r && s[u + 1] === r && (s[u] = a, s[u + 1] = l);
      }
    }
  }
  static generateHashSeeds(e = dm) {
    return r2(new Uint32Array(e));
  }
  getHash(e, t, i) {
    let r = this.hashSeeds[e];
    return r = Gu(r, t), r = Gu(r, i), this.entryStride * (r & this.tableSize - 1);
  }
  /**
   * Iterates over the Uint64 keys contained in the hash set.
   *
   * Creates a new Uint64 object at every iteration (otherwise spread and Array.from() fail)
   */
  *keys() {
    let e = this.emptyLow, t = this.emptyHigh, i = this.entryStride, r = this.table;
    for (let s = 0, a = r.length; s < a; s += i) {
      let l = r[s], d = r[s + 1];
      (l !== e || d !== t) && (yield new re(l, d));
    }
  }
  /**
   * Iterates over the Uint64 keys contained in the hash set.
   *
   * The same temp value will be modified and yielded at every iteration.
   */
  *unsafeKeys(e = new re()) {
    let t = this.emptyLow, i = this.emptyHigh, r = this.entryStride, s = this.table;
    for (let a = 0, l = s.length; a < l; a += r) {
      let d = s[a], u = s[a + 1];
      (d !== t || u !== i) && (e.low = d, e.high = u, yield e);
    }
  }
  indexOfPair(e, t) {
    let i = this.table, r = this.emptyLow, s = this.emptyHigh;
    if (e === r && t === s)
      return -1;
    for (let a = 0, l = this.hashSeeds.length; a < l; ++a) {
      let d = this.getHash(a, e, t);
      if (i[d] === e && i[d + 1] === t)
        return d;
    }
    return -1;
  }
  /**
   * Returns the offset into the hash table of the specified element, or -1 if the element is not
   * present.
   */
  indexOf(e) {
    return this.indexOfPair(e.low, e.high);
  }
  /**
   * Changes the empty key to a value that is not equal to the current empty key and is not present
   * in the table.
   *
   * This is called when an attempt is made to insert the empty key.
   */
  chooseAnotherEmptyKey() {
    let e = this.emptyLow, t = this.emptyHigh, i = this.table, r = this.entryStride, s, a;
    for (; s = Math.random() * 4294967296 >>> 0, a = Math.random() * 4294967296 >>> 0, !(!(s === e && a === t) && !this.hasPair(s, a)); )
      ;
    this.emptyLow = s, this.emptyHigh = a;
    for (let l = 0, d = i.length; l < d; l += r)
      i[l] === e && i[l + 1] === t && (i[l] = s, i[l + 1] = a);
  }
  /**
   * Returns true iff the specified element is present.
   */
  has(e) {
    return this.indexOf(e) !== -1;
  }
  /**
   * Returns true iff the specified element is present.
   */
  hasPair(e, t) {
    return this.indexOfPair(e, t) !== -1;
  }
  delete(e) {
    let t = this.indexOf(e);
    if (t !== -1) {
      let i = this.table;
      return i[t] = this.emptyLow, i[t + 1] = this.emptyHigh, ++this.generation, this.size--, true;
    }
    return false;
  }
  clearTable() {
    let e = this.table, t = this.entryStride, i = this.emptyLow, r = this.emptyHigh, s = e.length;
    for (let a = 0; a < s; a += t)
      e[a] = i, e[a + 1] = r;
  }
  clear() {
    return this.size === 0 ? false : (this.size = 0, ++this.generation, this.clearTable(), true);
  }
  reserve(e) {
    return e > this.capacity ? (this.backupPending(), this.grow(e), this.restorePending(), true) : false;
  }
  swapPending(e, t) {
    let i = Lr, r = Dr;
    this.storePending(e, t), e[t] = i, e[t + 1] = r;
  }
  storePending(e, t) {
    Lr = e[t], Dr = e[t + 1];
  }
  backupPending() {
    rw = Lr, sw = Dr;
  }
  restorePending() {
    Lr = rw, Dr = sw;
  }
  tryToInsert() {
    let e = 0, t = this.emptyLow, i = this.emptyHigh, r = this.maxAttempts, s = this.table, a = this.hashSeeds.length, l = Math.floor(Math.random() * a);
    for (; ; ) {
      let d = this.getHash(l, Lr, Dr);
      if (this.swapPending(s, d), Lr === t && Dr === i)
        return true;
      if (++e === r)
        break;
      l = (l + Math.floor(Math.random() * (a - 1)) + 1) % a;
    }
    return false;
  }
  allocate(e) {
    this.tableSize = e;
    let t = this.entryStride;
    this.table = new Uint32Array(e * t), this.maxAttempts = e, this.clearTable(), this.capacity = e * this.loadFactor, this.mungedEmptyKey = -1;
  }
  rehash(e, t) {
    this.allocate(t), this.updateHashFunctions(this.hashSeeds.length);
    let i = this.emptyLow, r = this.emptyHigh, s = this.entryStride;
    for (let a = 0, l = e.length; a < l; a += s) {
      let d = e[a], u = e[a + 1];
      if ((d !== i || u !== r) && (this.storePending(e, a), !this.tryToInsert()))
        return false;
    }
    return true;
  }
  grow(e) {
    let t = this.table, i = this.tableSize;
    for (; i < e; )
      i *= 2;
    for (; ; ) {
      for (let r = 0; r < this.maxRehashAttempts; ++r)
        if (this.rehash(t, i))
          return;
      i *= 2;
    }
  }
  insertInternal() {
    for (++this.generation, Lr === this.emptyLow && Dr === this.emptyHigh && this.chooseAnotherEmptyKey(), ++this.size > this.capacity && (this.backupPending(), this.grow(this.tableSize * 2), this.restorePending()); !this.tryToInsert(); )
      this.backupPending(), this.grow(this.tableSize), this.restorePending();
  }
};
var Lk = class extends kc {
  add(e) {
    let t = e.low, i = e.high;
    return this.hasPair(t, i) ? false : (Lr = t, Dr = i, this.insertInternal(), true);
  }
  /**
   * Iterates over the keys.
   * Creates a new Uint64 object at every iteration (otherwise spread and Array.from() fail)
   */
  [wZr]() {
    return this.unsafeKeys();
  }
};
Lk.prototype.entryStride = 2;
var Hl = 0;
var jl = 0;
var aw = 0;
var ow = 0;
var py = class extends kc {
  set(e, t) {
    let i = e.low, r = e.high;
    return this.hasPair(i, r) ? false : (Lr = i, Dr = r, Hl = t.low, jl = t.high, this.insertInternal(), true);
  }
  get(e, t) {
    let i = this.indexOf(e);
    if (i === -1)
      return false;
    let r = this.table;
    return t.low = r[i + 2], t.high = r[i + 3], true;
  }
  swapPending(e, t) {
    let i = Hl, r = jl;
    super.swapPending(e, t), e[t + 2] = i, e[t + 3] = r;
  }
  storePending(e, t) {
    super.storePending(e, t), Hl = e[t + 2], jl = e[t + 3];
  }
  backupPending() {
    super.backupPending(), aw = Hl, ow = jl;
  }
  restorePending() {
    super.restorePending(), Hl = aw, jl = ow;
  }
  /**
   * Iterates over entries.  The same temporary value will be modified and yielded at every
   * iteration.
   */
  [wZr]() {
    return this.unsafeEntries();
  }
  /**
   * Iterates over entries.
   * Creates new Uint64 objects at every iteration (otherwise spread and Array.from() fail)
   */
  *entries() {
    let e = this.emptyLow, t = this.emptyHigh, i = this.entryStride, r = this.table;
    for (let s = 0, a = r.length; s < a; s += i) {
      let l = r[s], d = r[s + 1];
      if (l !== e || d !== t) {
        let u = new re(l, d), f = new re(r[s + 2], r[s + 3]);
        yield [u, f];
      }
    }
  }
  /**
   * Iterates over entries.  The same temporary value will be modified and yielded at every
   * iteration.
   */
  *unsafeEntries(e = [new re(), new re()]) {
    let t = this.emptyLow, i = this.emptyHigh, r = this.entryStride, s = this.table;
    var a = ce(e, 2);
    let l = a[0], d = a[1];
    for (let u = 0, f = s.length; u < f; u += r) {
      let g = s[u], v = s[u + 1];
      (g !== t || v !== i) && (l.low = g, l.high = v, d.low = s[u + 2], d.high = s[u + 3], yield e);
    }
  }
};
py.prototype.entryStride = 4;
var jh = class {
};
var Zs = [-1, WebGL2RenderingContext.RED_INTEGER, WebGL2RenderingContext.RG_INTEGER, WebGL2RenderingContext.RGB_INTEGER, WebGL2RenderingContext.RGBA_INTEGER];
var v3 = [-1, WebGL2RenderingContext.RED, WebGL2RenderingContext.RG, WebGL2RenderingContext.RGB, WebGL2RenderingContext.RGBA];
var Xd = ["", "r", "rg", "rgb", "rgba"];
var y3 = [-1, WebGL2RenderingContext.R8UI, WebGL2RenderingContext.RG8UI, WebGL2RenderingContext.RGB8UI, WebGL2RenderingContext.RGBA8UI];
var S3 = [-1, WebGL2RenderingContext.R8I, WebGL2RenderingContext.RG8I, WebGL2RenderingContext.RGB8I, WebGL2RenderingContext.RGBA8I];
var b3 = [-1, WebGL2RenderingContext.R16UI, WebGL2RenderingContext.RG16UI, WebGL2RenderingContext.RGB16UI, WebGL2RenderingContext.RGBA16UI];
var C3 = [-1, WebGL2RenderingContext.R16I, WebGL2RenderingContext.RG16I, WebGL2RenderingContext.RGB16I, WebGL2RenderingContext.RGBA16I];
var lw = [-1, WebGL2RenderingContext.R32UI, WebGL2RenderingContext.RG32UI, WebGL2RenderingContext.RGB32UI, WebGL2RenderingContext.RGBA32UI];
var w3 = [-1, WebGL2RenderingContext.R32I, WebGL2RenderingContext.RG32I, WebGL2RenderingContext.RGB32I, WebGL2RenderingContext.RGBA32I];
var x3 = [-1, WebGL2RenderingContext.R32F, WebGL2RenderingContext.RG32F, WebGL2RenderingContext.RGB32F, WebGL2RenderingContext.RGBA32F];
function gy(n) {
  return n === J.FLOAT32 ? "" : s1[n] ? "i" : "u";
}
function Kc(n, e, t = 1) {
  switch (e) {
    case J.UINT8:
      if (t < 1 || t > 4)
        break;
      return n.texelsPerElement = 1, n.textureInternalFormat = y3[t], n.textureFormat = Zs[t], n.texelType = WebGL2RenderingContext.UNSIGNED_BYTE, n.arrayElementsPerTexel = t, n.arrayConstructor = Uint8Array, n.samplerPrefix = "u", n;
    case J.INT8:
      if (t < 1 || t > 4)
        break;
      return n.texelsPerElement = 1, n.textureInternalFormat = S3[t], n.textureFormat = Zs[t], n.texelType = WebGL2RenderingContext.BYTE, n.arrayElementsPerTexel = t, n.arrayConstructor = Int8Array, n.samplerPrefix = "i", n;
    case J.UINT16:
      if (t < 1 || t > 4)
        break;
      return n.texelsPerElement = 1, n.textureInternalFormat = b3[t], n.textureFormat = Zs[t], n.texelType = WebGL2RenderingContext.UNSIGNED_SHORT, n.arrayElementsPerTexel = t, n.arrayConstructor = Uint16Array, n.samplerPrefix = "u", n;
    case J.INT16:
      if (t < 1 || t > 4)
        break;
      return n.texelsPerElement = 1, n.textureInternalFormat = C3[t], n.textureFormat = Zs[t], n.texelType = WebGL2RenderingContext.SHORT, n.arrayElementsPerTexel = t, n.arrayConstructor = Int16Array, n.samplerPrefix = "i", n;
    case J.UINT32:
      if (t < 1 || t > 4)
        break;
      return n.texelsPerElement = 1, n.textureInternalFormat = lw[t], n.textureFormat = Zs[t], n.texelType = WebGL2RenderingContext.UNSIGNED_INT, n.arrayElementsPerTexel = 1, n.arrayConstructor = Uint32Array, n.samplerPrefix = "u", n;
    case J.INT32:
      if (t < 1 || t > 4)
        break;
      return n.texelsPerElement = 1, n.textureInternalFormat = w3[t], n.textureFormat = Zs[t], n.texelType = WebGL2RenderingContext.INT, n.arrayElementsPerTexel = 1, n.arrayConstructor = Int32Array, n.samplerPrefix = "i", n;
    case J.UINT64:
      if (t < 1 || t > 2)
        break;
      return n.texelsPerElement = 1, n.textureInternalFormat = lw[t * 2], n.textureFormat = Zs[t * 2], n.texelType = WebGL2RenderingContext.UNSIGNED_INT, n.arrayElementsPerTexel = 2 * t, n.arrayConstructor = Uint32Array, n.samplerPrefix = "u", n;
    case J.FLOAT32:
      if (t < 1 || t > 4)
        break;
      return n.texelsPerElement = 1, n.textureInternalFormat = x3[t], n.textureFormat = v3[t], n.texelType = WebGL2RenderingContext.FLOAT, n.arrayElementsPerTexel = t, n.arrayConstructor = Float32Array, n.samplerPrefix = "", n;
  }
  throw new Error(`No supported texture format for ${J[e]}[${t}].`);
}
function my(n, e, t) {
  const i = e.arrayConstructor, r = e.arrayElementsPerTexel, s = e.textureInternalFormat, a = e.textureFormat, l = e.texelsPerElement, d = n.maxTextureSize, u = t.length / r;
  if (u * l > d * d)
    throw new Error("Number of elements exceeds maximum texture size: " + l + " * " + u);
  const f = Math.ceil(u / d), g = Math.ceil(Zn(f)), v = (1 << g) * l, y = Math.ceil(u / (1 << g)), w = v * y * r;
  t.constructor !== i && (t = new i(t.buffer, t.byteOffset, t.byteLength / i.BYTES_PER_ELEMENT));
  let C = fN(t, w);
  n.pixelStorei(WebGL2RenderingContext.UNPACK_ALIGNMENT, 1), Lo(n), n.texImage2D(
    WebGL2RenderingContext.TEXTURE_2D,
    /*level=*/
    0,
    s,
    /*width=*/
    v,
    /*height=*/
    y,
    /*border=*/
    0,
    a,
    e.texelType,
    C
  );
}
function E3(n, e, t, i, r) {
  const s = e.arrayConstructor, a = e.textureInternalFormat, l = e.textureFormat, d = e.texelsPerElement;
  t.constructor !== s && (t = new s(t.buffer, t.byteOffset, t.byteLength / s.BYTES_PER_ELEMENT)), n.pixelStorei(WebGL2RenderingContext.UNPACK_ALIGNMENT, 1), Lo(n), n.texImage2D(
    WebGL2RenderingContext.TEXTURE_2D,
    /*level=*/
    0,
    a,
    /*width=*/
    i * d,
    /*height=*/
    r,
    /*border=*/
    0,
    l,
    e.texelType,
    t
  );
}
function T3(n, e, t, i, r, s) {
  const a = e.arrayConstructor, l = e.textureInternalFormat, d = e.textureFormat, u = e.texelsPerElement;
  t.constructor !== a && (t = new a(t.buffer, t.byteOffset, t.byteLength / a.BYTES_PER_ELEMENT)), n.pixelStorei(WebGL2RenderingContext.UNPACK_ALIGNMENT, 1), yV(n), n.texImage3D(
    WebGL2RenderingContext.TEXTURE_3D,
    /*level=*/
    0,
    l,
    /*width=*/
    i * u,
    /*height=*/
    r,
    /*depth=*/
    s,
    /*border=*/
    0,
    d,
    e.texelType,
    t
  );
}
function k3(n) {
  switch (n) {
    case J.UINT8:
      return IT;
    case J.INT8:
      return LT;
    case J.UINT16:
      return DT;
    case J.INT16:
      return PT;
    case J.UINT32:
      return Zv;
    case J.INT32:
      return AT;
    case J.UINT64:
      return Ht;
    case J.FLOAT32:
      return Kv;
  }
}
function Dk(n, e, t, i, r, s) {
  const a = wn(r, s);
  let l = [k3(r)], d = `
${a} ${n}(${i} index) {
`;
  switch (r) {
    case J.UINT8:
    case J.UINT16:
    case J.UINT32:
      d += `
  ${a} result;
  highp uvec4 temp;
  ${e}(${t}, index, temp);
  result.value = temp.${Xd[s]};
  return result;
`;
      break;
    case J.INT8:
    case J.INT16:
    case J.INT32:
      d += `
  ${a} result;
  highp ivec4 temp;
  ${e}(${t}, index, temp);
  result.value = temp.${Xd[s]};
  return result;
`;
      break;
    case J.UINT64:
      l.push(PV), d += `
  highp uvec4 temp;
  ${e}(${t}, index, temp);
  return unpackUint64leFromUint32(temp.${Xd[s * 2]});
`;
      break;
    case J.FLOAT32:
      l.push(Kv), d += `
  highp vec4 temp;
  ${e}(${t}, index, temp);
  return temp.${Xd[s]};
`;
      break;
  }
  return d += `
}
`, l.push(d), l;
}
var vy = class {
  constructor(e) {
    this.key = e, this.readTextureValue = `readTextureValue_${this.key}`;
  }
  defineShader(e) {
  }
  getReadTextureValueCode(e, t) {
    let i = `
void ${this.readTextureValue}(highp ${t}sampler2D sampler, highp uint index`;
    for (let r = 0; r < e; ++r)
      i += `, out ${t}vec4 output${r}`;
    i += `) {
  highp int width = textureSize(sampler, 0).x / ${e};
  highp uint log2width = log2Exact(uint(width));
  highp int y = int(index >> log2width);
  highp int x = int((index - (uint(y) << log2width)) * ${e}u);
`;
    for (let r = 0; r < e; ++r)
      i += `
  output${r} = texelFetch(sampler, ivec2(x + ${r}, y), 0);
`;
    return i += `
}
`, [OV, i];
  }
  getAccessor(e, t, i, r = 1) {
    const s = gy(i);
    return [this.getReadTextureValueCode(1, s), ...Dk(e, this.readTextureValue, t, "highp uint", i, r)];
  }
};
var I3 = class {
  constructor(e, t) {
    this.key = e, this.textureDims = t, this.readTextureValue = `readTextureValue_${this.key}`;
  }
  getReadTextureValueCode(e, t) {
    const i = this.textureDims;
    let r = `
void ${this.readTextureValue}(highp ${t}sampler${this.textureDims}D sampler, highp ivec${i} p`;
    for (let s = 0; s < e; ++s)
      r += `, out ${t}vec4 output${s}`;
    r += `) {
`;
    for (let s = 0; s < e; ++s)
      r += `
  output${s} = texelFetch(sampler, ivec${i}(p.x * ${e} + ${s}, p.y
                                         ${i === 3 ? ", p.z" : ""}), 0);
`;
    return r += `
}
`, r;
  }
  getAccessor(e, t, i, r = 1) {
    const s = gy(i);
    return [this.getReadTextureValueCode(1, s), ...Dk(e, this.readTextureValue, t, `highp ivec${this.textureDims}`, i, r)];
  }
};
var Pk = [Ht, `
highp uint hashCombine(highp uint state, highp uint value) {
  value *= 0xcc9e2d51u;
  value = (value << 15u) | (value >> 17u);
  value *= 0x1b873593u;
  state ^= value;
  state = (state << 13u) | (state >> 19u);
  state = (state * 5u) + 0xe6546b64u;
  return state;
}
highp uint hashCombine(highp uint state, uint64_t x) {
  state = hashCombine(state, x.value[0]);
  return hashCombine(state, x.value[1]);
}
`];
var L3 = Kc(new jh(), J.UINT64, 1);
var Jl = class extends Z {
  constructor(e, t) {
    super(), this.gl = e, this.hashTable = t, this.generation = -1, this.texture = null, this.texture = e.createTexture();
  }
  copyToGPU() {
    let e = this.hashTable, t = e.generation;
    if (this.generation === t)
      return;
    const i = this.gl, r = this.texture;
    this.generation = t, i.activeTexture(WebGL2RenderingContext.TEXTURE0 + i.tempTextureUnit), i.bindTexture(WebGL2RenderingContext.TEXTURE_2D, r), e.tableWithMungedEmptyKey((s) => {
      my(this.gl, L3, s);
    }), i.bindTexture(WebGL2RenderingContext.TEXTURE_2D, null);
  }
  disposed() {
    this.gl.deleteTexture(this.texture), this.texture = null, this.gl = void 0, this.hashTable = void 0, super.disposed();
  }
  static get(e, t) {
    return e.memoize.get(t, () => new this(e, t));
  }
};
var Ak = class {
  constructor(e, t = dm) {
    this.prefix = e, this.numAlternatives = t, this.textureUnitSymbol = g3(`gpuhashtable:${this.prefix}`), this.accessHelper = new vy(`gpuhashtable_${this.prefix}`), this.samplerName = this.prefix + "_sampler", this.hashSeedsName = this.prefix + "_seeds", this.hashKeyMask = this.prefix + "_keyMask", this.readTable = this.prefix + "_readTable";
  }
  defineShader(e) {
    let t = this.hashSeedsName, i = this.samplerName, r = this.numAlternatives, s = this.hashKeyMask;
    e.addUniform("highp uint", t, r), e.addUniform("highp uint", s), e.addTextureSampler("usampler2D", i, this.textureUnitSymbol), e.addFragmentCode(Pk), e.addFragmentCode(Ht), e.addFragmentCode(ET), this.accessHelper.defineShader(e), e.addFragmentCode(this.accessHelper.getAccessor(this.readTable, this.samplerName, J.UINT64, 1));
    let a = "";
    a += `
bool ${this.hasFunctionName}(uint64_t x) {
`;
    for (let l = 0; l < r; ++l)
      a += `
  {
    uint h = hashCombine(${t}[${l}], x) & ${s};
    uint64_t key = ${this.readTable}(h);
    if (equals(key, x)) {
      return true;
    }
  }
`;
    a += `
  return false;
}
`, e.addFragmentCode(a);
  }
  get hasFunctionName() {
    return `${this.prefix}_has`;
  }
  enable(e, t, i) {
    i.copyToGPU();
    const r = t.textureUnit(this.textureUnitSymbol);
    e.activeTexture(WebGL2RenderingContext.TEXTURE0 + r), e.bindTexture(WebGL2RenderingContext.TEXTURE_2D, i.texture), e.uniform1ui(t.uniform(this.hashKeyMask), i.hashTable.tableSize - 1), e.uniform1uiv(t.uniform(this.hashSeedsName), i.hashTable.hashSeeds);
  }
  disable(e, t) {
    const i = t.textureUnit(this.textureUnitSymbol);
    e.activeTexture(WebGL2RenderingContext.TEXTURE0 + i), e.bindTexture(WebGL2RenderingContext.TEXTURE_2D, null);
  }
};
var Rk = class extends Ak {
  defineShader(e) {
    super.defineShader(e);
    let t = this.numAlternatives, i = this.hashSeedsName, r = this.hashKeyMask, s = `
bool ${this.getFunctionName}(uint64_t x, out uint64_t value) {
`;
    for (let a = 0; a < t; ++a)
      s += `
  {
    uint h = hashCombine(${i}[${a}], x) & ${r};
    uint64_t key = ${this.readTable}(h * 2u);
    if (equals(key, x)) {
      value = ${this.readTable}(h * 2u + 1u);
      return true;
    }
  }
`;
    s += `
  return false;
}
`, e.addFragmentCode(s);
  }
  get getFunctionName() {
    return `${this.prefix}_get`;
  }
};
function $u(n, e, t, i) {
  e *= 6;
  let r = Math.floor(e), s = e - r, a = i * (1 - t), l = i * (1 - t * s), d = i * (1 - t * (1 - s));
  switch (r % 6) {
    case 0:
      n[0] = i, n[1] = d, n[2] = a;
      break;
    case 1:
      n[0] = l, n[1] = i, n[2] = a;
      break;
    case 2:
      n[0] = a, n[1] = i, n[2] = d;
      break;
    case 3:
      n[0] = a, n[1] = l, n[2] = i;
      break;
    case 4:
      n[0] = d, n[1] = a, n[2] = i;
      break;
    case 5:
      n[0] = i, n[1] = a, n[2] = l;
      break;
  }
  return n;
}
function D3(n, e, t, i) {
  const r = Math.max(Math.max(e, t), i), s = Math.min(Math.min(e, t), i);
  if (n[2] = r, s === r)
    n[0] = 0, n[1] = 0;
  else {
    const a = r - s;
    n[1] = a / r, e === r ? n[0] = (t - i) / a : t === r ? n[0] = 2 + (i - e) / a : n[0] = 4 + (e - t) / a, n[0] /= 6, n[0] < 0 && (n[0] += 1), n[0] > 1 && (n[0] -= 1);
  }
  return n;
}
var cw = 2;
var P3 = class {
  constructor(e) {
    this.prefix = e, this.seedName = this.prefix + "_seed";
  }
  defineShader(e) {
    const t = this.seedName;
    e.addUniform("highp uint", t), e.addFragmentCode(Ht), e.addFragmentCode(Pk), e.addFragmentCode(DV);
    let i = `
vec3 ${this.prefix}(uint64_t x) {
  uint h = hashCombine(${t}, x);
  vec${cw} v;
`;
    for (let r = 0; r < cw; ++r)
      i += `
  v[${r}] = float(h & 0xFFu) / 255.0;
  h >>= 8u;
`;
    i += `
  vec3 hsv = vec3(v.x, 0.5 + v.y * 0.5, 1.0);
  return hsvToRgb(hsv);
}
`, e.addFragmentCode(i);
  }
  enable(e, t, i) {
    e.uniform1ui(t.uniform(this.seedName), i);
  }
};
var dw = new Float32Array(3);
function Mk(n) {
  return `rgb(${n[0] * 100}%,${n[1] * 100}%,${n[2] * 100}%)`;
}
var yy = class _yy {
  constructor(e = Qb()) {
    this.hashSeed = e, this.changed = new Ee();
  }
  static getDefault() {
    return new _yy(0);
  }
  get value() {
    return this.hashSeed;
  }
  set value(e) {
    e !== this.hashSeed && (this.hashSeed = e, this.changed.dispatch());
  }
  compute(e, t) {
    let i = Gu(this.hashSeed, t.low);
    i = Gu(i, t.high);
    const r = (i & 255) / 255, s = (i >> 8 & 255) / 255;
    return $u(e, r, 0.5 + 0.5 * s, 1), e;
  }
  computeCssColor(e) {
    return this.compute(dw, e), Mk(dw);
  }
  randomize() {
    this.hashSeed = Qb(), this.changed.dispatch();
  }
  toString() {
    return `new SegmentColorHash(${this.hashSeed})`;
  }
  toJSON() {
    return this.hashSeed === 0 ? void 0 : this.hashSeed;
  }
  reset() {
    this.restoreState(0);
  }
  restoreState(e) {
    const t = e >>> 0;
    t !== this.hashSeed && (this.hashSeed = t, this.changed.dispatch());
  }
};
var A3 = class {
  constructor(e) {
    this.prefix = e, this.hashMapShaderManager = new Rk("segmentStatedColorHash");
  }
  defineShader(e) {
    this.hashMapShaderManager.defineShader(e);
    let t = `
bool ${this.getFunctionName}(uint64_t x, out vec3 value) {
  uint64_t uint64Value;
  if (${this.hashMapShaderManager.getFunctionName}(x, uint64Value)) {
    uint uintValue = uint64Value.value[0];
    value.r = float((uintValue & 0x0000ffu))       / 255.0;
    value.g = float((uintValue & 0x00ff00u) >>  8) / 255.0;
    value.b = float((uintValue & 0xff0000u) >> 16) / 255.0;
    return true;
  }
  return false;
}
`;
    e.addFragmentCode(t);
  }
  get getFunctionName() {
    return `${this.prefix}_get`;
  }
  enable(e, t, i) {
    this.hashMapShaderManager.enable(e, t, i);
  }
  disable(e, t) {
    this.hashMapShaderManager.disable(e, t);
  }
};
var Nk = "data:image/svg+xml;base64,PHN2ZyByb2xlPSJpbWciIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjI0IiBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIGFyaWEtbGFiZWxsZWRieT0iYXJyb3dMZWZ0SWNvblRpdGxlIj4KICAgIDx0aXRsZSBpZD0iYXJyb3dMZWZ0SWNvblRpdGxlIj5BcnJvdyBMZWZ0PC90aXRsZT4gICAgCiAgICA8cGF0aCBkPSJNOSA2bC02IDYgNiA2Ii8+CiAgICA8cGF0aCBkPSJNMjEgMTJINCIvPgogICAgPHBhdGggc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBkPSJNMyAxMmgxIi8+Cjwvc3ZnPg==";
var _k = "data:image/svg+xml;base64,PHN2ZyByb2xlPSJpbWciIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjI0IiBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIGFyaWEtbGFiZWxsZWRieT0iYXJyb3dSaWdodEljb25UaXRsZSI+CiAgICA8dGl0bGUgaWQ9ImFycm93UmlnaHRJY29uVGl0bGUiPkFycm93IFJpZ2h0PC90aXRsZT4gICAgCiAgICA8cGF0aCBkPSJNMTUgMThsNi02LTYtNiIvPgogICAgPHBhdGggZD0iTTMgMTJoMTciLz4KICAgIDxwYXRoIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgZD0iTTIxIDEyaC0xIi8+Cjwvc3ZnPg==";
var R3 = class {
  /**
   * If an existing HierarchicalMap is specified, a shallow copy is made.
   *
   * @param existing Existing map to make a shallow copy of.
   */
  constructor(e) {
    if (this.parents = new Array(), this.parentPriorities = new Array(), this.bindings = new de(), e !== void 0) {
      this.parents.push(...e.parents), this.parentPriorities.push(...e.parentPriorities);
      for (const i of e.bindings) {
        var t = ce(i, 2);
        const r = t[0], s = t[1];
        this.bindings.set(r, s);
      }
    }
  }
  /**
   * Register `parent` as a parent map.  If `priority > 0`, this map will take precedence over
   * direct bindings.
   *
   * @returns A nullary function that unregisters the parent (and may be called at most once).
   */
  addParent(e, t) {
    const i = this.parents, r = this.parentPriorities;
    let s = 0;
    const a = i.length;
    for (; s < a && t < r[s]; )
      ++s;
    return i.splice(s, 0, e), r.splice(s, 0, t), () => {
      this.removeParent(e);
    };
  }
  /**
   * Unregisters `parent` as a parent.
   */
  removeParent(e) {
    const t = this.parents.indexOf(e);
    if (t === -1)
      throw new Error("Attempt to remove non-existent parent map.");
    this.parents.splice(t, 1), this.parentPriorities.splice(t, 1);
  }
  /**
   * Register a direct binding.
   */
  set(e, t) {
    this.bindings.set(e, t);
  }
  /**
   * Unregister a direct binding.
   */
  delete(e) {
    this.bindings.delete(e);
  }
  /**
   * Deletes all bindings, including parents.
   */
  clear() {
    this.bindings.clear(), this.parents.length = 0, this.parentPriorities.length = 0;
  }
  /**
   * Lookup the highest priority value to which the specified key is mapped.
   */
  get(e) {
    const t = this.parents, i = this.parentPriorities, r = i.length;
    let s = 0, a;
    for (; s < r && i[s] > 0; ++s)
      if (a = t[s].get(e), a !== void 0)
        return a;
    if (a = this.bindings.get(e), a !== void 0)
      return a;
    for (; s < r; ++s)
      if (a = t[s].get(e), a !== void 0)
        return a;
  }
  /**
   * Find all values to which the specified key is mapped.
   */
  *getAll(e) {
    const t = this.parents, i = this.parentPriorities, r = i.length;
    let s = 0, a;
    for (; s < r && i[s] > 0; )
      a = t[s].get(e), a !== void 0 && (yield a);
    for (a = this.bindings.get(e), a !== void 0 && (yield a); s < r; )
      a = t[s].get(e), a !== void 0 && (yield a);
  }
  *entries() {
    const e = this.parents, t = this.parentPriorities, i = t.length;
    let r = 0;
    for (; r < i && t[r] > 0; ++r)
      yield* e[r].entries();
    for (yield* this.bindings.entries(); r < i; ++r)
      yield* e[r].entries();
  }
};
var uw;
(function(n) {
  n[n.CONTROL = 1] = "CONTROL", n[n.ALT = 2] = "ALT", n[n.META = 4] = "META", n[n.SHIFT = 8] = "SHIFT";
})(uw || (uw = {}));
function Sy(n) {
  return (n.ctrlKey ? 1 : 0) | (n.altKey ? 2 : 0) | (n.metaKey ? 4 : 0) | (n.shiftKey ? 8 : 0);
}
function um(n, e) {
  let t = "";
  return e & 1 && (t += "control+"), e & 2 && (t += "alt+"), e & 4 && (t += "meta+"), e & 8 && (t += "shift+"), t += n, t;
}
function M3(n, e, t) {
  let i = "";
  return e & 1 && (i += "control+"), t & 1 && (i += "control?+"), e & 2 && (i += "alt+"), t & 2 && (i += "alt?+"), e & 4 && (i += "meta+"), t & 4 && (i += "meta?+"), e & 8 && (i += "shift+"), t & 8 && (i += "shift?+"), i += n, i;
}
function hw(n) {
  const e = n.indexOf(":");
  let t;
  if (e !== -1 && (t = n.substring(0, e), t !== "at" && t !== "bubble"))
    throw new Error(`Invalid event phase: ${se(t)}`);
  const i = n.substring(e + 1).split("+");
  let r, s = 0, a = 0;
  e:
    for (let l of i)
      switch (l) {
        case "control":
          s |= 1;
          break;
        case "control?":
          a |= 1;
          break;
        case "alt":
          s |= 2;
          break;
        case "alt?":
          a |= 2;
          break;
        case "meta":
          s |= 4;
          break;
        case "meta?":
          a |= 4;
          break;
        case "shift":
          s |= 8;
          break;
        case "shift?":
          a |= 8;
          break;
        default:
          if (r === void 0)
            r = l;
          else {
            r = void 0;
            break e;
          }
      }
  if (r === void 0 || s & a)
    throw new Error(`Invalid event identifier: ${se(n)}`);
  return { phase: t, keyName: r, modifiers: s, optionalModifiers: a };
}
function* N3(n, e, t) {
  t === 0 && (yield um(n, e));
  for (let i = 0; i < 16; ++i)
    (i & (e | t)) === i && (i & e) === e && (yield um(n, i));
}
function* fw2(n) {
  const e = n.phase, t = N3(n.keyName, n.modifiers, n.optionalModifiers);
  if (e === void 0)
    for (const i of t)
      yield `at:${i}`, yield `bubble:${i}`;
  else
    for (const i of t)
      yield `${e}:${i}`;
}
function _3(n, e) {
  const t = M3(n.keyName, n.modifiers, n.optionalModifiers);
  return typeof e == "string" ? { action: e, originalEventIdentifier: t } : RZr(RZr({}, e), { originalEventIdentifier: t });
}
var vt = class _vt extends R3 {
  /**
   * Returns a new EventActionMap with the specified bindings.
   *
   * The keys of the `bindings` object specify unnormalized event identifiers to be mapped to their
   * corresponding `ActionOrEventAction` values.
   */
  static fromObject(e, t = {}) {
    const i = new _vt();
    if (i.label = t.label, t.parents !== void 0)
      for (const s of t.parents) {
        var r = ce(s, 2);
        const a = r[0], l = r[1];
        i.addParent(a, l);
      }
    for (const s of un(e))
      i.set(s, e[s]);
    return i;
  }
  setFromObject(e) {
    for (const t of un(e))
      this.set(t, e[t]);
  }
  /**
   * Maps the specified event `identifier` to the specified `action`.
   *
   * The `identifier` may be unnormalized; the actual mapping is created for each corresponding
   * normalized identifier.
   */
  set(e, t) {
    const i = hw(e), r = _3(i, t);
    for (const s of fw2(i))
      super.set(s, r);
  }
  /**
   * Deletes the mapping for the specified `identifier`.
   *
   * The `identifier` may be unnormalized; the mapping is deleted for each corresponding normalized
   * identifier.
   */
  delete(e) {
    for (const t of fw2(hw(e)))
      super.delete(t);
  }
  describe() {
    const e = [], t = new de();
    for (const s of this.entries()) {
      var i = ce(s, 2);
      const a = i[1];
      t.set(a.originalEventIdentifier, a.action);
    }
    for (const s of t) {
      var r = ce(s, 2);
      const a = r[0], l = r[1];
      e.push(`${a}→${l}`);
    }
    return e.join(", ");
  }
};
function Ok(n, e, t) {
  if (t === void 0)
    return;
  t.stopPropagation !== false && n.stopPropagation();
  const i = new CustomEvent("action:" + t.action, { bubbles: true, detail: e, cancelable: true }), r = !n.target.dispatchEvent(i);
  (t.preventDefault !== false || r) && n.preventDefault();
}
var Jh = [];
Jh[Event.AT_TARGET] = "at";
Jh[Event.CAPTURING_PHASE] = "capture";
Jh[Event.BUBBLING_PHASE] = "bubble";
function Vk(n, e, t, i, r) {
  const s = Jh[t] + ":" + n, a = r.get(s);
  Ok(e, i, a);
}
function Bk(n, e, t, i) {
  Vk(um(n, Sy(e)), e, e.eventPhase, t, i);
}
function be(n, e, t, i) {
  return Vi(n, `action:${e}`, t, i);
}
var jp;
function O3() {
  if (jp === void 0) {
    const n = new vt();
    n.set("keyl", "recolor"), n.set("keyx", "clear-segments"), n.set("keys", "toggle-show-slices"), n.set("keyb", "toggle-scale-bar"), n.set("keyv", "toggle-default-annotations"), n.set("keya", "toggle-axis-lines"), n.set("keyo", "toggle-orthographic-projection");
    for (let e = 1; e <= 9; ++e)
      n.set("digit" + e, "toggle-layer-" + e), n.set("control+digit" + e, "select-layer-" + e), n.set("alt+digit" + e, "toggle-pick-layer-" + e);
    for (let e = 0; e < 26; ++e) {
      const t = String.fromCharCode(97 + e), i = String.fromCharCode(65 + e);
      n.set(`alt?+control?+shift+key${t}`, `tool-${i}`);
    }
    n.set("keyn", "add-layer"), n.set("keyh", "help"), n.set("space", "toggle-layout"), n.set("shift+space", "toggle-layout-alternative"), n.set("backslash", "toggle-show-statistics"), jp = n;
  }
  return jp;
}
var Jp;
function Yh() {
  return Jp === void 0 && (Jp = vt.fromObject({ "control+mousedown2": "select-position" })), Jp;
}
var Yp;
function V3() {
  return Yp === void 0 && (Yp = vt.fromObject({
    click0: "pin-annotation",
    mousedown2: "move-to-annotation"
  }, { parents: [[Yh(), 0]] })), Yp;
}
var qp;
function Fk() {
  return qp === void 0 && (qp = vt.fromObject({
    arrowleft: "x-",
    arrowright: "x+",
    arrowup: "y-",
    arrowdown: "y+",
    comma: "z-",
    period: "z+",
    bracketleft: "t-",
    bracketright: "t+",
    keyz: "snap",
    "control+equal": "zoom-in",
    "alt+equal": "depth-range-decrease",
    "control+shift+equal": "zoom-in",
    "alt+shift+equal": "depth-range-decrease",
    "control+minus": "zoom-out",
    "alt+minus": "depth-range-increase",
    keyr: "rotate-relative-z-",
    keye: "rotate-relative-z+",
    "shift+arrowdown": "rotate-relative-x-",
    "shift+arrowup": "rotate-relative-x+",
    "shift+arrowleft": "rotate-relative-y-",
    "shift+arrowright": "rotate-relative-y+",
    "control+wheel": { action: "zoom-via-wheel", preventDefault: true },
    "alt+wheel": { action: "adjust-depth-range-via-wheel", preventDefault: true },
    "at:wheel": { action: "z+1-via-wheel", preventDefault: true },
    "at:shift+wheel": { action: "z+10-via-wheel", preventDefault: true },
    "at:alt+mousedown2": "copy-segment-id",
    "at:alt+shift+mousedown2": "add-copy-segment-id",
    "at:dblclick0": "select",
    "at:control+mousedown0": "annotate",
    "at:mousedown2": "move-to-mouse-position",
    "at:alt+mousedown0": "move-annotation",
    "at:control+alt+mousedown2": "delete-annotation",
    "at:touchpinch": "zoom-via-touchpinch",
    "at:touchrotate": "rotate-in-plane-via-touchrotate",
    "at:touchtranslate2": "translate-in-plane-via-touchtranslate",
    "at:touchhold1": "move-to-mouse-position",
    "at:touchtap1x2": "select",
    "at:touchtap2x3": "snap"
  }, {
    label: "All Data Panels",
    parents: [[Yh(), 0]]
  })), qp;
}
var Kp;
function B3() {
  return Kp === void 0 && (Kp = vt.fromObject({
    "at:mousedown0": { action: "rotate-via-mouse-drag", stopPropagation: true },
    "at:shift+mousedown0": { action: "translate-via-mouse-drag", stopPropagation: true },
    "at:touchtranslate1": "rotate-out-of-plane-via-touchtranslate"
  }, { parents: [[Fk(), Number.NEGATIVE_INFINITY]] })), Kp;
}
var Zp;
function F3() {
  return Zp === void 0 && (Zp = vt.fromObject({
    "at:mousedown0": { action: "translate-via-mouse-drag", stopPropagation: true },
    "at:shift+mousedown0": { action: "rotate-via-mouse-drag", stopPropagation: true },
    "at:touchtranslate1": "translate-z-via-touchtranslate"
  }, { parents: [[Fk(), Number.NEGATIVE_INFINITY]] })), Zp;
}
function U3(n) {
  n.global.addParent(O3(), Number.NEGATIVE_INFINITY), n.sliceView.addParent(F3(), Number.NEGATIVE_INFINITY), n.perspectiveView.addParent(B3(), Number.NEGATIVE_INFINITY);
}
function it(n) {
  for (; ; ) {
    let e = n.firstChild;
    if (!e)
      break;
    n.removeChild(e);
  }
}
function Ft(n) {
  let e = n.parentElement;
  return e ? (e.removeChild(n), true) : false;
}
function Kn(n, e = Math.max(1, n.value.length)) {
  const t = `${e}ch`;
  n.style.width !== t && (n.style.width = "0px", n.offsetWidth, n.style.width = t);
}
function ar(n, e) {
  let t = n.firstElementChild;
  for (const i of e)
    i !== t && n.insertBefore(i, t), t = i.nextElementSibling;
  for (; t !== null; ) {
    let i = t.nextElementSibling;
    n.removeChild(t), t = i;
  }
}
function by(n) {
  return n instanceof HTMLElement ? !!(n instanceof HTMLInputElement || n instanceof HTMLTextAreaElement || n.isContentEditable) : false;
}
function z3(n) {
  const e = n.cloneNode(
    /*deep=*/
    true
  );
  return e.style.position = "absolute", document.body.appendChild(e), e.getBoundingClientRect();
}
var yo;
var oc = [];
function G3() {
  if (yo === void 0) {
    const n = yo = document.createElement("div");
    n.classList.add("neuroglancer-drag-status"), document.body.appendChild(n);
  }
  return yo;
}
function $3() {
  yo !== void 0 && (it(yo), yo.style.display = "none");
}
function Uk(n) {
  const e = G3();
  it(e), typeof n == "string" ? e.appendChild(document.createTextNode(n)) : e.appendChild(n()), e.style.display = "";
}
function zk(n, e) {
  AE(oc, (t) => !(t.target === n && t.operation === e));
}
function or(n, e, t) {
  zk(n, e), oc.push({ target: n, operation: e, status: t }), Uk(t);
}
function Ln(n, e) {
  zk(n, e);
  const t = oc.length === 0 ? void 0 : oc[oc.length - 1];
  t === void 0 ? $3() : Uk(t.status);
}
var W3 = 300;
var H3 = 100;
var Ca = {
  side: "right",
  col: 0,
  row: 1 / 0,
  flex: 1,
  size: W3,
  minSize: H3,
  visible: false
};
var Ns = class {
  constructor(e = Ca, t = e) {
    this.defaultValue = e, this.value = t, this.changed = new ot(), this.locationChanged = new ot(), this.locationChanged.add(this.changed.dispatch);
    const i = this;
    this.watchableVisible = {
      get value() {
        return i.visible;
      },
      set value(r) {
        i.visible = r;
      },
      changed: i.locationChanged
    };
  }
  toJSON(e = this.defaultValue) {
    const t = {}, i = this.value;
    for (const r in i)
      i[r] !== e[r] && (t[r] = i[r]);
    return t;
  }
  get visible() {
    return this.value.visible;
  }
  set visible(e) {
    const t = this.value;
    t.visible !== e && (this.value = RZr(RZr({}, t), { visible: e }), this.locationChanged.dispatch());
  }
  reset() {
    this.value !== this.defaultValue && (this.value = this.defaultValue, this.locationChanged.dispatch());
  }
  restoreState(e, t = this.defaultValue) {
    if (e === void 0)
      return;
    pe(e);
    const i = {
      side: Ce(e, "side", (r) => {
        if (r !== "left" && r !== "right" && r !== "top" && r !== "bottom")
          throw new Error(`Expected "left", "right", "top", or "bottom", but received: ${se(r)}`);
        return r;
      }, t.side),
      col: Ce(e, "col", Lt, t.col),
      row: Ce(e, "row", Lt, t.row),
      flex: Ce(e, "flex", Lt, t.flex),
      size: Ce(e, "size", dn, t.size),
      visible: Ce(e, "visible", la, t.visible),
      // minSize cannot be modified.
      minSize: t.minSize
    };
    this.value = i, this.locationChanged.dispatch();
  }
};
function zi(n, e, t) {
  const i = n.view.document;
  let r = n.clientX, s = n.clientY;
  const a = (f) => {
    const g = f.clientX - r, v = f.clientY - s;
    r = f.clientX, s = f.clientY, e(f, g, v);
  }, l = n.button, d = (f) => {
    i.removeEventListener("pointermove", a, true), i.removeEventListener("pointerup", u, false), t !== void 0 && t(f, f.clientX - r, f.clientY - s);
  }, u = (f) => {
    f.button === l && d(f);
  };
  i.addEventListener("pointermove", a, true), i.addEventListener("pointerup", u, false), i.addEventListener("pointercancel", d, false);
}
var j3 = "data:image/svg+xml;base64,PHN2ZyByb2xlPSJpbWciIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjI0IiBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIGFyaWEtbGFiZWxsZWRieT0iY2xvc2VJY29uVGl0bGUiPgogICAgPHRpdGxlIGlkPSJjbG9zZUljb25UaXRsZSI+Q2xvc2U8L3RpdGxlPiAgICAKICAgIDxwYXRoIGQ9Ik02LjM0MzE0NTc1IDYuMzQzMTQ1NzVMMTcuNjU2ODU0MiAxNy42NTY4NTQyTTYuMzQzMTQ1NzUgMTcuNjU2ODU0MkwxNy42NTY4NTQyIDYuMzQzMTQ1NzUiLz4KPC9zdmc+";
var J3 = "data:image/svg+xml;base64,PHN2ZyByb2xlPSJpbWciIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjI0IiBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIGFyaWEtbGFiZWxsZWRieT0icmVmcmVzaEljb25UaXRsZSI+CiAgICA8dGl0bGUgaWQ9InJlZnJlc2hJY29uVGl0bGUiPlJlZnJlc2g8L3RpdGxlPiAgICAKICAgIDxwb2x5bGluZSBwb2ludHM9IjIyIDEyIDE5IDE1IDE2IDEyIi8+CiAgICA8cGF0aCBkPSJNMTEsMjAgQzYuNTgxNzIyLDIwIDMsMTYuNDE4Mjc4IDMsMTIgQzMsNy41ODE3MjIgNi41ODE3MjIsNCAxMSw0IEMxNS40MTgyNzgsNCAxOSw3LjU4MTcyMiAxOSwxMiBMMTksMTQiLz4KPC9zdmc+";
function Tt(n) {
  const e = n.title, t = n.onClick, i = n.href;
  let r;
  i !== void 0 ? (r = document.createElement("a"), r.href = i, r.target = "_blank") : r = document.createElement("div"), e !== void 0 && (r.title = e), t !== void 0 && r.addEventListener("click", t);
  const s = n.svg;
  return r.className = "neuroglancer-icon", s !== void 0 && (r.innerHTML = s), n.text !== void 0 && r.appendChild(document.createTextNode(n.text)), r;
}
function Cy(n = {}) {
  return Tt(RZr({ svg: j3 }, n));
}
function Y3(n = {}) {
  return Tt(RZr({ svg: J3 }, n));
}
var So = "neuroglancer-drag-over";
var pw2 = {
  row: "row",
  column: "col"
};
var q3 = {
  left: "right",
  right: "left",
  top: "bottom",
  bottom: "top"
};
var hs = {
  left: "column",
  right: "column",
  top: "row",
  bottom: "row"
};
var Qd = {
  left: "row",
  right: "row",
  top: "column",
  bottom: "column"
};
var io = {
  row: "width",
  column: "height"
};
var gw = {
  row: "left",
  column: "top"
};
var K3 = {
  row: "right",
  column: "bottom"
};
var mw = {
  left: "marginLeft",
  right: "marginRight",
  top: "marginTop",
  bottom: "marginBottom"
};
var eu = {
  left: -1,
  right: 1,
  top: -1,
  bottom: 1
};
var wa = class extends Z {
  constructor(e, t = new Ns()) {
    super(), this.sidePanelManager = e, this.location = t, this.element = document.createElement("div"), this.visibility = new Kt(Kt.VISIBLE);
    const i = this.element;
    i.classList.add("neuroglancer-side-panel"), i.draggable = true, i.addEventListener("dragstart", (r) => {
      this.sidePanelManager.startDrag(this.makeDragSource(), r), i.style.backgroundColor = "black", setTimeout(() => {
        i.style.backgroundColor = "";
      }, 0), or(i, "drag", () => document.createTextNode("Drag side panel to move it to the left/right/top/bottom of another panel"));
    }), i.addEventListener("dragend", (r) => {
      this.sidePanelManager.endDrag(), Ln(i, "drag");
    });
  }
  makeDragSource() {
    return {
      dropAsNewPanel: (e) => {
        const t = this.location.value;
        this.location.value = RZr(RZr({}, t), e), this.location.locationChanged.dispatch();
      }
    };
  }
  close() {
    this.location.visible = false;
  }
  addTitleBar(e) {
    const t = document.createElement("div");
    t.classList.add("neuroglancer-side-panel-titlebar");
    const i = e.title;
    let r;
    i !== void 0 && (r = document.createElement("div"), r.classList.add("neuroglancer-side-panel-title"), r.textContent = i, t.appendChild(r));
    const s = Cy({
      title: "Close panel",
      onClick: () => {
        this.close();
      }
    });
    return s.style.order = "100", t.appendChild(s), this.element.appendChild(t), { titleBar: t, titleElement: r, closeButton: s };
  }
  addBody(e) {
    e.draggable = true, e.addEventListener("dragstart", (t) => {
      t.preventDefault(), t.stopPropagation();
    }), this.element.appendChild(e);
  }
};
var Z3 = class extends Z {
  constructor(e, t, i = new Kt(Kt.VISIBLE)) {
    super(), this.display = e, this.center = t, this.visibility = i, this.element = document.createElement("div"), this.centerColumn = document.createElement("div"), this.beforeRender = new ot(), this.sides = {
      left: this.makeSidePanelSideState("left"),
      right: this.makeSidePanelSideState("right"),
      top: this.makeSidePanelSideState("top"),
      bottom: this.makeSidePanelSideState("bottom")
    }, this.registeredPanels = new je(), this.layoutNeedsUpdate = false, this.invalidateLayout = () => {
      this.layoutNeedsUpdate = true, this.display.scheduleRedraw();
    };
    const r = this.element, s = this.centerColumn;
    r.style.display = "flex", r.style.flex = "1", r.style.flexDirection = "row", s.style.display = "flex", s.style.flex = "1", s.style.flexDirection = "column", s.style.flexBasis = "0px", s.style.minWidth = "0px", this.render(), this.registerDisposer(e.updateStarted.add(() => {
      this.beforeRender.dispatch(), this.layoutNeedsUpdate && (this.render(), ++e.resizeGeneration);
    })), this.registerDisposer(this.visibility.changed.add(this.invalidateLayout));
  }
  get visible() {
    return this.visibility.visible;
  }
  makeSidePanelSideState(e) {
    return {
      flexGroups: [],
      outerDropZoneElement: this.makeDropZone(
        e,
        /*crossIndex=*/
        eu[e] * (1 / 0),
        /*flexIndex=*/
        0,
        /*zoneSide=*/
        e,
        /*centered=*/
        false
      )
    };
  }
  hasDroppablePanel() {
    return this.dragSource !== void 0;
  }
  startDrag(e, t) {
    setTimeout(() => {
      this.dragSource === e && (this.element.dataset.neuroglancerSidePanelDrag = "true");
    }, 0), this.dragSource = e, t.stopPropagation(), t.dataTransfer.setData("neuroglancer-side-panel", "");
  }
  endDrag() {
    delete this.element.dataset.neuroglancerSidePanelDrag, this.dragSource = void 0;
  }
  makeDropZone(e, t, i, r, s = false) {
    const a = document.createElement("div");
    a.className = "neuroglancer-side-panel-drop-zone";
    const l = 10, d = hs[r], u = Qd[r];
    return a.style[io[u]] = `${l}px`, a.style[io[d]] = "100%", s ? (a.style.position = "absolute", a.style[r] = "50%", a.style[mw[r]] = "-${size/2}px") : (a.style.position = "relative", a.style[mw[q3[r]]] = `-${l}px`), a.addEventListener("dragenter", (f) => {
      this.hasDroppablePanel() && (a.classList.add(So), f.preventDefault(), or(a, "drop", () => document.createTextNode(`Drop side panel as new ${d}`)));
    }), a.addEventListener("dragleave", () => {
      Ln(a, "drop"), a.classList.remove(So);
    }), a.addEventListener("dragover", (f) => {
      this.hasDroppablePanel() && f.preventDefault();
    }), a.addEventListener("drop", (f) => {
      const g = this.dragSource;
      if (g === void 0)
        return;
      Ln(a, "drop"), a.classList.remove(So);
      const v = hs[e];
      g.dropAsNewPanel({
        side: e,
        row: v === "column" ? i : t,
        col: v === "row" ? i : t
      }), this.dragSource = void 0, f.preventDefault(), f.stopPropagation();
    }), a;
  }
  registerPanel(e) {
    return this.registeredPanels.add(e), this.invalidateLayout(), e.location.locationChanged.add(this.invalidateLayout), () => {
      this.unregisterPanel(e);
    };
  }
  unregisterPanel(e) {
    var t;
    this.registeredPanels.delete(e), e.location.locationChanged.remove(this.invalidateLayout), (t = e.panel) === null || t === void 0 || t.dispose(), this.invalidateLayout();
  }
  disposed() {
    for (const e of this.registeredPanels) {
      const t = e.panel;
      t == null ? void 0 : t.dispose();
    }
    super.disposed();
  }
  render() {
    this.layoutNeedsUpdate = false;
    const e = { left: [], right: [], top: [], bottom: [] };
    for (const a of this.registeredPanels)
      e[a.location.value.side].push(a);
    const t = (a) => this.renderSide(a, this.sides[a].flexGroups, e[a]), i = this;
    function* r() {
      yield i.sides.left.outerDropZoneElement, yield* t("left"), yield i.centerColumn, yield* t("right"), yield i.sides.right.outerDropZoneElement;
    }
    ar(this.element, r());
    function* s() {
      yield i.sides.top.outerDropZoneElement, yield* t("top"), yield i.center, yield* t("bottom"), yield i.sides.bottom.outerDropZoneElement;
    }
    ar(this.centerColumn, s());
  }
  makeCrossGutter(e, t) {
    const i = document.createElement("div");
    i.style.position = "relative";
    const r = Qd[e];
    i.className = `neuroglancer-resize-gutter-${r === "row" ? "horizontal" : "vertical"}`, i.addEventListener("pointerdown", (a) => {
      if ("button" in a && a.button !== 0)
        return;
      a.preventDefault();
      const l = this.sides[e].flexGroups[t];
      if (l === void 0 || !l.visible)
        return;
      let u = l.element.getBoundingClientRect()[io[r]];
      const f = l.minSize, g = () => {
        or(i, "drag", `Drag to resize, current ${io[r]} is ${l.crossSize}px`);
      };
      g(), zi(a, (v, y, w) => {
        const C = r === "row" ? y : w;
        u -= eu[e] * C, l.crossSize = Math.max(f, Math.round(u)), g(), this.invalidateLayout();
      }, () => {
        Ln(i, "drag");
      });
    });
    const s = this.makeDropZone(
      e,
      t - eu[e] * 0.5,
      /*flexIndex=*/
      0,
      /*zoneSide=*/
      e,
      /*centered=*/
      true
    );
    return i.appendChild(s), i;
  }
  makeFlexGutter(e, t, i) {
    const r = document.createElement("div");
    r.style.position = "relative";
    const s = hs[e];
    r.className = `neuroglancer-resize-gutter-${s === "row" ? "horizontal" : "vertical"}`, r.addEventListener("pointerdown", (l) => {
      if ("button" in l && l.button !== 0)
        return;
      l.preventDefault();
      const d = this.sides[e].flexGroups[t];
      if (d === void 0 || !d.visible)
        return;
      const u = d.cells, f = u[i];
      if (f === void 0 || !f.registeredPanel.location.visible)
        return;
      let g = i + 1;
      for (; g < u.length && !u[g].registeredPanel.location.visible; )
        ++g;
      if (g === u.length)
        return;
      const v = u[g], y = () => {
        or(r, "drag", `Drag to resize, current ${io[s]} ratio is ${f.registeredPanel.location.value.flex} : ${v.registeredPanel.location.value.flex}`);
      };
      y(), zi(l, (w) => {
        const C = f.registeredPanel.panel, b = v.registeredPanel.panel;
        if (C === void 0 || b === void 0)
          return;
        const E = C.element.getBoundingClientRect(), L = b.element.getBoundingClientRect(), R = Math.max(0.1, Math.min(0.9, s === "column" ? (w.clientY - E.top) / (L.bottom - E.top) : (w.clientX - E.left) / (L.right - E.left))), _ = f.registeredPanel.location.value, A = v.registeredPanel.location.value, I = _.flex + A.flex;
        f.registeredPanel.location.value = RZr(RZr({}, _), { flex: Math.round(R * I * 100) / 100 }), v.registeredPanel.location.value = RZr(RZr({}, A), { flex: Math.round((1 - R) * I * 100) / 100 }), y(), f.registeredPanel.location.locationChanged.dispatch(), v.registeredPanel.location.locationChanged.dispatch(), this.invalidateLayout();
      }, () => {
        Ln(r, "drag");
      });
    });
    const a = this.makeDropZone(
      e,
      t,
      /*flexIndex=*/
      i + 0.5,
      /*zoneSide=*/
      gw[hs[e]],
      /*centered=*/
      true
    );
    return r.appendChild(a), r;
  }
  renderSide(e, t, i) {
    const r = pw2[Qd[e]], s = pw2[hs[e]];
    i.sort((d, u) => {
      const f = d.location.value, g = u.location.value, v = f[s] - g[s];
      return v !== 0 ? v : f[r] - g[r];
    });
    const a = this;
    function* l() {
      let d = 0, u = i.length, f = 0;
      for (; d < u; ) {
        const g = i[d].location.value[s];
        let v = d, y = 0, w = 0;
        do {
          const L = i[v].location.value;
          if (L[s] !== g)
            break;
          L.visible && (++y, w = Math.max(w, L.minSize)), ++v;
        } while (v < u);
        const C = y > 0;
        let b = t[f];
        if (b === void 0) {
          const L = a.makeCrossGutter(e, f), R = document.createElement("div");
          R.className = `neuroglancer-side-panel-${hs[e]}`, b = t[f] = {
            element: R,
            gutterElement: L,
            cells: [],
            crossSize: -1,
            minSize: w,
            visible: C,
            beginDropZone: a.makeDropZone(
              e,
              f,
              /*flexIndex=*/
              -1 / 0,
              gw[hs[e]]
            ),
            endDropZone: a.makeDropZone(
              e,
              f,
              /*flexIndex=*/
              1 / 0,
              K3[hs[e]]
            )
          };
        } else
          b.visible = C, b.minSize = w, b.crossSize = Math.max(b.crossSize, w);
        function* E() {
          yield b.beginDropZone;
          let L = 0;
          for (let R = d, _ = 0; R < v; ++R, ++_) {
            const A = i[R];
            let I = b.cells[_];
            I === void 0 ? I = b.cells[_] = {
              registeredPanel: A,
              gutterElement: void 0
            } : I.registeredPanel = A;
            const P = I.registeredPanel.location.value;
            b.crossSize == -1 && (b.crossSize = Math.max(w, P.size)), (P[s] !== f || P[r] !== _ || P.visible && P.size !== b.crossSize) && (I.registeredPanel.location.value = RZr(RZr({}, P), { [s]: f, [r]: _, size: P.visible ? b.crossSize : P.size }), I.registeredPanel.location.changed.dispatch());
            const N = P.visible && a.visibility.visible;
            let O = A.panel;
            if (!N) {
              O !== void 0 && (O.dispose(), A.panel = void 0);
              continue;
            }
            ++L, O === void 0 && (O = A.panel = A.makePanel()), O.element.style.flex = y > 1 ? `${P.flex}` : "1", yield O.element, L === y ? I.gutterElement = void 0 : (I.gutterElement === void 0 && (I.gutterElement = a.makeFlexGutter(e, f, _)), yield I.gutterElement);
          }
          yield b.endDropZone;
        }
        ar(b.element, E()), b.cells.length = v - d, C && (b.element.style[io[Qd[e]]] = `${b.crossSize}px`, eu[e] > 0 ? (yield b.gutterElement, yield b.element) : (yield b.element, yield b.gutterElement)), d = v, ++f;
      }
      t.length = f;
    }
    return l();
  }
};
function oi(n, e = "text/plain") {
  let t = false;
  const i = Vi(document, "copy", (r) => {
    const s = r.clipboardData;
    s !== null && (s.setData(e, n), t = true), r.stopPropagation(), r.preventDefault();
  }, true);
  try {
    document.execCommand("copy");
  } finally {
    i();
  }
  return t;
}
var qr = class extends Z {
  constructor(e, t, i) {
    super(), this.target = e, this.eventMap = t, this.registerEventListener(e, "wheel", (r) => {
      i !== void 0 && i(r), this.dispatch("wheel", r);
    }), this.registerEventListener(e, "click", (r) => {
      i !== void 0 && i(r), this.dispatch(`click${r.button}`, r);
    }), this.registerEventListener(e, "dblclick", (r) => {
      i !== void 0 && i(r), this.dispatch(`dblclick${r.button}`, r);
    }), this.registerEventListener(e, "mousedown", (r) => {
      i !== void 0 && i(r);
      let s = r.button;
      s === 2 && (r.buttons & 3) === 1 && (s = 0), this.dispatch(`mousedown${s}`, r);
    }), this.registerEventListener(e, "mouseup", (r) => {
      i !== void 0 && i(r), this.dispatch(`mouseup${r.button}`, r);
    });
  }
  dispatch(e, t) {
    Bk(e, t, t, this.eventMap);
  }
};
var tr = class extends Z {
  constructor(e, t) {
    super(), this.element = Tt(RZr(RZr({}, t), { onClick: () => {
      e.value = !e.value;
    } })), this.element.classList.add("neuroglancer-checkbox-icon"), this.element.classList.add(t.backgroundScheme === "dark" ? "dark-background" : "light-background");
    const i = () => {
      const r = e.value;
      this.element.dataset.checked = r ? "true" : "false", this.element.title = (r ? t.disableTitle : t.enableTitle) || "";
    };
    this.registerDisposer(e.changed.add(i)), i();
  }
};
var X3 = "data:image/svg+xml;base64,PHN2ZyByb2xlPSJpbWciIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjI0IiBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIGFyaWEtbGFiZWxsZWRieT0iY29weUljb25UaXRsZSI+CiAgICA8dGl0bGUgaWQ9ImNvcHlJY29uVGl0bGUiPkNvcHk8L3RpdGxlPiAgICAKICAgIDxyZWN0IHdpZHRoPSIxMiIgaGVpZ2h0PSIxNCIgeD0iOCIgeT0iNyIvPgogICAgPHBvbHlsaW5lIHBvaW50cz0iMTYgMyA0IDMgNCAxNyIvPgo8L3N2Zz4=";
function dr(n = {}) {
  return Tt(RZr({ svg: X3 }, n));
}
var Q3 = class extends Z {
  constructor(e) {
    super(), this.redraw = e;
  }
};
var ur = class extends Z {
  constructor(e, t, i = new Kt(Kt.VISIBLE)) {
    super(), this.model = e, this.render = t, this.visibility = i, this.element = document.createElement("div"), this.generation = -1, this.currentViewDisposer = void 0, this.debouncedUpdateView = this.registerCancellable(Ct(() => this.updateView())), this.element.style.display = "contents", this.registerDisposer(e.changed.add(this.debouncedUpdateView)), this.registerDisposer(i.changed.add(() => {
      this.visible && this.debouncedUpdateView();
    })), this.updateView();
  }
  get visible() {
    return this.visibility.visible;
  }
  updateView() {
    if (!this.visible)
      return;
    const e = this.model;
    if (e.changed.count === this.generation)
      return;
    this.disposeCurrentView();
    const i = this.currentViewDisposer = new Q3(this.debouncedUpdateView);
    this.render(e.value, this.element, i);
  }
  disposeCurrentView() {
    let e = this.currentViewDisposer;
    e !== void 0 && e.dispose(), it(this.element);
  }
  disposed() {
    this.disposeCurrentView(), super.disposed();
  }
};
function Gk(n = {}) {
  return Tt(RZr({ text: "↗" }, n));
}
function vw(n) {
  return n.closest(".neuroglancer-selection-details");
}
var yw = class extends wa {
  constructor(e, t, i, r) {
    super(e, t.location), this.sidePanelManager = e, this.state = t, this.manager = i, this.selectedLayer = r, this.body = document.createElement("div");
    const s = this.element, a = this.body;
    s.classList.add("neuroglancer-selection-details"), this.registerDisposer(new qr(this.element, Yh()));
    var l = this.addTitleBar({ title: "Selection" });
    const d = l.titleBar, u = Tt({
      svg: Nk,
      title: "Previous selection",
      onClick: () => {
        this.state.goBack();
      }
    }), f = Tt({
      svg: _k,
      title: "Next selection",
      onClick: () => {
        this.state.goForward();
      }
    });
    d.appendChild(u), d.appendChild(f), d.appendChild(this.registerDisposer(new tr(t.pin, {
      // Note: \ufe0e forces text display, as otherwise the pin icon may as an emoji with
      // color.
      text: "📌︎",
      enableTitle: "Pin selection",
      disableTitle: "Unpin selection"
    })).element), a.classList.add("neuroglancer-selection-details-body"), this.addBody(a), a.appendChild(this.registerDisposer(new ur(t, (g, v, y) => {
      if (!t.location.visible || (u.style.visibility = t.canGoBack() ? "visible" : "hidden", f.style.visibility = t.canGoForward() ? "visible" : "hidden", g === void 0))
        return;
      if (g.position !== void 0) {
        const b = document.createElement("div");
        b.classList.add("neuroglancer-selection-details-position");
        const E = dr({
          title: "Copy position",
          onClick: () => {
            oi(_.map((I) => Math.floor(I)).join(", "));
          }
        });
        b.appendChild(E);
        var C = g.coordinateSpace;
        const L = C.rank, R = C.names, _ = g.position;
        for (let I = 0; I < L; ++I) {
          const P = document.createElement("span");
          P.classList.add("neuroglancer-selection-details-position-dimension");
          const N = document.createElement("span");
          N.classList.add("neuroglancer-selection-details-position-dimension-name"), N.textContent = R[I];
          const O = document.createElement("span");
          O.classList.add("neuroglancer-selection-details-position-dimension-coordinate"), O.textContent = Math.floor(_[I]).toString(), P.appendChild(N), P.appendChild(O), b.appendChild(P);
        }
        const A = Gk({
          title: "Move to position",
          onClick: () => {
            this.manager.globalPosition.value = _;
          }
        });
        b.appendChild(A), v.appendChild(b);
      }
      for (const b of g.layers) {
        const E = b.layer;
        v.appendChild(y.registerDisposer(new ur({
          value: void 0,
          changed: E.managedLayer.layerChanged
        }, (L, R, _) => {
          if (E.wasDisposed || !E.isReady)
            return;
          const A = document.createElement("div");
          if (A.classList.add("neuroglancer-selection-details-layer-body"), !E.displaySelectionState(b.state, A, _))
            return;
          const I = document.createElement("div");
          R.appendChild(I), I.classList.add("neuroglancer-selection-details-layer");
          const P = document.createElement("div");
          P.classList.add("neuroglancer-selection-details-layer-title"), P.textContent = E.managedLayer.name, P.addEventListener("click", () => {
            this.selectedLayer.layer = E.managedLayer, this.selectedLayer.visible = true;
          }), P.title = "Click to show layer side panel", I.appendChild(P), I.appendChild(A);
        })).element);
      }
    })).element);
  }
  close() {
    super.close(), this.state.value = void 0, this.state.pin.value = true;
  }
};
var eU = "data:image/svg+xml;base64,PHN2ZyByb2xlPSJpbWciIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjI0IiBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIGFyaWEtbGFiZWxsZWRieT0iZmlsdGVySWNvblRpdGxlIj4KICAgIDx0aXRsZSBpZD0iZmlsdGVySWNvblRpdGxlIj5GaWx0ZXI8L3RpdGxlPiAgICAKICAgIDxwYXRoIGQ9Ik0xMCAxMi4yNjFMNC4wMjggMy45NzJoMTZMMTQgMTIuMzI5VjE3bC00IDN6Ii8+Cjwvc3ZnPg==";
function tU(n = {}) {
  return Tt(RZr({ svg: eU }, n));
}
var $r = class {
  constructor(e, t, i) {
    this.key = e, this.value = t, this.label = i;
  }
  toString() {
    const e = this.key, t = this.value, i = this.label;
    let r;
    return t === void 0 ? r = `${e}` : r = `${e}→${t}`, i === void 0 ? r : `${r} ${i}`;
  }
};
var $k = class extends Z {
  constructor() {
    super(...arguments), this.selectedSegment = new re(), this.baseSelectedSegment = new re(), this.hasSelectedSegment = false, this.changed = new Ee();
  }
  get value() {
    return this.hasSelectedSegment ? this.selectedSegment : void 0;
  }
  get baseValue() {
    return this.hasSelectedSegment ? this.baseSelectedSegment : void 0;
  }
  set(e, t = false) {
    const i = this.selectedSegment, r = this.baseSelectedSegment;
    let s = 0, a = 0, l = 0, d = 0, u;
    if (e == null)
      u = false;
    else if (typeof e == "number")
      s = l = e >>> 0, a = d = e < 0 ? 4294967295 : 0, u = true;
    else if (e instanceof $r) {
      const f = e.value || e.key;
      s = f.low, a = f.high, l = e.key.low, d = e.key.high, u = true;
    } else
      e instanceof re ? (s = l = e.low, a = d = e.high, u = true) : u = false;
    t && s === 0 && a === 0 && (u = false), u ? u && (!this.hasSelectedSegment || i.low !== s || i.high !== a || r.low !== l || r.high !== d) && (i.low = s, i.high = a, r.low = l, r.high = d, this.hasSelectedSegment = true, this.changed.dispatch()) : this.hasSelectedSegment && (this.hasSelectedSegment = false, this.changed.dispatch());
  }
  isSelected(e) {
    return this.hasSelectedSegment && re.equal(e, this.selectedSegment);
  }
  bindTo(e, t) {
    this.registerDisposer(e.changed.add(() => {
      const i = e.get(t);
      let r;
      i !== void 0 && (r = i.value), this.set(r, t.displayState.segmentationGroupState.value.hideSegmentZero.value);
    }));
  }
};
function Ic(n) {
  n.useTemporarySegmentEquivalences.value = false, n.useTemporaryVisibleSegments.value = false, n.temporaryVisibleSegments.clear(), n.temporarySegmentEquivalences.clear();
}
function wy(n, e, t = false) {
  let i, r, s, a;
  if (typeof e == "number" ? i = new re(e >>> 0, e < 0 ? 4294967295 : 0) : typeof e == "string" ? i = re.parseString(e) : i = t ? e.clone() : e, n == null)
    return i;
  var l = n.segmentationGroupState.value;
  const d = l.segmentEquivalences, u = l.segmentPropertyMap.value;
  return d.size !== 0 ? (r = d.get(i), re.equal(r, i) ? s = void 0 : s = r) : r = i, a = u == null ? void 0 : u.getSegmentLabel(r), a === void 0 && s == null ? i : new $r(i, s, a);
}
function ha(n, e) {
  if (e instanceof $r)
    return e;
  let t = wy(n, e);
  return t instanceof re ? new $r(t) : t;
}
function hm(n, e) {
  const t = e.length;
  n.value < t && (n.value = t);
}
function Bo(n, e) {
  return Vr((t) => e.style.setProperty("--neuroglancer-segment-list-width", `${t}ch`), n.segmentationGroupState.value.maxIdLength);
}
var xy = (() => {
  const n = document.createElement("div");
  n.classList.add("neuroglancer-segment-list-entry");
  const e = document.createElement("div");
  e.classList.add("neuroglancer-segment-list-entry-sticky"), n.appendChild(e);
  const t = dr({
    title: "Copy segment ID"
  });
  t.classList.add("neuroglancer-segment-list-entry-copy");
  const i = document.createElement("div");
  i.classList.add("neuroglancer-segment-list-entry-copy-container");
  const r = i.childElementCount;
  i.appendChild(t);
  const s = e.childElementCount;
  e.appendChild(i);
  const a = e.childElementCount, l = document.createElement("input");
  l.type = "checkbox", l.title = "Toggle segment visibility", l.classList.add("neuroglancer-segment-list-entry-visible-checkbox"), e.appendChild(l);
  const d = document.createElement("div");
  d.classList.add("neuroglancer-segment-list-entry-id-container");
  const u = e.childElementCount;
  e.appendChild(d);
  const f = document.createElement("div");
  f.classList.add("neuroglancer-segment-list-entry-id");
  const g = d.childElementCount;
  d.appendChild(f);
  const v = document.createElement("span");
  v.classList.add("neuroglancer-segment-list-entry-name");
  const y = n.childElementCount;
  n.appendChild(v);
  const w = tU({
    title: "Filter by label"
  });
  w.classList.add("neuroglancer-segment-list-entry-filter");
  const C = n.childElementCount;
  return n.appendChild(w), {
    template: n,
    copyContainerIndex: s,
    copyIndex: r,
    visibleIndex: a,
    idContainerIndex: u,
    idIndex: g,
    labelIndex: y,
    filterIndex: C,
    unmappedIdIndex: -1,
    unmappedCopyIndex: -1
  };
})();
var nU = (() => {
  const n = xy, e = n.template.cloneNode(
    /*deep=*/
    true
  ), t = e.children[0], i = t.children[n.idContainerIndex], r = i.childElementCount, s = i.children[n.idIndex].cloneNode(
    /*deep=*/
    true
  );
  s.classList.add("neuroglancer-segment-list-entry-unmapped-id"), i.appendChild(s);
  const a = t.children[n.copyContainerIndex], l = a.childElementCount;
  return a.appendChild(a.children[n.copyIndex].cloneNode(
    /*deep=*/
    true
  )), RZr(RZr({}, n), { template: e, unmappedIdIndex: r, unmappedCopyIndex: l });
})();
function Wk(n) {
  let e = xy;
  const t = e.template.cloneNode(
    /*deep=*/
    true
  ), i = [];
  for (let r = 0; r < n; ++r) {
    i.push(t.childElementCount);
    const s = document.createElement("div");
    s.classList.add("neuroglancer-segment-list-entry-extra-property"), s.style.width = `max(var(--neuroglancer-column-${r}-width), var(--neuroglancer-column-${r}-label-width))`, t.appendChild(s);
  }
  return RZr(RZr({}, e), { template: t, numericalPropertyIndices: i });
}
var Sw = new vk();
function iU(n) {
  const e = (f) => {
    const g = f.currentTarget, v = g.dataset.id, y = Oi;
    y.tryParseString(v), n.segmentSelectionState.set(y), vw(g) || n.selectSegment(y, false);
  }, t = (f) => {
    const g = f.currentTarget, v = g.dataset.id, y = Oi;
    y.tryParseString(v), n.selectSegment(y, vw(g) ? "toggle" : true);
  }, i = () => {
    n.segmentSelectionState.set(null);
  }, r = (f) => f.currentTarget.closest(".neuroglancer-segment-list-entry"), s = (f) => {
    const g = r(f);
    oi(g.dataset.id), f.stopPropagation();
  }, a = (f) => {
    const g = r(f);
    oi(g.dataset.unmappedId), f.stopPropagation();
  }, l = (f) => {
    const v = r(f).dataset.id, y = Oi;
    y.tryParseString(v);
    const w = n.segmentationGroupState.value.visibleSegments;
    w.set(y, !w.has(y)), f.stopPropagation();
  }, d = (f) => {
    const v = r(f).dataset.id, y = Oi;
    y.tryParseString(v), n.filterBySegmentLabel(y), f.stopPropagation();
  }, u = (f) => {
    if (f.button !== 2 || f.ctrlKey || f.altKey || f.metaKey || f.shiftKey)
      return;
    const v = f.currentTarget.dataset.id, y = Oi;
    y.tryParseString(v), n.moveToSegment(y);
  };
  return (f, g) => {
    const v = f.children, y = v[0].children;
    f.addEventListener("mousedown", u);
    const w = y[g.copyContainerIndex];
    g.unmappedCopyIndex !== -1 && w.children[g.unmappedCopyIndex].addEventListener("click", a), w.children[g.copyIndex].addEventListener("click", s), f.addEventListener("mouseenter", e), f.addEventListener("mouseleave", i), y[g.visibleIndex].addEventListener("click", l), v[g.filterIndex].addEventListener("click", d), f.addEventListener("action:select-position", t);
  };
}
var tl = class _tl {
  constructor(e, t) {
    if (this.displayState = e, this.template = t, e !== void 0) {
      let i = Sw.get(e);
      i === void 0 && (i = iU(e), Sw.set(e, i)), this.registerEventHandlers = i;
    }
  }
  static make(e, t) {
    return new _tl(e, t ? nU : xy);
  }
  get(e) {
    const t = this.displayState;
    return this.getWithNormalizedId(ha(t, e));
  }
  getWithNormalizedId(e) {
    var t, i;
    const r = this.displayState, s = this.template, a = s.template.cloneNode(
      /*deep=*/
      true
    ), l = e.key, d = (t = e.value) !== null && t !== void 0 ? t : l, u = d.toString();
    a.dataset.id = u;
    const f = a.children, g = f[0].children, v = g[s.idContainerIndex];
    v.children[s.idIndex].textContent = u;
    const y = s.unmappedIdIndex;
    if (r !== void 0 ? this.registerEventHandlers(a, s) : g[s.visibleIndex].style.display = "none", y !== -1) {
      const w = v.children[y];
      if (re.equal(l, d)) {
        w.style.display = "none";
        const C = g[s.copyContainerIndex];
        C.children[s.unmappedCopyIndex].style.display = "none";
      } else {
        const C = l.toString();
        a.dataset.unmappedId = C, w.textContent = C, r !== void 0 && hm(r.segmentationGroupState.value.maxIdLength, C);
      }
    }
    return f[s.labelIndex].textContent = (i = e.label) !== null && i !== void 0 ? i : "", r !== void 0 && (this.updateWithId(a, d), hm(r.segmentationGroupState.value.maxIdLength, u)), a;
  }
  update(e) {
    const t = Oi, i = e.dataset.id;
    i !== void 0 && (t.parseString(i), this.updateWithId(e, t));
  }
  updateWithId(e, t) {
    const r = e.children[0].children, s = this.template, a = this.displayState, l = a.segmentSelectionState, d = a.segmentationGroupState.value.visibleSegments;
    r[s.visibleIndex].checked = d.has(t), e.dataset.selected = (l.hasSelectedSegment && re.equal(l.selectedSegment, t)).toString();
    const u = r[s.idContainerIndex];
    bw(u.children[s.idIndex], Wu(this.displayState, t));
    const f = s.unmappedIdIndex;
    if (f !== -1) {
      let g, v;
      if (a.baseSegmentColoring.value && (g = e.dataset.unmappedId) !== void 0) {
        const y = Oi;
        y.parseString(g), v = Wu(this.displayState, y);
      } else
        v = qE;
      bw(u.children[f], v);
    }
  }
};
function bw(n, e) {
  n.style.backgroundColor = Mk(e), n.style.color = ku(e) ? "white" : "black";
}
var Hk = class extends tl {
  constructor(e, t, i) {
    var r;
    const s = e.segmentationGroupState.value.segmentPropertyMap.value, a = ((r = s == null ? void 0 : s.numericalProperties) !== null && r !== void 0 ? r : []).filter(i), l = Wk(a.length);
    super(e, l), this.parentElement = t, this.segmentPropertyMap = s, this.numericalProperties = a, (this.numericalPropertyWidths = new Array(this.numericalProperties.length)).fill(0);
  }
  getWithNormalizedId(e) {
    var t, i, r;
    const s = super.getWithNormalizedId(e), a = this.numericalProperties, l = this.template.numericalPropertyIndices;
    if (l.length > 0) {
      const d = (r = (t = this.segmentPropertyMap) === null || t === void 0 ? void 0 : t.getSegmentInlineIndex((i = e.value) !== null && i !== void 0 ? i : e.key)) !== null && r !== void 0 ? r : -1;
      if (d !== -1) {
        const u = this.numericalPropertyWidths;
        for (let f = 0, g = l.length; f < g; ++f) {
          const v = a[f].values[d];
          if (!isNaN(v)) {
            const y = v.toString(), w = y.length;
            w > u[f] && (u[f] = w, this.parentElement.style.setProperty(`--neuroglancer-column-${f}-width`, `${w}ch`)), s.children[l[f]].textContent = y;
          }
        }
      }
    }
    return s;
  }
  makeHeaderLabel(e, t, i) {
    const r = document.createElement("span");
    r.textContent = e, r.classList.add("neuroglancer-segment-list-header-label"), r.classList.add("neuroglancer-segment-list-header-label"), e === "label" && (i.style.textAlign = "left");
    const s = document.createElement("span");
    s.classList.add("neuroglancer-segment-list-header-label-sort"), r.appendChild(s), s.textContent = "▲";
    const a = z3(r).width;
    return this.parentElement.style.setProperty(t, `${a}px`), i.appendChild(r), { id: e, label: r, sortIcon: s };
  }
  getHeader() {
    const e = this.template, t = e.template.cloneNode(
      /*deep=*/
      true
    ), i = t.children, r = i[0].children, s = r[e.copyContainerIndex];
    s.style.visibility = "hidden", r[e.visibleIndex].style.visibility = "hidden", i[e.filterIndex].style.visibility = "hidden";
    const a = r[e.idContainerIndex], l = [this.makeHeaderLabel("id", "--neuroglancer-id-column-label-width", a.children[e.idIndex]), this.makeHeaderLabel("label", "--neuroglancer-label-column-label-width", i[e.labelIndex])], d = this.numericalProperties, u = this.template.numericalPropertyIndices;
    for (let f = 0, g = u.length; f < g; ++f) {
      const v = d[f], y = this.makeHeaderLabel(v.id, `--neuroglancer-column-${f}-label-width`, t.children[u[f]]), w = v.description;
      w && (y.label.title = w), l.push(y);
    }
    return { container: t, propertyLabels: l };
  }
};
function qh(n, e) {
  return tl.make(
    n ?? void 0,
    /*includeUnmapped=*/
    true
  ).getWithNormalizedId(e);
}
function nl(n, e, t) {
  e.registerDisposer(wo((i, r) => {
    $B(i, r, t);
  }, n.segmentationGroupState)), e.registerDisposer(wo((i, r) => {
    i.registerDisposer(r.segmentColorHash.changed.add(t)), i.registerDisposer(r.segmentDefaultColor.changed.add(t));
  }, n.segmentationColorGroupState)), e.registerDisposer(n.saturation.changed.add(t)), e.registerDisposer(n.segmentSelectionState.changed.add(t)), e.registerDisposer(n.baseSegmentColoring.changed.add(t));
}
function Ey(n, e) {
  const t = e.redrawNeeded.dispatch;
  nl(n, e, t), e.registerDisposer(wo((i, r) => {
    WB(i, r, t);
  }, n.segmentationGroupState));
}
function jk(n, e) {
  Ey(n, e), e.registerDisposer(n.objectAlpha.changed.add(e.redrawNeeded.dispatch));
}
function Kh(n, e) {
  jk(n, e), e.registerDisposer(n.transform.changed.add(e.redrawNeeded.dispatch)), e.registerDisposer(n.renderScaleTarget.changed.add(e.redrawNeeded.dispatch)), e.registerDisposer(n.transparentPickEnabled.changed.add(e.redrawNeeded.dispatch));
}
var Jk = Th();
var Oi = new re();
function Wu(n, e, t = Jk) {
  if (n == null)
    return t.fill(1), t;
  const i = n.segmentationColorGroupState.value;
  if (i.segmentStatedColors.size !== 0 && i.segmentStatedColors.get(e, Oi))
    return t[0] = (Oi.low & 255) / 255, t[1] = ((Oi.low & 65280) >>> 8) / 255, t[2] = ((Oi.low & 16711680) >>> 16) / 255, t;
  const s = i.segmentDefaultColor.value;
  return s !== void 0 ? (t[0] = s[0], t[1] = s[1], t[2] = s[2], t) : (i.segmentColorHash.compute(t, e), t);
}
function Yk(n, e, t = 1) {
  const i = Jk;
  i[3] = t, Wu(n, e, i);
  let r = n.saturation.value;
  n.segmentSelectionState.isSelected(e) && (r > 0.5 ? r = r -= 0.5 : r += 0.5);
  for (let s = 0; s < 3; ++s)
    i[s] = i[s] * r + (1 - r);
  return i[0] *= t, i[1] *= t, i[2] *= t, i;
}
function Ty(n, e = {}) {
  for (const t of GB)
    e[t] = n[t].rpcId;
  return e;
}
var rU = Oh(Hc);
var Zh = class extends rU {
  constructor(e, t, i) {
    super(i), this.chunkManager = e, this.displayState = t;
  }
  initializeCounterpartWithChunkManager(e) {
    let t = this.displayState;
    e.chunkManager = this.chunkManager.rpcId, Ty(t.segmentationGroupState.value, e), e.transform = this.registerDisposer(An.makeFromExisting(this.chunkManager.rpc, this.displayState.transform)).rpcId, e.renderScaleTarget = this.registerDisposer(An.makeFromExisting(this.chunkManager.rpc, this.displayState.renderScaleTarget)).rpcId, super.initializeCounterpart(this.chunkManager.rpc, e);
  }
};
function Xh(n, e, t, i, r) {
  const s = Math.min(1, n.objectAlpha.value), a = n.baseSegmentColoring.value;
  Zo(n.segmentationGroupState.value, (l, d) => {
    let u = i == null ? void 0 : i.registerUint64(e, l), f = t ? Yk(n, a ? l : d, s) : void 0;
    r(l, f, u, d);
  });
}
var sU = Object.freeze(Object.defineProperty({
  __proto__: null,
  SegmentSelectionState: $k,
  SegmentWidgetFactory: tl,
  SegmentWidgetWithExtraColumnsFactory: Hk,
  SegmentationLayerSharedObject: Zh,
  Uint64MapEntry: $r,
  augmentSegmentId: ha,
  bindSegmentListWidth: Bo,
  forEachVisibleSegmentToDraw: Xh,
  getBaseObjectColor: Wu,
  getObjectColor: Yk,
  makeSegmentWidget: qh,
  maybeAugmentSegmentId: wy,
  registerCallbackWhenSegmentationDisplayStateChanged: nl,
  registerRedrawWhenSegmentationDisplayState3DChanged: Kh,
  registerRedrawWhenSegmentationDisplayStateChanged: Ey,
  registerRedrawWhenSegmentationDisplayStateWithAlphaChanged: jk,
  resetTemporaryVisibleSegmentsState: Ic,
  segmentWidgetTemplateWithExtraColumns: Wk,
  sendVisibleSegmentsState: Ty,
  updateIdStringWidth: hm
}, Symbol.toStringTag, { value: "Module" }));
var qk = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, s = r < 3 ? e : i === null ? i = $i(e, t) : i, a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(n, e, t, i);
  else
    for (var l = n.length - 1; l >= 0; l--)
      (a = n[l]) && (s = (r < 3 ? a(s) : r > 3 ? a(e, t, s) : a(e, t)) || s);
  return r > 3 && s && UZr(e, t, s), s;
};
var aU = et();
var mi = Mc();
function Kk(n, e) {
  e.vertexBuffer = Xn.fromData(n, e.meshData.vertexPositions, n.ARRAY_BUFFER, n.STATIC_DRAW), e.indexBuffer = Xn.fromData(n, e.meshData.indices, n.ELEMENT_ARRAY_BUFFER, n.STATIC_DRAW), e.normalBuffer = Xn.fromData(n, e.meshData.vertexNormals, n.ARRAY_BUFFER, n.STATIC_DRAW);
}
function Zk(n) {
  n.vertexBuffer.dispose(), n.indexBuffer.dispose(), n.normalBuffer.dispose();
}
var oU = `
highp vec3 decodeNormalOctahedronSnorm8(highp vec2 e) {
  vec3 v = vec3(e.xy, 1.0 - abs(e.x) - abs(e.y));
  if (v.z < 0.0) v.xy = (1.0 - abs(v.yx)) * vec2(v.x > 0.0 ? 1.0 : -1.0, v.y > 0.0 ? 1.0 : -1.0);
  return normalize(v);
}
`;
function Cw(n) {
  return {
    defineShader: (e) => {
      e.addAttribute("highp vec3", "aVertexPosition"), e.addVertexCode("highp vec3 getVertexPosition() { return aVertexPosition; }");
    },
    bind(e, t, i) {
      i.vertexBuffer.bindToVertexAttrib(
        t.attribute("aVertexPosition"),
        /*components=*/
        3,
        n,
        /* normalized=*/
        true
      );
    },
    endLayer: (e, t) => {
      e.disableVertexAttribArray(t.attribute("aVertexPosition"));
    }
  };
}
var lU = {
  [Fr.float32]: Cw(WebGL2RenderingContext.FLOAT),
  [Fr.uint16]: Cw(WebGL2RenderingContext.UNSIGNED_SHORT),
  [Fr.uint10]: {
    defineShader: (n) => {
      n.addAttribute("highp uint", "aVertexPosition"), n.addVertexCode(`
highp vec3 getVertexPosition() {
  return vec3(float(aVertexPosition & 1023u),
              float((aVertexPosition >> 10) & 1023u),
              float((aVertexPosition >> 20) & 1023u)) / 1023.0;
}
`);
    },
    bind(n, e, t) {
      t.vertexBuffer.bindToVertexAttribI(
        e.attribute("aVertexPosition"),
        /*components=*/
        1,
        WebGL2RenderingContext.UNSIGNED_INT
      );
    },
    endLayer: (n, e) => {
      n.disableVertexAttribArray(e.attribute("aVertexPosition"));
    }
  }
};
var Xk = class {
  constructor(e, t) {
    this.fragmentRelativeVertices = e, this.vertexPositionFormat = t, this.tempLightVec = new Float32Array(4), this.vertexPositionHandler = lU[this.vertexPositionFormat];
  }
  beginLayer(e, t, i, r) {
    let s = i.lightDirection, a = i.ambientLighting, l = i.directionalLighting, d = this.tempLightVec;
    Ev(d, s, l), d[3] = a, e.uniform4fv(t.uniform("uLightDirection"), d);
    const u = r.silhouetteRendering.value;
    u > 0 && e.uniform1f(t.uniform("uSilhouettePower"), u);
  }
  setColor(e, t, i) {
    e.uniform4fv(t.uniform("uColor"), i);
  }
  setPickID(e, t, i) {
    e.uniform1ui(t.uniform("uPickID"), i);
  }
  beginModel(e, t, i, r) {
    const s = i.projectionParameters;
    e.uniformMatrix4fv(t.uniform("uModelViewProjection"), false, mn(aU, s.viewProjectionMat, r)), kh(mi, r), QE(mi, mi, s.displayDimensionRenderInfo.canonicalVoxelFactors), QN(mi, mi), XN(mi, mi), e.uniformMatrix3fv(t.uniform("uNormalMatrix"), false, mi);
  }
  drawFragmentHelper(e, t, i, r, s) {
    this.vertexPositionHandler.bind(e, t, i);
    const a = i.meshData;
    i.normalBuffer.bindToVertexAttrib(
      t.attribute("aVertexNormal"),
      /*components=*/
      2,
      WebGL2RenderingContext.BYTE,
      /*normalized=*/
      true
    ), i.indexBuffer.bind();
    const l = a.indices;
    e.drawElements(a.strips ? WebGL2RenderingContext.TRIANGLE_STRIP : WebGL2RenderingContext.TRIANGLES, s - r, l.BYTES_PER_ELEMENT === 2 ? WebGL2RenderingContext.UNSIGNED_SHORT : WebGL2RenderingContext.UNSIGNED_INT, r * l.BYTES_PER_ELEMENT);
  }
  drawFragment(e, t, i) {
    const s = i.meshData.indices;
    this.drawFragmentHelper(e, t, i, 0, s.length);
  }
  drawMultiscaleFragment(e, t, i, r, s) {
    const a = i.meshData.subChunkOffsets[r], l = i.meshData.subChunkOffsets[s];
    this.drawFragmentHelper(e, t, i, a, l);
  }
  endLayer(e, t) {
    this.vertexPositionHandler.endLayer(e, t), e.disableVertexAttribArray(t.attribute("aVertexNormal"));
  }
  makeGetter(e) {
    const t = e.registerDisposer(wi((i) => i > 0, [e.displayState.silhouetteRendering]));
    return Io(e, e.gl, {
      memoizeKey: `mesh/MeshShaderManager/${this.fragmentRelativeVertices}/${this.vertexPositionFormat}`,
      parameters: t,
      defineShader: (i, r) => {
        this.vertexPositionHandler.defineShader(i), i.addAttribute("highp vec2", "aVertexNormal"), i.addVarying("highp vec4", "vColor"), i.addUniform("highp vec4", "uLightDirection"), i.addUniform("highp vec4", "uColor"), i.addUniform("highp mat3", "uNormalMatrix"), i.addUniform("highp mat4", "uModelViewProjection"), i.addUniform("highp uint", "uPickID"), r && i.addUniform("highp float", "uSilhouettePower"), this.fragmentRelativeVertices && (i.addUniform("highp vec3", "uFragmentOrigin"), i.addUniform("highp vec3", "uFragmentShape")), i.addVertexCode(oU);
        let s = "";
        this.fragmentRelativeVertices ? s += `
highp vec3 vertexPosition = uFragmentOrigin + uFragmentShape * getVertexPosition();
highp vec3 normalMultiplier = 1.0 / uFragmentShape;
` : s += `
highp vec3 vertexPosition = getVertexPosition();
highp vec3 normalMultiplier = vec3(1.0, 1.0, 1.0);
`, s += `
gl_Position = uModelViewProjection * vec4(vertexPosition, 1.0);
vec3 origNormal = decodeNormalOctahedronSnorm8(aVertexNormal);
vec3 normal = normalize(uNormalMatrix * (normalMultiplier * origNormal));
float absCosAngle = abs(dot(normal, uLightDirection.xyz));
float lightingFactor = absCosAngle + uLightDirection.w;
vColor = vec4(lightingFactor * uColor.rgb, uColor.a);
`, r && (s += `
vColor *= pow(1.0 - absCosAngle, uSilhouettePower);
`), i.setVertexMain(s), i.setFragmentMain("emit(vColor, uPickID);");
      }
    });
  }
};
var ww = class extends el {
  constructor(e, t, i) {
    super(), this.chunkManager = e, this.source = t, this.displayState = i, this.meshShaderManager = new Xk(
      /*fragmentRelativeVertices=*/
      false,
      Fr.float32
    ), this.getShader = this.meshShaderManager.makeGetter(this), Kh(i, this), this.registerDisposer(i.silhouetteRendering.changed.add(this.redrawNeeded.dispatch));
    let r = this.backend = this.registerDisposer(new Zh(e, i, this.layerChunkProgressInfo));
    r.RPC_TYPE_ID = s3, r.initializeCounterpartWithChunkManager({
      source: t.addCounterpartRef()
    }), r.visibility.add(this.visibility), this.registerDisposer(i.renderScaleHistogram.visibility.add(this.visibility));
  }
  get isTransparent() {
    const e = this.displayState;
    return e.objectAlpha.value < 1 || e.silhouetteRendering.value > 0;
  }
  get transparentPickEnabled() {
    return this.displayState.transparentPickEnabled.value;
  }
  get gl() {
    return this.chunkManager.chunkQueueManager.gl;
  }
  draw(e, t) {
    if (!e.emitColor && e.alreadyEmittedPickID)
      return;
    const i = this.gl, r = this.displayState, s = this.meshShaderManager;
    if (r.objectAlpha.value <= 0)
      return;
    const a = _u(r.transform.value, e.projectionParameters.displayDimensionRenderInfo, t);
    if (a === void 0)
      return;
    var l = this.getShader(e.emitter);
    const d = l.shader;
    if (d === null)
      return;
    d.bind(), s.beginLayer(i, d, e, this.displayState), s.beginModel(i, d, e, a);
    const u = this.source.chunks;
    let f = 0, g = 0;
    const v = this.displayState.renderScaleHistogram, y = this.source.fragmentSource.chunks;
    Xh(r, this, e.emitColor, e.emitPickID ? e.pickIDs : void 0, (w, C, b) => {
      const E = sr(w), L = u.get(E);
      if (++f, L !== void 0) {
        ++g, e.emitColor && s.setColor(i, d, C), e.emitPickID && s.setPickID(i, d, b), f += L.fragmentIds.length;
        for (const _ of L.fragmentIds) {
          var R = this.source.getFragmentKey(E, _);
          const A = R.key, I = y.get(A);
          I !== void 0 && I.state === Et.GPU_MEMORY && (s.drawFragment(i, d, I), ++g);
        }
      }
    }), e.emitColor && (v.begin(this.chunkManager.chunkQueueManager.frameNumberCounter.frameNumber), v.add(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, g, f - g)), s.endLayer(i, d);
  }
  isReady() {
    const e = this.displayState, t = this.source;
    let i = true;
    const r = t.fragmentSource.chunks;
    return Zo(e.segmentationGroupState.value, (s) => {
      const a = sr(s), l = t.chunks.get(a);
      if (l === void 0) {
        i = false;
        return;
      }
      for (const u of l.fragmentIds) {
        var d = this.source.getFragmentKey(a, u);
        const f = d.key, g = r.get(f);
        if (g === void 0 || g.state !== Et.GPU_MEMORY) {
          i = false;
          return;
        }
      }
    }), i;
  }
};
var cU = class extends Ms {
  constructor(e, t) {
    super(e), this.fragmentIds = t.fragmentIds;
  }
};
var dU = class extends Ms {
  constructor(e, t) {
    super(e), this.meshData = t;
  }
  copyToGPU(e) {
    super.copyToGPU(e), Kk(e, this);
  }
  freeGPUMemory(e) {
    super.freeGPUMemory(e), Zk(this);
  }
};
var Zc = class extends Yr {
  constructor(e, t) {
    super(e, t), this.fragmentSource = this.registerDisposer(new fm(this.chunkManager, this));
  }
  initializeCounterpart(e, t) {
    this.fragmentSource.initializeCounterpart(this.chunkManager.rpc, {}), t.fragmentSource = this.fragmentSource.addCounterpartRef(), super.initializeCounterpart(e, t);
  }
  getChunk(e) {
    return new cU(this, e);
  }
  getFragmentKey(e, t) {
    return { key: `${e}/${t}`, fragmentId: t };
  }
};
var fm = class extends Yr {
  constructor(e, t) {
    super(e), this.meshSource = t;
  }
  get key() {
    return this.meshSource.key;
  }
  getChunk(e) {
    return new dU(this, e);
  }
};
fm = qk([ki(o3)], fm);
function xw(n, e, t, i) {
  const r = n.get(Ik(e, t, i));
  return r !== void 0 && r.state === Et.GPU_MEMORY;
}
var Xp = class extends el {
  constructor(e, t, i) {
    super(), this.chunkManager = e, this.source = t, this.displayState = i, this.meshShaderManager = new Xk(
      /*fragmentRelativeVertices=*/
      this.source.format.fragmentRelativeVertices,
      this.source.format.vertexPositionFormat
    ), this.getShader = this.meshShaderManager.makeGetter(this), Kh(i, this), this.registerDisposer(i.silhouetteRendering.changed.add(this.redrawNeeded.dispatch));
    let r = this.backend = this.registerDisposer(new Zh(e, i, this.layerChunkProgressInfo));
    r.RPC_TYPE_ID = a3, r.initializeCounterpartWithChunkManager({
      source: t.addCounterpartRef()
    }), r.visibility.add(this.visibility), this.registerDisposer(i.renderScaleHistogram.visibility.add(this.visibility));
  }
  get isTransparent() {
    const e = this.displayState;
    return e.objectAlpha.value < 1 || e.silhouetteRendering.value > 0;
  }
  get transparentPickEnabled() {
    return this.displayState.transparentPickEnabled.value;
  }
  get gl() {
    return this.chunkManager.chunkQueueManager.gl;
  }
  draw(e, t) {
    if (!e.emitColor && e.alreadyEmittedPickID)
      return;
    const i = this.gl, r = this.displayState, s = this.meshShaderManager;
    if (r.objectAlpha.value <= 0)
      return;
    const a = _u(r.transform.value, e.projectionParameters.displayDimensionRenderInfo, t);
    if (a === void 0)
      return;
    var l = this.getShader(e.emitter);
    const d = l.shader;
    if (d === null)
      return;
    d.bind(), s.beginLayer(i, d, e, this.displayState);
    const u = this.displayState.renderScaleHistogram;
    e.emitColor && u.begin(this.chunkManager.chunkQueueManager.frameNumberCounter.frameNumber), kh(mi, a), QE(mi, mi, e.projectionParameters.displayDimensionRenderInfo.voxelPhysicalScales);
    const f = Math.pow(Math.abs(wv(mi)), 1 / 3), g = this.source.chunks, v = this.source.fragmentSource.chunks, y = e.projectionParameters, w = mn(et(), y.viewProjectionMat, a), C = Eu(new Float32Array(24), w), b = this.displayState.renderScaleTarget.value, E = this.source.format.fragmentRelativeVertices;
    s.beginModel(i, d, e, a);
    let L = 0, R = 0;
    Xh(r, this, e.emitColor, e.emitPickID ? e.pickIDs : void 0, (_, A, I) => {
      const P = sr(_), N = g.get(P);
      if (++L, N === void 0)
        return;
      ++R;
      const O = N.manifest, B = O.octree, j = O.chunkShape, U = O.chunkGridSpatialOrigin, V = O.vertexOffsets;
      e.emitColor && s.setColor(i, d, A), e.emitPickID && s.setPickID(i, d, I), iw(O, w, C, b, y.width, y.height, (G, F, ue) => {
        const ae = xw(v, P, G, F);
        return e.emitColor && u.add(O.lodScales[G] * f, ue, ae ? 1 : 0, ae ? 0 : 1), ae;
      }, (G, F, ue, ae) => {
        const Ie = Ik(P, G, F), le = v.get(Ie), Te = B[5 * F], Ue = B[5 * F + 1], Ye = B[5 * F + 2], Ze = 1 << G;
        E && (i.uniform3f(d.uniform("uFragmentOrigin"), U[0] + Te * j[0] * Ze + V[G * 3 + 0], U[1] + Ue * j[1] * Ze + V[G * 3 + 1], U[2] + Ye * j[2] * Ze + V[G * 3 + 2]), i.uniform3f(d.uniform("uFragmentShape"), j[0] * Ze, j[1] * Ze, j[2] * Ze)), s.drawMultiscaleFragment(i, d, le, ue, ae);
      });
    }), u.add(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, R, L - R), s.endLayer(i, d);
  }
  isReady(e, t) {
    let i = this.displayState;
    if (i.objectAlpha.value <= 0)
      return true;
    const r = _u(i.transform.value, e.projectionParameters.displayDimensionRenderInfo, t);
    if (r === void 0)
      return false;
    const s = this.source.chunks, a = this.source.fragmentSource.chunks, l = e.projectionParameters, d = mn(et(), l.viewProjectionMat, r), u = Eu(new Float32Array(24), d), f = this.displayState.renderScaleTarget.value;
    let g = true;
    return Zo(i.segmentationGroupState.value, (v) => {
      if (!g)
        return;
      const y = sr(v), w = s.get(y);
      if (w === void 0) {
        g = false;
        return;
      }
      const C = w.manifest;
      iw(C, d, u, f, l.width, l.height, (b, E) => (g = g && xw(a, y, b, E), g), () => {
      });
    }), g;
  }
  getObjectPosition(e) {
    const t = this.displayState.transform.value;
    if (t.error !== void 0)
      return;
    const i = this.source.chunks.get(sr(e));
    if (i === void 0)
      return;
    const r = i.manifest, s = r.clipLowerBound, a = r.clipUpperBound, l = t.rank, d = new Float32Array(l);
    for (let f = 0; f < 3; ++f)
      d[f] = (s[f] + a[f]) / 2;
    const u = new Float32Array(l);
    return _r(u, t.modelToRenderLayerTransform, l + 1, d, l), u;
  }
};
var uU = class extends Ms {
  constructor(e, t) {
    super(e), this.manifest = t.manifest;
  }
};
var hU = class extends Ms {
  constructor(e, t) {
    super(e), this.meshData = t;
  }
  copyToGPU(e) {
    super.copyToGPU(e), Kk(e, this);
  }
  freeGPUMemory(e) {
    super.freeGPUMemory(e), Zk(this);
  }
};
var Qh = class extends Yr {
  constructor(e, t) {
    super(e, t), this.fragmentSource = this.registerDisposer(new pm(this.chunkManager, this)), this.format = t.format;
  }
  static encodeOptions(e) {
    return RZr({ format: e.format }, super.encodeOptions(e));
  }
  initializeCounterpart(e, t) {
    this.fragmentSource.initializeCounterpart(this.chunkManager.rpc, {}), t.fragmentSource = this.fragmentSource.addCounterpartRef(), t.format = this.format, super.initializeCounterpart(e, t);
  }
  getChunk(e) {
    return new uU(this, e);
  }
};
var pm = class extends Yr {
  constructor(e, t) {
    super(e), this.meshSource = t;
  }
  get key() {
    return this.meshSource.key;
  }
  getChunk(e) {
    return new hU(this, e);
  }
};
pm = qk([ki(l3)], pm);
var Ew = Y_;
var fU = ck(false);
Ew(Ew.S, "Object", {
  values: function(e) {
    return fU(e);
  }
});
var pU = xv.Object.values;
var gU = { default: pU, __esModule: true };
var gm = Gs(gU);
var mU = "skeleton/SkeletonLayer";
var ky = 6;
var Iy = `
vec2 getQuadVertexPosition(vec2 lower, vec2 upper) {
  const vec2 coeffs[] = vec2[](
    vec2(0.0, 0.0),
    vec2(0.0, 1.0),
    vec2(1.0, 1.0),
    vec2(1.0, 1.0),
    vec2(1.0, 0.0),
    vec2(0.0, 0.0)
  );
  int v = gl_VertexID % 6;
  return mix(lower, upper, coeffs[v]);
}
`;
function Ly(n, e, t) {
  n.drawArraysInstanced(WebGL2RenderingContext.TRIANGLES, 0, ky * e, t);
}
function vU(n, e) {
  const t = new Float32Array((n + 1) * (e + 1) * 3);
  let i = 0;
  for (let r = 0; r <= n; ++r) {
    const s = r * Math.PI / n, a = Math.sin(s), l = Math.cos(s);
    for (let d = 0; d <= e; ++d) {
      const u = d * 2 * Math.PI / e, f = Math.sin(u), g = Math.cos(u);
      t[i++] = g * a, t[i++] = l, t[i++] = f * a;
    }
  }
  return t;
}
function yU(n, e) {
  const t = new Uint16Array(n * e * 6);
  let i = 0;
  for (let r = 0; r < n; r++)
    for (let s = 0; s < e; s++) {
      const a = r * (e + 1) + s, l = a + e + 1;
      t[i++] = a, t[i++] = l, t[i++] = a + 1, t[i++] = l, t[i++] = l + 1, t[i++] = a + 1;
    }
  return t;
}
var Qk = class extends Z {
  constructor(e, t, i) {
    super(), this.vertexBuffer = this.registerDisposer(bc(e, WebGL2RenderingContext.ARRAY_BUFFER, vU, t, i)).value, this.indexBuffer = this.registerDisposer(bc(e, WebGL2RenderingContext.ELEMENT_ARRAY_BUFFER, yU, t, i)).value, this.numIndices = t * i * 6;
  }
  defineShader(e) {
    e.addAttribute("highp vec3", "aSphereVertex"), e.addVarying("highp float", "vLightingFactor"), e.addVertexCode(`
void emitSphere(mat4 projectionMatrix, mat4 normalTransformMatrix, vec3 centerPosition, vec3 radii, vec4 lightDirection) {
  vec3 vertexPosition = aSphereVertex * radii + centerPosition;
  gl_Position = projectionMatrix * vec4(vertexPosition, 1.0);
  vec3 normal = normalize((normalTransformMatrix * vec4(aSphereVertex / max(radii, 1e-6), 0.0)).xyz);
  vLightingFactor = abs(dot(normal, uLightDirection.xyz)) + uLightDirection.w;
}
`);
  }
  draw(e, t) {
    const i = e.attribute("aSphereVertex");
    this.vertexBuffer.bindToVertexAttrib(
      i,
      /*components=*/
      3,
      /*attributeType=*/
      WebGL2RenderingContext.FLOAT,
      /*normalized=*/
      false
    ), this.indexBuffer.bind(), e.gl.drawElementsInstanced(
      WebGL2RenderingContext.TRIANGLES,
      this.numIndices,
      WebGL2RenderingContext.UNSIGNED_SHORT,
      /*offset=*/
      0,
      t
    ), e.gl.disableVertexAttribArray(i);
  }
};
var Dy = ky;
function Xc(n, e) {
  n.addVertexCode(Iy), n.addUniform("highp vec3", "uCircleParams"), n.addVarying("highp vec4", "vCircleCoord"), n.addVertexCode(`
void emitCircle(vec4 position, float diameter, float borderWidth) {
  gl_Position = position;
  float totalDiameter = diameter + 2.0 * (borderWidth + uCircleParams.z);
  if (diameter == 0.0) totalDiameter = 0.0;
  vec2 circleCornerOffset = getQuadVertexPosition(vec2(-1.0, -1.0), vec2(1.0, 1.0));
  gl_Position.xy += circleCornerOffset * uCircleParams.xy * gl_Position.w * totalDiameter;
  vCircleCoord.xy = circleCornerOffset;
  if (borderWidth == 0.0) {
    vCircleCoord.z = totalDiameter;
    vCircleCoord.w = 1e-6;
  } else {
    vCircleCoord.z = diameter / totalDiameter;
    vCircleCoord.w = uCircleParams.z / totalDiameter;
  }
}
`), e ? n.addFragmentCode(`
float getCircleAlphaMultiplier() {
  return 1.0 - 2.0 * abs(0.5 - gl_FragCoord.z);
}
`) : n.addFragmentCode(`
float getCircleAlphaMultiplier() {
  return 1.0;
}
`), n.addFragmentCode(`
vec4 getCircleColor(vec4 interiorColor, vec4 borderColor) {
  float radius = length(vCircleCoord.xy);
  if (radius > 1.0) {
    discard;
  }

  float borderColorFraction = clamp((radius - vCircleCoord.z) / vCircleCoord.w, 0.0, 1.0);
  float feather = clamp((1.0 - radius) / vCircleCoord.w, 0.0, 1.0);
  vec4 color = mix(interiorColor, borderColor, borderColorFraction);

  return vec4(color.rgb, color.a * feather * getCircleAlphaMultiplier());
}
`);
}
function Qc(n, e, t) {
  n.gl.uniform3f(n.uniform("uCircleParams"), 1 / e.width, 1 / e.height, Math.max(1e-6, t.featherWidthInPixels));
}
function ed(n, e, t) {
  Ly(n, e, t);
}
var SU = class extends Z {
  constructor(e) {
    super(), this.lightDirection = new Float32Array([1, 0, 0, 0]), this.sphereHelper = this.registerDisposer(new Qk(e, 20, 20));
  }
  defineShader(e) {
    e.addUniform("highp vec4", "uLightDirection"), e.addUniform("highp mat4", "uNormalTransform"), e.addVertexCode(`
float getRadiusAdjustment(vec3 vertex, float r) {
  float radiusAdjustment = 1.0;
  for (int i = 0; i < 3; ++i) {
    if (r != 0.0) {
      float d = vertex[i] - uModelClipBounds[i];
      radiusAdjustment -= d * d / (r * r);
    }
  }

  return sqrt(max(0.1, radiusAdjustment));
}
    `), this.sphereHelper.defineShader(e);
  }
  draw(e, t, i) {
    const r = e.gl;
    r.uniformMatrix4fv(
      e.uniform("uNormalTransform"),
      /*transpose=*/
      false,
      xv2(et(), t.renderSubspaceInvModelMatrix)
    ), r.uniform4f(e.uniform("uLightDirection"), this.lightDirection[0], this.lightDirection[1], this.lightDirection[2], this.lightDirection[3]), this.sphereHelper.draw(e, i);
  }
};
var bs = ky;
function fr(n, e = false) {
  n.addVertexCode(Iy), n.addUniform("highp vec3", "uLineParams"), n.addVarying("highp float", "vLineCoord"), n.addVarying("highp float", "vLineFeatherFraction"), e && (n.addVarying("highp float", "vEndpointFraction"), n.addVarying("highp float", "vLineCoordT"), n.addVarying("highp float", "vLineBorderStartFraction")), n.addVertexCode(VV), n.addVertexCode(`
vec2 getLineOffset() { return getQuadVertexPosition(vec2(0.0, -1.0), vec2(1.0, 1.0)); }
float getLineEndpointCoefficient() { return getLineOffset().x; }
uint getLineEndpointIndex() { return uint(getLineEndpointCoefficient()); }
void emitLine(vec4 vertexAClip, vec4 vertexBClip, float lineWidthInPixels
              ${e ? ", float borderWidth" : ""}) {
  if (!clipLineToDepthRange(vertexAClip, vertexBClip)) {
    gl_Position = vec4(2.0, 2.0, 2.0, 1.0);
    return;
  }
  vec3 vertexADevice = vertexAClip.xyz / vertexAClip.w;
  vec3 vertexBDevice = vertexBClip.xyz / vertexBClip.w;

  vec2 lineDirectionUnnormalized = vertexBDevice.xy - vertexADevice.xy;
  vec2 lineDirection;
  float linePixelLength = length(lineDirectionUnnormalized / uLineParams.xy * 0.5);

  if (linePixelLength < 1e-3) {
    lineDirection = vec2(1.0, 0.0);
    vertexADevice.z = vertexBDevice.z = 0.0;
  } else {
    lineDirection = normalize(lineDirectionUnnormalized);
  }
  vec2 lineNormal = normalize(vec2(lineDirection.y, -lineDirection.x) / uLineParams.yx * uLineParams.xy);

  vec2 lineOffset = getLineOffset();
  gl_Position = vec4(mix(vertexADevice, vertexBDevice, lineOffset.x), 1.0);
  float totalLineWidth = lineWidthInPixels + 2.0 * uLineParams.z ${e ? " + 2.0 * borderWidth" : ""};
  if (lineWidthInPixels == 0.0) totalLineWidth = 0.0;
  vLineFeatherFraction = max(1e-6, uLineParams.z) / totalLineWidth;
  gl_Position.xy += (lineOffset.y * lineNormal
                     ${e ? "+ lineDirection * (2.0 * lineOffset.x - 1.0)" : ""})
                  * totalLineWidth * uLineParams.xy;
  vLineCoord = lineOffset.y;
  ${e ? "vEndpointFraction = totalLineWidth / (linePixelLength + totalLineWidth * 2.0);" : ""}
  ${e ? "vLineCoordT = lineOffset.x; vLineBorderStartFraction = lineWidthInPixels / totalLineWidth;" : ""}
}
void emitLine(mat4 projection, vec3 vertexA, vec3 vertexB, float lineWidthInPixels
              ${e ? ", float borderWidth" : ""}) {
  emitLine(projection * vec4(vertexA, 1.0), projection * vec4(vertexB, 1.0),
           lineWidthInPixels
           ${e ? ", borderWidth" : ""});
}
`), e && n.addFragmentCode(`
vec4 getRoundedLineColor(vec4 interiorColor, vec4 borderColor) {
  float radius;
  if (vLineCoordT < vEndpointFraction || vLineCoordT > 1.0 - vEndpointFraction) {
    radius = length(vec2(1.0 - min(vLineCoordT, 1.0 - vLineCoordT) / vEndpointFraction,
                         vLineCoord));
    if (radius > 1.0) {
      discard;
    }
  } else {
    radius = abs(vLineCoord);
  }
  float borderColorFraction = clamp((radius - vLineBorderStartFraction) / vLineFeatherFraction, 0.0, 1.0);
  float feather = clamp((1.0 - radius) / vLineFeatherFraction, 0.0, 1.0);
  vec4 color = mix(interiorColor, borderColor, borderColorFraction);
  return vec4(color.rgb, color.a * feather);
}
`), n.addFragmentCode(`
float getLineAlpha() {
  return clamp((1.0 - abs(vLineCoord)) / vLineFeatherFraction, 0.0, 1.0);
}
`);
}
function pr(n, e, t) {
  Ly(n, e, t);
}
function gr(n, e, t) {
  n.gl.uniform3f(n.uniform("uLineParams"), 1 / e.width, 1 / e.height, t);
}
function Wr(n) {
  n.addAttribute("int", "aDummyVertexId", 0), n.addVertexCode(`
int getVertexId () {
  return aDummyVertexId + gl_VertexID;
}
#define gl_VertexID (getVertexId())
`);
}
var mr = class _mr extends Z {
  constructor(e) {
    super(), this.buffer = new Xn(e), this.size = 0;
  }
  disposed() {
    this.buffer.dispose();
  }
  enable(e = 256) {
    const t = this.buffer, i = t.gl;
    t.bind(), e > this.size && (this.size = e, i.bufferData(WebGL2RenderingContext.ARRAY_BUFFER, new Int32Array(e), WebGL2RenderingContext.STATIC_DRAW)), i.vertexAttribIPointer(0, 1, WebGL2RenderingContext.INT, 0, 0), i.vertexAttribDivisor(0, 0), i.enableVertexAttribArray(0);
  }
  disable() {
    this.buffer.gl.disableVertexAttribArray(0);
  }
  static get(e) {
    return e.memoize.get("VertexIdHelper", () => new _mr(e));
  }
};
var bU = et();
var eI = `void main() {
  emitDefault();
}
`;
var Yl = [];
var CU = Kc(new jh(), J.FLOAT32, 3);
var tI = class extends Z {
  constructor(e, t) {
    super(), this.base = e, this.targetIsSliceView = t, this.textureAccessHelper = new vy("vertexData"), this.vertexIdHelper = this.registerDisposer(mr.get(this.gl)), this.edgeShaderGetter = Io(this, this.gl, {
      memoizeKey: { type: "skeleton/SkeletonShaderManager/edge", vertexAttributes: this.vertexAttributes },
      fallbackParameters: this.base.fallbackShaderParameters,
      parameters: this.base.displayState.skeletonRenderingOptions.shaderControlState.builderState,
      shaderError: this.base.displayState.shaderError,
      defineShader: (i, r) => {
        if (r.parseResult.errors.length !== 0)
          throw new Error("Invalid UI control specification");
        this.defineCommonShader(i), this.defineAttributeAccess(i), fr(i), i.addAttribute("highp uvec2", "aVertexIndex"), i.addUniform("highp float", "uLineWidth");
        let s = `
highp vec3 vertexA = readAttribute0(aVertexIndex.x);
highp vec3 vertexB = readAttribute0(aVertexIndex.y);
emitLine(uProjection, vertexA, vertexB, uLineWidth);
highp uint lineEndpointIndex = getLineEndpointIndex();
highp uint vertexIndex = aVertexIndex.x * lineEndpointIndex + aVertexIndex.y * (1u - lineEndpointIndex);
`;
        i.addFragmentCode(`
vec4 segmentColor() {
  return uColor;
}
void emitRGB(vec3 color) {
  emit(vec4(color * uColor.a, uColor.a * getLineAlpha() * ${this.getCrossSectionFadeFactor()}), uPickID);
}
void emitDefault() {
  emit(vec4(uColor.rgb, uColor.a * getLineAlpha() * ${this.getCrossSectionFadeFactor()}), uPickID);
}
`), i.addFragmentCode(xc);
        const a = this.vertexAttributes, l = a.length;
        for (let d = 1; d < l; ++d) {
          const u = a[d];
          i.addVarying(`highp ${u.glslDataType}`, `vCustom${d}`), s += `vCustom${d} = readAttribute${d}(vertexIndex);
`, i.addFragmentCode(`#define ${u.name} vCustom${d}
`);
        }
        i.setVertexMain(s), wc(r, i), i.setFragmentMainFunction(Sc(r.parseResult.code));
      }
    }), this.nodeShaderGetter = Io(this, this.gl, {
      memoizeKey: { type: "skeleton/SkeletonShaderManager/node", vertexAttributes: this.vertexAttributes },
      fallbackParameters: this.base.fallbackShaderParameters,
      parameters: this.base.displayState.skeletonRenderingOptions.shaderControlState.builderState,
      shaderError: this.base.displayState.shaderError,
      defineShader: (i, r) => {
        if (r.parseResult.errors.length !== 0)
          throw new Error("Invalid UI control specification");
        this.defineCommonShader(i), this.defineAttributeAccess(i), Xc(
          i,
          /*crossSectionFade=*/
          this.targetIsSliceView
        ), i.addUniform("highp float", "uNodeDiameter");
        let s = `
highp uint vertexIndex = uint(gl_InstanceID);
highp vec3 vertexPosition = readAttribute0(vertexIndex);
emitCircle(uProjection * vec4(vertexPosition, 1.0), uNodeDiameter, 0.0);
`;
        i.addFragmentCode(`
vec4 segmentColor() {
  return uColor;
}
void emitRGBA(vec4 color) {
  vec4 borderColor = color;
  emit(getCircleColor(color, borderColor), uPickID);
}
void emitRGB(vec3 color) {
  emitRGBA(vec4(color, 1.0));
}
void emitDefault() {
  emitRGBA(uColor);
}
`), i.addFragmentCode(xc);
        const a = this.vertexAttributes, l = a.length;
        for (let d = 1; d < l; ++d) {
          const u = a[d];
          i.addVarying(`highp ${u.glslDataType}`, `vCustom${d}`), s += `vCustom${d} = readAttribute${d}(vertexIndex);
`, i.addFragmentCode(`#define ${u.name} vCustom${d}
`);
        }
        i.setVertexMain(s), wc(r, i), i.setFragmentMainFunction(Sc(r.parseResult.code));
      }
    });
  }
  get vertexAttributes() {
    return this.base.vertexAttributes;
  }
  defineCommonShader(e) {
    Wr(e), e.addUniform("highp vec4", "uColor"), e.addUniform("highp mat4", "uProjection"), e.addUniform("highp uint", "uPickID");
  }
  get gl() {
    return this.base.gl;
  }
  defineAttributeAccess(e) {
    const t = this.textureAccessHelper;
    t.defineShader(e);
    const i = this.vertexAttributes.length;
    for (let r = Yl.length; r < i; ++r)
      Yl[r] = NZr(`SkeletonShader.vertexAttributeTextureUnit${r}`);
    this.vertexAttributes.forEach((r, s) => {
      e.addTextureSampler(`${gy(r.dataType)}sampler2D`, `uVertexAttributeSampler${s}`, Yl[s]), e.addVertexCode(t.getAccessor(`readAttribute${s}`, `uVertexAttributeSampler${s}`, r.dataType, r.numComponents));
    });
  }
  getCrossSectionFadeFactor() {
    return this.targetIsSliceView ? "(clamp(1.0 - 2.0 * abs(0.5 - gl_FragCoord.z), 0.0, 1.0))" : "(1.0)";
  }
  beginLayer(e, t, i, r) {
    const s = i.projectionParameters.viewProjectionMat;
    let a = mn(bU, s, r);
    e.uniformMatrix4fv(t.uniform("uProjection"), false, a), this.vertexIdHelper.enable();
  }
  setColor(e, t, i) {
    e.uniform4fv(t.uniform("uColor"), i);
  }
  setPickID(e, t, i) {
    e.uniform1ui(t.uniform("uPickID"), i);
  }
  drawSkeleton(e, t, i, r, s) {
    const l = this.vertexAttributes.length, d = r.vertexAttributeTextures;
    for (let u = 0; u < l; ++u) {
      const f = WebGL2RenderingContext.TEXTURE0 + t.textureUnit(Yl[u]);
      e.activeTexture(f), e.bindTexture(WebGL2RenderingContext.TEXTURE_2D, d[u]);
    }
    {
      t.bind();
      const u = t.attribute("aVertexIndex");
      r.indexBuffer.bindToVertexAttribI(u, 2, WebGL2RenderingContext.UNSIGNED_INT), e.vertexAttribDivisor(u, 1), gr(t, s, this.targetIsSliceView ? 1 : 0), pr(e, 1, r.numIndices / 2), e.vertexAttribDivisor(u, 0), e.disableVertexAttribArray(u);
    }
    i !== null && (i.bind(), Qc(i, s, { featherWidthInPixels: this.targetIsSliceView ? 1 : 0 }), ed(i.gl, 2, r.numVertices));
  }
  endLayer(e, t) {
    const r = this.vertexAttributes.length;
    for (let s = 0; s < r; ++s) {
      let a = t.textureUnit(Yl[s]) + WebGL2RenderingContext.TEXTURE0;
      e.activeTexture(a), e.bindTexture(e.TEXTURE_2D, null);
    }
    this.vertexIdHelper.disable();
  }
};
var Fo;
(function(n) {
  n[n.LINES = 0] = "LINES", n[n.LINES_AND_POINTS = 1] = "LINES_AND_POINTS";
})(Fo || (Fo = {}));
var Tw = class extends Hh {
  constructor(e, t = e) {
    super(Fo, e, t);
  }
};
var kw = class extends hn {
  constructor(e, t = e) {
    super(e, vn, t);
  }
};
var wU = class {
  constructor() {
    this.compound = new $h(), this.shader = Yv(eI), this.shaderControlState = new iy(this.shader), this.params2d = {
      mode: new Tw(Fo.LINES_AND_POINTS),
      lineWidth: new kw(2)
    }, this.params3d = {
      mode: new Tw(Fo.LINES),
      lineWidth: new kw(1)
    };
    const e = this.compound;
    e.add("shader", this.shader), e.add("shaderControls", this.shaderControlState), e.add("mode2d", this.params2d.mode), e.add("lineWidth2d", this.params2d.lineWidth), e.add("mode3d", this.params3d.mode), e.add("lineWidth3d", this.params3d.lineWidth);
  }
  get changed() {
    return this.compound.changed;
  }
  reset() {
    this.compound.reset();
  }
  restoreState(e) {
    e !== void 0 && this.compound.restoreState(e);
  }
  toJSON() {
    const e = this.compound.toJSON();
    for (const t of gm(e))
      if (t !== void 0)
        return e;
  }
};
var xU = class extends Z {
  constructor(e, t, i) {
    super(), this.chunkManager = e, this.source = t, this.displayState = i, this.layerChunkProgressInfo = new $v(), this.redrawNeeded = new Ee(), this.fallbackShaderParameters = new gt(ny(Fh(eI))), Kh(i, this), this.displayState.shaderError.value = void 0;
    const r = i.skeletonRenderingOptions;
    this.registerDisposer(r.shader.changed.add(() => {
      this.displayState.shaderError.value = void 0, this.redrawNeeded.dispatch();
    }));
    let s = this.sharedObject = this.registerDisposer(new Zh(e, i, this.layerChunkProgressInfo));
    s.RPC_TYPE_ID = mU, s.initializeCounterpartWithChunkManager({
      source: t.addCounterpartRef()
    });
    const a = this.vertexAttributes = [TU];
    for (let d of t.vertexAttributes) {
      var l = ce(d, 2);
      let u = l[0], f = l[1];
      a.push({
        name: u,
        dataType: f.dataType,
        numComponents: f.numComponents,
        webglDataType: EU(f.dataType),
        glslDataType: f.numComponents > 1 ? `vec${f.numComponents}` : "float"
      });
    }
  }
  get visibility() {
    return this.sharedObject.visibility;
  }
  get gl() {
    return this.chunkManager.chunkQueueManager.gl;
  }
  draw(e, t, i, r, s) {
    let a = r.lineWidth.value;
    const l = this.gl, d = this.source, u = this.displayState;
    if (u.objectAlpha.value <= 0)
      return;
    const f = _u(u.transform.value, e.projectionParameters.displayDimensionRenderInfo, s);
    if (f === void 0)
      return;
    let g;
    r.mode.value === Fo.LINES_AND_POINTS ? g = Math.max(5, a * 2) : g = a;
    const v = i.edgeShaderGetter(e.emitter), y = i.nodeShaderGetter(e.emitter), w = v.shader, C = v.parameters, b = y.shader, E = y.parameters;
    if (w === null || b === null)
      return;
    const L = this.displayState.skeletonRenderingOptions.shaderControlState;
    w.bind(), i.beginLayer(l, w, e, f), Ao(l, w, L, C.parseResult.controls), l.uniform1f(w.uniform("uLineWidth"), a), b.bind(), i.beginLayer(l, b, e, f), l.uniform1f(b.uniform("uNodeDiameter"), g), Ao(l, b, L, E.parseResult.controls);
    const R = d.chunks;
    Xh(u, t, e.emitColor, e.emitPickID ? e.pickIDs : void 0, (_, A, I) => {
      const P = sr(_), N = R.get(P);
      N === void 0 || N.state !== Et.GPU_MEMORY || (A !== void 0 && (w.bind(), i.setColor(l, w, A), b.bind(), i.setColor(l, b, A)), I !== void 0 && (w.bind(), i.setPickID(l, w, I), b.bind(), i.setPickID(l, b, I)), i.drawSkeleton(l, w, b, N, e.projectionParameters));
    }), i.endLayer(l, w);
  }
  isReady() {
    const e = this.source, t = this.displayState;
    if (t.objectAlpha.value <= 0)
      return true;
    const i = e.chunks;
    let r = true;
    return Zo(t.segmentationGroupState.value, (s) => {
      const a = sr(s), l = i.get(a);
      if (l === void 0 || l.state !== Et.GPU_MEMORY) {
        r = false;
        return;
      }
    }), r;
  }
};
var Qp = class extends el {
  constructor(e) {
    super(), this.base = e, this.renderHelper = this.registerDisposer(new tI(this.base, false)), this.renderOptions = this.base.displayState.skeletonRenderingOptions.params3d, this.layerChunkProgressInfo = e.layerChunkProgressInfo, this.registerDisposer(e), this.registerDisposer(e.redrawNeeded.add(this.redrawNeeded.dispatch));
    const t = this.renderOptions;
    this.registerDisposer(t.mode.changed.add(this.redrawNeeded.dispatch)), this.registerDisposer(t.lineWidth.changed.add(this.redrawNeeded.dispatch)), this.registerDisposer(e.visibility.add(this.visibility));
  }
  get gl() {
    return this.base.gl;
  }
  get isTransparent() {
    return this.base.displayState.objectAlpha.value < 1;
  }
  draw(e, t) {
    !e.emitColor && e.alreadyEmittedPickID || this.base.draw(e, this, this.renderHelper, this.renderOptions, t);
  }
  isReady() {
    return this.base.isReady();
  }
};
var Iw = class extends Mo {
  constructor(e) {
    super(), this.base = e, this.renderHelper = this.registerDisposer(new tI(this.base, true)), this.renderOptions = this.base.displayState.skeletonRenderingOptions.params2d, this.layerChunkProgressInfo = e.layerChunkProgressInfo, this.registerDisposer(e);
    const t = this.renderOptions;
    this.registerDisposer(t.mode.changed.add(this.redrawNeeded.dispatch)), this.registerDisposer(t.lineWidth.changed.add(this.redrawNeeded.dispatch)), this.registerDisposer(e.redrawNeeded.add(this.redrawNeeded.dispatch)), this.registerDisposer(e.visibility.add(this.visibility));
  }
  get gl() {
    return this.base.gl;
  }
  draw(e, t) {
    this.base.draw(e, this, this.renderHelper, this.renderOptions, t);
  }
  isReady() {
    return this.base.isReady();
  }
};
function EU(n) {
  switch (n) {
    case J.FLOAT32:
      return WebGL2RenderingContext.FLOAT;
    default:
      throw new Error(`Data type not supported by WebGL: ${J[n]}`);
  }
}
var TU = {
  dataType: J.FLOAT32,
  numComponents: 3,
  name: "",
  webglDataType: WebGL2RenderingContext.FLOAT,
  glslDataType: "vec3"
};
var kU = class extends Ms {
  constructor(e, t) {
    super(e), this.vertexAttributes = t.vertexAttributes;
    let i = this.indices = t.indices;
    this.numVertices = t.numVertices, this.vertexAttributeOffsets = t.vertexAttributeOffsets, this.numIndices = i.length;
  }
  copyToGPU(e) {
    super.copyToGPU(e);
    const t = this.source.attributeTextureFormats, i = this.vertexAttributes, r = this.vertexAttributeOffsets, s = this.vertexAttributeTextures = [];
    for (let a = 0, l = r.length; a < l; ++a) {
      const d = e.createTexture();
      e.bindTexture(WebGL2RenderingContext.TEXTURE_2D, d), my(e, t[a], i.subarray(r[a], a + 1 !== l ? r[a + 1] : i.length)), s[a] = d;
    }
    e.bindTexture(WebGL2RenderingContext.TEXTURE_2D, null), this.indexBuffer = Xn.fromData(e, this.indices, WebGL2RenderingContext.ARRAY_BUFFER, WebGL2RenderingContext.STATIC_DRAW);
  }
  freeGPUMemory(e) {
    super.freeGPUMemory(e);
    const t = this.vertexAttributeTextures;
    for (const i of t)
      e.deleteTexture(i);
    t.length = 0, this.indexBuffer.dispose();
  }
};
var IU = new de();
function LU(n) {
  const e = [CU];
  for (const t of n.values())
    e.push(Kc(new jh(), t.dataType, t.numComponents));
  return e;
}
var ef = class extends Yr {
  constructor(e, t) {
    super(e, t);
  }
  get attributeTextureFormats() {
    let e = this.attributeTextureFormats_;
    return e === void 0 && (e = this.attributeTextureFormats_ = LU(this.vertexAttributes)), e;
  }
  getChunk(e) {
    return new kU(this, e);
  }
  get vertexAttributes() {
    return IU;
  }
};
function nI(n, e, t, i) {
  const r = e.dataType;
  e.defineShader(n, t);
  let s = "", a = "";
  if (t === 0)
    s += "highp int ignoredChannelIndex";
  else
    for (let d = 0; d < t; ++d)
      d !== 0 && (s += ", "), s += `highp int channelIndex${d}`, a += `, channelIndex${d}`;
  n.addFragmentCode(LV);
  let l = `
${wn(r)} getDataValue(${s}) {
  highp ivec3 p = ivec3(max(vec3(0.0, 0.0, 0.0), min(floor(${i}), uChunkDataSize - 1.0)));
  return getDataValueAt(p${a});
}
${wn(r)} getInterpolatedDataValue(${s}) {
  highp vec3 positionWithinChunk = ${i};
  highp ivec3[2] points;
  points[0] = ivec3(max(vec3(0.0, 0.0, 0.0), min(floor(positionWithinChunk - 0.5), uChunkDataSize - 1.0)));
  points[1] = ivec3(max(vec3(0.0, 0.0, 0.0), min(ceil(positionWithinChunk - 0.5), uChunkDataSize - 1.0)));
  highp vec3 mixCoeff = fract(positionWithinChunk - 0.5);
  ${wn(r)} xvalues[2];
  for (int ix = 0; ix < 2; ++ix) {
    ${wn(r)} yvalues[2];
    for (int iy = 0; iy < 2; ++iy) {
      ${wn(r)} zvalues[2];
      for (int iz = 0; iz < 2; ++iz) {
        zvalues[iz] = getDataValueAt(ivec3(points[ix].x, points[iy].y, points[iz].z)
                                     ${a});
      }
      yvalues[iy] = mixLinear(zvalues[0], zvalues[1], mixCoeff.z);
    }
    xvalues[ix] = mixLinear(yvalues[0], yvalues[1], mixCoeff.y);
  }
  return mixLinear(xvalues[0], xvalues[1], mixCoeff.x);
}
`;
  n.addFragmentCode(l), t <= 1 && n.addFragmentCode(`
${wn(r)} getDataValue() { return getDataValue(0); }
${wn(r)} getInterpolatedDataValue() { return getInterpolatedDataValue(0); }
`);
}
var iI = new Array();
function rI(n) {
  iI.push(n);
}
function DU(n, e) {
  for (let t of iI) {
    let i = t(n, e);
    if (i != null)
      return i;
  }
  throw new Error("No chunk format handler found.");
}
var td = class extends qT {
  constructor(e, t) {
    super(e, t), this.chunkFormatHandler = this.registerDisposer(DU(e.chunkQueueManager.gl, this.spec));
    const i = this.spec.upperVoxelBound.length;
    this.tempChunkGridPosition = new Float32Array(i), this.tempPositionWithinChunk = new Uint32Array(i);
  }
  static encodeSpec(e) {
    const t = e;
    return RZr(RZr({}, super.encodeSpec(e)), { dataType: t.dataType, compressedSegmentationBlockSize: t.compressedSegmentationBlockSize && De(t.compressedSegmentationBlockSize), baseVoxelOffset: De(t.baseVoxelOffset) });
  }
  get chunkFormat() {
    return this.chunkFormatHandler.chunkFormat;
  }
  getValueAt(e, t) {
    const i = this.spec.rank, r = this.tempChunkGridPosition, s = this.tempPositionWithinChunk, a = this.spec;
    {
      const C = a.chunkDataSize;
      for (let b = 0; b < i; ++b) {
        const E = e[b], L = C[b], R = Math.floor(E / L);
        r[b] = R, s[b] = Math.floor(E - L * R);
      }
    }
    const l = this.chunks.get(r.join());
    if (l === void 0)
      return null;
    const d = l.chunkDataSize;
    for (let C = 0; C < 3; ++C)
      if (s[C] >= d[C])
        return;
    if (t.channelSpaceShape.length === 0)
      return l.getValueAt(s);
    const u = t.numChannels, f = t.chunkChannelCoordinates, g = t.chunkChannelDimensionIndices, v = g.length;
    let y = 0;
    const w = new Array(u);
    for (let C = 0; C < u; ++C) {
      for (let b = 0; b < v; ++b)
        s[g[b]] = f[y++];
      w[C] = l.getValueAt(s);
    }
    return w;
  }
  getChunk(e) {
    return this.chunkFormatHandler.getChunk(this, e);
  }
};
var PU = class extends KT {
  constructor(e, t) {
    super(e, t), this.chunkDataSize = t.chunkDataSize || e.spec.chunkDataSize;
  }
  get chunkFormat() {
    return this.source.chunkFormat;
  }
};
var _s = class extends XB {
};
var Hu = "data:image/svg+xml;base64,PHN2ZyByb2xlPSJpbWciIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjI0IiBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIGFyaWEtbGFiZWxsZWRieT0icGx1c0ljb25UaXRsZSI+CiAgICA8dGl0bGUgaWQ9InBsdXNJY29uVGl0bGUiPlBsdXM8L3RpdGxlPiAgICAKICAgIDxwYXRoIGQ9Ik0yMCAxMkw0IDEyTTEyIDRMMTIgMjAiLz4KPC9zdmc+";
function sI(n = {}) {
  return Tt(RZr({ svg: Hu }, n));
}
var AU = "data:image/svg+xml;base64,PHN2ZyByb2xlPSJpbWciIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjI0IiBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIGFyaWEtbGFiZWxsZWRieT0iYXJyb3dVcEljb25UaXRsZSI+CiAgICA8dGl0bGUgaWQ9ImFycm93VXBJY29uVGl0bGUiPkFycm93IFVwPC90aXRsZT4gICAgCiAgICA8cGF0aCBkPSJNMTggOWwtNi02LTYgNiIvPgogICAgPHBhdGggZD0iTTEyIDIxVjQiLz4KICAgIDxwYXRoIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgZD0iTTEyIDN2MSIvPgo8L3N2Zz4=";
var ju = new gt(0);
window.addEventListener("keydown", (n) => {
  ju.value = Sy(n);
});
window.addEventListener("keyup", (n) => {
  ju.value = Sy(n);
});
var RU = new je(["f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "f10", "f11", "f12", "escape", "pause"]);
var MU = new je(["color", "date", "datetime", "datetime-local", "email", "month", "number", "password", "search", "tel", "text", "time", "url", "week"]);
var Wi = class extends Z {
  constructor(e, t) {
    super(), this.target = e, this.eventMap = t, this.modifierShortcutsAreGlobal = true, this.allShortcutsAreGlobal = false, this.allowSpaceKeyOnButtons = false, this.registerEventListener(
      e,
      "keydown",
      this.handleKeyDown.bind(this),
      /*useCapture=*/
      false
    );
  }
  shouldIgnoreEvent(e, t) {
    var i = t.target;
    let r = i.tagName;
    if (i === this.target)
      return false;
    var s = r === "TEXTAREA" || r === "INPUT" || r === "BUTTON" || r === "SELECT", a = !s && (i.isContentEditable || i.ownerDocument && i.ownerDocument.designMode === "on");
    return !s && !a || this.allShortcutsAreGlobal || RU.has(e) ? false : a || this.modifierShortcutsAreGlobal && (t.altKey || t.ctrlKey || t.metaKey) ? true : r === "INPUT" && MU.has(i.type) ? e !== "enter" : r === "INPUT" || r === "BUTTON" ? this.allowSpaceKeyOnButtons ? false : e === "space" : true;
  }
  handleKeyDown(e) {
    const t = NU(e);
    this.shouldIgnoreEvent(t, e) || Bk(t, e, e, this.eventMap);
  }
};
function NU(n) {
  return n.code.toLowerCase();
}
function ql(n, e = n.value) {
  n.style.minWidth = e.length + 1 + "ch";
}
var Lw = "neuroglancer-coordinate-space-transform-singleton";
function Dw(n, e) {
  let t;
  n === Number.NEGATIVE_INFINITY ? t = "(-∞," : t = `[${Math.floor(n)},`;
  let i;
  return e === Number.POSITIVE_INFINITY ? i = "+∞)" : i = `${Math.floor(e)})`, { lower: t, upper: i };
}
var Pw = vt.fromObject({
  arrowup: { action: "move-up" },
  arrowdown: { action: "move-down" },
  arrowleft: { action: "move-left", preventDefault: false },
  arrowright: { action: "move-right", preventDefault: false },
  enter: { action: "commit" },
  escape: { action: "cancel" }
});
function Aw() {
  const n = document.createElement("div"), e = document.createElement("input");
  n.classList.add("neuroglancer-coordinate-space-transform-scale-container"), e.spellcheck = false, e.autocomplete = "off", e.size = 1, e.classList.add("neuroglancer-coordinate-space-transform-scale"), n.appendChild(e);
  const t = document.createElement("div"), i = document.createElement("span");
  i.innerHTML = AU, t.appendChild(i);
  const r = document.createTextNode("");
  return t.appendChild(r), t.classList.add("neuroglancer-coordinate-space-transform-scale-suggestion"), n.appendChild(t), { cellElement: n, inputElement: e, suggestionElement: t };
}
function Rw(n, e, t, i, r) {
  if (e === void 0 || e.scale === t && e.unit === i)
    n.style.display = "none";
  else {
    n.style.display = "";
    const s = ca(e.scale, e.unit, { elide1: false });
    n.lastChild.textContent = s, n.title = `${r}${s}`;
  }
}
function Mw() {
  const n = document.createElement("input");
  return n.spellcheck = false, n.autocomplete = "off", n.size = 1, n.placeholder = " ", n.classList.add("neuroglancer-coordinate-space-transform-output-name"), n;
}
function Nw(n, e, t) {
  const i = n.map((v) => pc(v.value));
  if (i.includes(void 0))
    return false;
  const r = Float64Array.from(i, (v) => v.scale), s = De(i, (v) => v.unit), a = t.value, l = a.scales, d = a.units, u = a.rank;
  for (let v = 0; v < u; ++v)
    e[v] || (r[v] = l[v], s[v] = d[v]);
  if (Fe(l, r) && Fe(d, s))
    return false;
  const f = a.timestamps.map((v, y) => r[y] === l[y] && s[y] === d[y] ? v : Date.now()), g = mt({
    valid: a.valid,
    rank: a.rank,
    scales: r,
    units: s,
    timestamps: f,
    ids: a.ids,
    names: a.names,
    boundingBoxes: a.boundingBoxes,
    coordinateArrays: a.coordinateArrays
  });
  return t.value = g, true;
}
function _w(n, e, t, i) {
  const r = new Float64Array(n.scales), s = De(n.units);
  if (r[e] === t && s[e] === i)
    return n;
  const a = De(n.timestamps);
  return r[e] = t, s[e] = i, a[e] = Date.now(), RZr(RZr({}, n), { scales: r, units: s, timestamps: a });
}
var _U = class extends Z {
  constructor(e, t, i) {
    super(), this.transform = e, this.localCombiner = t, this.globalCombiner = i, this.element = document.createElement("div"), this.coefficientContainer = document.createElement("div"), this.translationContainer = document.createElement("div"), this.outputNameContainer = document.createElement("div"), this.outputScaleContainer = document.createElement("div"), this.inputNameContainer = document.createElement("div"), this.inputScaleContainer = document.createElement("div"), this.inputLowerBoundsContainer = document.createElement("div"), this.inputUpperBoundsContainer = document.createElement("div"), this.coefficientElements = [], this.inputNameElements = [], this.outputNameElements = [], this.outputScaleElements = [], this.outputScaleSuggestionElements = [], this.inputScaleSuggestionElements = [], this.inputScaleElements = [], this.inputBoundsElements = [], this.outputBoundsElements = [], this.addSourceDimensionIcon = Tt({ svg: Hu, text: "S" }), this.addOutputDimensionIcon = Tt({ svg: Hu, text: "V" }), this.addOutputDimensionCell = document.createElement("div"), this.addOutputDimensionInput = Mw(), this.inputScaleModified = [], this.outputScaleModified = [], this.curSourceRank = -1, this.curRank = -1, this.curTransform = void 0, this.addingSourceDimension = false, this.resetToIdentityButton = Tt({
      text: "Set to identity",
      title: "Reset to identity transform",
      onClick: () => {
        const B = this.transform, j = B.value.rank;
        B.transform = Ds(Float64Array, j + 1);
      }
    }), this.resetToDefaultButton = Tt({
      text: "Reset to default",
      title: "Reset to default input scales, transform, and output dimensions.",
      onClick: () => {
        const B = this.transform;
        if (B.mutableSourceRank)
          return;
        const j = B.defaultTransform;
        let U = j.outputSpace;
        const V = U.ids.map(() => lo());
        B.value = RZr(RZr({}, j), { outputSpace: RZr(RZr({}, U), { ids: V }) });
      }
    });
    const r = this.element, s = this.registerDisposer(new Wi(r, Pw));
    s.allShortcutsAreGlobal = true, r.classList.add("neuroglancer-coordinate-space-transform-widget"), this.registerDisposer(new qr(r, Pw));
    const a = Ct(() => this.updateView());
    this.registerDisposer(e.changed.add(a));
    const l = this.coefficientContainer, d = this.translationContainer, u = this.outputNameContainer, f = this.inputNameContainer, g = this.inputScaleContainer, v = this.inputLowerBoundsContainer, y = this.inputUpperBoundsContainer, w = this.outputScaleContainer, C = this.addOutputDimensionCell, b = this.addOutputDimensionIcon, E = this.addSourceDimensionIcon, L = this.resetToIdentityButton, R = this.resetToDefaultButton;
    l.style.display = "contents", d.style.display = "contents", u.style.display = "contents", f.style.display = "contents", g.style.display = "contents", w.style.display = "contents", v.style.display = "contents", y.style.display = "contents";
    const _ = document.createElement("div");
    _.classList.add("neuroglancer-coordinate-space-transform-widget-reset-buttons"), L.classList.add("neuroglancer-coordinate-space-transform-widget-reset-to-identity"), R.classList.add("neuroglancer-coordinate-space-transform-widget-reset-to-default"), _.appendChild(L), _.appendChild(R), r.appendChild(_);
    for (const B of [["source", "Source dimensions"], ["output", "Output dimensions"], ["input-lower", "Lower"], ["input-upper", "Upper"], ["input-scale", "Scale"], ["translation", "Translation"]]) {
      var A = ce(B, 2);
      const j = A[0], U = A[1], V = document.createElement("div");
      V.classList.add(`neuroglancer-coordinate-space-transform-${j}-label`), V.classList.add("neuroglancer-coordinate-space-transform-label"), V.textContent = U, r.appendChild(V);
    }
    e.mutableSourceRank && C.appendChild(E), C.appendChild(b), C.classList.add("neuroglancer-coordinate-space-transform-output-extend");
    const I = "Embed in additional output dimension", P = "Extend to additional source dimension";
    b.title = I, E.title = P, C.appendChild(this.addOutputDimensionInput), C.dataset.isActive = "false", b.addEventListener("click", () => {
      this.addingSourceDimension = false, this.addOutputDimensionInput.title = I, this.addOutputDimensionCell.dataset.isActive = "true", this.addOutputDimensionInput.focus();
    }), E.addEventListener("click", () => {
      this.addingSourceDimension = true, this.addOutputDimensionInput.title = P, this.addOutputDimensionCell.dataset.isActive = "true", this.addOutputDimensionInput.focus();
    }), this.addOutputDimensionInput.addEventListener("blur", () => {
      this.updateAddOutputDimensionCellStyle();
    }), r.appendChild(l), r.appendChild(u), r.appendChild(f), r.appendChild(g), r.appendChild(w), r.appendChild(v), r.appendChild(y), l.appendChild(d), r.addEventListener("input", (B) => {
      const j = B.target;
      if (j instanceof HTMLInputElement) {
        ql(j);
        let U = this.inputScaleElements.indexOf(j);
        if (U !== -1) {
          this.inputScaleModified[U] = true, this.updateScaleValidity(j);
          return;
        }
        if (U = this.outputScaleElements.indexOf(j), U !== -1) {
          this.outputScaleModified[U] = true, this.updateScaleValidity(j);
          return;
        }
        if (U = this.outputNameElements.indexOf(j), U !== -1) {
          this.updateOutputNameValidity();
          return;
        }
        if (this.coefficientContainer.contains(j)) {
          this.updateCoefficientValidity(j);
          return;
        }
      }
    });
    const N = (B, j, U) => {
      be(r, B, (V) => {
        V.stopPropagation();
        const G = V.target;
        if (!(G instanceof HTMLInputElement) || U !== 0 && (G.selectionStart !== G.selectionEnd || G.selectionStart !== (U === 1 ? G.value.length : 0)))
          return;
        const F = this.getElementGridPosition(G);
        if (F === void 0)
          return;
        const ue = this.getElementByGridPosition(F.row + j, F.col + U);
        ue !== null && (ue.focus(), V.preventDefault());
      });
    };
    N("move-up", -1, 0), N("move-down", 1, 0), N("move-left", 0, -1), N("move-right", 0, 1);
    const O = (B, j) => {
      B.addEventListener("focusout", (U) => {
        const V = U.relatedTarget;
        V instanceof Node && B.contains(V) || j(U);
      });
    };
    O(l, () => {
      this.updateModelTransform() || this.updateViewTransformCoefficients();
    }), O(u, () => {
      this.updateModelOutputNames() || this.updateViewOutputNames();
    }), O(g, () => {
      this.updateModelInputScales() || this.updateViewInputScales();
    }), O(w, () => {
      this.updateModelOutputScales() || this.updateViewOutputScales();
    }), be(r, "cancel", (B) => {
      this.curTransform = void 0, this.updateView(), B.target.blur();
    }), be(l, "commit", () => {
      this.updateModelTransform();
    }), be(u, "commit", () => {
      this.updateModelOutputNames();
    }), be(g, "commit", () => {
      this.updateModelInputScales();
    }), be(w, "commit", () => {
      this.updateModelOutputScales();
    }), r.addEventListener("focusin", (B) => {
      const j = B.target;
      j instanceof HTMLInputElement && j.select();
    }), this.updateView();
  }
  updateWillBeDeletedAttributes(e) {
    const t = this.transform.value.rank;
    e === void 0 && (e = new Array(t), e.fill(false));
    const i = this.coefficientElements, r = this.inputBoundsElements, s = this.inputScaleElements;
    for (let l = 0; l < t; ++l) {
      const d = e[l];
      for (let g = 0; g <= t; ++g) {
        const v = i[t * g + l], y = g < t && e[g];
        v.dataset.willBeDeleted = (d || y).toString();
      }
      s[l].dataset.willBeDeleted = d.toString();
      var a = r[l];
      const u = a.lower, f = a.upper;
      u.dataset.willBeDeleted = d.toString(), f.dataset.willBeDeleted = d.toString();
    }
  }
  updateAddOutputDimensionCellStyle() {
    const e = this.addOutputDimensionInput;
    this.addOutputDimensionCell.dataset.isActive = (e.value.length !== 0 || document.activeElement === e).toString();
  }
  updateOutputNameValidity() {
    const e = this.outputNameElements, t = e.map((f) => f.value);
    var i = this.transform, r = i.value;
    const s = r.sourceRank, a = r.rank, l = i.mutableSourceRank;
    if (e.length !== a + 1)
      return;
    const d = Uv(t);
    let u = new Array(a);
    u.fill(false);
    for (let f = 0; f <= a; ++f) {
      let g = d[f];
      t[f].length === 0 && (l || f >= s) && (g = true, u[f] = true), e[f].dataset.isValid = g.toString();
    }
    this.updateWillBeDeletedAttributes(u), this.updateAddOutputDimensionCellStyle();
  }
  updateScaleValidity(e) {
    const t = pc(e.value) !== void 0;
    e.dataset.isValid = t.toString();
  }
  updateCoefficientValidity(e) {
    const t = kt(Number(e.value));
    e.dataset.isValid = t.toString();
  }
  getElementGridPosition(e) {
    {
      const t = this.outputNameElements.indexOf(e);
      if (t !== -1)
        return { row: t, col: -2 };
    }
    {
      const t = this.inputScaleElements.indexOf(e);
      if (t !== -1)
        return { row: -1, col: t };
    }
    {
      const t = this.coefficientElements.indexOf(e), i = this.transform.value.rank;
      if (t !== -1)
        return { row: t % i, col: Math.floor(t / i) };
    }
    {
      const t = this.outputScaleElements.indexOf(e);
      if (t !== -1)
        return { row: t, col: -1 };
    }
  }
  getElementByGridPosition(e, t) {
    const i = this.transform.value.rank;
    return e === -1 ? t < 0 || t >= i ? null : this.inputScaleElements[t] : t === -2 ? e < 0 || e > i ? null : this.outputNameElements[e] : t === -1 ? e < 0 || e >= i ? null : this.outputScaleElements[e] : e < 0 || e >= i || t < 0 || t > i ? null : this.coefficientElements[t * i + e];
  }
  dimensionRefCount(e) {
    return (ic(e) ? this.localCombiner : this.globalCombiner).dimensionRefCounts.get(e) || 0;
  }
  updateModelInputScales() {
    return Nw(this.inputScaleElements, this.inputScaleModified, this.transform.inputSpace);
  }
  updateModelOutputScales() {
    return Nw(this.outputScaleElements, this.outputScaleModified, this.transform.outputSpace);
  }
  updateModelOutputNames() {
    const e = this.outputNameElements.map((R) => R.value);
    var t = this.transform;
    const i = t.value, r = t.mutableSourceRank, s = i.outputSpace, a = i.rank, l = i.sourceRank;
    if (e.length !== a + 1)
      return;
    const d = [], u = [], f = e[a].length !== 0;
    let g = l;
    for (let R = 0; R <= a; ++R) {
      const _ = e[R];
      if (_.length === 0) {
        if (R < l) {
          if (!r)
            return false;
          --g;
        }
        continue;
      }
      u.push(_), d.push(R);
    }
    if (!Ah(u))
      return false;
    const v = s.names;
    if (!f && Fe(v, u))
      return true;
    let y = i.inputSpace, w = i.outputSpace, C = i.transform;
    if (f) {
      this.addingSourceDimension && ++g;
      const R = e[a], _ = (ic(R) ? this.localCombiner : this.globalCombiner).combined.value, A = _.names.indexOf(R);
      let I, P;
      A !== -1 ? (I = _.units[A], P = _.scales[A]) : (I = "", P = 1);
      const N = y.boundingBoxes.map((O) => N1(O, a, a + 1));
      this.addingSourceDimension || N.push(M1(a + 1, a)), y = mt({
        valid: y.valid,
        rank: a + 1,
        names: [...y.names, ""],
        ids: [...y.ids, lo()],
        timestamps: [...y.timestamps, Date.now()],
        scales: Float64Array.from([...y.scales, P]),
        units: [...y.units, I],
        boundingBoxes: N,
        coordinateArrays: [...y.coordinateArrays, void 0]
      }), w = mt({
        valid: s.valid,
        rank: a + 1,
        names: [...s.names, R],
        ids: [...s.ids, lo()],
        timestamps: [...s.timestamps, Date.now()],
        scales: Float64Array.from([...s.scales, P]),
        units: [...s.units, I],
        coordinateArrays: [...s.coordinateArrays, void 0]
      }), C = Nv(new Float64Array((a + 2) ** 2), a + 1, C, a);
    }
    C = B1(Float64Array, C, y.rank, d, d), y = Wg(y, d), w = Wg(w, d);
    const b = w.ids.map((R, _) => {
      const A = d[_];
      if (A === a)
        return R;
      const I = u[_], P = v[A];
      return I === P || this.dimensionRefCount(P) === 1 && this.dimensionRefCount(I) === (v.includes(I) ? 1 : 0) ? R : lo();
    }), E = w.timestamps.map((R, _) => {
      const A = d[_];
      return A === a || u[_] === v[A] ? R : Date.now();
    });
    w = RZr(RZr({}, w), {
      names: u,
      ids: b,
      timestamps: E
    });
    let L = {
      rank: w.rank,
      sourceRank: g,
      outputSpace: w,
      inputSpace: y,
      transform: C
    };
    return this.transform.value = L, true;
  }
  updateModelTransform() {
    const e = this.coefficientElements, t = this.transform.value.rank, i = new Float64Array((t + 1) ** 2);
    i[i.length - 1] = 1;
    for (let r = 0; r < t; ++r)
      for (let s = 0; s <= t; ++s) {
        const a = e[s * t + r], l = parseFloat(a.value);
        if (!kt(l))
          return false;
        i[s * (t + 1) + r] = l;
      }
    return this.transform.transform = i, true;
  }
  updateViewOutputNames() {
    var e = this.transform.value;
    const t = e.outputSpace, i = e.rank;
    if (i !== this.curRank)
      return;
    const r = this.outputNameElements, s = t.names;
    for (let a = 0; a < i; ++a) {
      const l = r[a];
      l.value = s[a], l.dataset.isValid = "true", ql(l);
    }
    r[i].value = "", this.updateWillBeDeletedAttributes();
  }
  updateViewTransformCoefficients() {
    var e = this.transform.value;
    const t = e.transform, i = e.rank, r = this.coefficientElements;
    for (let s = 0; s < i; ++s)
      for (let a = 0; a <= i; ++a) {
        const l = r[a * i + s];
        l.value = t[a * (i + 1) + s].toString(), l.dataset.isValid = "true", ql(l);
      }
  }
  ensureViewRankUpdated() {
    const e = this.transform.value, t = e.rank, i = e.sourceRank;
    if (this.curSourceRank === i && this.curRank === t)
      return;
    const r = this.inputBoundsElements, s = this.inputNameElements, a = this.inputScaleElements, l = this.element, d = this.coefficientElements, u = this.outputNameElements, f = this.outputScaleElements, g = this.outputScaleSuggestionElements, v = this.inputScaleSuggestionElements, y = this.outputBoundsElements, w = this.coefficientContainer, C = this.translationContainer, b = this.outputNameContainer, E = this.inputNameContainer, L = this.inputScaleContainer, R = this.inputLowerBoundsContainer, _ = this.inputUpperBoundsContainer, A = this.outputScaleContainer;
    l.style.gridTemplateColumns = `[outputLabel headerStart] min-content [outputNames] 1fr [outputScales] 1fr [headerEnd] repeat(${Math.max(1, t) + 1}, [sourceDim] 1fr)`, l.style.gridTemplateRows = `[sourceLabel headerStart] auto [sourceNames] auto [sourceLower] auto [sourceUpper] auto [sourceScales] auto [headerEnd]repeat(${t + 1}, [outputDim] auto)`, it(w), it(C), w.appendChild(C), it(b), it(E), it(L), it(R), it(_), it(A), s.length = 0, a.length = 0, r.length = 0, f.length = 0, g.length = 0, v.length = 0, d.length = 0, u.length = 0, y.length = 0;
    for (let N = 0; N < t; ++N) {
      const O = (B) => {
        B.classList.add("neuroglancer-coordinate-space-transform-input"), N >= i && B.classList.add(Lw);
      };
      {
        const B = document.createElement("div");
        B.classList.add("neuroglancer-coordinate-space-transform-input-name"), O(B), B.style.gridRowStart = "sourceNames", B.style.gridColumnStart = `sourceDim ${N + 1}`, E.appendChild(B), s.push(B);
      }
      {
        var I = Aw();
        const B = I.cellElement, j = I.inputElement, U = I.suggestionElement;
        B.classList.add("neuroglancer-coordinate-space-transform-input-scale-container"), O(B), B.style.gridRowStart = "sourceScales", B.style.gridColumnStart = `sourceDim ${N + 1}`, L.appendChild(B), a.push(j), v.push(U);
        const V = N;
        U.addEventListener("click", () => {
          const G = oC(this.transform, V);
          G !== void 0 && (this.transform.inputSpace.value = _w(this.transform.inputSpace.value, V, G.scale, G.unit));
        });
      }
      {
        const B = document.createElement("div");
        O(B), B.classList.add("neuroglancer-coordinate-space-transform-input-bounds"), B.style.gridRowStart = "sourceLower", B.style.gridColumnStart = `sourceDim ${N + 1}`, R.appendChild(B);
        const j = document.createElement("div");
        O(j), j.classList.add("neuroglancer-coordinate-space-transform-input-bounds"), j.style.gridRowStart = "sourceUpper", j.style.gridColumnStart = `sourceDim ${N + 1}`, _.appendChild(j), r.push({ lower: B, upper: j });
      }
    }
    for (let N = 0; N < t; ++N) {
      for (let O = 0; O <= t; ++O) {
        const B = document.createElement("input");
        B.classList.add("neuroglancer-coordinate-space-transform-coeff"), B.spellcheck = false, B.autocomplete = "off", B.size = 1, B.style.gridRowStart = `outputDim ${N + 1}`, B.placeholder = " ", B.style.gridColumnStart = `sourceDim ${O + 1}`, d[O * t + N] = B, O === t ? B.classList.add("neuroglancer-coordinate-space-transform-translation-coeff") : O == i && B.classList.add(Lw), (O === t ? C : w).appendChild(B);
      }
      {
        var P = Aw();
        const O = P.cellElement, B = P.suggestionElement, j = P.inputElement;
        O.classList.add("neuroglancer-coordinate-space-transform-output-scale-container"), O.style.gridRowStart = `outputDim ${N + 1}`, O.style.gridColumnStart = "outputScales";
        const U = N;
        B.addEventListener("click", () => {
          const V = this.transform.value, G = aC(V, U);
          G !== void 0 && (this.transform.outputSpace.value = _w(V.outputSpace, U, G.scale, G.unit));
        }), g.push(B), A.appendChild(O), f.push(j);
      }
      {
        const O = document.createElement("div");
        O.classList.add("neuroglancer-coordinate-space-transform-output-name-container"), O.style.gridRowStart = `outputDim ${N + 1}`, O.style.gridColumnStart = "outputNames";
        const B = Mw();
        B.title = "Rebind to a different dimension", N >= i ? B.title += ", or delete to remove singleton dimension" : this.transform.mutableSourceRank && (B.title += ", or delete to remove source dimension"), B.title += ".  Names ending in ' or ^ indicate dimensions local to the layer; names ending in ^ indicate channel dimensions (image layers only).", u.push(B), b.appendChild(O), O.appendChild(B);
        const j = document.createElement("div");
        j.classList.add("neuroglancer-coordinate-space-transform-output-bounds"), O.appendChild(j);
        const U = document.createElement("div");
        U.classList.add("neuroglancer-coordinate-space-transform-output-bounds"), O.appendChild(U), y.push({ lower: j, upper: U }), O.addEventListener("mousedown", (V) => {
          V.target !== B && (B.focus(), V.preventDefault());
        });
      }
    }
    u.push(this.addOutputDimensionInput), this.addOutputDimensionInput.value = "", b.appendChild(this.addOutputDimensionCell), this.curSourceRank = i, this.curRank = t;
  }
  updateViewInputScales() {
    this.ensureViewRankUpdated(), this.inputScaleModified.length = 0;
    var e = this.transform.value;
    const t = e.inputSpace, i = e.rank, r = e.sourceRank, s = this.inputBoundsElements, a = this.inputNameElements, l = this.inputScaleElements, d = this.inputScaleSuggestionElements, u = t.names, f = t.scales, g = t.units;
    var v = t.bounds;
    const y = v.lowerBounds, w = v.upperBounds;
    for (let b = 0; b < i; ++b) {
      const E = l[b], L = f[b], R = g[b];
      E.value = ca(L, R, { elide1: false }), E.dataset.isValid = "true", ql(E);
      let _;
      if (b < r) {
        let N = u[b];
        N || (N = `${b}`), a[b].textContent = N, _ = `source dimension ${N}`, E.title = `Override scale of ${_}`;
      } else
        _ = "singleton dimension", E.title = `Set extent of ${_}`;
      var C = Dw(y[b], w[b]);
      const A = C.lower, I = C.upper, P = s[b];
      P.lower.textContent = A, P.lower.title = `Lower bound of ${_}`, P.upper.title = `Upper bound of ${_}`, P.upper.textContent = I, Rw(d[b], oC(this.transform, b), L, R, `Revert scale of ${_} to `);
    }
  }
  updateViewOutputScales() {
    const e = this.transform.value;
    var t = e.outputSpace;
    const i = t.rank, r = t.names, s = t.units, a = t.scales;
    var l = t.bounds;
    const d = l.lowerBounds, u = l.upperBounds, f = this.outputScaleElements, g = this.outputBoundsElements, v = this.outputScaleSuggestionElements;
    for (let w = 0; w < i; ++w) {
      const C = f[w], b = a[w], E = s[w];
      C.value = ca(b, E, { elide1: false }), ql(C);
      const L = r[w];
      C.dataset.isValid = "true";
      const R = `Change coordinates of ${ic(L) ? "local" : "global"} dimension ${L}`;
      C.title = `${R} (does not rescale the source)`;
      var y = Dw(d[w], u[w]);
      const _ = y.lower, A = y.upper, I = g[w];
      I.lower.textContent = _, I.upper.textContent = A, Rw(v[w], aC(e, w), b, E, `${R} to inferred scale of `);
    }
  }
  updateResetButtonVisibility(e = false, t = false) {
    var i = this.transform;
    const r = i.value, s = i.mutableSourceRank, a = i.defaultTransform, l = r.rank;
    this.resetToIdentityButton.style.visibility = e || !b2(r.transform, l + 1, l + 1) ? "visible" : "hidden", this.resetToDefaultButton.style.visibility = !s && (e || t || !F2(a, r)) ? "visible" : "hidden";
  }
  updateView() {
    const e = this.transform.value;
    this.curTransform !== e && (this.curTransform = e, this.ensureViewRankUpdated(), this.updateViewInputScales(), this.updateViewOutputNames(), this.updateViewTransformCoefficients(), this.updateViewOutputScales(), this.updateAddOutputDimensionCellStyle(), this.updateResetButtonVisibility());
  }
  disposed() {
    Ft(this.element), super.disposed();
  }
};
function OU(n, e, { horizontal: t = false, vertical: i = true, topMargin: r = 6, bottomMargin: s = 6, leftMargin: a = 6, rightMargin: l = 6, maxHeight: d = true, maxWidth: u = true } = {}) {
  const f = e.getBoundingClientRect();
  if (t) {
    const g = n.ownerDocument.documentElement.clientWidth;
    let v = f.right, y = g - f.left;
    v > y ? (n.style.left = "", n.style.right = `${g - f.right}px`, u && (n.style.maxWidth = v - a + "px")) : (n.style.right = "", n.style.left = `${f.left}px`, u && (n.style.maxWidth = y - l + "px"));
  }
  if (i) {
    const g = n.ownerDocument.documentElement.clientHeight;
    let v = f.top - r, y = g - f.bottom - s;
    n.style.left = `${f.left}px`, n.style.width = `${f.width}px`, v > y * 3 ? (n.style.top = "", n.style.bottom = `${g - f.top}px`, d && (n.style.maxHeight = v + "px")) : (n.style.top = `${f.bottom}px`, n.style.bottom = "", d && (n.style.maxHeight = y + "px"));
  }
}
function VU(n) {
  let e = bv(n);
  var t = e.next();
  let i = t.value;
  if (t.done)
    return "";
  let s = i.length;
  for (; s > 0; ) {
    var a = e.next();
    let l = a.value;
    if (a.done)
      break;
    let u = 0;
    for (; u < s && i.charCodeAt(u) === l.charCodeAt(u); ++u)
      ;
    s = u;
  }
  return i.substring(0, s);
}
var Ow = 10;
var tu = 0.5;
var BU = class {
  constructor() {
    this.anchorIndex = 0, this.anchorClientOffset = 0;
  }
  splice(e) {
    let t = this.anchorIndex, i = 0;
    for (const r of e) {
      if (i += r.retainCount, t < i)
        break;
      const s = r.deleteCount;
      if (t < i + s) {
        t = i;
        break;
      }
      const a = r.insertCount;
      t = t - s + a, i += a - a;
    }
    this.anchorIndex = t;
  }
};
var Vw = class {
  constructor() {
    this.startIndex = 0, this.endIndex = 0, this.anchorIndex = 0, this.anchorOffset = 0, this.scrollOffset = 0;
  }
};
var FU = class {
  constructor() {
    this.itemSize = [], this.totalKnownSize = 0, this.numItemsInTotalKnownSize = 0;
  }
  get averageSize() {
    return this.totalKnownSize / this.numItemsInTotalKnownSize;
  }
  getEstimatedSize(e) {
    var t;
    return (t = this.itemSize[e]) !== null && t !== void 0 ? t : this.averageSize;
  }
  getEstimatedTotalSize() {
    return this.totalKnownSize / this.numItemsInTotalKnownSize * this.itemSize.length;
  }
  getEstimatedOffset(e, t = 0, i = 0) {
    for (; t < e; ++t)
      i += this.getEstimatedSize(t);
    for (; t > e; --t)
      i -= this.getEstimatedSize(t - 1);
    return i;
  }
  getRangeSize(e, t) {
    var i;
    let r = 0;
    const s = this.itemSize, a = this.averageSize;
    for (let l = e; l < t; ++l)
      r += (i = s[l]) !== null && i !== void 0 ? i : a;
    return r;
  }
  splice(e) {
    let t = this.itemSize;
    t = this.itemSize = yN(t, e), this.totalKnownSize = t.reduce((i, r) => i + r, 0), this.numItemsInTotalKnownSize = t.reduce((i) => i + 1, 0);
  }
};
function UU(n, e, t, i, r, s) {
  let a = s.anchorIndex, l = s.anchorClientOffset, d = r.getEstimatedOffset(a), u, f, g, v, y;
  if (i === 0 || r.totalKnownSize === 0)
    u = Math.max(0, a - Ow / 2), f = Math.min(t, u + Ow), y = a, g = 0, v = l;
  else {
    const w = r.getEstimatedTotalSize(), C = Math.max(0, w - i);
    v = d - l, v = Math.max(0, Math.min(C, v));
    const b = v - 2 * tu * i, E = v - tu * i, L = v + i + tu * i, R = d - l + i + 2 * tu * i;
    u = Math.min(t, e.startIndex);
    let _ = r.getEstimatedOffset(u, a, d);
    if (_ < b)
      for (; u + 1 < t; ++u) {
        const I = r.getEstimatedSize(u);
        if (_ + I >= E)
          break;
        _ += I;
      }
    if (_ >= E)
      for (; _ > b && u > 0; --u) {
        const I = r.getEstimatedSize(u - 1);
        _ -= I;
      }
    f = Math.min(t, e.endIndex);
    let A = r.getEstimatedOffset(f, a, d);
    if (A < L)
      for (; A <= R && f + 1 <= t; ++f) {
        const I = r.getEstimatedSize(f);
        A += I;
      }
    else if (A >= R)
      for (; f > u; --f) {
        const I = r.getEstimatedSize(f - 1);
        if (A - I < L)
          break;
        A -= I;
      }
    for (y = a, g = d; y < u; ++y) {
      const I = r.getEstimatedSize(y);
      g += I;
    }
    for (; y > f; --y) {
      const I = r.getEstimatedSize(y - 1);
      g -= I;
    }
  }
  n.startIndex = u, n.endIndex = f, n.anchorIndex = y, n.anchorOffset = g, n.scrollOffset = v;
}
function zU(n, e) {
  const t = e.getEstimatedOffset(n.anchorIndex), i = n.anchorOffset;
  n.anchorOffset = t, n.scrollOffset += t - i;
}
function GU(n, e) {
  return n.startIndex < e.startIndex || n.endIndex > e.endIndex;
}
var Py = class extends Z {
  constructor(e) {
    super(), this.element = document.createElement("div"), this.scrollContent = document.createElement("div"), this.header = document.createElement("div"), this.body = document.createElement("div"), this.topItems = document.createElement("div"), this.bottomItems = document.createElement("div"), this.renderedItems = [], this.renderGeneration = -1, this.listGeneration = -1, this.newRenderedItems = [], this.state = new BU(), this.renderParams = new Vw(), this.newRenderParams = new Vw(), this.sizes = new FU(), this.debouncedUpdateView = this.registerCancellable(Ct(() => this.updateView())), this.resizeObserver = new ResizeObserver(() => this.updateView());
    const t = e.selectedIndex;
    t !== void 0 && (this.state.anchorIndex = t, this.state.anchorClientOffset = 0);
    const i = this.source = e.source;
    this.sizes.itemSize.length = i.length;
    const r = this.element, s = this.header, a = this.body, l = this.scrollContent, d = this.topItems, u = this.bottomItems;
    this.resizeObserver.observe(r), this.registerDisposer(() => this.resizeObserver.disconnect()), r.appendChild(l), r.style.overflowAnchor = "none", l.appendChild(s), l.appendChild(a), s.style.position = "sticky", s.style.zIndex = "1", s.style.top = "0", e.horizontalScroll ? (l.style.width = "min-content", l.style.minWidth = "100%", s.style.width = "min-content", s.style.minWidth = "100%", u.style.width = "min-content", u.style.minWidth = "100%") : (l.style.width = "100%", s.style.width = "100%", u.style.width = "100%"), a.appendChild(d), a.appendChild(u), d.style.width = "min-content", d.style.position = "relative", d.style.height = "0", d.style.minWidth = "100%", u.style.height = "0", u.style.position = "relative", r.addEventListener("scroll", () => {
      const f = r.scrollTop;
      this.state.anchorClientOffset = this.renderParams.anchorOffset - f, this.renderParams.scrollOffset = f, this.debouncedUpdateView();
    }), i.changed !== void 0 && this.registerDisposer(i.changed.add((f) => {
      this.sizes.splice(f), this.state.splice(f), this.renderedItems.length = 0, this.debouncedUpdateView();
    })), i.renderChanged !== void 0 && this.registerDisposer(i.renderChanged.add(this.debouncedUpdateView));
  }
  updateView() {
    const e = this.element;
    if (e.offsetHeight === 0)
      return;
    const t = e.clientHeight - this.header.offsetHeight, i = this.source, r = this.state, s = this.sizes, a = i.length, l = this.body, d = this.topItems, u = this.bottomItems, f = i.changed, g = i.renderChanged;
    let v;
    for (; ; ) {
      v = this.newRenderParams;
      const b = this.renderParams;
      UU(v, b, a, t, s, r);
      let E;
      if (g !== void 0 && g.count !== this.renderGeneration || f !== void 0 && f.count !== this.listGeneration ? (this.renderGeneration = g === void 0 ? -1 : g.count, this.listGeneration = f === void 0 ? -1 : f.count, E = true, this.renderedItems.length = 0) : E = false, !E && !GU(v, b)) {
        b.scrollOffset = v.scrollOffset, v = b;
        break;
      }
      this.renderParams = v, this.newRenderParams = b;
      const L = this.renderedItems, R = this.newRenderedItems;
      R.length = 0, this.renderedItems = R, this.newRenderedItems = L;
      const _ = this.source, A = _.render;
      var y = v;
      const I = y.startIndex, P = y.endIndex, N = y.anchorIndex;
      function* O(B, j) {
        for (let U = B; U < j; ++U) {
          let V = L[U];
          V === void 0 && (V = A.call(_, U)), R[U] = V, yield V;
        }
      }
      ar(d, O(I, N)), ar(u, O(N, P));
      for (let B = I; B < P; ++B) {
        const V = R[B].getBoundingClientRect().height, G = s.itemSize[B];
        G !== void 0 && (s.totalKnownSize -= G, --s.numItemsInTotalKnownSize), s.itemSize[B] = V, s.totalKnownSize += V, ++s.numItemsInTotalKnownSize;
      }
    }
    zU(v, s), r.anchorIndex = v.anchorIndex, r.anchorClientOffset = v.anchorOffset - v.scrollOffset;
    const w = s.getRangeSize(v.startIndex, v.anchorIndex), C = s.getEstimatedTotalSize();
    l.style.height = `${C}px`, d.style.top = `${v.anchorOffset - w}px`, u.style.top = `${v.anchorOffset}px`, e.scrollTop = v.scrollOffset;
  }
  getItemElement(e) {
    return this.renderedItems[e];
  }
  forEachRenderedItem(e) {
    var t = this.renderParams;
    const i = t.startIndex, r = t.endIndex, s = this.renderedItems;
    for (let a = i; a < r; ++a) {
      const l = s[a];
      l !== void 0 && e(l, a);
    }
  }
  scrollToTop() {
    this.state.anchorIndex = 0, this.state.anchorClientOffset = 0, this.debouncedUpdateView();
  }
  scrollItemIntoView(e) {
    const t = this.sizes.getEstimatedOffset(e), i = t + this.sizes.getEstimatedSize(e), r = this.element.scrollTop;
    if (t < r)
      this.state.anchorIndex = e, this.state.anchorClientOffset = 0;
    else if (t > r && i > r + this.element.offsetHeight)
      this.state.anchorIndex = e + 1, this.state.anchorClientOffset = this.element.offsetHeight;
    else
      return;
    this.debouncedUpdateView();
  }
  disposed() {
    Ft(this.element);
  }
};
var eg2 = "neuroglancer-multiline-autocomplete-completion-active";
function $U(n) {
  let e = document.createElement("div");
  return e.textContent = n.value, e;
}
function* Bw(n) {
  for (; n.length > 0; ) {
    const e = n.match(/[:/_]+/);
    if (e === null) {
      yield n;
      return;
    }
    const t = e.index + e[0].length;
    yield n.substring(0, t), n = n.substring(t);
  }
}
function WU(n) {
  let e = document.createElement("div");
  e.className = "neuroglancer-multiline-autocomplete-completion-with-description", e.textContent = n.value;
  let t = document.createElement("div");
  return t.className = "neuroglancer-multiline-autocomplete-completion-description", t.textContent = n.description || "", e.appendChild(t), e;
}
var HU = vt.fromObject({
  arrowdown: { action: "cycle-next-active-completion" },
  arrowup: { action: "cycle-prev-active-completion" },
  home: { action: "home" },
  end: { action: "end" },
  tab: { action: "choose-active-completion-or-prefix", preventDefault: false },
  enter: { action: "commit" },
  escape: { action: "cancel", preventDefault: false, stopPropagation: false }
});
var jU = 200;
var JU = class extends Z {
  constructor(e) {
    super(), this.element = document.createElement("div"), this.inputElement = document.createElement("span"), this.hintElement = document.createElement("span"), this.completionsVirtualList = void 0, this.onCommit = new ot(), this.onInput = new ot(), this.prevInputValue = "", this.completionsVisible = false, this.activeCompletionPromise = null, this.activeCompletionCancellationToken = void 0, this.hasFocus = false, this.completionResult = null, this.dropdownContentsStale = true, this.hasResultForDropdown = false, this.commonPrefix = "", this.completionDisabled = -1, this.activeIndex = -1, this.dropdownStyleStale = true, this.resizeHandler = () => {
      this.completionsVisible && this.updateDropdownStyle();
    }, this.resizeObserver = new ResizeObserver(this.resizeHandler), this.debouncedUpdateHintState = this.registerCancellable(lt(() => this.updateHintState(), 0)), this.completer = e.completer;
    var t = e.delay;
    const i = t === void 0 ? jU : t;
    let r = this.scheduleUpdateCompletions = lt(() => {
      const u = this.activeCompletionCancellationToken = new As();
      let f = this.activeCompletionPromise = this.completer(this.value, u);
      f !== null && f.then((g) => {
        this.activeCompletionPromise === f && (this.setCompletions(g), this.activeCompletionPromise = null);
      });
    }, i);
    this.registerDisposer(() => {
      r.cancel();
    });
    const s = this.element, a = this.inputElement, l = this.hintElement;
    s.classList.add("neuroglancer-multiline-autocomplete"), this.registerEventListener(window, "resize", this.resizeHandler), this.resizeObserver.observe(s), this.registerDisposer(() => this.resizeObserver.unobserve(a)), a.contentEditable = "true", a.spellcheck = false, s.appendChild(document.createTextNode("​")), s.appendChild(a), s.appendChild(l), a.classList.add("neuroglancer-multiline-autocomplete-input"), l.classList.add("neuroglancer-multiline-autocomplete-hint"), a.addEventListener("input", () => {
      this.completionDisabled = -1, this.setValueAndSelection(this.value, this.getSelectionRange()), this.debouncedUpdateHintState();
    }), a.addEventListener("copy", (u) => {
      const f = u.clipboardData;
      if (f !== null) {
        const g = window.getSelection();
        g !== null && !g.isCollapsed && g.containsNode(
          a,
          /*allowPartialContainment=*/
          true
        ) && f.setData("text/plain", g.toString());
      }
      u.preventDefault(), u.stopPropagation();
    }), this.registerEventListener(document, "selectionchange", () => {
      const u = this.getSelectionRange(), f = this.completionDisabled;
      u !== void 0 && u.begin === f && u.end === f || (this.completionDisabled = -1, this.debouncedUpdateHintState());
    }), this.setValueAndSelection(""), this.updateHintState(), s.addEventListener("pointerdown", (u) => {
      const f = u.target;
      if (f instanceof Node) {
        if (a.contains(f))
          return;
        const g = this.completionsVirtualList;
        if (g !== void 0 && g.element.contains(f))
          return;
      }
      a === document.activeElement && (this.moveCaretToEndOfInput(), u.stopPropagation(), u.preventDefault());
    }), s.addEventListener("click", () => {
      a.focus();
    }), this.registerEventListener(this.inputElement, "focus", () => {
      if (!this.hasFocus) {
        this.hasFocus = true, this.dropdownStyleStale = true, this.updateDropdown();
        const u = document.createRange(), f = a.childNodes;
        u.setStart(a, 0), f.length === 0 ? u.setEnd(a, 0) : u.setEndAfter(f[f.length - 1]);
        const g = window.getSelection();
        g !== null && (g.removeAllRanges(), g.addRange(u)), this.debouncedUpdateHintState();
      }
    }), this.registerEventListener(this.inputElement, "blur", () => {
      this.hasFocus && (this.hasFocus = false, this.updateDropdown()), this.debouncedUpdateHintState();
      const u = window.getSelection();
      u !== null && u.containsNode(this.inputElement, true) && u.removeAllRanges(), this.onCommit.dispatch(this.value, false);
    }), this.registerEventListener(window, "resize", () => {
      this.dropdownStyleStale = true;
    }), this.registerEventListener(window, "scroll", () => {
      this.dropdownStyleStale = true;
    });
    const d = this.registerDisposer(new Wi(a, HU));
    d.allShortcutsAreGlobal = true, be(a, "cycle-next-active-completion", () => {
      this.cycleActiveCompletion(1);
    }), be(a, "cycle-prev-active-completion", () => {
      this.cycleActiveCompletion(-1);
    }), be(a, "home", () => {
      this.moveCaretToBeginningOfInput();
    }), be(a, "end", () => {
      this.moveCaretToEndOfInput();
    }), be(a, "choose-active-completion-or-prefix", (u) => {
      this.selectActiveCompletion(
        /*allowPrefix=*/
        true
      ) && u.preventDefault();
    }), be(a, "commit", (u) => {
      if (this.selectActiveCompletion(
        /*allowPrefix=*/
        false
      ))
        u.stopPropagation();
      else {
        let f = !this.completionsVisible;
        this.disableCompletion(), this.hideCompletions(), this.onCommit.dispatch(this.value, f);
      }
    }), be(a, "cancel", (u) => {
      u.stopPropagation(), this.cancel() && (u.detail.preventDefault(), u.detail.stopPropagation());
    });
  }
  disableCompletion() {
    const e = this.getSelectionRange();
    this.completionDisabled = e !== void 0 && e.end === e.begin ? e.end : -1;
  }
  get placeholder() {
    return this.inputElement.dataset.placeholder || "";
  }
  set placeholder(e) {
    this.inputElement.dataset.placeholder = e;
  }
  getSelectionRange() {
    const e = window.getSelection();
    if (e === null || e.rangeCount === 0)
      return;
    const t = e.getRangeAt(0), i = this.inputElement, r = document.createRange();
    r.setStart(i, 0), r.setEnd(t.startContainer, t.startOffset);
    const s = r.toString().length, a = e.toString().length;
    return { begin: s, end: s + a };
  }
  setValueAndSelection(e, t = void 0) {
    const i = this.completionDisabled !== -1;
    this.onInput.dispatch(e);
    const r = this.inputElement;
    it(r);
    let s = 0;
    const a = t !== void 0 ? document.createRange() : void 0;
    let l = true;
    for (const d of Bw(e)) {
      l || r.appendChild(document.createElement("wbr")), l = false;
      const u = s + d.length, f = document.createTextNode(d);
      if (r.appendChild(f), a !== void 0) {
        const g = t.begin, v = t.end;
        g >= s && g <= u && a.setStart(f, g - s), v >= s && v <= u && a.setEnd(f, v - s);
      }
      s = u;
    }
    if (a !== void 0) {
      l && (a.setStart(r, 0), a.setEnd(r, 0));
      const d = window.getSelection();
      d !== null && (d.removeAllRanges(), d.addRange(a));
    }
    this.completionDisabled = i && t !== void 0 && t.end === t.begin ? t.end : -1;
  }
  shouldAttemptCompletion() {
    const e = this.inputElement;
    if (document.activeElement !== e)
      return false;
    const t = this.getSelectionRange();
    return t !== void 0 && t.end === t.begin && t.end != this.completionDisabled && t.end === this.value.length;
  }
  hideCompletions() {
    this.cancelActiveCompletion(), this.clearCompletions(), this.hintElement.textContent = "";
  }
  updateHintState() {
    if (this.debouncedUpdateHintState.cancel(), this.shouldAttemptCompletion()) {
      const e = this.value;
      if (e === this.prevInputValue)
        return;
      this.hideCompletions(), this.prevInputValue = e, this.scheduleUpdateCompletions();
    } else {
      this.hideCompletions();
      return;
    }
  }
  handleDropdownClick(e) {
    let t = this.completionsVirtualList;
    if (t === void 0)
      return;
    const i = t.element;
    for (let r = e.target; r instanceof HTMLElement && r !== i; r = r.parentElement) {
      const s = r.dataset.completionIndex;
      if (s !== void 0) {
        this.selectCompletion(Number(s));
        break;
      }
    }
  }
  cycleActiveCompletion(e) {
    if (this.completionResult === null)
      return;
    let t = this.activeIndex, i = this.completionResult.completions.length;
    t === -1 ? e > 0 ? t = 0 : t = i - 1 : t = (t + e + i) % i, this.setActiveIndex(t);
  }
  shouldShowDropdown() {
    return this.completionResult === null || !this.hasFocus ? false : this.hasResultForDropdown;
  }
  updateDropdownStyle() {
    const e = this.completionsVirtualList, t = this.element;
    e !== void 0 && OU(e.element, t, { horizontal: false }), this.dropdownStyleStale = false;
  }
  updateDropdown() {
    let e = this.completionsVirtualList;
    if (this.shouldShowDropdown()) {
      if (this.dropdownContentsStale) {
        e !== void 0 && e.dispose();
        const r = this.completionResult;
        var t = r.makeElement;
        const s = t === void 0 ? $U : t;
        e = this.completionsVirtualList = new Py({
          source: {
            length: r.completions.length,
            render: (a) => {
              const l = r.completions[a], d = s.call(r, l);
              return d.classList.add("neuroglancer-multiline-autocomplete-completion"), d.dataset.completionIndex = `${a}`, this.activeIndex === a && d.classList.add(eg2), d;
            }
          },
          selectedIndex: this.activeIndex === -1 ? void 0 : this.activeIndex
        }), e.element.classList.add("neuroglancer-multiline-autocomplete-dropdown"), e.element.addEventListener("mousedown", (a) => {
          this.inputElement.focus(), a.preventDefault();
        }), e.element.addEventListener("mouseup", this.handleDropdownClick.bind(this)), this.element.appendChild(e.element), this.dropdownContentsStale = false;
      }
      this.dropdownStyleStale && this.updateDropdownStyle(), this.completionsVisible || (this.completionsVisible = true);
      const i = this.activeIndex;
      i !== -1 && this.completionsVirtualList.scrollItemIntoView(i);
    } else
      this.completionsVisible && (e !== void 0 && (e.dispose(), this.completionsVirtualList = void 0, this.dropdownContentsStale = true), this.completionsVisible = false);
  }
  setCompletions(e) {
    this.clearCompletions();
    let t = e.completions;
    if (t.length === 0)
      return;
    const i = this.prevInputValue;
    if (i !== void 0) {
      if (this.completionResult = e, t.length === 1) {
        let r = t[0];
        e.showSingleResult ? this.hasResultForDropdown = true : r.value.startsWith(i) ? this.hasResultForDropdown = false : this.hasResultForDropdown = true, e.selectSingleResult ? this.setActiveIndex(0) : this.setHintValue(this.getCompletedValueByIndex(0));
      } else {
        this.hasResultForDropdown = true;
        let r = VU(function* () {
          for (let a of e.completions)
            yield a.value;
        }()), s = this.getCompletedValue(r);
        s.startsWith(i) && (this.commonPrefix = s, this.setHintValue(s));
      }
      this.updateDropdown();
    }
  }
  setHintValue(e) {
    const t = this.prevInputValue;
    if (t === void 0)
      return;
    (e === t || !e.startsWith(t)) && (e = ""), e = e.substring(t.length);
    const i = this.hintElement;
    it(i);
    let r = true;
    for (const s of Bw(e)) {
      r || i.appendChild(document.createElement("wbr")), r = false;
      const a = document.createTextNode(s);
      i.appendChild(a);
    }
  }
  /**
   * This sets the active completion, which causes it to be highlighted and displayed as the hint.
   * Additionally, if the user hits tab then it is chosen.
   */
  setActiveIndex(e) {
    if (!this.dropdownContentsStale) {
      let t = this.activeIndex;
      const i = this.completionsVirtualList;
      if (i !== void 0) {
        if (t !== -1) {
          const r = i.getItemElement(t);
          r !== void 0 && r.classList.remove(eg2);
        }
        if (e !== -1) {
          let r = i.getItemElement(e);
          r !== void 0 && r.classList.add(eg2), i.scrollItemIntoView(e);
        }
      }
    }
    e !== -1 && this.setHintValue(this.getCompletedValueByIndex(e)), this.activeIndex = e;
  }
  getCompletedValueByIndex(e) {
    return this.getCompletedValue(this.completionResult.completions[e].value);
  }
  getCompletedValue(e) {
    let t = this.completionResult, i = this.prevInputValue;
    return i === void 0 ? "" : i.substring(0, t.offset) + e;
  }
  moveCaretToBeginningOfInput() {
    const e = document.createRange(), t = this.inputElement;
    e.setStart(t, 0), e.setEnd(t, 0);
    const i = window.getSelection();
    i !== null && (i.removeAllRanges(), i.addRange(e), this.debouncedUpdateHintState());
  }
  moveCaretToEndOfInput() {
    const e = document.createRange(), t = this.inputElement, i = t.childNodes, r = i[i.length - 1];
    r === void 0 ? (e.setStart(t, 0), e.setEnd(t, 0)) : (e.setStartAfter(r), e.setEndAfter(r));
    const s = window.getSelection();
    s !== null && (s.removeAllRanges(), s.addRange(e), this.debouncedUpdateHintState());
  }
  selectActiveCompletion(e) {
    let t = this.activeIndex;
    if (t === -1) {
      if (!e)
        return false;
      let r = this.completionResult;
      if (r !== null && r.completions.length === 1)
        t = 0;
      else {
        let s = this.commonPrefix;
        return s.length > this.value.length ? (this.value = s, this.moveCaretToEndOfInput(), true) : false;
      }
    }
    let i = this.getCompletedValueByIndex(t);
    return this.value === i ? false : (this.value = i, this.moveCaretToEndOfInput(), true);
  }
  selectCompletion(e) {
    this.value = this.getCompletedValueByIndex(e), this.moveCaretToEndOfInput();
  }
  /**
   * Called when user presses escape.  Does nothing here, but may be overridden in a subclass.
   */
  cancel() {
    return false;
  }
  cancelActiveCompletion() {
    this.prevInputValue = void 0;
    const e = this.activeCompletionCancellationToken;
    e !== void 0 && e.cancel(), this.activeCompletionCancellationToken = void 0, this.activeCompletionPromise = null;
  }
  clearCompletions() {
    if (this.completionResult !== null) {
      this.activeIndex = -1, this.completionResult = null, this.dropdownContentsStale = true, this.dropdownStyleStale = true, this.commonPrefix = "";
      const e = this.completionsVirtualList;
      e !== void 0 && (e.dispose(), this.completionsVirtualList = void 0), this.updateDropdown();
    }
  }
  get value() {
    return this.inputElement.textContent || "";
  }
  set value(e) {
    e !== this.value && (this.completionDisabled = -1, this.setValueAndSelection(e), this.debouncedUpdateHintState());
  }
  disposed() {
    const e = this.completionsVirtualList;
    e !== void 0 && e.dispose(), Ft(this.element), this.cancelActiveCompletion(), super.disposed();
  }
};
var Kr = class extends Z {
  constructor(e = new Kt(Kt.VISIBLE)) {
    super(), this.visibility = e, this.element = document.createElement("div"), this.element.classList.add("neuroglancer-tab-content");
  }
  get visible() {
    return this.visibility.visible;
  }
  disposed() {
    Ft(this.element), super.disposed();
  }
};
var YU = class extends Z {
  constructor() {
    super(...arguments), this.changed = new Ee(), this.options = new de(), this.optionsChanged = new Ee(), this.selectedValue = void 0, this.defaultValue = void 0, this.ready_ = true;
  }
  get value() {
    const e = this.selectedValue;
    return e !== void 0 ? e : this.defaultValue;
  }
  set default(e) {
    this.defaultValue !== e && (this.defaultValue = e, this.changed.dispatch());
  }
  get default() {
    return this.defaultValue;
  }
  set value(e) {
    e !== void 0 && this.ready_ && !this.options.has(e) && (e = void 0), this.selectedValue !== e && (this.selectedValue = e, this.changed.dispatch());
  }
  get validValue() {
    const e = this.selectedValue;
    return e === void 0 || !this.options.has(e) ? this.defaultValue : e;
  }
  add(e, t) {
    const i = this.options;
    if (i.has(e))
      throw new Error(`Option already defined: ${se(e)}.`);
    i.set(e, t), this.optionsChanged.dispatch(), this.defaultValue === void 0 && (this.default = e);
  }
  toJSON() {
    const e = this.value, t = this.defaultValue;
    if (e !== t)
      return e;
  }
  reset() {
    this.value = void 0;
  }
  /**
   * When `ready` is `false`, the selected `value` may be set to an unknown option.
   */
  get ready() {
    return this.ready_;
  }
  set ready(e) {
    e !== this.ready_ && (this.ready_ = e, e && (this.value = this.value), this.changed.dispatch());
  }
  restoreState(e) {
    typeof e != "string" && (e = void 0), this.value = e;
  }
};
var qU = class extends Z {
  constructor(e, t, i = new Kt(Kt.VISIBLE), r = false) {
    super(), this.getter = e, this.selected = t, this.visibility = i, this.invalidateByDefault = r, this.element = document.createElement("div"), this.tabs = new de(), this.tabVisibilityChanged = new ot(), this.debouncedUpdateSelectedTab = this.registerCancellable(Ct(() => this.updateSelectedTab()));
    const s = this.element;
    s.className = "neuroglancer-stack-view", this.registerDisposer(i.changed.add(this.debouncedUpdateSelectedTab)), this.registerDisposer(t.changed.add(this.debouncedUpdateSelectedTab)), this.updateSelectedTab();
  }
  get visible() {
    return this.visibility.visible;
  }
  flush() {
    this.debouncedUpdateSelectedTab.flush();
  }
  invalidate(e) {
    const t = this.tabs, i = t.get(e);
    i !== void 0 && (i.dispose(), t.delete(e), e === this.displayedTab && (this.displayedTab = void 0, this.debouncedUpdateSelectedTab()));
  }
  hideTab(e) {
    const t = this.tabs.get(e);
    t !== void 0 && (t.visibility.value = Kt.IGNORED, t.element.style.display = "none"), this.tabVisibilityChanged.dispatch(e, false);
  }
  showTab(e) {
    const t = this.tabs;
    let i = t.get(e);
    i === void 0 && (i = this.getter(e), this.element.appendChild(i.element), t.set(e, i)), i.element.style.display = "", i.visibility.value = Kt.VISIBLE, this.tabVisibilityChanged.dispatch(e, true);
  }
  updateSelectedTab() {
    const e = this.displayedTab, t = this.visible ? this.selected.value : void 0;
    t === e && (t === void 0 || this.tabs.has(t)) || (e !== void 0 && this.hideTab(e), this.invalidateByDefault && this.invalidateAll(), this.displayedTab = t, t !== void 0 && this.showTab(t));
  }
  invalidateAll(e = void 0) {
    const t = this.tabs;
    for (const r of t) {
      var i = ce(r, 2);
      const s = i[0], a = i[1];
      e !== void 0 && e(s) || (t.delete(s), a.dispose());
    }
    this.debouncedUpdateSelectedTab();
  }
  disposed() {
    this.invalidateAll(), Ft(this.element), super.disposed();
  }
};
var KU = class extends YU {
};
function ZU(n, e) {
  const t = "neuroglancer-selected-tab-label";
  e ? n.classList.add(t) : n.classList.remove(t);
}
var XU = class extends Z {
  constructor(e, t = new Kt(Kt.VISIBLE)) {
    super(), this.visibility = t, this.element = document.createElement("div"), this.tabBar = document.createElement("div"), this.tabLabels = new de(), this.tabsGeneration = -1, this.debouncedUpdateView = this.registerCancellable(Ct(() => this.updateTabs())), this.tabs = e.tabs, this.selectedTab = e.selectedTab, this.handleTabElement = e.handleTabElement;
    const i = this.element, r = this.tabBar;
    i.className = "neuroglancer-tab-view", r.className = "neuroglancer-tab-view-bar", i.appendChild(r), this.registerDisposer(t.changed.add(this.debouncedUpdateView));
    const s = this.stack = this.registerDisposer(new qU(e.makeTab, e.selectedTab, this.visibility));
    i.appendChild(s.element), this.registerDisposer(e.tabs.changed.add(this.debouncedUpdateView)), this.registerDisposer(e.selectedTab.changed.add(() => this.updateTabLabelStyles())), this.updateTabs();
  }
  get visible() {
    return this.visibility.visible;
  }
  updateTabLabelStyles() {
    const e = this.selectedTab.value;
    for (const i of this.tabLabels) {
      var t = ce(i, 2);
      const r = t[0], s = t[1];
      ZU(s, r === e);
    }
  }
  updateTabs() {
    this.tabsGeneration !== this.tabs.changed.count && (this.destroyTabs(), this.visible && this.makeTabs());
  }
  destroyTabs() {
    if (this.tabsGeneration !== -1) {
      if (this.tabLabels.clear(), !this.visible)
        this.stack.invalidateAll();
      else {
        const e = this.tabs.value;
        this.stack.invalidateAll((t) => e.find(({ id: i }) => i === t) !== void 0);
      }
      it(this.tabBar), this.tabsGeneration = -1;
    }
  }
  makeTabs() {
    const e = this.tabBar, t = this.tabLabels, i = this.handleTabElement;
    for (const r of this.tabs.value) {
      const s = r.id, a = r.label, l = document.createElement("div");
      l.classList.add("neuroglancer-tab-label"), l.textContent = a, l.addEventListener("click", () => {
        this.selectedTab.value = s;
      }), i !== void 0 && i(s, l), t.set(s, l), e.appendChild(l);
    }
    this.updateTabLabelStyles(), this.tabsGeneration = this.tabs.changed.count;
  }
  disposed() {
    it(this.tabBar), this.tabLabels.clear(), Ft(this.element), super.disposed();
  }
};
var QU = class extends JU {
  constructor(e) {
    const t = e.source.layer.manager, i = (s, a) => t.dataSourceProviderRegistry.completeUrl({ url: s, chunkManager: t.chunkManager, cancellationToken: a }).then((l) => ({
      completions: l.completions,
      makeElement: WU,
      offset: l.offset,
      showSingleResult: true
    }));
    super({ completer: i, delay: 0 }), this.placeholder = "Data source URL", this.dataSourceView = e, this.element.classList.add("neuroglancer-layer-data-source-url-input"), this.dirty = new gt(false);
    const r = (s) => {
      s !== this.dataSourceView.source.spec.url && (this.dirty.value = true);
    };
    r(""), this.onInput.add(r);
  }
  cancel() {
    return this.value = this.dataSourceView.source.spec.url, this.dirty.value = false, this.inputElement.blur(), true;
  }
};
var aI = class extends Z {
  constructor(e) {
    super(), this.model = e, this.element = document.createElement("ul"), this.generation = -1, this.element.classList.add("neuroglancer-layer-data-sources-source-messages");
    const t = this.registerCancellable(Ct(() => this.updateView()));
    this.registerDisposer(e.changed.add(t)), this.registerDisposer(() => Ft(this.element)), this.updateView();
  }
  updateView() {
    const e = this.model, t = e.changed.count;
    if (t === this.generation)
      return;
    this.generation = t;
    const i = this.element;
    it(i);
    const r = new je();
    for (const s of e) {
      const a = `${s.severity} ${s.message}`;
      if (r.has(a))
        continue;
      r.add(a);
      const l = document.createElement("li");
      i.appendChild(l), l.classList.add("neuroglancer-message"), l.classList.add(`neuroglancer-message-${cr[s.severity]}`), l.textContent = s.message;
    }
  }
};
var ez = class extends Z {
  constructor(e, t) {
    super(), this.loadedSubsource = t, this.element = document.createElement("div");
    const i = this.element;
    i.classList.add("neuroglancer-layer-data-source-subsource");
    const r = document.createElement("label"), s = document.createElement("span"), a = () => {
      r.dataset.isActive = (t.activated !== void 0 || !t.enabled).toString();
    };
    a(), this.registerDisposer(t.isActiveChanged.add(a)), this.registerDisposer(e.enabledSubsourcesChanged.add(a));
    const l = this.registerDisposer(new Rs({
      get value() {
        return t.enabled;
      },
      set value(w) {
        t.enabled = w, e.enableDefaultSubsources = false, e.enabledSubsourcesChanged.dispatch();
      },
      changed: e.enabledSubsourcesChanged
    }));
    r.classList.add("neuroglancer-layer-data-sources-info-line"), r.appendChild(l.element);
    const d = document.createElement("span");
    d.classList.add("neuroglancer-layer-data-sources-source-id");
    const u = t.subsourceEntry.id;
    u !== "default" && (d.textContent = u), r.appendChild(d), s.classList.add("neuroglancer-layer-data-sources-source-type");
    const f = this.registerDisposer(new aI(this.loadedSubsource.messages));
    i.appendChild(r), r.appendChild(s), i.appendChild(f.element);
    let g = "";
    const v = t.subsourceEntry.subsource, y = v.volume;
    if (y instanceof _s)
      g = `${J[y.dataType].toLowerCase()} volume`;
    else if (v.mesh instanceof Zc)
      g = "meshes (single-res.)";
    else if (v.mesh instanceof Qh)
      g = "meshes (multi-res.)";
    else if (v.mesh instanceof ef)
      g = "skeletons";
    else if (v.segmentPropertyMap !== void 0)
      g = "segment property map";
    else if (v.local !== void 0)
      switch (v.local) {
        case Gr.annotations:
          g = "Local annotations";
          break;
        case Gr.equivalences:
          g = "local segmentation graph";
          break;
      }
    else
      v.staticAnnotations !== void 0 ? g = "default annotations" : v.annotation !== void 0 ? g = "annotations" : v.singleMesh !== void 0 ? g = "single mesh" : v.segmentationGraph !== void 0 && (g = "segmentation graph");
    s.textContent = g;
  }
};
var tz = class extends Z {
  constructor(e) {
    super(), this.source = e, this.element = document.createElement("div");
    const t = this.element, i = document.createElement("label");
    i.classList.add("neuroglancer-layer-data-sources-source-default"), i.appendChild(this.registerDisposer(new Rs({
      changed: e.enabledSubsourcesChanged,
      get value() {
        return e.enableDefaultSubsources;
      },
      set value(s) {
        if (e.enableDefaultSubsources !== s) {
          if (e.enableDefaultSubsources = s, s)
            for (const a of e.subsources)
              a.enabled = a.subsourceEntry.default;
          e.enabledSubsourcesChanged.dispatch();
        }
      }
    })).element), i.appendChild(document.createTextNode("Enable default subsource set")), i.title = "Enable the default set of subsources for this data source.", t.appendChild(i);
    for (const s of e.subsources)
      t.appendChild(this.registerDisposer(new ez(e, s)).element);
    const r = e.transform;
    if (r.mutableSourceRank || r.value.sourceRank !== 0) {
      const s = this.registerDisposer(new _U(e.transform, e.layer.localCoordinateSpaceCombiner, e.layer.manager.root.coordinateSpaceCombiner));
      this.element.appendChild(s.element);
    }
    this.registerDisposer(() => Ft(this.element));
  }
};
var nz = class extends Z {
  constructor(e, t) {
    super(), this.tab = e, this.source = t, this.element = document.createElement("div"), this.seenGeneration = 0, this.generation = -1;
    const i = this.urlInput = this.registerDisposer(new QU(this)), r = (a, l) => {
      const d = this.source, u = d.spec, f = this.source.layer;
      if (a = f.manager.dataSourceProviderRegistry.normalizeUrl({ url: a }), a !== i.value && (i.disableCompletion(), i.setValueAndSelection(a, { begin: a.length, end: a.length })), i.dirty.value = false, a && a === u.url) {
        l && e.detectedLayerConstructor !== void 0 && oI(d.layer);
        return;
      }
      if (f instanceof Hr)
        try {
          const g = f.manager.dataSourceProviderRegistry.suggestLayerName(a);
          iL(f.managedLayer, g);
        } catch {
        }
      d.spec = RZr(RZr({}, u), { url: a });
    };
    i.onCommit.add(r);
    const s = this.element;
    s.classList.add("neuroglancer-layer-data-source"), s.appendChild(i.element), s.appendChild(this.registerDisposer(new aI(t.messages)).element), this.updateView();
  }
  updateView() {
    const e = this.source.changed.count;
    if (e === this.generation)
      return;
    this.generation = e, this.urlInput.value = this.source.spec.url, this.urlInput.dirty.value = false;
    const t = this.source.loadState;
    let i = this.loadedView;
    if (i !== void 0) {
      if (i.source === t)
        return;
      i.dispose(), i = this.loadedView = void 0;
    }
    t instanceof fy && (i = this.loadedView = new tz(t), this.element.appendChild(i.element));
  }
  disposed() {
    const e = this.loadedView;
    e !== void 0 && e.dispose(), Ft(this.element), super.disposed();
  }
};
function oI(n) {
  if (n instanceof Hr) {
    const e = n.detectedLayerConstructor;
    if (e !== void 0)
      return $y(n.managedLayer, e), true;
  }
  return false;
}
var iz = class extends Kr {
  constructor(e) {
    super(), this.layer = e, this.generation = -1, this.sourceViews = new de(), this.addDataSourceIcon = sI({ title: "Add additional data source" }), this.layerTypeDetection = document.createElement("div"), this.layerTypeElement = document.createElement("span"), this.dataSourcesContainer = document.createElement("div"), this.detectedLayerConstructor = void 0;
    const t = this.element, i = this.dataSourcesContainer;
    t.classList.add("neuroglancer-layer-data-sources-tab"), i.classList.add("neuroglancer-layer-data-sources-container");
    const r = this.addDataSourceIcon;
    if (r.style.alignSelf = "start", r.addEventListener("click", () => {
      const a = this.layer.addDataSource(void 0);
      this.updateView();
      const l = this.sourceViews.get(a);
      l !== void 0 && l.urlInput.inputElement.focus();
    }), t.appendChild(this.dataSourcesContainer), e instanceof Hr) {
      const a = this.layerTypeDetection, l = this.layerTypeElement;
      a.style.display = "none", l.classList.add("neuroglancer-layer-data-sources-tab-type-detection-type"), a.appendChild(document.createTextNode("Create as ")), a.appendChild(l), a.appendChild(document.createTextNode(" layer")), t.appendChild(a), a.classList.add("neuroglancer-layer-data-sources-tab-type-detection"), a.addEventListener("click", () => {
        oI(e);
      });
    }
    const s = this.reRender = Ct(() => this.updateView());
    this.registerDisposer(e.dataSourcesChanged.add(s)), this.registerDisposer(this.visibility.changed.add(s)), this.updateView();
  }
  updateLayerTypeDetection() {
    const e = (() => {
      const i = this.layer;
      if (!(i instanceof Hr))
        return;
      const r = i.detectedLayerConstructor;
      if (r !== void 0) {
        for (const s of this.sourceViews.values())
          if (s.urlInput.dirty.value)
            return;
        return r;
      }
    })();
    if (e === this.detectedLayerConstructor)
      return;
    const t = this.layerTypeDetection;
    if (this.detectedLayerConstructor = e, e !== void 0) {
      const i = this.layerTypeElement;
      i.textContent = e.type, t.title = `Click here or press enter in the data source URL input box to create as ${e.type} layer`, t.style.display = "";
    } else
      t.style.display = "none";
  }
  disposed() {
    const e = this.sourceViews;
    for (const t of e.values())
      t.dispose();
    e.clear(), super.disposed();
  }
  updateView() {
    if (!this.visible)
      return;
    const e = this.layer.dataSourcesChanged.count;
    if (e !== this.generation) {
      this.generation = e;
      const i = Date.now(), r = this.sourceViews, s = this.layer;
      function* a() {
        let l = true;
        const d = s.dataSources;
        for (const u of d) {
          let f = r.get(u);
          f === void 0 && (f = new nz(this, u), f.registerDisposer(f.urlInput.dirty.changed.add(this.reRender)), r.set(u, f)), f.seenGeneration = i, f.updateView();
          const g = u.spec.url;
          d.length === 1 && g === "" && setTimeout(() => {
            f.urlInput.inputElement.focus();
          }, 0), l = u.spec.url.length === 0, yield f.element;
        }
        l || (yield this.addDataSourceIcon);
      }
      ar(this.dataSourcesContainer, a.call(this));
      for (const l of r) {
        var t = ce(l, 2);
        const d = t[0], u = t[1];
        u.seenGeneration !== i && (u.dispose(), r.delete(d));
      }
    }
    this.updateLayerTypeDetection();
  }
};
var nu = "tab";
var Fw = "tabs";
var Uw = "panels";
var rz = RZr(RZr({}, Ca), { row: 0 });
var lI = RZr(RZr({}, Ca), { visible: true, row: 0 });
var Lc = class _Lc extends Z {
  constructor(e) {
    super(), this.panels = e, this.layer = this.panels.layer, this.location = new Ns(lI), this.tabsChanged = new ot(), this.selectedTab = new gt(void 0), this.tabs = [];
  }
  initialize() {
    const e = this.panels;
    this.tabsChanged.add(e.specificationChanged.dispatch), this.selectedTab.changed.add(e.specificationChanged.dispatch), this.location.changed.add(() => {
      var t;
      e.specificationChanged.dispatch();
      const i = this.layer, r = i.manager.root.selectedLayer;
      if (((t = r.layer) === null || t === void 0 ? void 0 : t.layer) !== i || this !== i.panels.panels[0])
        return;
      const s = this.location.value;
      r.location.value !== s && (r.location.value = s, r.location.locationChanged.dispatch());
    }), this.location.locationChanged.add(() => {
      this.location.visible || this !== this.panels.panels[0] && this.panels.removePanel(this);
    });
  }
  normalizeTabs() {
    const e = this.tabs;
    if (e.length === 0) {
      this.selectedTab.value = void 0;
      return;
    }
    const t = this.layer.tabs.options, i = (a) => {
      var l;
      return (l = t.get(a).order) !== null && l !== void 0 ? l : 0;
    };
    e.sort((a, l) => i(a) - i(l));
    const r = this.selectedTab, s = r.value;
    (s === void 0 || !e.includes(s)) && (r.value = e[0]);
  }
  pin() {
    var e;
    const t = this.layer, i = t.manager.root.selectedLayer;
    if (((e = i.layer) === null || e === void 0 ? void 0 : e.layer) !== t || this !== t.panels.panels[0] || this.tabs.length === 0)
      return;
    const r = this.panels, s = t.registerDisposer(new _Lc(r));
    r.panels.splice(0, 1, s), r.panels.push(this), r.updateTabs(), s.initialize(), i.layerManager.layersChanged.dispatch(), this.panels.specificationChanged.dispatch();
  }
  unpin() {
    var e;
    const t = this.panels, i = t.panels.indexOf(this);
    if (i === -1 || i === 0)
      return;
    const r = this.layer, s = r.manager.root.selectedLayer, a = (e = s.layer) === null || e === void 0 ? void 0 : e.layer;
    s.visible && a != null && a != r && a.panels.panels[0].pin(), t.panels.splice(i, 1);
    var l = t.panels.splice(0, 1, this), d = ce(l, 1);
    const u = d[0];
    if (this.explicitTabs === void 0)
      r.unregisterDisposer(u);
    else {
      t.panels.push(u);
      for (let f = 1, g = t.panels.length; f < g; ++f) {
        const v = t.panels[f];
        v.explicitTabs === void 0 && (v.explicitTabs = new je(v.tabs));
      }
    }
    this.explicitTabs = void 0, t.updateTabs(), s.layer = r.managedLayer, s.location.value = this.location.value, s.location.locationChanged.dispatch(), s.layerManager.layersChanged.dispatch(), this.panels.specificationChanged.dispatch();
  }
  splitOffTab(e, t) {
    if (!this.tabs.includes(e))
      return;
    const i = this.panels;
    {
      const a = this.explicitTabs;
      a !== void 0 && a.delete(e);
    }
    const r = this.layer, s = r.registerDisposer(new _Lc(i));
    s.location.value = t, s.explicitTabs = new je([e]), i.panels.splice(1, 0, s), i.updateTabs(), s.initialize(), r.manager.root.layerManager.layersChanged.dispatch(), i.specificationChanged.dispatch();
  }
  moveTabTo(e, t) {
    if (!this.tabs.includes(e))
      return;
    {
      const r = this.explicitTabs;
      r !== void 0 && r.delete(e);
    }
    {
      const r = t.explicitTabs;
      r !== void 0 && r.add(e);
    }
    const i = this.panels;
    i.updateTabs(), t.selectedTab.value = e, i.specificationChanged.dispatch();
  }
  mergeInto(e) {
    const t = e.explicitTabs;
    if (t !== void 0)
      for (const r of this.tabs)
        t.add(r);
    this.panels.removePanel(this);
  }
};
var sz = class {
  constructor(e) {
    this.layer = e, this.specificationChanged = new ot(), this.updating = false, this.panels = [e.registerDisposer(new Lc(this))];
  }
  restoreState(e) {
    const t = this.panels;
    t[0].selectedTab.value = Ce(e, nu, Le);
    const i = this.layer, r = i.tabs, s = new je(r.options.keys());
    Ce(e, Uw, (a) => Je(a, (l) => {
      pe(l);
      const d = new Lc(this);
      d.location.restoreState(l), d.location.visible && (d.selectedTab.value = Ce(l, nu, Le), d.explicitTabs = Ce(l, Fw, (u) => {
        const f = new je();
        for (const g of Ci(u))
          s.has(g) && (s.delete(g), f.add(g));
        return f;
      }), d.explicitTabs === void 0 ? (d.tabs = De(s), s.clear()) : d.tabs = De(d.explicitTabs), d.tabs.length !== 0 && (d.normalizeTabs(), i.registerDisposer(d), d.initialize(), t.push(d)));
    })), t[0].tabs = De(s), t[0].normalizeTabs(), this.panels[0].initialize();
  }
  removePanel(e) {
    if (this.updating)
      return;
    const t = this.panels.indexOf(e);
    this.panels.splice(t, 1), this.layer.unregisterDisposer(e), this.updateTabs();
  }
  updateTabs() {
    var e;
    const t = this.layer, i = t.tabs, r = new je(i.options.keys()), s = this.panels;
    this.updating = true;
    const a = (l) => {
      const d = l.tabs;
      if (l.explicitTabs === void 0)
        l.tabs = De(r), r.clear();
      else {
        l.tabs = De(l.explicitTabs);
        for (const u of l.tabs)
          r.delete(u);
      }
      Fe(d, l.tabs) || (l.normalizeTabs(), l.tabsChanged.dispatch());
    };
    for (let l = 1; l < s.length; ) {
      const d = s[l];
      if (d.location.visible && (a(d), d.tabs.length !== 0)) {
        ++l;
        continue;
      }
      s.splice(l, 1), t.unregisterDisposer(d);
    }
    if (a(s[0]), s[0].tabs.length === 0) {
      const l = this.layer.manager.root.selectedLayer;
      ((e = l.layer) === null || e === void 0 ? void 0 : e.layer) === this.layer && (l.location.visible = false);
    }
    this.updating = false;
  }
  toJSON() {
    var e;
    const t = this.panels, i = {};
    if (i[nu] = t[0].selectedTab.value, t.length > 1) {
      const r = [];
      for (let s = 1, a = t.length; s < a; ++s) {
        const l = t[s], d = (e = l.location.toJSON()) !== null && e !== void 0 ? e : {};
        d[nu] = l.selectedTab.value;
        const u = l.explicitTabs;
        u !== void 0 && (d[Fw] = De(u)), r.push(d);
      }
      i[Uw] = r;
    }
    return i;
  }
};
var az = /^[A-Z]$/;
var zw = class extends Z {
  constructor(e, t) {
    super(), this.tool = e, this.inputEventMapBinder = t;
  }
  bindAction(e, t) {
    this.registerDisposer(be(window, e, t));
  }
  bindInputEventMap(e) {
    this.inputEventMapBinder(e, this);
  }
  cancel() {
    this == this.tool.layer.manager.root.toolBinder.activeTool_ && this.tool.layer.manager.root.toolBinder.deactivate_();
  }
};
var Uo = class extends Z {
  constructor(e, t = false) {
    super(), this.layer = e, this.toggle = t, this.changed = new ot(), this.keyBinding = void 0;
  }
  get mouseState() {
    return this.layer.manager.root.layerSelectedValues.mouseState;
  }
  unbind() {
    const e = this.layer, t = this.keyBinding;
    t !== void 0 && e.toolBinder.set(t, void 0);
  }
};
var cI = class extends Z {
  constructor(e) {
    super(), this.layer = e, this.changed = new ot();
  }
  get mouseState() {
    return this.layer.manager.root.layerSelectedValues.mouseState;
  }
  deactivate() {
  }
  unbind() {
    const e = this.layer;
    e.tool.value === this && (e.tool.value = void 0);
  }
};
function Gw(n, e) {
  var t;
  if (e === void 0)
    return;
  typeof e == "string" && (e = { type: e }), pe(e);
  const i = K(e, "type", Le);
  let r = (t = mm.get(n.constructor)) === null || t === void 0 ? void 0 : t.get(i);
  if (r === void 0 && (r = lz.get(i)), r === void 0)
    throw new Error(`Invalid tool type: ${se(e)}.`);
  return r(n, e);
}
function oz(n, e) {
  if (e === void 0)
    return;
  typeof e == "string" && (e = { type: e }), pe(e);
  const t = K(e, "type", Le), i = dI.get(t);
  if (i === void 0)
    throw new Error(`Invalid tool type: ${se(e)}.`);
  return i(n, e);
}
var dI = new de();
var lz = new de();
var mm = new de();
function nd(n, e) {
  dI.set(n, e);
}
function Dc(n, e, t) {
  let i = mm.get(n);
  i === void 0 && (i = new de(), mm.set(n, i)), i.set(e, t);
}
var cz = class extends Z {
  constructor(e) {
    super(), this.layer = e, this.changed = new ot();
  }
  get value() {
    return this.value_;
  }
  set value(e) {
    e !== this.value_ && (this.unregister(), e !== void 0 && (e.changed.add(this.changed.dispatch), this.value_ = e), this.changed.dispatch());
  }
  unregister() {
    const e = this.value_;
    e !== void 0 && (e.changed.remove(this.changed.dispatch), e.dispose(), this.value_ = void 0);
  }
  disposed() {
    this.unregister(), super.disposed();
  }
  restoreState(e) {
    this.value = oz(this.layer, e);
  }
  reset() {
    this.value = void 0;
  }
  toJSON() {
    const e = this.value_;
    if (e !== void 0)
      return e.toJSON();
  }
};
var dz = class extends Z {
  constructor(e) {
    super(), this.inputEventMapBinder = e, this.bindings = new de(), this.changed = new ot(), this.debounceDeactivate = this.registerCancellable(lt(() => this.deactivate_(), 100)), this.debounceReactivate = this.registerCancellable(lt(() => this.reactivateQueuedTool(), 100));
  }
  get(e) {
    return this.bindings.get(e);
  }
  set(e, t) {
    const i = this.bindings, r = i.get(e);
    if (r !== void 0) {
      r.keyBinding = void 0, i.delete(e);
      const s = r.layer.toolBinder;
      s.bindings.delete(e), s.jsonToKey.delete(se(r.toJSON())), this.destroyTool(r), s.changed.dispatch();
    }
    if (t !== void 0) {
      const s = t.layer.toolBinder, a = se(t.toJSON()), l = s.jsonToKey.get(a);
      if (l !== void 0) {
        const d = s.bindings.get(l);
        d.keyBinding = void 0, i.delete(l), s.bindings.delete(l), s.jsonToKey.delete(a), this.destroyTool(d);
      }
      s.bindings.set(e, t), t.keyBinding = e, s.jsonToKey.set(a, e), i.set(e, t), s.changed.dispatch();
    }
    this.changed.dispatch();
  }
  activate(e) {
    const t = this.get(e);
    if (t === void 0) {
      this.deactivate_();
      return;
    }
    this.debounceDeactivate.cancel(), this.debounceReactivate.cancel();
    const i = this.activeTool_;
    if (t === (i == null ? void 0 : i.tool)) {
      t.toggle && this.deactivate_();
      return;
    } else
      i !== void 0 && (i.tool.toggle && !t.toggle && (this.queuedTool = i.tool), this.deactivate_());
    const r = new zw(t, this.inputEventMapBinder);
    if (this.activeTool_ = r, !t.toggle) {
      const s = `Key${e}`;
      r.registerEventListener(window, "keyup", (a) => {
        a.code === s && (this.debounceDeactivate(), this.debounceReactivate());
      }), r.registerEventListener(window, "blur", () => {
        this.debounceDeactivate(), this.debounceReactivate();
      });
    }
    return t.activate(r), t;
  }
  reactivateQueuedTool() {
    if (this.queuedTool) {
      const e = new zw(this.queuedTool, this.inputEventMapBinder);
      this.activeTool_ = e, this.queuedTool.activate(e), this.queuedTool = void 0;
    }
  }
  destroyTool(e) {
    var t;
    this.queuedTool === e && (this.queuedTool = void 0), ((t = this.activeTool_) === null || t === void 0 ? void 0 : t.tool) === e && this.deactivate_(), e.dispose();
  }
  disposed() {
    this.deactivate_(), super.disposed();
  }
  deactivate_() {
    this.debounceDeactivate.cancel();
    const e = this.activeTool_;
    e !== void 0 && (this.activeTool_ = void 0, e.dispose());
  }
};
var uz = class {
  constructor(e) {
    this.layer = e, this.bindings = new de(), this.jsonToKey = new de(), this.changed = new ot(), e.registerDisposer(() => this.clear());
  }
  get globalBinder() {
    return this.layer.manager.root.toolBinder;
  }
  get(e) {
    return this.bindings.get(e);
  }
  set(e, t) {
    this.globalBinder.set(e, t);
  }
  setJson(e, t) {
    const i = Gw(this.layer, t);
    i !== void 0 && this.set(e, i);
  }
  removeJsonString(e) {
    const t = this.jsonToKey.get(e);
    t !== void 0 && this.set(t, void 0);
  }
  toJSON() {
    const e = this.bindings;
    if (e.size === 0)
      return;
    const t = {};
    for (const r of e) {
      var i = ce(r, 2);
      const s = i[0], a = i[1];
      t[s] = a.toJSON();
    }
    return t;
  }
  clear() {
    const e = this.globalBinder, t = this.bindings;
    if (t.size !== 0) {
      for (const r of t) {
        var i = ce(r, 2);
        const s = i[0], a = i[1];
        a.keyBinding = void 0, e.bindings.delete(s), e.destroyTool(a);
      }
      t.clear(), this.jsonToKey.clear(), e.changed.dispatch(), this.changed.dispatch();
    }
  }
  reset() {
    this.clear();
  }
  restoreState(e) {
    if (e !== void 0) {
      pe(e);
      for (const i of Jc(e)) {
        var t = ce(i, 2);
        const r = t[0], s = t[1];
        if (!r.match(az))
          throw new Error(`Invalid tool key: ${se(r)}`);
        const a = Gw(this.layer, s);
        if (a === void 0)
          return;
        this.set(r, a);
      }
    }
  }
};
var uI = class extends Z {
  constructor(e, t) {
    super(), this.layer = e, this.toolJson = t, this.element = document.createElement("div"), this.toolJsonString = se(this.toolJson);
    const i = this.element;
    i.classList.add("neuroglancer-tool-key-binding"), this.registerDisposer(e.toolBinder.changed.add(this.registerCancellable(Ct(() => this.updateView())))), this.updateView(), i.title = "click → bind key, dbclick → unbind", i.addEventListener("dblclick", () => {
      this.layer.toolBinder.removeJsonString(this.toolJsonString);
    }), hI(this, i, (r) => this.layer.toolBinder.setJson(r, this.toolJson));
  }
  updateView() {
    const t = this.layer.toolBinder.jsonToKey.get(this.toolJsonString);
    this.element.textContent = t ?? " ";
  }
};
function hI(n, e, t) {
  let i;
  e.addEventListener("mousedown", (r) => {
    if (r.button !== 0 || i !== void 0)
      return;
    r.preventDefault(), r.stopPropagation(), i = new Z(), n.registerDisposer(i), i.registerDisposer(new nt(false)).setText("Press A-Z to bind key"), i.registerEventListener(window, "keydown", (a) => {
      const d = a.code.match(/^Key([A-Z])$/);
      if (d === null)
        return;
      a.stopPropagation(), a.preventDefault();
      const u = d[1];
      t(u);
    }, { capture: true }), i.registerEventListener(window, "mouseup", (a) => {
      a.button !== 0 || i === void 0 || (a.preventDefault(), a.stopPropagation(), n.unregisterDisposer(i), i.dispose(), i = void 0);
    });
  }), e.addEventListener("click", (r) => {
    r.preventDefault(), r.stopPropagation();
  });
}
function tg(n, e, t) {
  const i = document.createElement("div");
  i.classList.add("neuroglancer-tool-button"), i.appendChild(n.registerDisposer(new uI(e, t.toolJson)).element);
  const r = document.createElement("div");
  return r.classList.add("neuroglancer-tool-button-label"), r.textContent = t.label, t.title && (r.title = t.title), i.appendChild(r), i;
}
function hz(n) {
  const e = n.registerDisposer(new nt(false));
  e.element.classList.add("neuroglancer-tool-status");
  const t = document.createElement("div");
  t.classList.add("neuroglancer-tool-status-content"), e.element.appendChild(t);
  const i = n.inputEventMapBinder;
  return n.inputEventMapBinder = (r, s) => {
    const a = document.createElement("div");
    a.textContent = r.describe(), a.classList.add("neuroglancer-tool-status-bindings"), e.element.appendChild(a), i(r, s);
  }, { message: e, content: t };
}
function tf(n) {
  var e = hz(n);
  const t = e.message, i = e.content, r = document.createElement("div");
  r.classList.add("neuroglancer-tool-status-header");
  const s = document.createElement("div");
  s.classList.add("neuroglancer-tool-status-header-container"), s.appendChild(r), i.appendChild(s);
  const a = document.createElement("div");
  return a.classList.add("neuroglancer-tool-status-body"), i.appendChild(a), { message: t, body: a, header: r };
}
function fz(n, e) {
  n.remove(e);
}
function pz(n, e) {
  n.add(e);
}
var fI = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiBhcmlhLWxhYmVsbGVkYnk9ImNvbnRyb2xzQWx0SWNvblRpdGxlIj4KICAgIDx0aXRsZSBpZD0iY29udHJvbHNBbHRJY29uVGl0bGUiPkNvbnRyb2xzPC90aXRsZT4KICAgIDxjaXJjbGUgY3g9IjkiIGN5PSI2IiByPSIyIi8+CiAgICA8cGF0aCBkPSJNNCA2SDciLz4KICAgIDxwYXRoIGQ9Ik0xMSA2SDIwIi8+CiAgICA8Y2lyY2xlIGN4PSI5IiBjeT0iMTgiIHI9IjIiLz4KICAgIDxwYXRoIGQ9Ik00IDE4SDciLz4KICAgIDxwYXRoIGQ9Ik0xMSAxOEgyMCIvPgogICAgPGNpcmNsZSBjeD0iMTUiIGN5PSIxMiIgcj0iMiIvPgogICAgPHBhdGggZD0iTTQgMTJIMTMiLz4KICAgIDxwYXRoIGQ9Ik0xNyAxMkwyMCAxMiIvPgo8L3N2Zz4=";
var gz = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiBhcmlhLWxhYmVsbGVkYnk9ImxheWVyc0ljb25UaXRsZSI+CiAgICA8dGl0bGUgaWQ9ImxheWVyc0ljb25UaXRsZSI+TGF5ZXJzPC90aXRsZT4KICAgIDxwYXRoIGQ9Ik0xMiA0TDIwIDguMDAwMDRMMTIgMTJMNCA4LjAwMDA0TDEyIDRaIi8+CiAgICA8cGF0aCBkPSJNMjAgMTJMMTIgMTZMNCAxMiIvPgogICAgPHBhdGggZD0iTTIwIDE2TDEyIDIwTDQgMTYiLz4KPC9zdmc+";
var mz = "data:image/svg+xml;base64,PHN2ZyByb2xlPSJpbWciIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjI0IiBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIGFyaWEtbGFiZWxsZWRieT0ibGlzdEljb25UaXRsZSI+CiAgICA8dGl0bGUgaWQ9Imxpc3RJY29uVGl0bGUiLz4KICAgIAogICAgPHBhdGggZD0iTTEwIDdMMTggN00xMCAxMkwxOCAxMk0xMCAxN0wxOCAxNyIvPgogICAgPGxpbmUgeDE9IjciIHkxPSI3IiB4Mj0iNyIgeTI9IjciLz4KICAgIDxsaW5lIHgxPSI3IiB5MT0iMTIiIHgyPSI3IiB5Mj0iMTIiLz4KICAgIDxsaW5lIHgxPSI3IiB5MT0iMTciIHgyPSI3IiB5Mj0iMTciLz4KPC9zdmc+";
var vz = "data:image/svg+xml;base64,PHN2ZyByb2xlPSJpbWciIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjI0IiBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIGFyaWEtbGFiZWxsZWRieT0ic2V0dGluZ3NJY29uVGl0bGUiPgogICAgPHRpdGxlIGlkPSJzZXR0aW5nc0ljb25UaXRsZSI+U2V0dGluZ3M8L3RpdGxlPiAgICAKICAgIDxwYXRoIGQ9Ik01LjAzNTA2NDI5LDEyLjcwNTAzMzkgQzUuMDExODc0ODQsMTIuNDczMTY5NiA1LDEyLjIzNzk3MTYgNSwxMiBDNSwxMS43NjIwMjg0IDUuMDExODc0ODQsMTEuNTI2ODMwNCA1LjAzNTA2NDI5LDExLjI5NDk2NjEgTDMuMjA1NzcxMzcsOS4yMzIwNTA4MSBMNS4yMDU3NzEzNyw1Ljc2Nzk0OTE5IEw3LjkwNjk3MTMsNi4zMjA3MDkwNCBDOC4yODcyOTEyMyw2LjA0NjEzNDIgOC42OTYyOTI5OCw1LjgwODgyMjEyIDkuMTI4NjI1MzMsNS42MTQxMjQwMiBMMTAsMyBMMTQsMyBMMTQuODcxMzc0Nyw1LjYxNDEyNDAyIEMxNS4zMDM3MDcsNS44MDg4MjIxMiAxNS43MTI3MDg4LDYuMDQ2MTM0MiAxNi4wOTMwMjg3LDYuMzIwNzA5MDQgTDE4Ljc5NDIyODYsNS43Njc5NDkxOSBMMjAuNzk0MjI4Niw5LjIzMjA1MDgxIEwxOC45NjQ5MzU3LDExLjI5NDk2NjEgQzE4Ljk4ODEyNTIsMTEuNTI2ODMwNCAxOSwxMS43NjIwMjg0IDE5LDEyIEMxOSwxMi4yMzc5NzE2IDE4Ljk4ODEyNTIsMTIuNDczMTY5NiAxOC45NjQ5MzU3LDEyLjcwNTAzMzkgTDIwLjc5NDIyODYsMTQuNzY3OTQ5MiBMMTguNzk0MjI4NiwxOC4yMzIwNTA4IEwxNi4wOTMwMjg3LDE3LjY3OTI5MSBDMTUuNzEyNzA4OCwxNy45NTM4NjU4IDE1LjMwMzcwNywxOC4xOTExNzc5IDE0Ljg3MTM3NDcsMTguMzg1ODc2IEwxNCwyMSBMMTAsMjEgTDkuMTI4NjI1MzMsMTguMzg1ODc2IEM4LjY5NjI5Mjk4LDE4LjE5MTE3NzkgOC4yODcyOTEyMywxNy45NTM4NjU4IDcuOTA2OTcxMywxNy42NzkyOTEgTDUuMjA1NzcxMzcsMTguMjMyMDUwOCBMMy4yMDU3NzEzNywxNC43Njc5NDkyIEw1LjAzNTA2NDI5LDEyLjcwNTAzMzkgWiIvPgogICAgPGNpcmNsZSBjeD0iMTIiIGN5PSIxMiIgcj0iMSIvPgo8L3N2Zz4=";
var id = class extends Z {
};
function pI(n) {
  let e, t, i;
  return (r, s) => t !== void 0 && (e === void 0 || r === void 0 || e.generation !== r.generation) ? (e === void 0 && i.addConsumer(s), t) : (e = void 0, i = new QO(), t = n(r, i).then((a) => (e = a, i = void 0, a), (a) => {
    throw i.isCanceled && (i = void 0, t = void 0), a;
  }), t);
}
function nf(n) {
  let e = 0;
  return pI((t, i) => n(i).then((r) => ({ generation: ++e, credentials: r })));
}
var yz = class {
  constructor() {
    this.providers = new de(), this.topLevelManager = this;
  }
  register(e, t) {
    this.providers.set(e, t);
  }
  getCredentialsProvider(e, t) {
    const i = this.providers.get(e);
    if (i === void 0)
      throw new Error(`No registered credentials provider: ${se(e)}`);
    return i(t, this.topLevelManager);
  }
};
var Sz = class extends Z {
  constructor(e) {
    super(), this.base = e, this.memoize = new q1();
  }
  getCredentialsProvider(e, t) {
    return this.memoize.get({ key: e, parameters: t }, () => this.registerDisposer(this.base.getCredentialsProvider(e, t).addRef()));
  }
};
var gI = class extends Sz {
  constructor() {
    super(new yz()), this.base.topLevelManager = this;
  }
  register(e, t) {
    this.base.register(e, t);
  }
};
var bz = class extends id {
  constructor(e, t) {
    super(), this.baseProvider = e, this.anonymousCredentials = t, this.anonymous = true, this.get = pI((i) => this.anonymous && i === void 0 ? Bt.resolve({ generation: -10, credentials: this.anonymousCredentials }) : (this.anonymous = false, this.baseProvider.get(i)));
  }
};
var il = new gI();
function vi(n, e) {
  return (t) => {
    t.style.flex = n, e(t);
  };
}
function ta(n, e) {
  return (t) => {
    t.style.display = "flex", t.style.flexDirection = n;
    for (let i of e) {
      let r = t.ownerDocument.createElement("div");
      t.appendChild(r), i(r);
    }
  };
}
var Cz = et();
function mI(n, e) {
  const t = zE(Cz), i = n.globalPosition;
  var r = n.displayDimensionRenderInfo;
  const s = r.canonicalVoxelFactors, a = r.displayDimensionIndices;
  for (let l = 0; l < 3; ++l) {
    const d = a[l];
    t[12 + l] = d === -1 ? 0 : i[d], t[5 * l] = e / s[l];
  }
  return mn(t, n.viewProjectionMat, t), t;
}
var rf = class _rf extends Z {
  constructor(e) {
    super(), this.gl = e, this.vertexBuffer = this.registerDisposer(Xn.fromData(e, new Float32Array([0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1]), e.ARRAY_BUFFER, e.STATIC_DRAW));
    let t = 0.5;
    this.colorBuffer = this.registerDisposer(Xn.fromData(e, new Float32Array([1, 0, 0, t, 1, 0, 0, t, 0, 1, 0, t, 0, 1, 0, t, 0, 0, 1, t, 0, 0, 1, t]), e.ARRAY_BUFFER, e.STATIC_DRAW)), this.trivialColorShader = this.registerDisposer(wV(e));
  }
  static get(e) {
    return e.memoize.get("SliceViewPanel:AxesLineHelper", () => new _rf(e));
  }
  draw(e, t = true) {
    let i = this.trivialColorShader, r = this.gl;
    i.bind(), r.uniformMatrix4fv(i.uniform("uProjectionMatrix"), false, e);
    let s = i.attribute("aVertexPosition");
    this.vertexBuffer.bindToVertexAttrib(s, 4);
    let a = i.attribute("aColor");
    this.colorBuffer.bindToVertexAttrib(a, 4), t && (r.colorMask(false, false, false, true), r.clearColor(0, 0, 0, 0), r.clear(r.COLOR_BUFFER_BIT), r.colorMask(true, true, true, true), r.enable(r.BLEND), r.blendFunc(r.ONE_MINUS_DST_ALPHA, r.DST_ALPHA)), r.lineWidth(1), r.drawArrays(r.LINES, 0, 6), t && r.disable(r.BLEND), r.disableVertexAttribArray(s), r.disableVertexAttribArray(a);
  }
};
var wz = "perspective_view/PerspectiveView";
var vI = class {
  constructor() {
    this.renderLayers = [null], this.pickData = [null], this.values = [0, 0, 0], this.nextPickID = 1;
  }
  clear() {
    this.renderLayers.length = 1, this.pickData.length = 1, this.values.length = 3, this.nextPickID = 1;
  }
  registerUint64(e, t, i = 1, r = null) {
    return this.register(e, i, t.low, t.high, r);
  }
  register(e, t = 1, i = 0, r = 0, s = null) {
    let a = this.renderLayers, l = this.values, d = this.nextPickID;
    this.nextPickID += t;
    let u = a.length;
    a[u] = e;
    let f = u * 3;
    return l[f] = d, l[f + 1] = i, l[f + 2] = r, this.pickData[u] = s, d;
  }
  /**
   * Set the object state according to the specified pick ID.
   */
  setMouseState(e, t) {
    const i = this.renderLayers, r = this.values;
    let s = 0, a = i.length - 1;
    for (; s < a; ) {
      const v = Math.ceil(s + (a - s) / 2);
      r[v * 3] > t ? a = v - 1 : s = v;
    }
    const l = e.pickedRenderLayer = i[s], d = s * 3, u = e.pickedOffset = t - r[d];
    let f = e.pickedValue;
    f.low = r[d + 1], f.high = r[d + 2], e.pickedAnnotationId = void 0, e.pickedAnnotationLayer = void 0, e.pickedAnnotationBuffer = void 0, e.pickedAnnotationBufferBaseOffset = void 0, e.pickedAnnotationIndex = void 0, e.pickedAnnotationCount = void 0, e.pickedAnnotationType = void 0;
    const g = this.pickData[s];
    l !== null && l.updateMouseState(e, f, u, g);
  }
};
var uo = class {
  static insertAfter(e, t) {
    let i = e.next0;
    t.next0 = i, t.prev0 = e, e.next0 = t, i.prev0 = t;
  }
  static insertBefore(e, t) {
    let i = e.prev0;
    t.prev0 = i, t.next0 = e, e.prev0 = t, i.next0 = t;
  }
  static front(e) {
    let t = e.next0;
    return t === e ? null : t;
  }
  static back(e) {
    let t = e.prev0;
    return t === e ? null : t;
  }
  static pop(e) {
    let t = e.next0, i = e.prev0;
    return t.prev0 = i, i.next0 = t, e.next0 = null, e.prev0 = null, e;
  }
  static *iterator(e) {
    for (let t = e.next0; t !== e; t = t.next0)
      yield t;
  }
  static *reverseIterator(e) {
    for (let t = e.prev0; t !== e; t = t.prev0)
      yield t;
  }
  static initializeHead(e) {
    e.next0 = e.prev0 = e;
  }
};
var xz = class {
  constructor() {
    uo.initializeHead(this);
  }
};
var vm = new xz();
var Ez = window.top === window;
var Ay = lt(() => {
  if (!Ez)
    return;
  var n = document;
  const e = n.activeElement;
  if (e === null || e === document.body) {
    const t = uo.front(vm);
    t !== null && t.element.focus({ preventScroll: true });
  }
});
window.addEventListener("focus", () => {
  Ay();
}, true);
window.addEventListener("blur", () => {
  Ay();
}, true);
var sf = class extends Z {
  constructor(e) {
    super(), this.element = e, this.prev0 = null, this.next0 = null, this.lastFocusedElement = null, this.scheduleUpdateFocus = this.registerCancellable(lt(() => {
      var t = document;
      const i = t.activeElement, r = this.element;
      r.contains(i) || by(i) || (i != null && (i === this.lastFocusedElement || i.contains(r)) && this.element.focus({ preventScroll: true }), this.lastFocusedElement = null);
    }, 0)), e.tabIndex = -1, this.registerEventListener(e, "pointerdown", (t) => {
      t.target === e && (this.lastFocusedElement = null, e.focus({ preventScroll: true }));
    }), this.registerEventListener(e, "mouseenter", () => {
      this.lastFocusedElement = document.activeElement, this.scheduleUpdateFocus();
    }), this.registerEventListener(e, "mouseleave", () => {
      this.scheduleUpdateFocus.cancel();
    }), uo.insertBefore(vm, this), this.registerEventListener(e, "focus", () => {
      uo.pop(this), uo.insertAfter(vm, this);
    }), Ay();
  }
  disposed() {
    uo.pop(this), super.disposed();
  }
};
var $w = 10;
var Tz = 1e3;
var kz = 400;
var Iz = 500;
var Lz = Math.PI / 20;
var Dz = 20;
var Pz = 10;
function yI(n, e) {
  return Math.sqrt(n * n + e * e);
}
function Ww(n) {
  var e = ce(n, 2);
  let t = e[0], i = e[1];
  if (t.identifier > i.identifier) {
    var r = [t, i];
    i = r[0], t = r[1];
  }
  const s = t.clientX - i.clientX, a = t.clientY - i.clientY, l = yI(s, a), d = Math.atan2(s, a);
  return { distance: l, angle: d };
}
function Az(n, e) {
  const t = Math.PI * 2, i = Math.abs(n - e) % t;
  return Math.min(i, t - i);
}
var Rz = class extends Z {
  constructor(e, t) {
    super(), this.target = e, this.eventMap = t, this.prevTouches = new de(), this.moved = false, this.prevAngle = 0, this.rotated = false, this.prevDistance = 0, this.pinched = false, this.prevCenterX = 0, this.prevCenterY = 0, this.translated = false, this.startHold = this.registerCancellable(zh((i, r, s, a) => {
      const l = { event: i, centerX: s, centerY: a };
      this.dispatch(`touchhold${i.targetTouches.length}`, i, l, r);
    }, Tz, { leading: false, trailing: true })), this.numPriorTaps = 0, this.priorTapNumTouches = 0, this.tapStartTime = 0, this.tapEndTime = 0, this.curTapNumTouches = 0, this.registerEventListener(e, "touchstart", (i) => {
      this.handleTouchEvent(i);
    }), this.registerEventListener(e, "touchmove", (i) => {
      this.handleTouchEvent(i);
    }), this.registerEventListener(e, "touchend", (i) => {
      this.handleTouchEvent(i);
    });
  }
  dispatch(e, t, i, r = t.eventPhase) {
    Vk(e, t, r, i, this.eventMap);
  }
  handleTouchEvent(e) {
    if (e.target === this.target)
      e.preventDefault();
    else
      return;
    const t = new de(), i = this.prevTouches, r = this.prevEvent;
    let s = 0, a = 0;
    for (const C of e.targetTouches)
      t.set(C.identifier, C), s += C.clientX, a += C.clientY;
    s /= t.size, a /= t.size;
    for (const C of i.entries()) {
      var l = ce(C, 2);
      const b = l[0], E = l[1], L = t.get(b);
      if (L === void 0)
        i.delete(b);
      else {
        const R = L.clientX - E.clientX, _ = L.clientY - E.clientY;
        (Math.abs(R) >= $w || Math.abs(_) >= $w) && (this.moved = true);
      }
    }
    if (r === void 0 || r.targetTouches.length !== t.size || t.size == 0) {
      if (this.moved = false, e.type === "touchstart")
        this.startHold(e, e.eventPhase, s, a), (r === void 0 || r.targetTouches.length === 0) && (this.tapStartTime = Date.now(), this.curTapNumTouches = 0), this.curTapNumTouches = Math.max(this.curTapNumTouches, e.targetTouches.length);
      else {
        if (e.type == "touchend") {
          const C = Date.now();
          if (e.targetTouches.length === 0 && C - this.tapStartTime < kz) {
            (this.curTapNumTouches !== this.priorTapNumTouches || C - this.tapEndTime >= Iz) && (this.numPriorTaps = 0), ++this.numPriorTaps, this.tapEndTime = C, this.priorTapNumTouches = this.curTapNumTouches;
            const b = { event: e, centerX: s, centerY: a };
            this.dispatch(`touchtap${this.curTapNumTouches}x${this.numPriorTaps}`, e, b);
          }
        }
        this.startHold.cancel();
      }
      if (this.prevTouches = t, this.prevEvent = e, this.prevCenterX = s, this.prevCenterY = a, this.translated = false, t.size === 2) {
        var d = Ww(t.values());
        const C = d.distance, b = d.angle;
        this.prevDistance = C, this.prevAngle = b, this.rotated = false, this.pinched = false;
      }
      return;
    }
    if (!this.moved)
      return;
    this.tapStartTime = 0, this.startHold.cancel(), this.prevTouches = t, this.prevEvent = e;
    let u = this.prevCenterX, f = this.prevCenterY, g = this.translated;
    const v = s - u, y = a - f;
    if (g === false && yI(v, y) >= Pz && (g = this.translated = true), g === true && (v !== 0 || y !== 0)) {
      this.prevCenterX = s, this.prevCenterY = a;
      const C = { event: e, deltaX: v, deltaY: y, centerX: s, centerY: a };
      this.dispatch(`touchtranslate${t.size}`, e, C);
    }
    if (t.size === 2) {
      var w = Ww(t.values());
      const C = w.distance, b = w.angle;
      let E = this.pinched, L = this.rotated, R = this.prevDistance, _ = this.prevAngle;
      E === false && Math.abs(C - R) >= Dz && (this.pinched = E = true);
      const A = Az(b, _);
      if (L === false && A >= Lz && (this.rotated = L = true), E === true && C != R) {
        this.prevDistance = C;
        const I = { event: e, distance: C, prevDistance: R, centerX: s, centerY: a };
        this.dispatch("touchpinch", e, I);
      }
      L === true && b !== _ && (this.prevAngle = b, this.dispatch("touchrotate", e, { event: e, centerX: s, centerY: a, angle: b, prevAngle: _ }));
    }
  }
};
var Mz = 0;
var Nz = 1;
var _z = 2;
function Ju(n) {
  let e = 0;
  switch (n.deltaMode) {
    case Mz:
      e = 1 / 200;
      break;
    case Nz:
      e = 1 / 10;
      break;
    case _z:
      e = 2;
      break;
  }
  return Math.exp(n.deltaY * e);
}
var ng = _e();
var Hw = class {
  constructor() {
    this.pickIDs = new vI(), this.viewportWidth = 0, this.viewportHeight = 0, this.invTransform = et(), this.frameNumber = -1;
  }
};
var jw = class {
  constructor() {
    this.buffer = null, this.glWindowX = 0, this.glWindowY = 0;
  }
};
var Oz = 30;
var gn = 5;
var ut = 1 + gn * 2;
var Yu = (() => {
  const n = gn ** 2, e = (r, s) => (r - gn) ** 2 + (s - gn) ** 2;
  let t = new Uint32Array(ut * ut), i = 0;
  for (let r = 0; r < ut; ++r)
    for (let s = 0; s < ut; ++s)
      e(r, s) > n || (t[i++] = s * ut + r);
  return t = t.subarray(0, i), t.sort((r, s) => {
    const a = r % ut, l = (r - a) / ut, d = s % ut, u = (s - d) / ut;
    return e(a, l) - e(d, u);
  }), t;
})();
function SI(n, e, t, i, r, s, a) {
  const l = i - gn, d = r - gn;
  if (!(l >= 0 && d >= 0 && l + ut <= s && d + ut <= a))
    for (let u = 0; u < ut; ++u)
      for (let f = 0; f < ut; ++f) {
        const g = l + f, v = d + u;
        (g < 0 || v < 0 || g >= s || v >= a) && (n[e + (v * ut + g) * t] = 0);
      }
}
var bI = class extends X1 {
  constructor(e, t, i) {
    super(e, t, i.visibility), this.viewer = i, this.mouseX = -1, this.mouseY = -1, this.pickRequestPending = false, this.mouseStateForcer = () => this.blockOnPickRequest(), this.pickingData = [new Hw(), new Hw()], this.pickRequests = [new jw(), new jw()], this.pickBufferContents = new Float32Array(2 * 4 * ut * ut), this.pickTimerId = -1, this.nextPickRequestTime = 0, this.pendingPickRequestTimerId = -1, this.pendingPickRequestTimerExpired = () => {
      this.pendingPickRequestTimerId = -1, this.pickRequestPending && this.attemptToIssuePickRequest();
    }, this.inputEventMap = i.inputEventMap, t.classList.add("neuroglancer-rendered-data-panel"), t.classList.add("neuroglancer-panel"), t.classList.add("neuroglancer-noselect"), typeof NEUROGLANCER_SHOW_OBJECT_SELECTION_TOOLTIP < "u" && NEUROGLANCER_SHOW_OBJECT_SELECTION_TOOLTIP === true && (t.title = "Double click to toggle display of object under mouse pointer.  Control+rightclick to pin/unpin selection."), this.registerDisposer(new sf(t)), this.registerDisposer(new Wi(t, this.inputEventMap)), this.registerDisposer(new qr(t, this.inputEventMap, (r) => {
      this.onMousemove(r);
    })), this.registerDisposer(new Rz(t, this.inputEventMap)), this.registerEventListener(t, "mousemove", this.onMousemove.bind(this)), this.registerEventListener(t, "touchstart", this.onTouchstart.bind(this)), this.registerEventListener(t, "mouseleave", () => this.onMouseout()), this.registerEventListener(
      t,
      "mouseover",
      (r) => {
        r.target !== t && this.onMouseout();
      },
      /*capture=*/
      true
    ), be(t, "select-position", () => {
      this.viewer.selectionDetailsState.select(false);
    }), be(t, "snap", () => {
      this.navigationState.pose.snap();
    }), be(t, "zoom-in", () => {
      this.navigationState.zoomBy(0.5);
    }), be(t, "zoom-out", () => {
      this.navigationState.zoomBy(2);
    }), be(t, "depth-range-decrease", () => {
      this.navigationState.depthRange.value *= 0.5;
    }), be(t, "depth-range-increase", () => {
      this.navigationState.depthRange.value *= 2;
    });
    for (let r = 0; r < 3; ++r) {
      let s = v_[r];
      for (let a of [-1, 1]) {
        let l = a < 0 ? "-" : "+";
        be(t, `rotate-relative-${s}${l}`, () => {
          this.navigationState.pose.rotateRelative(Xi[r], a * 0.1);
        });
        let d = _e();
        be(t, `${s}${l}`, () => {
          let u = this.navigationState, f = d;
          f[0] = 0, f[1] = 0, f[2] = 0, f[r] = a, u.pose.translateVoxelsRelative(f, true);
        });
      }
    }
    be(t, "zoom-via-wheel", (r) => {
      const s = r.detail;
      this.onMousemove(s, false), this.zoomByMouse(Ju(s));
    }), be(t, "adjust-depth-range-via-wheel", (r) => {
      const s = r.detail;
      this.navigationState.depthRange.value *= Ju(s);
    }), be(t, "translate-via-mouse-drag", (r) => {
      zi(r.detail, (s, a, l) => {
        this.translateByViewportPixels(a, l);
      });
    }), be(t, "translate-in-plane-via-touchtranslate", (r) => {
      const s = r.detail;
      this.translateByViewportPixels(s.deltaX, s.deltaY);
    }), be(t, "translate-z-via-touchtranslate", (r) => {
      const s = r.detail;
      let a = this.navigationState, l = ng;
      l[0] = 0, l[1] = 0, l[2] = s.deltaY + s.deltaX, a.pose.translateVoxelsRelative(l, true);
    });
    for (const r of [1, 10])
      be(t, `z+${r}-via-wheel`, (s) => {
        const a = s.detail;
        let l = this.navigationState, d = ng, u = a.deltaY !== 0 ? a.deltaY : a.deltaX;
        d[0] = 0, d[1] = 0, d[2] = (u > 0 ? -1 : 1) * r, l.pose.translateVoxelsRelative(d, true);
      });
    be(t, "move-to-mouse-position", () => {
      const r = this.viewer.mouseState;
      r.updateUnconditionally() && (this.navigationState.position.value = r.position);
    }), be(t, "snap", () => this.navigationState.pose.snap()), be(t, "move-annotation", (r) => {
      const s = this.viewer.mouseState, a = s.pickedAnnotationId, l = s.pickedAnnotationLayer;
      if (l !== void 0 && a !== void 0) {
        r.stopPropagation();
        let d = l.source.getReference(a), u = d.value;
        const f = sc(u.type), g = s.pickedOffset, v = l.chunkTransform.value;
        if (v.error !== void 0)
          return;
        const y = v.layerRank, w = new Float32Array(y);
        f.getRepresentativePoint(w, u, s.pickedOffset);
        let C = g_(JE(), 0, 0);
        s.updateUnconditionally() && zi(r.detail, (b, E, L) => {
          m_(C, C, [E, L]);
          const R = new Float32Array(y);
          _r(R, v.chunkToLayerTransform, y + 1, w, y);
          const _ = ng, A = this.navigationState.pose.displayDimensions.value.displayDimensionIndices;
          X2(_, R, v.modelTransform, A), this.translateDataPointByViewportPixels(_, _, C[0], C[1]), Q2(R, _, v.modelTransform, A);
          const I = new Float32Array(y);
          _r(I, v.layerToChunkTransform, y + 1, R, y);
          let P = f.updateViaRepresentativePoint(u, I, g);
          l.source.update(d, P);
        }, (b) => {
          l.source.commit(d), d.dispose();
        });
      }
    }), be(t, "delete-annotation", () => {
      const r = this.viewer.mouseState, s = r.pickedAnnotationId, a = r.pickedAnnotationLayer;
      if (a !== void 0 && !a.source.readonly && s !== void 0) {
        const l = a.source.getReference(s);
        try {
          a.source.delete(l);
        } finally {
          l.dispose();
        }
      }
    }), be(t, "zoom-via-touchpinch", (r) => {
      const s = r.detail;
      this.handleMouseMove(s.centerX, s.centerY);
      const a = s.prevDistance / s.distance;
      a > 0.1 && a < 10 && this.zoomByMouse(a);
    });
  }
  cancelPickRequests() {
    const e = this.gl;
    for (const t of this.pickRequests) {
      const i = t.sync;
      i !== null && e.deleteSync(i), t.sync = null;
    }
    clearTimeout(this.pickTimerId), this.pickTimerId = -1;
  }
  issuePickRequestInternal(e) {
    const t = this.gl;
    let i = e.buffer;
    i === null ? (i = e.buffer = t.createBuffer(), t.bindBuffer(WebGL2RenderingContext.PIXEL_PACK_BUFFER, i), t.bufferData(WebGL2RenderingContext.PIXEL_PACK_BUFFER, 2 * 4 * 4 * ut * ut, WebGL2RenderingContext.STREAM_READ)) : t.bindBuffer(WebGL2RenderingContext.PIXEL_PACK_BUFFER, i);
    const r = this.renderViewport;
    let s = this.mouseX - r.visibleLeftFraction * r.logicalWidth, a = r.height - (this.mouseY - r.visibleTopFraction * r.logicalHeight);
    this.issuePickRequest(s, a), e.sync = t.fenceSync(WebGL2RenderingContext.SYNC_GPU_COMMANDS_COMPLETE, 0), e.frameNumber = this.context.frameNumber, e.glWindowX = s, e.glWindowY = a, t.flush(), t.bindBuffer(WebGL2RenderingContext.PIXEL_PACK_BUFFER, null), this.pickTimerId === -1 && this.scheduleCheckForPickRequestCompletion(), this.pickRequestPending = false;
    const l = this.pickRequests;
    e !== l[0] && (l[1] = l[0], l[0] = e), this.nextPickRequestTime = Date.now() + Oz;
  }
  completePickInternal(e) {
    const t = this.gl, i = this.pickBufferContents;
    t.bindBuffer(WebGL2RenderingContext.PIXEL_PACK_BUFFER, e.buffer), t.getBufferSubData(WebGL2RenderingContext.PIXEL_PACK_BUFFER, 0, i), t.bindBuffer(WebGL2RenderingContext.PIXEL_PACK_BUFFER, null);
    const r = this.pickingData, s = e.frameNumber;
    this.completePickRequest(e.glWindowX, e.glWindowY, i, r[0].frameNumber === s ? r[0] : r[1]);
  }
  scheduleCheckForPickRequestCompletion() {
    this.pickTimerId = window.setTimeout(() => {
      this.pickTimerId = -1, this.checkForPickRequestCompletion();
    }, 0);
  }
  checkForPickRequestCompletion(e = false, t = false) {
    let i = this.context.frameNumber, r = -1;
    e && (--i, r = i - 1);
    const s = this.pickRequests, a = this.gl;
    let l = false, d = false, u;
    for (const g of s) {
      const v = g.sync;
      if (v === null)
        continue;
      const y = g.frameNumber;
      if (!d && y >= i - 1) {
        if (t || a.getSyncParameter(v, WebGL2RenderingContext.SYNC_STATUS) === WebGL2RenderingContext.SIGNALED)
          this.completePickInternal(g), d = true;
        else if (y !== r) {
          l = true;
          continue;
        }
      }
      a.deleteSync(v), g.sync = null, u = g;
    }
    const f = this.pickTimerId;
    l && f === -1 ? this.scheduleCheckForPickRequestCompletion() : !l && f !== -1 && (window.clearTimeout(f), this.pickTimerId = -1), !e && u !== void 0 && this.pickRequestPending && this.canIssuePickRequest() && this.issuePickRequestInternal(u);
  }
  blockOnPickRequest() {
    this.pickRequestPending && (this.cancelPickRequests(), this.nextPickRequestTime = 0, this.attemptToIssuePickRequest()), this.checkForPickRequestCompletion(
      /*checkingBeforeDraw=*/
      false,
      /*block=*/
      true
    );
  }
  draw() {
    var e = this.renderViewport;
    const t = e.width, i = e.height;
    this.checkForPickRequestCompletion(true);
    const r = this.pickingData;
    r[0] = r[1];
    const s = this.context.frameNumber, a = r[1];
    if (a.frameNumber = s, a.viewportWidth = t, a.viewportHeight = i, a.pickIDs.clear(), !this.drawWithPicking(a)) {
      a.frameNumber = -1;
      return;
    }
    this.nextPickRequestTime = 0, this.mouseX >= 0 && this.attemptToIssuePickRequest();
  }
  canIssuePickRequest() {
    const e = Date.now(), t = this.nextPickRequestTime, i = this.pendingPickRequestTimerId;
    return e < t ? (i == -1 && (this.pendingPickRequestTimerId = window.setTimeout(this.pendingPickRequestTimerExpired, t - e)), false) : true;
  }
  attemptToIssuePickRequest() {
    if (!this.canIssuePickRequest())
      return;
    const e = this.context.frameNumber, t = this.gl, i = this.pickRequests;
    for (const r of i) {
      let s = r.sync;
      if (s !== null)
        if (r.frameNumber < e - 1)
          t.deleteSync(s);
        else
          continue;
      this.issuePickRequestInternal(r);
      return;
    }
  }
  /**
   * Called each time the mouse position relative to the top level of the rendered viewport changes.
   */
  updateMousePosition(e, t) {
    if (e === this.mouseX && t === this.mouseY)
      return;
    if (this.mouseX = e, this.mouseY = t, e < 0) {
      this.pickRequestPending = false, this.cancelPickRequests();
      return;
    }
    const i = this.context.frameNumber, r = this.pickingData[1];
    r.frameNumber !== i || this.renderViewport.width !== r.viewportWidth || this.renderViewport.height !== r.viewportHeight || (this.pickRequestPending = true, this.attemptToIssuePickRequest());
  }
  onMouseout() {
    this.updateMousePosition(-1, -1), this.viewer.mouseState.setForcer(void 0);
  }
  handleMouseMove(e, t) {
    const i = this.element, r = i.getBoundingClientRect(), s = e - (r.left + i.clientLeft), a = t - (r.top + i.clientTop), l = this.viewer.mouseState;
    l.pageX = e + window.scrollX, l.pageY = t + window.scrollY, l.setForcer(this.mouseStateForcer), this.updateMousePosition(s, a);
  }
  onMousemove(e, t = true) {
    const i = this.element;
    t && e.target !== i || this.handleMouseMove(e.clientX, e.clientY);
  }
  onTouchstart(e) {
    let t = this.element;
    if (e.target !== t || e.targetTouches.length !== 1)
      return;
    var i = e.targetTouches[0];
    const r = i.clientX, s = i.clientY;
    this.handleMouseMove(r, s);
  }
  disposed() {
    this.viewer.mouseState.removeForcer(this.mouseStateForcer);
    const t = this.gl;
    this.cancelPickRequests();
    const i = this.pendingPickRequestTimerId;
    i !== -1 && window.clearTimeout(i);
    for (const r of this.pickRequests)
      t.deleteBuffer(r.buffer);
    super.disposed();
  }
};
var Vz = [1.5, 2, 3, 5, 7.5, 10];
var Bz = class {
  constructor() {
    this.allowedSignificands = Vz, this.targetLengthInPixels = 0, this.physicalSizePerPixel = 0, this.prevPhysicalSizePerPixel = 0, this.prevTargetLengthInPixels = 0, this.prevPhysicalUnit = "\0";
  }
  /**
   * Updates physicalLength, physicalUnit, and lengthInPixels to be the optimal values corresponding
   * to targetLengthInPixels and physicalSizePerPixel.
   *
   * @returns true if the scale bar has changed, false if it is unchanged.
   */
  update() {
    let e = this.physicalSizePerPixel, t = this.targetLengthInPixels;
    if (this.prevPhysicalSizePerPixel === e && this.prevTargetLengthInPixels === t && this.prevPhysicalUnit === this.physicalUnit)
      return false;
    this.prevPhysicalSizePerPixel = e, this.prevTargetLengthInPixels = t, this.prevPhysicalUnit = this.physicalUnit;
    const i = t * e, r = Math.floor(T1(i)), s = 10 ** r, a = i / s;
    let l = 1;
    for (let f of this.allowedSignificands)
      if (Math.abs(f - a) < Math.abs(l - a))
        l = f;
      else
        break;
    const d = l * s, u = k1(d);
    return this.lengthInPixels = Math.round(d / e), this.physicalUnit = `${u.prefix}${this.physicalBaseUnit}`, this.physicalLength = l * 10 ** (r - u.exponent), true;
  }
};
function Fz(n, e, t, i, r) {
  const s = document.createElement("canvas"), a = s.getContext("2d"), l = r.textHeightInPixels * r.scaleFactor, d = `bold ${l}px ${r.fontName}`;
  a.font = d, a.fillStyle = "white";
  const u = `${i}${n.physicalLength} ${n.physicalUnit}`, f = a.measureText(u), g = Math.max(n.lengthInPixels, f.width), v = r.barHeightInPixels * r.scaleFactor, y = r.barTopMarginInPixels * r.scaleFactor, w = v + y + l, C = r.paddingInPixels * r.scaleFactor, b = w + 2 * C, E = g + 2 * C;
  return s.width = E, s.height = b, a.font = d, a.textAlign = "center", a.fillStyle = "rgba(0, 0, 0, 0.3)", a.fillRect(0, 0, E, b), a.fillStyle = "white", a.fillText(u, E / 2, b - C - v - y), a.fillRect(C, b - C - v, n.lengthInPixels, v), bV(e, t, s), { width: E, height: b };
}
var Uz = class extends Z {
  constructor(e, t = new Bz()) {
    super(), this.gl = e, this.dimensions = t, this.texture = null, this.width = 0, this.height = 0, this.label = "", this.factor = 1, this.priorOptions = void 0, this.prevLabel = "";
  }
  update(e) {
    const t = this.dimensions, i = this.label;
    let r = this.texture;
    if (!t.update() && r !== null && e === this.priorOptions && i == this.prevLabel)
      return;
    r === null && (r = this.texture = this.gl.createTexture());
    var s = Fz(t, this.gl, r, i, e);
    const a = s.width, l = s.height;
    this.priorOptions = e, this.prevLabel = i, this.width = a, this.height = l;
  }
  disposed() {
    this.gl.deleteTexture(this.texture), this.texture = null, super.disposed();
  }
};
var CI = class extends Z {
  constructor(e) {
    super(), this.gl = e, this.scaleBarCopyHelper = this.registerDisposer(Po.get(this.gl)), this.scaleBars = [];
    for (let t = 0; t < 3; ++t)
      this.scaleBars.push(this.registerDisposer(new Uz(e)));
  }
  draw(e, t, i, r, s) {
    const a = this.scaleBars, l = t.displayRank, d = t.displayDimensionIndices, u = t.canonicalVoxelFactors, f = t.globalDimensionNames, g = t.displayDimensionUnits, v = t.displayDimensionScales, y = i.factors, w = Math.min(s.maxWidthFraction * e.logicalWidth, s.maxWidthInPixels * s.scaleFactor);
    let C = 0;
    for (let R = 0; R < l; ++R) {
      const _ = d[R], A = g[R], I = y[_];
      let P, N, O;
      for (P = 0; P < C && (N = a[P], O = N.dimensions, !(O.physicalBaseUnit === A && N.factor === I)); ++P)
        ;
      P === C && (++C, N = a[P], N.label = "", O = N.dimensions, N.factor = I, O.physicalBaseUnit = A, O.targetLengthInPixels = w, O.physicalSizePerPixel = v[R] * r / u[R]), N.label += `${f[_]} `;
    }
    const b = this.gl, E = this.scaleBarCopyHelper;
    let L = s.bottomPixelOffset * s.scaleFactor;
    for (let R = C - 1; R >= 0; --R) {
      const _ = a[R];
      C === 1 ? _.label = "" : _.label += ": ", _.update(s), b.viewport(s.leftPixelOffset * s.scaleFactor - e.visibleLeftFraction * e.logicalWidth, L - (1 - (e.visibleTopFraction + e.visibleHeightFraction)) * e.logicalHeight, _.width, _.height), E.draw(_.texture), L += _.height + s.marginPixelsBetweenScaleBars * s.scaleFactor;
    }
  }
};
var zz = {
  scaleFactor: 1,
  textHeightInPixels: 15,
  barHeightInPixels: 8,
  barTopMarginInPixels: 5,
  fontName: "sans-serif",
  paddingInPixels: 2
};
var wI = RZr(RZr({}, zz), { maxWidthInPixels: 100, maxWidthFraction: 0.25, leftPixelOffset: 10, bottomPixelOffset: 10, marginPixelsBetweenScaleBars: 5 });
function Gz(n) {
  const e = RZr({}, wI);
  for (const t of ["textHeightInPixels", "barTopMarginInPixels", "barHeightInPixels", "paddingInPixels", "scaleFactor", "maxWidthInPixels", "maxWidthFraction", "leftPixelOffset", "bottomPixelOffset"])
    K(n, t, (i) => {
      i !== void 0 && (e[t] = Jo(i));
    });
  return K(n, "fontName", (t) => {
    t !== void 0 && (e.fontName = Le(t));
  }), e;
}
var $z = class extends hn {
  constructor() {
    super(wI, Gz);
  }
};
var ni;
(function(n) {
  n[n.COLOR = 0] = "COLOR", n[n.Z = 1] = "Z", n[n.PICK = 2] = "PICK", n[n.NUM_TEXTURES = 3] = "NUM_TEXTURES";
})(ni || (ni = {}));
var Wz = `
void emit(vec4 color, highp uint pickId) {
  out_color = color;
  float zValue = 1.0 - gl_FragCoord.z;
  out_z = vec4(zValue, zValue, zValue, 1.0);
  float pickIdFloat = float(pickId);
  out_pickId = vec4(pickIdFloat, pickIdFloat, pickIdFloat, 1.0);
}
`;
var Hz = `
float computeOITWeight(float alpha) {
  float a = min(1.0, alpha) * 8.0 + 0.01;
  float b = -gl_FragCoord.z * 0.95 + 1.0;
  return a * a * a * b * b * b;
}
`;
var jz = [Hz, `
void emit(vec4 color, highp uint pickId) {
  float weight = computeOITWeight(color.a);
  vec4 accum = color * weight;
  v4f_fragData0 = vec4(accum.rgb, color.a);
  v4f_fragData1 = vec4(accum.a, 0.0, 0.0, 0.0);
}
`];
function ig(n) {
  n.addOutputBuffer("vec4", "out_color", ni.COLOR), n.addOutputBuffer("highp vec4", "out_z", ni.Z), n.addOutputBuffer("highp vec4", "out_pickId", ni.PICK), n.addFragmentCode(Wz);
}
function Jz(n) {
  n.addOutputBuffer("vec4", "v4f_fragData0", 0), n.addOutputBuffer("vec4", "v4f_fragData1", 1), n.addFragmentCode(jz);
}
var Tr = _e();
var Jw = Th();
var Yz = et();
function qz(n) {
  n.addOutputBuffer("vec4", "v4f_fragColor", null), n.setFragmentMain(`
vec4 v0 = getValue0();
vec4 v1 = getValue1();
vec4 accum = vec4(v0.rgb, v1.r);
float revealage = v0.a;

v4f_fragColor = vec4(accum.rgb / accum.a, revealage);
`);
}
var Kz = Oh(hr);
var Zz = class extends Kz {
  constructor(e) {
    super(), this.panel = e;
  }
  initializeCounterpart(e, t) {
    this.sharedProjectionParameters = this.registerDisposer(new Ou(e, this.panel.projectionParameters)), t.projectionParameters = this.sharedProjectionParameters.rpcId, super.initializeCounterpart(e, t);
  }
};
var Ry = class extends bI {
  constructor(e, t, i) {
    super(e, t, i), this.sliceViews = this.registerDisposer(new Jv((s, a, l) => {
      s.registerDisposer(l), s.registerDisposer(l.visibility.add(this.visibility));
    })), this.axesLineHelper = this.registerDisposer(rf.get(this.gl)), this.sliceViewRenderHelper = this.registerDisposer(ZT.get(this.gl, ig)), this.offscreenFramebuffer = this.registerDisposer(new Do(this.gl, {
      colorBuffers: [new sa(this.gl, WebGL2RenderingContext.RGBA8, WebGL2RenderingContext.RGBA, WebGL2RenderingContext.UNSIGNED_BYTE), new sa(this.gl, WebGL2RenderingContext.R32F, WebGL2RenderingContext.RED, WebGL2RenderingContext.FLOAT), new sa(this.gl, WebGL2RenderingContext.R32F, WebGL2RenderingContext.RED, WebGL2RenderingContext.FLOAT)],
      depthBuffer: new TV(this.gl)
    })), this.offscreenCopyHelper = this.registerDisposer(Po.get(this.gl)), this.transparencyCopyHelper = this.registerDisposer(Po.get(this.gl, qz, 2)), this.scaleBars = this.registerDisposer(new CI(this.gl)), this.projectionParameters = this.registerDisposer(new bT({
      navigationState: this.navigationState,
      update: (s, a) => {
        const l = s.invViewMatrix, d = s.projectionMat, u = s.logicalWidth, f = s.logicalHeight, g = u / f, v = Math.PI / 4;
        let y = a.relativeDepthRange, C = a.zoomFactor.value / 2;
        if (this.viewer.orthographicProjection.value) {
          const b = Math.max(0.1, 1 - y), E = 1 + y;
          GE(d, -g, g, -1, 1, b, E);
        } else {
          const b = 1 / Math.tan(v / 2);
          y /= b;
          const E = Math.max(0.1, 1 - y), L = 1 + y;
          C *= b, s_(d, v, g, E, L);
        }
        K1(s, d), a.pose.toMat4(l, C), n_(l, l, Lg(Tr, 1, -1, -1)), t_(l, l, Xi[2]), tT(s);
      }
    })), this.projectionParameters.changed.add(() => this.context.scheduleRedraw());
    const r = this.sharedObject = this.registerDisposer(new Zz(this));
    if (r.RPC_TYPE_ID = wz, r.initializeCounterpart(i.rpc, {}), r.visibility.add(this.visibility), this.visibleLayerTracker = YI(this.viewer.layerManager, el, this.viewer.visibleLayerRoles, this), be(t, "rotate-via-mouse-drag", (s) => {
      zi(s.detail, (a, l, d) => {
        this.navigationState.pose.rotateRelative(Xi[1], l / 4 * Math.PI / 180), this.navigationState.pose.rotateRelative(Xi[0], -d / 4 * Math.PI / 180);
      });
    }), be(t, "rotate-in-plane-via-touchrotate", (s) => {
      const a = s.detail;
      this.navigationState.pose.rotateRelative(Xi[2], a.angle - a.prevAngle);
    }), be(t, "rotate-out-of-plane-via-touchtranslate", (s) => {
      const a = s.detail;
      this.navigationState.pose.rotateRelative(Xi[1], a.deltaX / 4 * Math.PI / 180), this.navigationState.pose.rotateRelative(Xi[0], -a.deltaY / 4 * Math.PI / 180);
    }), i.showSliceViewsCheckbox) {
      let s = this.registerDisposer(new Rs(i.showSliceViews));
      s.element.className = "perspective-panel-show-slice-views neuroglancer-noselect";
      let a = document.createElement("label");
      a.className = "perspective-panel-show-slice-views neuroglancer-noselect", a.appendChild(document.createTextNode("Sections")), a.appendChild(s.element), this.element.appendChild(a);
    }
    this.registerDisposer(i.orthographicProjection.changed.add(() => {
      this.projectionParameters.update(), this.scheduleRedraw();
    })), this.registerDisposer(i.showScaleBar.changed.add(() => this.scheduleRedraw())), this.registerDisposer(i.scaleBarOptions.changed.add(() => this.scheduleRedraw())), this.registerDisposer(i.showSliceViews.changed.add(() => this.scheduleRedraw())), this.registerDisposer(i.showAxisLines.changed.add(() => this.scheduleRedraw())), this.registerDisposer(i.crossSectionBackgroundColor.changed.add(() => this.scheduleRedraw())), this.registerDisposer(i.perspectiveViewBackgroundColor.changed.add(() => this.scheduleRedraw())), this.registerDisposer(i.wireFrame.changed.add(() => this.scheduleRedraw())), this.sliceViews.changed.add(() => this.scheduleRedraw());
  }
  get rpc() {
    return this.sharedObject.rpc;
  }
  get rpcId() {
    return this.sharedObject.rpcId;
  }
  get displayDimensionRenderInfo() {
    return this.navigationState.displayDimensionRenderInfo;
  }
  flushBackendProjectionParameters() {
    this.sharedObject.sharedProjectionParameters.flush();
  }
  translateByViewportPixels(e, t) {
    const i = Tr;
    var r = this.projectionParameters.value;
    const s = r.viewProjectionMat, a = r.invViewProjectionMat, l = r.logicalWidth, d = r.logicalHeight;
    this.viewer.navigationState.pose.updateDisplayPosition((f) => {
      Si(i, f, s), i[0] += -2 * e / l, i[1] += 2 * t / d, Si(f, i, a);
    });
  }
  get navigationState() {
    return this.viewer.navigationState;
  }
  ensureBoundsUpdated() {
    super.ensureBoundsUpdated(), this.projectionParameters.setViewport(this.renderViewport);
  }
  isReady() {
    if (!this.visible)
      return true;
    for (const u of this.sliceViews) {
      var e = ce(u, 2);
      const f = e[0];
      if ((e[1] || this.viewer.showSliceViews.value) && !f.isReady())
        return false;
    }
    this.ensureBoundsUpdated();
    var t = this.renderViewport;
    const i = t.width, r = t.height;
    if (i === 0 || r === 0)
      return true;
    const a = {
      projectionParameters: this.projectionParameters.value
    }, l = this.visibleLayerTracker.visibleLayers;
    for (const u of l) {
      var d = ce(u, 2);
      const f = d[0], g = d[1];
      if (!f.isReady(a, g))
        return false;
    }
    return true;
  }
  disposed() {
    this.sliceViews.clear(), super.disposed();
  }
  getDepthArray() {
    if (!this.navigationState.valid)
      return;
    const e = this.offscreenFramebuffer;
    var t = this.renderViewport;
    const i = t.width, r = t.height, s = i * r, a = new Float32Array(s * 4);
    try {
      e.bindSingle(ni.Z), this.gl.readPixels(0, 0, i, r, WebGL2RenderingContext.RGBA, WebGL2RenderingContext.FLOAT, a);
    } finally {
      e.framebuffer.unbind();
    }
    const l = new Float32Array(s);
    for (let d = 0; d < s; ++d)
      l[d] = a[d * 4];
    return l;
  }
  issuePickRequest(e, t) {
    const i = this.offscreenFramebuffer;
    i.readPixelFloat32IntoBuffer(ni.Z, e - gn, t - gn, 0, ut, ut), i.readPixelFloat32IntoBuffer(ni.PICK, e - gn, t - gn, 4 * 4 * ut * ut, ut, ut);
  }
  completePickRequest(e, t, i, r) {
    const s = this.viewer.mouseState;
    s.pickedRenderLayer = null, SI(i, 0, 4, e, t, r.viewportWidth, r.viewportHeight);
    const a = Yu.length;
    for (let l = 0; l < a; ++l) {
      const d = Yu[l];
      let u = i[4 * d];
      if (u === 0)
        continue;
      const f = d % ut, g = (d - f) / ut;
      let v = 1 - u;
      Tr[0] = 2 * (e + f - gn) / r.viewportWidth - 1, Tr[1] = 2 * (t + g - gn) / r.viewportHeight - 1, Tr[2] = 2 * v - 1, Si(Tr, Tr, r.invTransform);
      let y = s.position, w = s.unsnappedPosition;
      const C = this.navigationState.position.value, b = C.length;
      y.length !== b && (y = s.position = new Float32Array(b)), w.length !== b && (w = s.unsnappedPosition = new Float32Array(b)), y.set(C), s.coordinateSpace = this.navigationState.coordinateSpace.value;
      const E = this.navigationState.pose.displayDimensions.value, L = E.displayDimensionIndices;
      for (let _ = 0, A = L.length; _ < A; ++_)
        y[L[_]] = Tr[_];
      w.set(y);
      const R = i[4 * ut * ut + 4 * d];
      r.pickIDs.setMouseState(s, R), s.displayDimensions = E, s.setActive(true);
      return;
    }
    s.setActive(false);
  }
  translateDataPointByViewportPixels(e, t, i, r) {
    const s = Tr;
    var a = this.projectionParameters.value;
    const l = a.viewProjectionMat, d = a.invViewProjectionMat, u = a.width, f = a.height;
    return Si(s, t, l), s[0] += 2 * i / u, s[1] += -2 * r / f, Si(e, s, d);
  }
  get transparentConfiguration() {
    let e = this.transparentConfiguration_;
    return e === void 0 && (e = this.transparentConfiguration_ = this.registerDisposer(new Do(this.gl, {
      colorBuffers: Vu(this.gl, 2, this.gl.RGBA32F, this.gl.RGBA, this.gl.FLOAT),
      depthBuffer: this.offscreenFramebuffer.depthBuffer.addRef()
    }))), e;
  }
  drawWithPicking(e) {
    if (!this.navigationState.valid)
      return false;
    var t = this.renderViewport;
    const i = t.width, r = t.height, s = this.viewer.showSliceViews.value;
    for (const I of this.sliceViews) {
      var a = ce(I, 2);
      const P = a[0];
      (a[1] || s) && P.updateRendering();
    }
    let l = this.gl;
    this.offscreenFramebuffer.bind(i, r), l.disable(l.SCISSOR_TEST), l.enable(WebGL2RenderingContext.STENCIL_TEST), l.stencilMask(4294967295), l.clearStencil(0), l.clear(WebGL2RenderingContext.STENCIL_BUFFER_BIT), l.stencilOp(
      /*sfail=*/
      WebGL2RenderingContext.KEEP,
      /*dpfail=*/
      WebGL2RenderingContext.KEEP,
      /*dppass=*/
      WebGL2RenderingContext.REPLACE
    ), l.stencilFunc(
      /*func=*/
      WebGL2RenderingContext.ALWAYS,
      /*ref=*/
      1,
      /*mask=*/
      1
    );
    const d = this.viewer.perspectiveViewBackgroundColor.value;
    this.gl.clearColor(d[0], d[1], d[2], 0), l.clear(l.DEPTH_BUFFER_BIT), l.clearBufferfv(WebGL2RenderingContext.COLOR, ni.COLOR, [d[0], d[1], d[2], 0]), l.clearBufferfv(WebGL2RenderingContext.COLOR, ni.Z, Rg), l.clearBufferfv(WebGL2RenderingContext.COLOR, ni.PICK, Rg), l.enable(l.DEPTH_TEST);
    const u = this.projectionParameters.value;
    let f = _e();
    po(f, Xi[2], this.navigationState.pose.orientation.orientation), Ev(f, f, -1);
    let g = 0.2, v = 1 - g;
    const y = {
      wireFrame: this.viewer.wireFrame.value,
      projectionParameters: u,
      lightDirection: f,
      ambientLighting: g,
      directionalLighting: v,
      pickIDs: e.pickIDs,
      emitter: ig,
      emitColor: true,
      emitPickID: true,
      alreadyEmittedPickID: false
    };
    Cu(e.invTransform, u.invViewProjectionMat);
    const w = this.visibleLayerTracker.visibleLayers;
    let C = false, b = false;
    for (const I of w) {
      var E = ce(I, 2);
      const P = E[0], N = E[1];
      P.isTransparent ? C = true : P.isAnnotation ? b = true : P.draw(y, N);
    }
    if (this.drawSliceViews(y), b) {
      l.enable(WebGL2RenderingContext.BLEND), l.depthFunc(WebGL2RenderingContext.LEQUAL), l.blendFunc(WebGL2RenderingContext.SRC_ALPHA, WebGL2RenderingContext.ONE_MINUS_SRC_ALPHA);
      for (const I of w) {
        var L = ce(I, 2);
        const P = L[0], N = L[1];
        P.isAnnotation && P.draw(y, N);
      }
      l.depthFunc(WebGL2RenderingContext.LESS), l.disable(WebGL2RenderingContext.BLEND);
    }
    if (this.viewer.showAxisLines.value && this.drawAxisLines(), l.stencilOp(
      /*sfail=*/
      WebGL2RenderingContext.KEEP,
      /*dpfail=*/
      WebGL2RenderingContext.KEEP,
      /*dppass=*/
      WebGL2RenderingContext.KEEP
    ), C) {
      l.depthMask(false), l.enable(WebGL2RenderingContext.BLEND);
      const I = this.transparentConfiguration;
      I.bind(i, r), this.gl.clearColor(0, 0, 0, 1), l.clear(WebGL2RenderingContext.COLOR_BUFFER_BIT), y.emitter = Jz, l.blendFuncSeparate(WebGL2RenderingContext.ONE, WebGL2RenderingContext.ONE, WebGL2RenderingContext.ZERO, WebGL2RenderingContext.ONE_MINUS_SRC_ALPHA), y.emitPickID = false;
      for (const P of w) {
        var R = ce(P, 2);
        const N = R[0], O = R[1];
        N.isTransparent && N.draw(y, O);
      }
      l.disable(WebGL2RenderingContext.DEPTH_TEST), this.offscreenFramebuffer.bindSingle(ni.COLOR), l.blendFunc(WebGL2RenderingContext.ONE_MINUS_SRC_ALPHA, WebGL2RenderingContext.SRC_ALPHA), this.transparencyCopyHelper.draw(I.colorBuffers[0].texture, I.colorBuffers[1].texture), l.depthMask(true), l.disable(WebGL2RenderingContext.BLEND), l.enable(WebGL2RenderingContext.DEPTH_TEST), this.offscreenFramebuffer.bind(i, r), l.enable(WebGL2RenderingContext.STENCIL_TEST), l.drawBuffers([l.NONE, l.COLOR_ATTACHMENT1, l.COLOR_ATTACHMENT2]), y.emitter = ig, y.emitPickID = true, y.emitColor = false, l.stencilFunc(
        /*func=*/
        WebGL2RenderingContext.NOTEQUAL,
        /*ref=*/
        3,
        /*mask=*/
        1
      ), l.stencilOp(
        /*sfail=*/
        WebGL2RenderingContext.KEEP,
        /*dpfail=*/
        WebGL2RenderingContext.KEEP,
        /*dppass=*/
        WebGL2RenderingContext.REPLACE
      ), l.stencilMask(2);
      for (const P of w) {
        var _ = ce(P, 2);
        const N = _[0], O = _[1];
        !N.isTransparent || !N.transparentPickEnabled || N.draw(y, O);
      }
      l.stencilFunc(
        /*func=*/
        WebGL2RenderingContext.EQUAL,
        /*ref=*/
        0,
        /*mask=*/
        3
      ), l.stencilOp(
        /*sfail=*/
        WebGL2RenderingContext.KEEP,
        /*dpfail=*/
        WebGL2RenderingContext.KEEP,
        /*dppass=*/
        WebGL2RenderingContext.KEEP
      ), l.stencilMask(0);
      for (const P of w) {
        var A = ce(P, 2);
        const N = A[0], O = A[1];
        !N.isTransparent || N.transparentPickEnabled || N.draw(y, O);
      }
    }
    if (l.stencilMask(4294967295), l.disable(WebGL2RenderingContext.STENCIL_TEST), this.viewer.showScaleBar.value && this.viewer.orthographicProjection.value) {
      l.drawBuffers([l.COLOR_ATTACHMENT0]), l.disable(WebGL2RenderingContext.DEPTH_TEST), l.enable(WebGL2RenderingContext.BLEND), l.blendFunc(WebGL2RenderingContext.SRC_ALPHA, WebGL2RenderingContext.ONE_MINUS_SRC_ALPHA);
      const I = this.scaleBars, P = this.viewer.scaleBarOptions.value;
      I.draw(this.renderViewport, this.navigationState.displayDimensionRenderInfo.value, this.navigationState.relativeDisplayScales.value, this.navigationState.zoomFactor.value / this.renderViewport.logicalHeight, P), l.disable(WebGL2RenderingContext.BLEND);
    }
    return this.offscreenFramebuffer.unbind(), this.setGLClippedViewport(), this.offscreenCopyHelper.draw(this.offscreenFramebuffer.colorBuffers[ni.COLOR].texture), true;
  }
  drawSliceViews(e) {
    let t = this.sliceViewRenderHelper, i = e.lightDirection, r = e.ambientLighting, s = e.directionalLighting, a = e.projectionParameters.viewProjectionMat;
    const l = this.viewer.showSliceViews.value;
    for (const f of this.sliceViews) {
      var d = ce(f, 2);
      const g = d[0];
      if (!d[1] && !l)
        continue;
      var u = g.projectionParameters.value;
      const y = u.width, w = u.height, C = u.invViewMatrix, b = u.viewportNormalInCanonicalCoordinates;
      if (y === 0 || w === 0 || !g.valid)
        continue;
      let E = Math.abs(Tv(i, b)), L = r + E * s, R = Yz;
      zE(R), R[0] = y / 2, R[5] = -w / 2, mn(R, C, R), mn(R, a, R);
      const _ = Jw, A = this.viewer.crossSectionBackgroundColor.value;
      _[0] = A[0], _[1] = A[1], _[2] = A[2], _[3] = 1, t.draw(g.offscreenFramebuffer.colorBuffers[0].texture, R, Nc(L, L, L, 1), Jw, 0, 0, 1, 1);
    }
  }
  drawAxisLines() {
    const e = this.viewer.navigationState.zoomFactor.value, t = this.projectionParameters.value, i = Math.min(t.logicalWidth, t.logicalHeight) / this.renderViewport.logicalHeight / 4, r = e * i, s = this.gl;
    s.drawBuffers([s.COLOR_ATTACHMENT0]), this.axesLineHelper.draw(
      mI(t, r),
      /*blend=*/
      false
    );
  }
  zoomByMouse(e) {
    this.navigationState.zoomBy(e);
  }
};
var ho;
(function(n) {
  n[n.COLOR = 0] = "COLOR", n[n.PICK = 1] = "PICK", n[n.NUM_TEXTURES = 2] = "NUM_TEXTURES";
})(ho || (ho = {}));
function Xz(n) {
  n.addOutputBuffer("vec4", "out_fragColor", 0), n.addOutputBuffer("highp vec4", "out_pickId", 1), n.addFragmentCode(`
void emit(vec4 color, highp uint pickId) {
  out_fragColor = color;
  float pickIdFloat = float(pickId);
  out_pickId = vec4(pickIdFloat, pickIdFloat, pickIdFloat, 1.0);
}
`);
}
function Qz(n) {
  n.addOutputBuffer("vec4", "out_fragColor", null), n.addFragmentCode(`
void emit(vec4 color, highp uint pickId) {
  out_fragColor = color;
}
`);
}
var Xs = _e();
var eG = _e();
var tG = Th();
var af = class extends bI {
  constructor(e, t, i, r) {
    super(e, t, r), this.sliceView = i, this.axesLineHelper = this.registerDisposer(rf.get(this.gl)), this.sliceViewRenderHelper = this.registerDisposer(ZT.get(this.gl, Qz)), this.colorFactor = Nc(1, 1, 1, 1), this.pickIDs = new vI(), this.offscreenFramebuffer = this.registerDisposer(new Do(this.gl, {
      colorBuffers: [new sa(this.gl, WebGL2RenderingContext.RGBA8, WebGL2RenderingContext.RGBA, WebGL2RenderingContext.UNSIGNED_BYTE), new sa(this.gl, WebGL2RenderingContext.R32F, WebGL2RenderingContext.RED, WebGL2RenderingContext.FLOAT)]
    })), this.offscreenCopyHelper = this.registerDisposer(Po.get(this.gl)), this.scaleBars = this.registerDisposer(new CI(this.gl)), r.wireFrame.changed.add(() => this.scheduleRedraw()), be(t, "rotate-via-mouse-drag", (s) => {
      const a = this.viewer.mouseState;
      if (a.updateUnconditionally()) {
        const l = Float32Array.from(a.position);
        zi(s.detail, (d, u, f) => {
          const g = this.navigationState.pose, v = po(Xs, Xi[0], g.orientation.orientation), y = po(eG, Xi[1], g.orientation.orientation);
          this.viewer.navigationState.pose.rotateAbsolute(y, -u / 4 * Math.PI / 180, l), this.viewer.navigationState.pose.rotateAbsolute(v, -f / 4 * Math.PI / 180, l);
        });
      }
    }), be(t, "rotate-in-plane-via-touchrotate", (s) => {
      const a = s.detail, l = this.viewer.mouseState;
      this.handleMouseMove(a.centerX, a.centerY), l.updateUnconditionally() && this.navigationState.pose.rotateAbsolute(this.sliceView.projectionParameters.value.viewportNormalInCanonicalCoordinates, a.angle - a.prevAngle, l.position);
    }), this.registerDisposer(i), this.visibleLayerTracker = YI(this.viewer.layerManager, Mo, this.viewer.visibleLayerRoles, this), this.registerDisposer(r.crossSectionBackgroundColor.changed.add(() => this.scheduleRedraw())), this.registerDisposer(i.visibility.add(this.visibility)), this.registerDisposer(i.viewChanged.add(() => {
      this.visible && e.scheduleRedraw();
    })), this.registerDisposer(r.showAxisLines.changed.add(() => {
      this.visible && this.scheduleRedraw();
    })), this.registerDisposer(r.showScaleBar.changed.add(() => {
      this.visible && this.context.scheduleRedraw();
    })), this.registerDisposer(r.scaleBarOptions.changed.add(() => {
      this.visible && this.context.scheduleRedraw();
    }));
  }
  flushBackendProjectionParameters() {
    this.sliceView.flushBackendProjectionParameters();
  }
  get displayDimensionRenderInfo() {
    return this.navigationState.displayDimensionRenderInfo;
  }
  // FIXME: use separate backend object for the panel
  get rpc() {
    return this.sliceView.rpc;
  }
  get rpcId() {
    return this.sliceView.rpcId;
  }
  get navigationState() {
    return this.sliceView.navigationState;
  }
  translateByViewportPixels(e, t) {
    this.viewer.navigationState.pose.updateDisplayPosition((r) => {
      Lg(r, -e, -t, 0), Si(r, r, this.sliceView.projectionParameters.value.invViewMatrix);
    });
  }
  translateDataPointByViewportPixels(e, t, i, r) {
    const s = this.sliceView.projectionParameters.value;
    return Si(e, t, s.viewMatrix), Lg(e, e[0] + i, e[1] + r, e[2]), Si(e, e, s.invViewMatrix), e;
  }
  isReady() {
    if (!this.visible)
      return false;
    const e = this.sliceView;
    if (this.ensureBoundsUpdated(), !e.isReady())
      return false;
    const t = {
      projectionParameters: e.projectionParameters.value,
      sliceView: e
    };
    for (const r of this.visibleLayerTracker.visibleLayers) {
      var i = ce(r, 2);
      const s = i[0], a = i[1];
      if (!s.isReady(t, a))
        return false;
    }
    return true;
  }
  drawWithPicking(e) {
    const t = this.sliceView;
    if (!t.valid)
      return false;
    t.updateRendering();
    const i = t.projectionParameters.value, r = i.width, s = i.height, a = i.invViewProjectionMat;
    Cu(e.invTransform, a);
    const l = this.gl;
    this.offscreenFramebuffer.bind(r, s), l.disable(WebGL2RenderingContext.SCISSOR_TEST), this.gl.clearColor(0, 0, 0, 0), l.clear(WebGL2RenderingContext.COLOR_BUFFER_BIT);
    const d = tG, u = this.viewer.crossSectionBackgroundColor.value;
    d[0] = u[0], d[1] = u[1], d[2] = u[2], d[3] = 1, this.offscreenFramebuffer.bindSingle(ho.COLOR), this.sliceViewRenderHelper.draw(t.offscreenFramebuffer.colorBuffers[0].texture, YE, this.colorFactor, d, 0, 0, 1, 1);
    const f = this.visibleLayerTracker.visibleLayers;
    let g = this.pickIDs;
    g.clear();
    const v = {
      wireFrame: this.viewer.wireFrame.value,
      projectionParameters: i,
      pickIDs: g,
      emitter: Xz,
      emitColor: true,
      emitPickID: true,
      sliceView: t
    };
    this.offscreenFramebuffer.bind(r, s), l.enable(WebGL2RenderingContext.BLEND), l.blendFunc(WebGL2RenderingContext.SRC_ALPHA, WebGL2RenderingContext.ONE_MINUS_SRC_ALPHA);
    for (const w of f) {
      var y = ce(w, 2);
      const C = y[0], b = y[1];
      C.draw(v, b);
    }
    if (l.disable(WebGL2RenderingContext.BLEND), this.viewer.showAxisLines.value || this.viewer.showScaleBar.value) {
      if (this.offscreenFramebuffer.bindSingle(ho.COLOR), this.viewer.showAxisLines.value) {
        const w = Math.min(i.logicalWidth, i.logicalHeight) / 4 * 1.5, C = this.viewer.navigationState.zoomFactor.value;
        this.axesLineHelper.draw(w_(mI(i, w * C)));
      }
      this.viewer.showScaleBar.value && (l.enable(WebGL2RenderingContext.BLEND), l.blendFunc(WebGL2RenderingContext.SRC_ALPHA, WebGL2RenderingContext.ONE_MINUS_SRC_ALPHA), this.scaleBars.draw(i, this.navigationState.displayDimensionRenderInfo.value, this.navigationState.relativeDisplayScales.value, this.navigationState.zoomFactor.value, this.viewer.scaleBarOptions.value), l.disable(WebGL2RenderingContext.BLEND));
    }
    return this.offscreenFramebuffer.unbind(), this.setGLClippedViewport(), this.offscreenCopyHelper.draw(this.offscreenFramebuffer.colorBuffers[ho.COLOR].texture), true;
  }
  ensureBoundsUpdated() {
    super.ensureBoundsUpdated(), this.sliceView.projectionParameters.setViewport(this.renderViewport);
  }
  issuePickRequest(e, t) {
    this.offscreenFramebuffer.readPixelFloat32IntoBuffer(ho.PICK, e - gn, t - gn, 0, ut, ut);
  }
  completePickRequest(e, t, i, r) {
    const s = this.viewer.mouseState;
    s.pickedRenderLayer = null, SI(i, 0, 4, e, t, r.viewportWidth, r.viewportHeight);
    const a = r.viewportWidth, l = r.viewportHeight, d = Yu.length, u = this.navigationState.position.value, f = u.length, g = this.navigationState.pose.displayDimensions.value, v = g.displayRank, y = g.displayDimensionIndices, w = (E, L, R) => {
      const _ = e + E, A = t + L;
      Xs[0] = 2 * _ / a - 1, Xs[1] = 2 * A / l - 1, Xs[2] = 0, Si(Xs, Xs, r.invTransform), R.set(u);
      for (let I = 0; I < v; ++I)
        R[y[I]] = Xs[I];
    };
    let C = s.unsnappedPosition;
    C.length !== f && (C = s.unsnappedPosition = new Float32Array(f)), s.coordinateSpace = this.navigationState.coordinateSpace.value, s.displayDimensions = g, w(0, 0, C);
    const b = (E, L, R) => {
      let _ = s.position;
      _.length !== f && (_ = s.position = new Float32Array(f)), w(E - gn, L - gn, _), this.pickIDs.setMouseState(s, R), s.setActive(true);
    };
    for (let E = 0; E < d; ++E) {
      const L = Yu[E], R = i[4 * E];
      if (R === 0)
        continue;
      const _ = L % ut, A = (L - _) / ut;
      b(_, A, R);
      return;
    }
    b(gn, gn, 0);
  }
  /**
   * Zooms by the specified factor, maintaining the data position that projects to the current mouse
   * position.
   */
  zoomByMouse(e) {
    const t = this.navigationState;
    if (!t.valid)
      return;
    var r = this.sliceView.projectionParameters.value;
    const s = r.width, a = r.height, l = r.invViewMatrix;
    var d = r.displayDimensionRenderInfo;
    const u = d.displayDimensionIndices, f = d.displayRank;
    let g = this.mouseX, v = this.mouseY;
    g -= s / 2, v -= a / 2;
    const y = this.navigationState.position.value;
    for (let w = 0; w < f; ++w) {
      const C = u[w], b = l[w] * g + l[4 + w] * v;
      y[C] += b * (1 - e);
    }
    this.navigationState.position.changed.dispatch(), t.zoomBy(e);
  }
};
function xI(n, e) {
  let t = "";
  for (let i = 0; i <= e && (t = n.toFixed(i), parseFloat(t) !== n); ++i)
    ;
  return t;
}
var nG = ["#f00", "#0f0", "#00f"];
var Yw = vt.fromObject({
  arrowup: { action: "move-up" },
  arrowdown: { action: "move-down" },
  wheel: { action: "adjust-via-wheel" },
  enter: { action: "commit" },
  escape: { action: "cancel" }
});
function iG(n) {
  if (n < 1 || n > 1024) {
    const e = Zn(n) | 0, t = n / 2 ** e;
    return `${xI(t, 1)}p${e}`;
  }
  return n.toString();
}
var rG = [(n) => n.name, (n) => n.scaleFactor];
var sG = 2e3;
var aG = class extends Z {
  constructor(e, t, i, r = "px") {
    super(), this.displayDimensionRenderInfo = e, this.zoom = t, this.depthRange = i, this.displayUnit = r, this.element = document.createElement("div"), this.dimensionGridContainer = document.createElement("div"), this.depthGridContainer = document.createElement("div"), this.defaultCheckbox = document.createElement("input"), this.dimensionElements = De(Array(3), (C, b) => {
      const E = document.createElement("div");
      E.classList.add("neuroglancer-display-dimensions-widget-dimension"), E.style.display = "contents", be(E, "adjust-via-wheel", (P) => {
        const O = P.detail.deltaY;
        O !== 0 && this.zoomDimension(b, Ec(O));
      });
      const L = document.createElement("input");
      L.classList.add("neuroglancer-display-dimensions-widget-name"), L.title = "Change display dimensions", L.spellcheck = false, L.autocomplete = "off", L.style.color = nG[b], L.style.gridColumn = "1", L.style.gridRow = `${b + 1}`, L.addEventListener("focus", () => {
        L.select();
      }), E.appendChild(L);
      const R = document.createElement("span");
      R.classList.add("neuroglancer-display-dimensions-widget-scale-factor");
      const _ = document.createElement("input");
      _.spellcheck = false, _.title = "Change relative scale at which dimension is displayed", _.autocomplete = "off", R.style.gridColumn = "2", R.style.gridRow = `${b + 1}`, _.addEventListener("focus", () => {
        _.select();
      }), R.appendChild(_), E.appendChild(R);
      const A = document.createElement("span");
      A.classList.add("neuroglancer-display-dimensions-widget-scale"), A.style.gridColumn = "3", A.style.gridRow = `${b + 1}`, E.appendChild(A), this.dimensionGridContainer.appendChild(E);
      const I = {
        name: L,
        container: E,
        scaleFactor: _,
        scale: A,
        scaleFactorModified: false
      };
      L.addEventListener("input", () => {
        Kn(L), this.updateNameValidity();
      }), be(L, "commit", () => {
        this.updateNames();
      }), L.addEventListener("blur", (P) => {
        const N = P.relatedTarget;
        this.dimensionElements.some((O) => O.name === N) || this.updateNames() || this.updateView();
      }), R.addEventListener("click", (P) => {
        P.target !== _ && (_.focus(), P.preventDefault());
      }), _.addEventListener("input", () => {
        Kn(_), I.scaleFactorModified = true;
      }), be(_, "commit", () => {
        this.updateScaleFactors();
      }), _.addEventListener("blur", () => {
        this.updateScaleFactors() || this.updateView();
      });
      for (const P of rG)
        be(P(I), "move-up", () => {
          b !== 0 && P(this.dimensionElements[b - 1]).focus();
        }), be(P(I), "move-down", () => {
          b !== 2 && P(this.dimensionElements[b + 1]).focus();
        });
      return I;
    }), this.scheduleUpdateView = Ct(() => this.updateView());
    const s = this.element, a = this.dimensionGridContainer, l = this.defaultCheckbox, d = document.createElement("label"), u = this.registerCancellable(lt(() => {
      s.dataset.active = "false";
    }, sG)), f = () => {
      s.dataset.active = "true", u();
    };
    this.registerDisposer(t.changed.add(f)), this.registerDisposer(e.relativeDisplayScales.changed.add(f)), this.registerDisposer(i.changed.add(f)), s.classList.add("neuroglancer-display-dimensions-widget"), s.appendChild(a), a.classList.add("neuroglancer-display-dimensions-widget-dimension-grid"), s.addEventListener("pointerleave", () => {
      const C = document.activeElement;
      C instanceof HTMLElement && s.contains(C) && C.blur();
    }), l.type = "checkbox", d.appendChild(l), d.appendChild(document.createTextNode("Default")), d.title = "Display first 3 dimensions", d.classList.add("neuroglancer-display-dimensions-widget-default"), l.addEventListener("change", () => {
      this.updateDefault();
    }), a.appendChild(d), this.registerDisposer(e), this.registerDisposer(i), this.registerDisposer(t.changed.add(this.scheduleUpdateView)), this.registerDisposer(e.changed.add(this.scheduleUpdateView));
    const g = this.registerDisposer(new Wi(s, Yw));
    g.allShortcutsAreGlobal = true, this.registerDisposer(new qr(s, Yw)), be(a, "cancel", () => {
      this.updateView();
      const C = document.activeElement;
      C instanceof HTMLElement && s.contains(C) && C.blur();
    });
    const v = this.depthGridContainer;
    v.classList.add("neuroglancer-depth-range-widget-grid"), s.appendChild(v);
    const y = document.createElement("label"), w = document.createElement("input");
    w.type = "checkbox", y.classList.add("neuroglancer-depth-range-relative-checkbox-label"), w.classList.add("neuroglancer-depth-range-relative-checkbox"), y.appendChild(w), y.appendChild(document.createTextNode("Zoom-relative")), w.addEventListener("change", () => {
      const C = w.checked;
      let b = this.depthRange.value;
      C !== b < 0 && (C ? b = -b / this.zoom.value : b = -b * this.zoom.value, this.depthRange.value = b);
    }), y.title = "Depth range is multiplied by scale", s.appendChild(y), be(v, "adjust-via-wheel", (C) => {
      const E = C.detail.deltaY;
      if (E === 0)
        return;
      const L = this.depthRange.value;
      this.depthRange.value = L * 2 ** Ec(E);
    }), this.registerDisposer(Ur((C, b, { factors: E }) => {
      it(v);
      const L = b.displayRank, R = b.globalDimensionNames, _ = b.displayDimensionIndices, A = b.displayDimensionUnits, I = b.displayDimensionScales, P = b.canonicalVoxelFactors, N = [], O = () => {
        w.checked = this.depthRange.value < 0;
        let U = this.depthRange.value;
        U < 0 && (U *= -this.zoom.value);
        for (const V of N) {
          const G = V.input;
          G.value = ca(U * V.scale, V.unit, { precision: 2, elide1: false }), Kn(G);
        }
      }, B = (U) => {
        const V = pc(U.input.value);
        if (V === void 0 || V.unit !== U.unit)
          return false;
        let G = V.scale / U.scale;
        return this.depthRange.value < 0 && (G = -G / this.zoom.value), this.depthRange.value = G, true;
      };
      for (let U = 0; U < L; ++U) {
        const V = _[U], G = R[V], F = A[U], ue = E[V];
        let ae = N.find((Ie) => Ie.unit === F && Ie.factor === ue);
        if (ae === void 0) {
          const Ie = document.createElement("div");
          Ie.title = "Visible depth range", Ie.style.display = "contents", v.appendChild(Ie);
          const le = document.createElement("span");
          le.textContent = "±", Ie.appendChild(le);
          const Te = document.createElement("input");
          Te.spellcheck = false, Te.autocomplete = "off", Te.addEventListener("focus", () => {
            Te.select();
          }), be(Te, "commit", () => {
            B(ae);
          }), Te.addEventListener("change", () => {
            B(ae) || O();
          }), Te.addEventListener("input", () => {
            Kn(Te);
          }), Ie.appendChild(Te);
          const Ue = document.createElement("span");
          Ue.classList.add("neuroglancer-depth-range-widget-dimension-names"), Ie.appendChild(Ue), ae = {
            unit: F,
            factor: ue,
            dimensionNames: [],
            input: Te,
            label: Ue,
            scale: I[U] / P[U]
          }, N.push(ae);
        }
        ae.dimensionNames.push(G);
      }
      for (const U of N)
        U.dimensionNames.length !== L && (U.label.textContent = U.dimensionNames.join(" "));
      C.registerDisposer(be(v, "cancel", () => {
        O();
        const U = document.activeElement;
        U instanceof HTMLElement && v.contains(U) && U.blur();
      }));
      const j = C.registerCancellable(Ct(O));
      C.registerDisposer(this.depthRange.changed.add(j)), C.registerDisposer(this.zoom.changed.add(j)), O();
    }, e, this.relativeDisplayScales)), this.updateView();
  }
  zoomDimension(e, t) {
    this.updateScaleFactors();
    const i = this.displayDimensions, r = this.relativeDisplayScales, a = i.value.displayDimensionIndices[e];
    if (a === -1)
      return;
    const l = r.value.factors, d = new Float64Array(l);
    d[a] *= 2 ** -t, r.setFactors(d);
  }
  updateNameValidity() {
    const e = this.dimensionElements, t = this.displayDimensions.value.displayDimensionIndices, i = e.map((d) => d.name.value), r = Uv(i), a = this.displayDimensions.coordinateSpace.value.names, l = i.length;
    for (let d = 0; d < l; ++d) {
      let u = r[d];
      const f = i[d];
      let g = -1;
      f.length === 0 ? u = true : (g = a.indexOf(f), g === -1 && (u = false));
      const v = e[d];
      v.name.dataset.isValid = u.toString(), v.container.dataset.isModified = (g !== t[d]).toString();
    }
  }
  get displayDimensions() {
    return this.displayDimensionRenderInfo.displayDimensions;
  }
  get relativeDisplayScales() {
    return this.displayDimensionRenderInfo.relativeDisplayScales;
  }
  updateNames() {
    const e = this.dimensionElements.map((l) => l.name.value).filter((l) => l.length > 0);
    if (!Ah(e))
      return false;
    const t = this.displayDimensionRenderInfo.displayDimensions;
    if (e.length === 0)
      return t.reset(), true;
    const i = new Int32Array(3);
    i.fill(-1);
    const s = t.coordinateSpace.value.names, a = e.length;
    for (let l = 0; l < a; ++l) {
      const d = s.indexOf(e[l]);
      if (d === -1)
        return false;
      i[l] = d;
    }
    return Fe(i, t.value.displayDimensionIndices) || t.setDimensionIndices(a, i), true;
  }
  updateDefault() {
    this.displayDimensions.default = this.defaultCheckbox.checked;
  }
  updateScaleFactors() {
    const e = this.displayDimensions, t = this.relativeDisplayScales;
    var i = e.value;
    const r = i.displayDimensionIndices, s = i.displayRank, a = t.value.factors, l = this.dimensionElements, d = new Float64Array(a);
    for (let u = 0; u < s; ++u) {
      const f = l[u];
      if (!f.scaleFactorModified)
        continue;
      const g = Number(f.scaleFactor.value), v = r[u];
      !kt(g) || g <= 0 || (d[v] = g);
    }
    return Fe(d, a) || t.setFactors(d), true;
  }
  updateView() {
    const e = this.dimensionElements, t = this.displayDimensions.default;
    var i = this.displayDimensionRenderInfo.value;
    const r = i.displayDimensionIndices, s = i.canonicalVoxelFactors, a = i.displayDimensionUnits, l = i.displayDimensionScales, d = i.globalDimensionNames, u = this.relativeDisplayScales.value.factors;
    this.defaultCheckbox.checked = t;
    const f = this.zoom.value, g = r[0];
    let v = true;
    if (g !== -1) {
      const y = a[0], w = u[g];
      for (let C = 1; C < 3; ++C) {
        const b = r[C];
        if (b !== -1 && (a[C] !== y || u[b] !== w)) {
          v = false;
          break;
        }
      }
    }
    for (let y = 0; y < 3; ++y) {
      const w = r[y], C = e[y];
      if (delete C.name.dataset.isValid, C.container.dataset.isModified = (w === -1).toString(), w === -1)
        C.name.value = "", C.scale.textContent = "", C.scaleFactor.value = "";
      else {
        C.name.value = d[w];
        const b = l[y] * f / s[y];
        if (y === 0 || !v) {
          const E = ca(b, a[y], { precision: 2, elide1: false });
          C.scale.textContent = `${E}/${this.displayUnit}`;
        } else
          C.scale.textContent = "";
        C.scaleFactor.value = iG(u[w]);
      }
      Kn(C.name), Kn(C.scaleFactor);
    }
  }
  disposed() {
    Ft(this.element), super.disposed();
  }
};
var EI = new de([["xy", void 0], ["xz", h_($n(), $n(), Math.PI / 2)], ["yz", f_($n(), $n(), Math.PI / 2)]]);
var TI = "◻";
var ym = new de([["4panel", "◱"], ["3d", TI]]);
function oG(n, e) {
  let t;
  return e === void 0 ? t = n.navigationState.addRef() : t = new Vo(new Oo(n.navigationState.pose.position.addRef(), n.navigationState.pose.displayDimensionRenderInfo.addRef(), _o.makeRelative(n.navigationState.pose.orientation, e)), n.navigationState.zoomFactor.addRef(), n.navigationState.depthRange.addRef()), new Fu(n.chunkManager, n.layerManager, t, n.wireFrame);
}
function lc(n, e) {
  return oG(n, EI.get(e));
}
function lG(n) {
  return new de([["xy", lc(n, "xy")], ["xz", lc(n, "xz")], ["yz", lc(n, "yz")]]);
}
function kI(n) {
  return {
    crossSectionBackgroundColor: n.crossSectionBackgroundColor,
    perspectiveViewBackgroundColor: n.perspectiveViewBackgroundColor,
    selectionDetailsState: n.selectionDetailsState,
    mouseState: n.mouseState,
    layerManager: n.layerManager,
    showAxisLines: n.showAxisLines,
    wireFrame: n.wireFrame,
    visibleLayerRoles: n.visibleLayerRoles,
    selectedLayer: n.selectedLayer,
    visibility: n.visibility,
    scaleBarOptions: n.scaleBarOptions
  };
}
function My(n) {
  const e = n.viewer;
  return RZr(RZr({}, kI(e)), { navigationState: e.perspectiveNavigationState, inputEventMap: e.inputEventBindings.perspectiveView, orthographicProjection: n.specification.orthographicProjection, showScaleBar: e.showScaleBar, rpc: e.chunkManager.rpc });
}
function qu(n) {
  return RZr(RZr({}, kI(n)), { navigationState: n.navigationState, inputEventMap: n.inputEventBindings.sliceView });
}
function zo(n, e) {
  const t = e.navigationState;
  e.element.appendChild(n.registerDisposer(new aG(t.pose.displayDimensionRenderInfo.addRef(), t.zoomFactor, t.depthRange.addRef(), e instanceof af ? "px" : "vh")).element);
}
function Go(n, e, t) {
  const i = document.createElement("div");
  i.className = "neuroglancer-data-panel-layout-controls", n.registerDisposer(() => Ft(i));
  for (let r = 0; r < 2; ++r) {
    const s = t[Math.min(t.length - 1, r)];
    n.registerDisposer(be(e.element, r === 0 ? "toggle-layout" : "toggle-layout-alternative", (a) => {
      n.container.name = s, a.stopPropagation();
    }));
  }
  for (const r of t) {
    const s = document.createElement("button"), a = document.createElement("div");
    s.appendChild(a), a.textContent = ym.get(r), s.title = `Switch to ${r} layout.`, s.addEventListener("click", () => {
      n.container.name = r;
    }), i.appendChild(s);
  }
  e.element.appendChild(i);
}
function cG(n, e) {
  const t = new Fu(n.chunkManager, n.layerManager, e.navigationState.addRef(), n.wireFrame), i = () => {
    const r = e.width.value, s = e.height.value;
    t.projectionParameters.setViewport({
      width: r,
      height: s,
      logicalWidth: r,
      logicalHeight: s,
      visibleLeftFraction: 0,
      visibleTopFraction: 0,
      visibleWidthFraction: 1,
      visibleHeightFraction: 1
    });
  };
  return t.registerDisposer(e.width.changed.add(i)), t.registerDisposer(e.height.changed.add(i)), i(), t;
}
function Ny(n, e, t) {
  const i = new de();
  (() => {
    const s = new je();
    for (const l of t.values()) {
      if (s.add(l), i.has(l))
        continue;
      const d = cG(n, l);
      e.sliceViews.set(d, true), i.set(l, d);
    }
    for (const l of i) {
      var a = ce(l, 2);
      const d = a[0], u = a[1];
      s.has(d) || e.sliceViews.delete(u);
    }
  })();
}
var dG = class extends Z {
  constructor(e, t, i, r) {
    super(), this.container = e, this.rootElement = t, this.viewer = i;
    let s = lG(i), a = i.display;
    const l = RZr(RZr({}, My(e)), { showSliceViews: i.showPerspectiveSliceViews, showSliceViewsCheckbox: true }), d = RZr(RZr({}, qu(i)), { showScaleBar: i.showScaleBar }), u = RZr(RZr({}, qu(i)), { showScaleBar: new en(false, false) }), f = (v, y, w, C) => {
      const b = this.registerDisposer(new af(a, y, s.get(v), w));
      return C && zo(this, b), Go(this, b, [v, `${v}-3d`]), b;
    };
    let g = [vi(1, ta("column", [vi(1, ta("row", [vi(1, (v) => {
      f("xy", v, d, true);
    }), vi(1, (v) => {
      f("xz", v, u, false);
    })])), vi(1, ta("row", [vi(1, (v) => {
      let y = this.registerDisposer(new Ry(a, v, l));
      for (let w of s.values())
        y.sliceViews.set(w.addRef(), false);
      zo(this, y), Ny(i, y, r), Go(this, y, ["3d"]);
    }), vi(1, (v) => {
      f("yz", v, u, false);
    })]))]))];
    ta("row", g)(t);
  }
  disposed() {
    it(this.rootElement), super.disposed();
  }
};
var uG = class extends Z {
  constructor(e, t, i, r, s, a) {
    super(), this.container = e, this.rootElement = t, this.viewer = i, this.direction = r;
    let l = lc(i, s), d = i.display;
    const u = RZr(RZr({}, My(e)), { showSliceViews: i.showPerspectiveSliceViews, showSliceViewsCheckbox: true }), f = RZr(RZr({}, qu(i)), { showScaleBar: i.showScaleBar });
    vi(1, ta(r, [vi(1, (g) => {
      const v = this.registerDisposer(new af(d, g, l, f));
      zo(this, v), Go(this, v, [s, "4panel"]);
    }), vi(1, (g) => {
      let v = this.registerDisposer(new Ry(d, g, u));
      v.sliceViews.set(l.addRef(), false), Ny(i, v, a), zo(this, v), Go(this, v, ["3d", "4panel"]);
    })]))(t);
  }
  disposed() {
    it(this.rootElement), super.disposed();
  }
};
var hG = class extends Z {
  constructor(e, t, i, r) {
    super(), this.container = e, this.rootElement = t, this.viewer = i;
    let s = lc(i, r);
    const a = RZr(RZr({}, qu(i)), { showScaleBar: i.showScaleBar });
    ta("row", [vi(1, (l) => {
      const d = this.registerDisposer(new af(i.display, l, s, a));
      zo(this, d), Go(this, d, ["4panel", `${r}-3d`]);
    })])(t);
  }
  disposed() {
    it(this.rootElement), super.disposed();
  }
};
var fG = class extends Z {
  constructor(e, t, i, r) {
    super(), this.container = e, this.rootElement = t, this.viewer = i;
    let s = RZr(RZr({}, My(e)), { showSliceViews: new en(false, false) });
    ta("row", [vi(1, (a) => {
      const l = this.registerDisposer(new Ry(i.display, a, s));
      Ny(i, l, r), zo(this, l), Go(this, l, ["4panel"]);
    })])(t);
  }
  disposed() {
    it(this.rootElement), super.disposed();
  }
};
var Sm = new de([["4panel", {
  factory: (n, e, t, i) => new dG(n, e, t, i)
}], ["3d", {
  factory: (n, e, t, i) => new fG(n, e, t, i)
}]]);
for (const n of EI.keys()) {
  Sm.set(n, {
    factory: (t, i, r) => new hG(t, i, r, n)
  });
  const e = `${n}-3d`;
  ym.set(n, TI), ym.set(e, "◫"), Sm.set(e, {
    factory: (t, i, r, s) => new uG(t, i, r, "row", n, s)
  });
}
function II(n) {
  let e = Sm.get(n);
  if (e === void 0)
    throw new Error(`Invalid layout name: ${se(n)}.`);
  return e;
}
function pG(n) {
  return II(n), n;
}
var gG = class extends Z {
  constructor(e) {
    super(), this.width = new hn(1e3, dn), this.height = new hn(1e3, dn), this.changed = new Ee(), this.position = new wk(e.position.addRef()), this.position.changed.add(this.changed.dispatch), this.orientation = new om(e.pose.orientation.addRef()), this.orientation.changed.add(this.changed.dispatch), this.width.changed.add(this.changed.dispatch), this.height.changed.add(this.changed.dispatch), this.scale = new lm(e.zoomFactor.addRef(), e.zoomFactor.displayDimensionRenderInfo.addRef()), this.scale.changed.add(this.changed.dispatch), this.navigationState = this.registerDisposer(new Vo(new Oo(this.position.value, e.pose.displayDimensionRenderInfo.addRef(), this.orientation.value), this.scale.value, e.depthRange.addRef()));
  }
  restoreState(e) {
    pe(e), In(e, "width", this.width), In(e, "height", this.height), In(e, "position", Tc(this.position)), In(e, "orientation", this.orientation), In(e, "scale", this.scale), In(e, "zoom", Tc(this.scale));
  }
  reset() {
    this.width.reset(), this.height.reset(), this.position.reset(), this.orientation.reset(), this.scale.reset();
  }
  toJSON() {
    return {
      width: this.width.toJSON(),
      height: this.height.toJSON(),
      position: this.position.toJSON(),
      orientation: this.orientation.toJSON(),
      scale: this.scale.toJSON()
    };
  }
};
var mG = class extends Jv {
  constructor(e) {
    super((t, i) => t.registerDisposer(t.registerDisposer(i).changed.add(this.changed.dispatch))), this.parentNavigationState = e, this.registerDisposer(e);
  }
  restoreState(e) {
    pe(e);
    for (const t of un(e)) {
      const i = new gG(this.parentNavigationState);
      try {
        this.set(t, i.addRef()), i.restoreState(e[t]);
      } finally {
        i.dispose();
      }
    }
  }
  reset() {
    this.clear();
  }
  toJSON() {
    if (this.size === 0)
      return;
    const e = {};
    for (const i of this) {
      var t = ce(i, 2);
      const r = t[0], s = t[1];
      e[r] = s.toJSON();
    }
    return e;
  }
};
var vG = class extends Z {
  constructor(e, t) {
    super(), this.changed = new Ee(), this.orthographicProjection = new en(false), this.type = new hn(t, pG), this.type.changed.add(this.changed.dispatch), this.crossSections = this.registerDisposer(new mG(e.addRef())), this.crossSections.changed.add(this.changed.dispatch), this.orthographicProjection.changed.add(this.changed.dispatch), this.registerDisposer(e);
  }
  reset() {
    this.crossSections.clear(), this.orthographicProjection.reset(), this.type.reset();
  }
  restoreState(e) {
    this.crossSections.clear(), this.orthographicProjection.reset(), typeof e == "string" ? this.type.restoreState(e) : (pe(e), K(e, "type", (t) => this.type.restoreState(t)), K(e, "orthographicProjection", (t) => this.orthographicProjection.restoreState(t)), K(e, "crossSections", (t) => t !== void 0 && this.crossSections.restoreState(t)));
  }
  toJSON() {
    const e = this.type, t = this.crossSections, r = this.orthographicProjection.toJSON();
    return t.size === 0 && r === void 0 ? e.value : {
      type: e.value,
      crossSections: t.toJSON(),
      orthographicProjection: r
    };
  }
};
var yG = class extends Z {
  constructor(e, t) {
    super(), this.viewer = e, this.element = document.createElement("div"), this.specification = this.registerDisposer(new vG(this.viewer.navigationState.addRef(), t)), this.element.style.flex = "1";
    const i = this.registerCancellable(lt(() => this.updateLayout(), 0));
    this.specification.type.changed.add(i), be(this.element, "toggle-orthographic-projection", () => this.specification.orthographicProjection.toggle()), this.registerDisposer(this.viewer.display.updateStarted.add(() => i.flush())), i();
  }
  get name() {
    return this.specification.type.value;
  }
  set name(e) {
    this.specification.type.value = e;
  }
  get changed() {
    return this.specification.changed;
  }
  toJSON() {
    return this.specification.toJSON();
  }
  restoreState(e) {
    this.specification.restoreState(e);
  }
  reset() {
    this.specification.reset();
  }
  disposeLayout() {
    let e = this.layout;
    e !== void 0 && (e.dispose(), this.layout = void 0);
  }
  updateLayout() {
    this.disposeLayout(), this.layout = II(this.name).factory(this, this.element, this.viewer, this.specification.crossSections);
  }
  disposed() {
    this.disposeLayout(), super.disposed();
  }
};
var LI = new de();
function xa(n, e) {
  LI.set(n, e);
}
function SG(n) {
  const e = new aF(n.credentialsManager);
  for (const i of LI) {
    var t = ce(i, 2);
    const r = t[0], s = t[1];
    e.register(r, s(n));
  }
  return e;
}
var fa = class _fa extends Error {
  constructor(e, t, i, r) {
    let s = `Fetching ${se(e)} resulted in HTTP error ${t}`;
    i && (s += `: ${i}`), s += ".", super(s), this.name = "HttpError", this.message = s, this.url = e, this.status = t, this.statusText = i, r && (this.response = r);
  }
  static fromResponse(e) {
    return new _fa(e.url, e.status, e.statusText, e);
  }
  static fromRequestError(e, t) {
    if (t instanceof TypeError) {
      let i;
      return typeof e == "string" ? i = e : i = e.url, new _fa(i, 0, "Network or CORS error");
    }
    return t;
  }
};
async function qw(n, e) {
  let t;
  try {
    t = await fetch(n, e);
  } catch (i) {
    throw fa.fromRequestError(n, i);
  }
  if (!t.ok)
    throw fa.fromResponse(t);
  return t;
}
function of(n) {
  return n.arrayBuffer();
}
function Hi(n) {
  return n.json();
}
async function lr(n, e, t, i = Zt) {
  if (i === Zt) {
    const a = await qw(n, e);
    return await t(a);
  }
  const r = new AbortController(), s = i.add(() => r.abort());
  try {
    const a = await qw(n, RZr(RZr({}, e), { signal: r.signal }));
    return await t(a);
  } finally {
    s();
  }
}
function $o(n) {
  const e = /^([^:\/]+):\/\/([^\/]+)((?:\/.*)?)$/;
  let t = n.match(e);
  if (t === null)
    throw new Error(`Invalid URL: ${se(n)}`);
  return { protocol: t[1], host: t[2], path: t[3] };
}
function lf(n) {
  return n instanceof fa ? n.status === 0 || n.status === 403 || n.status === 404 : false;
}
var bG = 32;
var CG = 3;
var wG = 500;
var xG = 1e4;
function Kw(n) {
  return Math.min(2 ** n * wG, xG / 2) * (1 + Math.random());
}
async function _y(n, e, t, i, r, s, a = Zt) {
  let l;
  e:
    for (let d = 0; ; ) {
      XO(a), d > 1 && await new Bt((u) => setTimeout(u, Kw(d - 2))), l = await n.get(l, a);
      t:
        for (let u = 0; ; )
          try {
            return await lr(typeof e == "function" ? e(l.credentials) : e, r(l.credentials, t), i, a);
          } catch (f) {
            if (f instanceof fa) {
              if (s(f, l.credentials) === "refresh") {
                if (++d === CG)
                  throw f;
                continue e;
              }
              if (++u === bG)
                throw f;
              await new Bt((g) => setTimeout(g, Kw(u - 1)));
              continue t;
            }
            throw f;
          }
    }
}
function na(n, e, t, i, r = Zt) {
  return n === void 0 ? lr(e, t, i, r) : _y(n, e, t, i, (s, a) => {
    if (!s.accessToken)
      return a;
    const l = new Headers(a.headers);
    return l.set("Authorization", `${s.tokenType} ${s.accessToken}`), RZr(RZr({}, a), { headers: l });
  }, (s, a) => {
    const l = s.status;
    if (l === 401)
      return "refresh";
    if (l === 504 || l === 503)
      return "retry";
    if (l === 403 && !a.accessToken)
      return "refresh";
    throw s;
  }, r);
}
async function EG(n, e, t, i, r) {
  const s = await na(
    n,
    `${e}?prefix=${encodeURIComponent(t)}&delimiter=${encodeURIComponent(i)}`,
    /*init=*/
    {},
    (f) => f.text(),
    r
  ), a = new DOMParser().parseFromString(s, "application/xml"), l = a.evaluate('//*[name()="CommonPrefixes"]/*[name()="Prefix"]', a, null, XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE, null), d = [];
  for (let f = 0, g = l.snapshotLength; f < g; ++f)
    d.push(l.snapshotItem(f).textContent || "");
  const u = a.evaluate('//*[name()="Contents"]/*[name()="Key"]', a, null, XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE, null);
  for (let f = 0, g = u.snapshotLength; f < g; ++f)
    d.push(u.snapshotItem(f).textContent || "");
  return d;
}
async function bm(n, e, t, i, r) {
  if (!i.startsWith("/"))
    throw null;
  const a = await EG(n, t, i.substring(1), "/", r);
  let l = i.lastIndexOf("/");
  return {
    offset: l + e.length + 1,
    completions: a.map((d) => ({ value: d.substring(l) }))
  };
}
var TG = class extends id {
  constructor(e) {
    super(), this.bucket = e, this.get = nf(async () => {
      var t;
      const i = this.bucket, r = await lr(`https://s3.amazonaws.com/${i}?location`, {}, (d) => d.text()), a = new DOMParser().parseFromString(r, "application/xml").querySelector("LocationConstraint");
      if (a === null)
        throw new Error(`Unable to determine location of S3 bucket: ${i}`);
      return { region: ((t = a.textContent) === null || t === void 0 ? void 0 : t.trim()) || "us-east-1" };
    });
  }
};
var iu;
function DI(n) {
  return iu === void 0 && (iu = new gI(), iu.register("s3", (e) => new TG(e))), iu.getCredentialsProvider("s3", n);
}
async function kG(n, e, t, i, r, s = Zt) {
  const l = (await n.get()).credentials.region;
  return await lr(`https://${e}.s3.${l}.amazonaws.com${t}`, i, r, s);
}
async function IG(n, e, t) {
  const s = (await DI(n).get()).credentials.region;
  return await bm(void 0, `s3://${n}`, `https://${n}.s3.${s}.amazonaws.com`, e, t);
}
function LG(n, e) {
  return n.getCredentialsProvider("middleauthapp", new URL(e).origin);
}
function ru(n, e, t) {
  const i = /^\/([^\/]+)/, r = t.match(i);
  if (r !== null)
    return typeof NEUROGLANCER_PYTHON_INTEGRATION < "u" ? n.getCredentialsProvider("gcs", { bucket: r[1] }) : n.getCredentialsProvider("ngauth_gcs", { authServer: e, bucket: r[1] });
}
function rl(n, e) {
  const t = $o(n);
  switch (t.protocol) {
    case "gs":
    case "gs+json":
    case "gs+xml":
      return {
        credentialsProvider: typeof NEUROGLANCER_PYTHON_INTEGRATION < "u" ? e.getCredentialsProvider("gcs", { bucket: t.host }) : void 0,
        url: n
      };
    case "gs+ngauth+http":
      return {
        credentialsProvider: ru(e, `http://${t.host}`, t.path),
        url: "gs:/" + t.path
      };
    case "gs+ngauth+https":
      return {
        credentialsProvider: ru(e, `https://${t.host}`, t.path),
        url: "gs:/" + t.path
      };
    case "gs+xml+ngauth+http":
      return {
        credentialsProvider: ru(e, `http://${t.host}`, t.path),
        url: "gs+xml:/" + t.path
      };
    case "gs+xml+ngauth+https":
      return {
        credentialsProvider: ru(e, `https://${t.host}`, t.path),
        url: "gs+xml:/" + t.path
      };
    case "middleauth+https":
      return n = n.substr(11), {
        credentialsProvider: LG(e, n),
        url: n
      };
    case "s3":
      return {
        credentialsProvider: DI(t.host),
        url: n
      };
    default:
      return {
        credentialsProvider: void 0,
        url: n
      };
  }
}
async function Ea(n, e, t, i, r = Zt) {
  const s = $o(e);
  switch (s.protocol) {
    case "gs":
      return na(n, `https://www.googleapis.com/storage/v1/b/${s.host}/o/${encodeURIComponent(s.path.substring(1))}?alt=media&neuroglancerOrigin=${encodeURIComponent(location.origin)}`, t, i, r);
    case "gs+json":
      return na(n, `https://storage.googleapis.com/storage/v1/b/${s.host}/o/${encodeURIComponent(s.path.substring(1))}?alt=media`, t, i, r);
    case "gs+xml":
      return na(n, `https://storage.googleapis.com/${s.host}${s.path}`, t, i, r);
    case "s3":
      return kG(n, s.host, s.path, t, i, r);
    default:
      return na(n, e, t, i, r);
  }
}
var DG = typeof STATE_SERVERS < "u" && un(STATE_SERVERS).length > 0;
var PG = class extends Z {
  constructor(e) {
    if (super(), this.element = document.createElement("div"), this.button = Tt({ text: "Share", title: "Share State" }), typeof STATE_SERVERS > "u")
      throw new Error("Cannot construct StateSare without defining STATE_SERVERS");
    if (un(STATE_SERVERS).length > 1) {
      const i = document.createElement("select");
      i.style.marginRight = "5px", this.registerDisposer(e.selectedStateServer.changed.add(() => {
        const r = e.selectedStateServer.value;
        gm(STATE_SERVERS).map((s) => s.url).includes(r) && (i.value = r);
      })), this.registerEventListener(i, "change", () => {
        e.selectedStateServer.value = i.value;
      });
      for (let r of Jc(STATE_SERVERS)) {
        var t = ce(r, 2);
        let s = t[0], a = t[1];
        const l = document.createElement("option");
        l.textContent = s, l.value = a.url, l.selected = !!a.default, i.appendChild(l);
      }
      this.element.appendChild(i), this.selectStateServerElement = i;
    }
    this.element.appendChild(this.button), this.registerEventListener(this.button, "click", () => {
      const i = this.selectStateServerElement ? this.selectStateServerElement.value : gm(STATE_SERVERS)[0].url, r = new URL(i).protocol;
      var s = rl(i, il);
      const a = s.url, l = s.credentialsProvider;
      nt.forPromise(Ea(l, a, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: se(e.state.toJSON())
      }, Hi).then((d) => {
        const u = new URL(d);
        u.protocol = r;
        const f = `${window.location.origin}/#!${u}`;
        navigator.clipboard.writeText(f).then(() => {
          nt.showTemporaryMessage("Share link copied to clipboard");
        });
      }).catch(() => {
        nt.showTemporaryMessage("Could not access state server.", 4e3);
      }), {
        initialMessage: `Posting state to ${i}.`,
        delay: true,
        errorPrefix: ""
      });
    });
  }
  disposed() {
    this.element.remove(), super.disposed();
  }
};
function AG(n) {
  return n.startsWith("key") ? n.substring(3) : n.startsWith("digit") || n.startsWith("arrow") ? n.substring(5) : n;
}
function RG(n) {
  return n.split("+").map(AG).join("+");
}
var MG = RZr(RZr({}, Ca), { side: "left", row: 1 });
var NG = class {
  constructor() {
    this.location = new Ns(MG);
  }
  get changed() {
    return this.location.changed;
  }
  toJSON() {
    return ya(this.location.toJSON());
  }
  reset() {
    this.location.reset();
  }
  restoreState(e) {
    this.location.restoreState(e);
  }
};
var _G = class extends wa {
  constructor(e, t, i, r, s) {
    super(e, t.location), this.bindings = i, this.toolBinder = s, this.scroll = document.createElement("div"), this.addTitleBar({ title: "Help" });
    const a = document.createElement("div");
    a.classList.add("neuroglancer-help-body");
    const l = this.scroll;
    l.classList.add("neuroglancer-help-scroll-container"), a.appendChild(l), this.addBody(a);
    const d = this.registerCancellable(Ct(() => this.updateView()));
    this.registerDisposer(s.changed.add(d)), this.registerDisposer(r.layersChanged.add(d)), this.updateView();
  }
  updateView() {
    const e = this.scroll, t = this.bindings, i = this.toolBinder;
    it(e);
    const r = new de();
    function s(y, w) {
      for (const b of y.parents)
        b.label !== void 0 ? a(b.label, b) : s(b, w);
      for (const b of y.bindings.entries()) {
        var C = ce(b, 2);
        const E = C[0], L = C[1], R = E.indexOf(":"), _ = E.substring(R + 1);
        w.set(_, L.action);
      }
    }
    function a(y, w) {
      if (r.has(w))
        return;
      const C = {
        label: y,
        entries: new de()
      };
      s(w, C.entries), r.set(w, C);
    }
    for (const y of t) {
      var l = ce(y, 2);
      const w = l[0], C = l[1];
      a(w, C);
    }
    const d = (y, w) => {
      let C = document.createElement("h2");
      C.textContent = y, e.appendChild(C);
      for (const E of w) {
        var b = ce(E, 2);
        const L = b[0], R = b[1];
        let _ = document.createElement("div");
        _.className = "dt", _.textContent = RG(L);
        let A = document.createElement("div");
        A.className = "dd", A.textContent = R, e.appendChild(_), e.appendChild(A);
      }
    }, u = new de();
    for (const y of i.bindings) {
      var f = ce(y, 2);
      const w = f[0], C = f[1];
      let b = u.get(C.layer);
      b === void 0 && (b = [], u.set(C.layer, b)), b.push([`shift+key${w.toLowerCase()}`, C.description]);
    }
    const g = De(u.entries());
    g.length > 0 && (g[0][0].manager.root.layerManager.updateNonArchivedLayerIndices(), g.sort((y, w) => y[0].managedLayer.nonArchivedLayerIndex - w[0].managedLayer.nonArchivedLayerIndex));
    for (const y of g) {
      var v = ce(y, 2);
      const w = v[0], C = v[1];
      C.sort(), d(`Tool bindings for layer ${w.managedLayer.nonArchivedLayerIndex + 1}: ${w.managedLayer.name}`, C);
    }
    for (const y of r.values())
      d(y.label, y.entries);
  }
};
function OG(n, e) {
  n.style.display = "block";
  const t = n.offsetWidth, i = n.offsetHeight, r = document.documentElement.clientWidth, s = document.documentElement.clientHeight, a = document.documentElement.scrollLeft + Math.min(r - t, e.clientX), l = document.documentElement.scrollTop + Math.min(s - i, e.clientY);
  n.style.left = a + "px", n.style.top = l + "px";
}
var VG = class extends Z {
  constructor(e) {
    super(), this.element = document.createElement("div"), this.parentDisposers = new de(), this.disabledValue = false, this.opened = new Ee(), this.closed = new Ee();
    const t = this.element;
    t.className = "neuroglancer-context-menu", t.style.display = "none", t.tabIndex = -1, document.body.appendChild(t), e !== void 0 && this.registerParent(e);
  }
  get disabled() {
    return this.disabledValue;
  }
  set disabled(e) {
    this.disabledValue !== e && (this.disabledValue = e, e && this.hide());
  }
  get open() {
    return this.menuDisposer !== void 0;
  }
  registerParent(e) {
    const t = this.parentDisposers;
    t.has(e) || t.set(e, Vi(e, "contextmenu", (i) => {
      this.show(i), i.stopPropagation(), i.preventDefault();
    }));
  }
  show(e) {
    if (this.disabledValue)
      return;
    this.hide();
    const t = this.element, i = Vi(
      document,
      "mousedown",
      (a) => {
        a.target instanceof Node && !t.contains(a.target) && this.hide();
      },
      /*capture=*/
      true
    ), r = Vi(
      document,
      "keydown",
      (a) => {
        a.code === "Escape" && this.hide();
      },
      /*capture=*/
      true
    ), s = () => {
      r(), i(), t.style.display = "none";
    };
    this.opened.dispatch(), OG(t, e), this.menuDisposer = s;
  }
  unregisterParent(e) {
    const t = this.parentDisposers, i = t.get(e);
    i !== void 0 && (i(), t.delete(e));
  }
  disposed() {
    const e = this.parentDisposers;
    for (const t of e.values())
      t();
    e.clear(), Ft(this.element);
  }
  hide() {
    this.menuDisposer !== void 0 && (this.menuDisposer(), this.menuDisposer = void 0, this.closed.dispatch());
  }
};
function BG(n) {
  return E_(new TextEncoder().encode(n));
}
function FG(n) {
  return new TextDecoder().decode(T_(n));
}
function UG(n, e) {
  if (n.startsWith(e))
    try {
      const t = FG(n.substring(e.length));
      return JSON.parse(t);
    } catch {
      return;
    }
}
function zG(n, e) {
  return n + BG(se(e));
}
function GG(n, e) {
  for (const t of n) {
    const i = UG(t, e);
    if (i !== void 0)
      return { parameters: i, dragType: t };
  }
}
var PI;
function Oy(n, e) {
  return n.dataTransfer.dropEffect = e, PI = e, e;
}
function Cm() {
  return PI;
}
function $G(n) {
  return n.draggable = true, Vi(n, "dragstart", (e) => {
    e.stopPropagation(), e.preventDefault();
  });
}
var AI = "neuroglancer-layer\0";
var bi;
function RI(n, e) {
  var t;
  n.dataTransfer.setData(zG(AI, e.layers.map((s) => ({ name: s.name, visible: s.visible }))), se({ layers: e.layers.map((s) => s.toJSON()), layout: e.layoutSpec })), bi !== void 0 && bi.disposer();
  let i, r = () => {
    e.manager.unregisterDisposer(r);
    for (const s of e.layers)
      s.dispose();
    e.manager.dispose(), bi === i && (bi = void 0);
  };
  bi = i = {
    manager: e.manager.addRef(),
    layers: e.layers.map((s) => s.addRef()),
    layoutSpec: e.layoutSpec,
    isLayerListPanel: (t = e.isLayerListPanel) !== null && t !== void 0 ? t : false,
    disposer: r
  };
}
function cf(n = "none") {
  if (bi !== void 0) {
    if (n === "move") {
      const e = new je(bi.layers);
      bi.manager.layerManager.filter((t) => !e.has(t));
    }
    bi.disposer();
  }
}
function Ku(n) {
  return GG(n.dataTransfer.types, AI);
}
function MI(n) {
  if (bi !== void 0 && bi.manager.rootLayers === n.rootLayers)
    return bi;
}
var Zw = class {
  /**
   * Called in the 'drop' event handler to actually initialize the layers if they are external.
   * Returns false if any layers failed to initialized.
   */
  initializeExternalLayers(e) {
    const t = this.dragType;
    if (t !== void 0)
      try {
        var i = JSON.parse(e.dataTransfer.getData(t));
        const s = i.layers, a = i.layout;
        if (!Array.isArray(s) || this.numSourceLayers !== s.length)
          throw new Error("Invalid layer drop data");
        this.layoutSpec = a;
        for (const l of this.layers) {
          var r = ce(l, 2);
          const d = r[0], u = r[1];
          fW(d, s[u]);
        }
      } catch {
        return false;
      }
    return true;
  }
  updateArchiveStates(e) {
    const t = this.targetIsLayerListPanel, i = e.dataTransfer.dropEffect;
    for (const r of this.layers.keys()) {
      let s = t;
      t && !r.archived && i !== "copy" && this.sourceIsLayerListPanel && (s = false), (r.archived !== s || s && r.visible) && (r.archived = s, s && (r.visible = false), r.layerChanged.dispatch());
    }
  }
  get method() {
    return this.sourceManager !== void 0 ? this.manager === this.sourceManager && this.sourceIsLayerListPanel === this.targetIsLayerListPanel ? "move" : "link" : "copy";
  }
  compatibleWithMethod(e) {
    return this.method === e ? true : this.forceCopy && e !== "copy" ? false : !this.moveSupported && e === "move";
  }
};
function NI(n, e, t) {
  let i;
  n.shiftKey ? i = "copy" : n.ctrlKey && t ? i = "move" : i = e;
  let r = "";
  const s = (a) => {
    r !== "" && (r += ", "), r += a;
  };
  return e !== "none" && i !== e && (n.shiftKey ? s(`release SHIFT to ${e}`) : s(`release CONTROL to ${e}`)), i !== "copy" && s("hold SHIFT to copy"), i !== "move" && t && e !== "move" && s("hold CONTROL to move"), { dropEffect: i, dropEffectMessage: r };
}
function _I(n, e, t, i) {
  const r = MI(e);
  let s = false, a;
  return r === void 0 ? a = "copy" : i ? (r.isLayerListPanel || (s = true), a = "link") : r.manager === e && r.isLayerListPanel === t ? (a = "move", s = true) : t ? a = "none" : (r.isLayerListPanel || (s = true), a = "link"), NI(n, a, s);
}
function WG(n, e, t, i) {
  const r = _I(n, e, t, i);
  return Oy(n, r.dropEffect), r;
}
function wm(n, e, t) {
  const i = t.forceCopy, r = t.newTarget;
  var s = t.isLayerListPanel;
  const a = s === void 0 ? false : s, l = MI(e);
  if (!i && l !== void 0) {
    const u = !r && l.manager === e && (l.isLayerListPanel === a || l.isLayerListPanel), f = new Zw();
    return f.manager = e, f.numSourceLayers = l.layers.length, f.sourceManager = l.manager, f.targetIsLayerListPanel = a, f.sourceIsLayerListPanel = l.isLayerListPanel, f.moveSupported = u, f.layers = new de(), f.forceCopy = false, f.layoutSpec = l.layoutSpec, u ? l.layers.forEach((g, v) => {
      f.layers.set(g, v);
    }) : l.layers.forEach((g, v) => {
      (r || !e.layerManager.has(g)) && f.layers.set(g.addRef(), v);
    }), f;
  }
  const d = Ku(n);
  if (d !== void 0)
    try {
      const u = Je(d.parameters, (g, v) => {
        const y = K(g, "name", Le);
        let w = K(g, "visible", la);
        const C = new Uy(y, e);
        return a && (w = false), C.visible = w, C.archived = a, [C, v];
      }), f = new Zw();
      return f.numSourceLayers = u.length, f.targetIsLayerListPanel = a, f.sourceIsLayerListPanel = false, f.sourceManager = void 0, f.moveSupported = false, f.forceCopy = l !== void 0, f.manager = e, f.dragType = d.dragType, f.layers = new de(u), f;
    } catch {
    }
}
function xm(n, e) {
  return n.moveSupported ? false : (n.manager.layerManager.filter((t) => !n.layers.has(t)), e !== void 0 && n.layers.has(e));
}
function df(n, e, t, i = false) {
  function r(s, a) {
    let l = n.dropLayers;
    var d = a ? _I(
      s,
      n.manager,
      i,
      /*newTarget=*/
      false
    ) : { dropEffect: Cm(), dropEffectMessage: "" };
    const u = d.dropEffect, f = d.dropEffectMessage;
    if (u === void 0)
      return;
    Oy(s, u);
    let g = true;
    if (!(l !== void 0 && !l.compatibleWithMethod(u) && (n.dropLayers = void 0, xm(l, t)))) {
      if (l === void 0) {
        if (l = n.dropLayers = wm(s, n.manager, { forceCopy: u === "copy", newTarget: false, isLayerListPanel: i }), l === void 0)
          return;
        g = l.method === "move";
      }
      if (t !== void 0 && l.layers.has(t))
        return { dropLayers: l, dropEffect: u, dropEffectMessage: f };
      if (g) {
        const v = n.manager.layerManager, y = new je();
        let w = Number.POSITIVE_INFINITY;
        const C = v.managedLayers = v.managedLayers.filter((E, L) => l.layers.has(E) ? (w === Number.POSITIVE_INFINITY && (w = L), y.add(E), false) : true);
        let b;
        t !== void 0 ? (b = C.indexOf(t), w <= b && ++b) : b = C.length;
        for (const E of l.layers.keys())
          y.has(E) || l.layers.delete(E);
        C.splice(b, 0, ...l.layers.keys()), v.layersChanged.dispatch();
      } else {
        let v;
        t !== void 0 && (v = n.manager.layerManager.managedLayers.indexOf(t));
        for (const y of l.layers.keys())
          n.manager.add(y, v);
      }
      return { dropLayers: l, dropEffect: u, dropEffectMessage: f };
    }
  }
  e.addEventListener("dragenter", (s) => {
    r(
      s,
      /*updateDropEffect=*/
      true
    ) !== void 0 ? s.preventDefault() : Ln(n.element, "drop");
  }), e.addEventListener("drop", (s) => {
    var a;
    s.preventDefault(), n.dragEnterCount = 0, Ln(n.element, "drop");
    const l = (a = r(
      s,
      /*updateDropEffect=*/
      false
    )) === null || a === void 0 ? void 0 : a.dropLayers;
    if (n.dropLayers = void 0, l !== void 0) {
      if (!l.initializeExternalLayers(s)) {
        xm(l);
        return;
      }
      l.updateArchiveStates(s), cf(l.method === "move" ? void 0 : s.dataTransfer.dropEffect);
    }
  }), e.addEventListener("dragover", (s) => {
    const a = r(
      s,
      /*updateDropEffect=*/
      true
    );
    if (a === void 0) {
      Ln(n.element, "drop");
      return;
    }
    const l = a.dropLayers, d = a.dropEffect, u = a.dropEffectMessage, f = l.layers.size;
    let g = "";
    const v = l.numSourceLayers === 1 ? "" : "s", y = l.numSourceLayers;
    if (d === "none")
      g = `Cannot link dragged layer${v} here`;
    else {
      const w = y === f ? `${y}` : `${f}/${y}`;
      g = `Drop to ${d} ${w} layer${v}`;
    }
    u && (g += ` (${u})`), or(n.element, "drop", g), s.preventDefault(), s.stopPropagation();
  });
}
function OI(n, e, t, i) {
  e.draggable = true, e.addEventListener("dragstart", (r) => {
    or(e, "drag", "Drag layer to another layer bar/panel (including in another Neuroglancer window), or to the left/top/right/bottom edge of a layer group"), RI(r, {
      manager: n.manager,
      layers: [t],
      layoutSpec: i.getLayoutSpec(),
      isLayerListPanel: i.isLayerListPanel
    }), r.stopPropagation();
  }), e.addEventListener("dragend", () => {
    Ln(e, "drag"), cf();
  });
}
function VI(n) {
  n.element.addEventListener("dragenter", () => {
    ++n.dragEnterCount;
  }), n.element.addEventListener("dragleave", () => {
    if (--n.dragEnterCount !== 0)
      return;
    Ln(n.element, "drop");
    const e = n.dropLayers;
    e !== void 0 && (xm(e), n.manager.layerManager.layersChanged.dispatch(), n.dropLayers = void 0);
  });
}
var HG = "data:image/svg+xml;base64,PHN2ZyByb2xlPSJpbWciIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjI0IiBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIGFyaWEtbGFiZWxsZWRieT0iYmluSWNvblRpdGxlIj4KICAgIDx0aXRsZSBpZD0iYmluSWNvblRpdGxlIj5CaW48L3RpdGxlPiAgICAKICAgIDxwYXRoIGQ9Ik0xOSA2TDUgNk0xNCA1TDEwIDVNNiAxMEw2IDIwQzYgMjAuNjY2NjY2NyA2LjMzMzMzMzMzIDIxIDcgMjEgNy42NjY2NjY2NyAyMSAxMSAyMSAxNyAyMSAxNy42NjY2NjY3IDIxIDE4IDIwLjY2NjY2NjcgMTggMjAgMTggMTkuMzMzMzMzMyAxOCAxNiAxOCAxMCIvPgo8L3N2Zz4=";
function Cs(n = {}) {
  const e = Tt(RZr({ svg: HG }, n)), t = e.firstElementChild;
  return t.style.fill = "white", e;
}
var Xw = Y_;
var jG = z_;
var JG = wQn;
Xw(Xw.S, "String", {
  // 21.1.2.4 String.raw(callSite, ...substitutions)
  raw: function(e) {
    for (var t = jG(e.raw), i = JG(t.length), r = arguments.length, s = [], a = 0; i > a; )
      s.push(String(t[a++])), a < r && s.push(String(arguments[a]));
    return s.join("");
  }
});
var YG = xv.String.raw;
var qG = { default: YG, __esModule: true };
var Ql = Gs(qG);
var gu = "neuroglancer-position";
var Qw = vt.fromObject({
  arrowup: { action: "adjust-up" },
  arrowdown: { action: "adjust-down" },
  arrowleft: { action: "maybe-tab-backward", preventDefault: false },
  arrowright: { action: "maybe-tab-forward", preventDefault: false },
  tab: { action: "tab-forward" },
  "shift+tab": { action: "tab-backward" },
  wheel: { action: "adjust-via-wheel" },
  backspace: { action: "delete-backward", preventDefault: false },
  enter: { action: "commit" },
  escape: { action: "cancel" }
});
var KG = [(n) => n.nameElement, (n) => n.coordinate, (n) => n.scaleElement];
function mu(n, e) {
  const t = n.coordinateArrays[e];
  return t === void 0 ? t : n.units[e] != "" || n.scales[e] !== 1 ? null : t;
}
var ZG = class {
  constructor(e, t) {
    this.coordinateSpace = e, this.container = document.createElement("div"), this.nameContainer = document.createElement("span"), this.nameElement = document.createElement("input"), this.scaleContainer = document.createElement("span"), this.scaleElement = document.createElement("input"), this.coordinate = document.createElement("input"), this.coordinateLabel = document.createElement("span"), this.coordinateLabelWidth = 0, this.dropdownOwner = void 0, this.modified = false, this.draggingPosition = false, this.hasFocus = false;
    const i = this.container, r = this.scaleElement, s = this.scaleContainer, a = this.coordinate, l = this.nameElement, d = this.nameContainer, u = this.coordinateLabel;
    i.title = "", i.classList.add("neuroglancer-position-dimension"), i.draggable = true, i.tabIndex = -1, i.appendChild(d), i.appendChild(r), d.appendChild(l), d.title = "Drag to reorder, double click to rename.  Names ending in ' or ^ indicate dimensions local to the layer; names ending in ^ indicate channel dimensions (image layers only).", s.appendChild(r), l.classList.add("neuroglancer-position-dimension-name"), l.disabled = true, l.spellcheck = false, l.autocomplete = "off", l.required = true, l.placeholder = " ", s.classList.add("neuroglancer-position-dimension-scale-container"), r.classList.add("neuroglancer-position-dimension-scale"), r.disabled = true, r.spellcheck = false, r.autocomplete = "off", i.appendChild(s), i.appendChild(a), a.type = "text", a.classList.add("neuroglancer-position-dimension-coordinate"), a.spellcheck = false, a.autocomplete = "off", a.pattern = Ql`(-?\d+(?:\.(?:\d+)?)?)`;
    const f = mu(e, t);
    if (f != null) {
      let g = 0;
      for (const v of f.labels)
        g = Math.max(g, v.length);
      this.coordinateLabelWidth = g, u.style.width = `${g + 2}ch`, i.appendChild(u);
    }
    a.required = true, a.placeholder = " ", u.classList.add("neuroglancer-position-dimension-coordinate-label");
  }
};
function Em(n, e, t, i) {
  return Math.floor((n - e) * (i - 1) / (t - e));
}
function XG(n, e, t) {
  const i = n.boundingBoxes, r = n.bounds, s = Math.floor(r.lowerBounds[e]), a = Math.ceil(r.upperBounds[e] - 1);
  if (!kt(s) || !kt(a))
    return;
  const l = [], d = (f) => Em(f, s, a, t), u = n.rank;
  for (const f of i) {
    const g = R1(f, e, u);
    g !== void 0 && (g.lower = d(g.lower), g.upper = d(Math.ceil(g.upper - 1)), l.push(g));
  }
  return l.sort((f, g) => {
    const v = f.lower - g.lower;
    return v !== 0 ? v : g.upper - g.upper;
  }), AE(l, (f, g) => {
    if (g === 0)
      return true;
    const v = l[g - 1];
    return v.lower !== f.lower || v.upper !== f.upper;
  }), { lowerBound: s, upperBound: a, normalizedBounds: l };
}
var Tm = 10;
var km = 15;
var QG = 10;
var rg = Tm + km + QG;
function e$(n, e, t) {
  e.clearRect(0, 0, n.width, n.height);
  const i = t.normalizedBounds;
  function r(l) {
    e.fillRect(0, l, Tm, 1);
  }
  e.fillStyle = "#fff";
  for (const l of i) {
    const d = l.lower, u = l.upper;
    r(d), r(u);
  }
  const s = i.length;
  e.fillStyle = "#ccc";
  for (let l = 0; l < s; ++l) {
    var a = i[l];
    const d = a.lower, u = a.upper, f = Math.floor(l * km / s), g = Math.max(1, km / s);
    e.fillRect(f + Tm, d, g, u + 1 - d);
  }
}
function ex(n, e) {
  Kn(n, e.length + 1);
}
function tx(n) {
  const e = n.value;
  Kn(n), n.parentElement.dataset.isEmpty = e === "" ? "true" : "false";
}
var uf = class extends Z {
  constructor(e, t, { copyButton: i = true } = {}) {
    super(), this.position = e, this.combiner = t, this.element = document.createElement("div"), this.dimensionContainer = document.createElement("div"), this.coordinateSpace = void 0, this.dimensionWidgets = new de(), this.dimensionWidgetList = [], this.dragSource = void 0;
    const r = this.element, s = this.dimensionContainer;
    if (this.registerDisposer(e.coordinateSpace.changed.add(this.registerCancellable(Ct(() => this.updateDimensions())))), r.className = "neuroglancer-position-widget", s.style.display = "contents", r.appendChild(s), i) {
      const l = dr({
        title: "Copy position to clipboard",
        onClick: () => {
          const d = oi(this.getPositionText());
          nt.showTemporaryMessage(d ? "Position copied to clipboard" : "Failed to copy position to clipboard");
        }
      });
      l.addEventListener("dragstart", (d) => {
        d.dataTransfer.setData(gu, se({ position: e.toJSON(), dimensions: e.coordinateSpace.value.names })), d.dataTransfer.setData("text", this.getPositionText()), d.stopPropagation();
      }), l.draggable = true, r.appendChild(l);
    }
    this.registerDisposer(e.changed.add(this.registerCancellable(Ct(() => this.updateView()))));
    const a = this.registerDisposer(new Wi(r, Qw));
    a.allShortcutsAreGlobal = true, this.registerDisposer(new qr(r, Qw)), this.registerDisposer(be(r, "cancel", (l) => {
      this.coordinateSpace = void 0, this.updateView(), this.closeDropdown();
      const d = l.target;
      d instanceof HTMLElement && d.blur();
    })), this.updateView();
  }
  openRegularDropdown(e, t) {
    t.classList.add("neuroglancer-position-dimension-dropdown");
    const i = document.createElement("canvas"), r = i.getContext("2d"), s = document.createElement("div"), a = document.createElement("div");
    a.appendChild(s);
    const l = document.createTextNode("");
    s.appendChild(l);
    const d = document.createElement("div"), u = document.createElement("div");
    a.classList.add("neuroglancer-position-dimension-dropdown-lowerbound"), d.classList.add("neuroglancer-position-dimension-dropdown-upperbound"), u.classList.add("neuroglancer-position-dimension-dropdown-hoverposition"), t.appendChild(a), t.appendChild(d), t.appendChild(u), t.appendChild(i);
    const f = 100;
    i.width = rg, i.height = f, d.style.marginTop = `${f - 1}px`;
    let g, v, y;
    const w = () => {
      const R = this.dimensionWidgetList.indexOf(e);
      if (R === -1)
        return;
      const _ = e.coordinateSpace, A = XG(_, R, f);
      if (A === void 0 || _.bounds.lowerBounds[R] + 1 === _.bounds.upperBounds[R]) {
        t.style.display = "none", e.container.dataset.dropdownVisible = void 0;
        return;
      }
      e.container.dataset.dropdownVisible = "true", t.style.display = "";
      const I = A.lowerBound, P = A.upperBound;
      g = I, v = P, l.textContent = I.toString(), d.textContent = P.toString(), e$(i, r, A);
      const N = this.position.value[R];
      if (N >= I && N <= P && (r.fillStyle = "#f66", r.fillRect(0, Em(N, I, P, f), rg, 1)), y !== void 0 && y >= I && y <= P) {
        r.fillStyle = "#66f";
        const O = Em(y, I, P, f);
        r.fillRect(0, O, rg, 1), u.textContent = y.toString();
        const B = s.clientHeight;
        s.style.visibility = O > B ? "" : "hidden", d.style.visibility = O < f - B ? "" : "hidden", u.style.display = "", u.style.visibility = "visible", u.style.marginTop = `${O}px`;
      } else
        s.style.visibility = "", u.style.display = "none", d.style.visibility = "";
    }, C = e.dropdownOwner, b = C.registerCancellable(Ct(w));
    C.registerDisposer(this.position.changed.add(b));
    const E = (R) => {
      if (g === void 0 || v === void 0)
        return;
      const _ = i.getBoundingClientRect();
      let A = (R.clientY - _.top) / _.height;
      return A = Math.max(0, A), A = Math.min(1, A), Math.round(A * (v - g)) + g;
    }, L = (R) => {
      const _ = this.dimensionWidgetList.indexOf(e);
      if (_ === -1)
        return;
      const A = E(R);
      if (A === void 0)
        return;
      const I = this.position, P = I.value;
      P[_] = A + 0.5, e.modified = false, I.value = P;
    };
    i.addEventListener("pointermove", (R) => {
      y = E(R), b();
    }), i.addEventListener("pointerleave", () => {
      y = void 0, b();
    }), i.addEventListener("pointerdown", (R) => {
      R.preventDefault(), R.stopPropagation(), !(R.ctrlKey || R.altKey || R.shiftKey || R.metaKey) && (zi(R, (_) => {
        e.dropdownOwner !== void 0 && (y = void 0, L(_), b(), e.draggingPosition = true);
      }, () => {
        e.draggingPosition = false, this.updateDropdownVisibility(e);
      }), L(R));
    }), w();
  }
  openCoordinateArrayDropdown(e, t, i) {
    t.classList.add("neuroglancer-position-dimension-coordinate-dropdown");
    const r = i.coordinates, s = i.labels, a = r.length;
    t.style.setProperty("--neuroglancer-coordinate-label-width", `${e.coordinateLabelWidth}ch`);
    for (let l = 0; l < a; ++l) {
      const d = document.createElement("div");
      d.classList.add("neuroglancer-dimension-dropdown-coordinate-entry");
      const u = document.createElement("div");
      u.classList.add("neuroglancer-dimension-dropdown-coordinate");
      const f = document.createElement("div");
      f.classList.add("neuroglancer-dimension-dropdown-coordinate-label"), f.textContent = s[l], u.textContent = r[l].toString(), d.appendChild(u), d.appendChild(f), d.addEventListener("click", () => {
        const g = this.dimensionWidgetList.indexOf(e);
        if (g === -1)
          return;
        const v = this.position, y = v.value;
        y[g] = r[l] + 0.5, e.modified = false, v.value = y;
      }), t.appendChild(d);
    }
  }
  openDropdown(e) {
    if (e.dropdownOwner !== void 0)
      return;
    const t = this.dimensionWidgetList.indexOf(e);
    if (t === -1)
      return;
    this.closeDropdown();
    const i = e.dropdownOwner = new Z(), r = document.createElement("div");
    r.draggable = true, r.addEventListener("dragstart", (a) => {
      a.stopPropagation(), a.preventDefault();
    }), r.addEventListener("pointerenter", () => {
      e.hasFocus = true;
    }), r.tabIndex = -1, e.container.appendChild(r);
    const s = mu(e.coordinateSpace, t);
    s == null ? this.openRegularDropdown(e, r) : this.openCoordinateArrayDropdown(e, r, s), this.widgetWithOpenDropdown = e, i.registerDisposer(() => {
      Ft(r), e.dropdownOwner = void 0, delete e.container.dataset.dropdownVisible, this.widgetWithOpenDropdown = void 0;
    }), i.registerEventListener(document, "pointerdown", (a) => {
      const l = a.target;
      l instanceof Node && e.container.contains(l) || this.closeDropdown(e);
    }, { capture: true });
  }
  closeDropdown(e = this.widgetWithOpenDropdown) {
    if (e === void 0)
      return;
    const t = e.dropdownOwner;
    t !== void 0 && t.dispose();
  }
  pasteString(e, t) {
    for (; ; ) {
      e.coordinate.focus();
      const i = t.match(/^\s*(-?\d+(?:\.(?:\d+)?)?)((?:\s+(?![\s,]))|(?:\s*,\s*))?/);
      if (i === null)
        break;
      if (i[1] !== void 0 && document.execCommand("insertText", void 0, i[1]), i[2] !== void 0) {
        const r = this.dimensionWidgetList, s = r.indexOf(e);
        if (s === -1 || s + 1 === r.length)
          break;
        const a = t.substring(i[0].length);
        e = r[s + 1], t = a;
        continue;
      }
      break;
    }
  }
  reorderDimensionTo(e, t) {
    if (e === t)
      return;
    const i = this.position.coordinateSpace;
    i.value = z1(i.value, e, t);
  }
  updateDropdownVisibility(e) {
    e.hasFocus || e.draggingPosition ? this.openDropdown(e) : this.closeDropdown(e);
  }
  newDimension(e, t) {
    const i = new ZG(e, t);
    i.container.addEventListener("dragstart", (r) => {
      this.dragSource = i, r.stopPropagation(), r.dataTransfer.setData("neuroglancer-dimension", "");
    }), i.container.addEventListener("dragenter", (r) => {
      const s = this.dragSource;
      if (s === void 0 || s === i)
        return;
      const a = this.dimensionWidgetList, l = a.indexOf(s), d = a.indexOf(i);
      l === -1 || d === -1 || (r.preventDefault(), this.reorderDimensionTo(d, l));
    }), i.container.addEventListener("dragend", (r) => {
      this.dragSource === i && (this.dragSource = void 0);
    }), i.nameContainer.addEventListener("dblclick", () => {
      i.nameElement.disabled = false, i.nameElement.focus(), i.nameElement.select();
    }), i.scaleContainer.addEventListener("dblclick", () => {
      i.scaleElement.disabled = false, i.scaleElement.focus(), i.scaleElement.select();
    }), i.coordinate.addEventListener("focus", () => {
      i.coordinate.select();
    }), i.container.addEventListener("focusin", () => {
      i.hasFocus = true, this.updateDropdownVisibility(i);
    }), i.container.addEventListener("focusout", (r) => {
      const s = r.relatedTarget;
      s instanceof Node && i.container.contains(s) || (i.hasFocus = false, this.updateDropdownVisibility(i));
    }), i.container.addEventListener("click", (r) => {
      (!(r.target instanceof HTMLInputElement) || r.target.disabled) && i.coordinate.focus();
    }), i.coordinate.addEventListener("paste", (r) => {
      const s = i.coordinate, a = s.value, l = r.clipboardData;
      if (l === null)
        return;
      let d = l.getData("text"), u = s.selectionEnd, f = s.selectionStart;
      if (f !== 0 || u !== a.length) {
        f == null && (f = 0), u == null && (u = 0);
        const g = d.match(/[^\-0-9\.]/);
        g !== null && (d = d.substring(0, g.index)), d.length > 0 && document.execCommand("insertText", void 0, d);
      } else
        this.pasteString(i, d);
      r.preventDefault(), r.stopPropagation();
    }), i.coordinate.addEventListener("input", () => {
      i.modified = true;
      const r = i.coordinate, s = r.value;
      let a = r.selectionDirection, l = r.selectionEnd, d = r.selectionStart;
      d === null && (d = 0), l === null && (l = d);
      let u = "";
      const f = /[^\-0-9\.]/g;
      u += s.substring(0, d).replace(f, "");
      const g = u.length;
      u += s.substring(d, l).replace(f, "");
      const v = u.length;
      u += s.substring(l).replace(f, ""), r.value = u, r.selectionStart = g, r.selectionEnd = v, r.selectionDirection = a, ex(r, u), l === d && l === s.length && s.match(/^(-?\d+(?:\.(?:\d+)?)?)((?:\s+(?![\s,]))|(?:\s*,\s*))$/) && this.selectAdjacentCoordinate(i, 1);
    }), i.nameElement.addEventListener("input", () => {
      const r = i.nameElement;
      Kn(r), this.updateNameValidity();
    }), i.scaleElement.addEventListener("input", () => {
      const r = i.scaleElement;
      tx(r), this.updateScaleValidity(i);
    }), i.coordinate.addEventListener("blur", (r) => {
      const s = r.relatedTarget;
      this.dimensionWidgetList.some((a) => a.coordinate === s) || i.modified && this.updatePosition();
    }), i.nameElement.addEventListener("blur", (r) => {
      i.nameElement.disabled = true;
      const s = r.relatedTarget;
      this.dimensionWidgetList.some((a) => a.nameElement === s) || this.updateNames() || this.forceUpdateDimensions();
    }), i.scaleElement.addEventListener("blur", (r) => {
      i.scaleElement.disabled = true;
      const s = r.relatedTarget;
      this.dimensionWidgetList.some((a) => a.scaleElement === s) || this.updateScales() || this.forceUpdateDimensions();
    }), be(i.container, "adjust-via-wheel", (r) => {
      const a = r.detail.deltaY;
      a !== 0 && this.adjustDimension(i, Ec(a));
    }), be(i.container, "adjust-up", () => {
      this.adjustDimension(i, -1);
    }), be(i.container, "adjust-down", () => {
      this.adjustDimension(i, 1);
    });
    for (const r of KG) {
      const s = r(i);
      be(s, "maybe-tab-forward", (a) => {
        this.handleLeftRightMovement(a, i, 1, r);
      }), be(s, "maybe-tab-backward", (a) => {
        this.handleLeftRightMovement(a, i, -1, r);
      }), be(s, "tab-forward", () => {
        this.selectAdjacentField(i, 1, r);
      }), be(s, "tab-backward", () => {
        this.selectAdjacentField(i, -1, r);
      });
    }
    return be(i.coordinate, "commit", () => {
      this.updatePosition();
    }), be(i.nameElement, "commit", () => {
      this.updateNames();
    }), be(i.scaleElement, "commit", () => {
      this.updateScales();
    }), be(i.coordinate, "delete-backward", (r) => {
      r.stopPropagation();
      const s = i.coordinate;
      s.selectionStart === s.selectionEnd && s.selectionStart === 0 && (r.preventDefault(), this.selectAdjacentCoordinate(i, -1));
    }), i;
  }
  forceUpdateDimensions() {
    let e = this.position.coordinateSpace.value;
    e.valid || (e = zr), this.coordinateSpace = e;
    const t = this.dimensionWidgets, i = this.dimensionWidgetList;
    i.length = 0;
    var r = e;
    const s = r.names, a = r.ids, l = r.scales, d = r.units;
    ar(this.dimensionContainer, a.map((f, g) => {
      let v = t.get(f);
      v === void 0 ? (v = this.newDimension(e, g), t.set(f, v)) : v.coordinateSpace = e;
      const y = s[g];
      v.nameElement.value = y, delete v.nameElement.dataset.isValid, Kn(v.nameElement);
      const w = mu(e, g);
      w === void 0 ? v.container.dataset.coordinateArray = "none" : w === null ? v.container.dataset.coordinateArray = "invalid" : v.container.dataset.coordinateArray = "valid", v.scaleContainer.title = "Drag to reorder, double click to change scale", w === null && (v.scaleContainer.title += ".  Coordinate array disabled.  To use the coordinate array, remove the unit/scale.");
      var C = I1(l[g], d[g]);
      const b = C.scale, E = C.prefix, L = C.unit, R = `${b}${E}${L}`;
      return v.scaleElement.value = R, delete v.scaleElement.dataset.isValid, tx(v.scaleElement), i.push(v), v.container;
    }));
    for (const f of t) {
      var u = ce(f, 2);
      const g = u[0], v = u[1];
      v.coordinateSpace !== e && (this.closeDropdown(v), t.delete(g));
    }
  }
  updateDimensions() {
    this.position.coordinateSpace.value !== this.coordinateSpace && this.forceUpdateDimensions();
  }
  selectAdjacentField(e, t, i) {
    const r = this.dimensionWidgetList;
    let s = r.indexOf(e);
    if (s !== -1)
      for (; ; ) {
        if (s += t, s < 0 || s >= r.length)
          return false;
        const a = r[s], l = i(a);
        if (l.style.display !== "none")
          return l.disabled = false, l.focus(), l.selectionStart = 0, l.selectionEnd = l.value.length, l.selectionDirection = t === 1 ? "forward" : "backward", true;
      }
  }
  selectAdjacentCoordinate(e, t) {
    return this.selectAdjacentField(e, t, (i) => i.coordinate);
  }
  handleLeftRightMovement(e, t, i, r) {
    e.stopPropagation();
    const s = r(t);
    s.selectionStart !== s.selectionEnd || s.selectionStart !== (i === 1 ? s.value.length : 0) || this.selectAdjacentField(t, i, r) && e.preventDefault();
  }
  updateNameValidity() {
    const e = this.dimensionWidgetList, t = e.map((s) => s.nameElement.value), i = t.length, r = this.combiner.getRenameValidity(t);
    for (let s = 0; s < i; ++s)
      e[s].nameElement.dataset.isValid = r[s] === false ? "false" : "true";
  }
  updateScaleValidity(e) {
    const t = pc(e.scaleElement.value) !== void 0;
    e.scaleElement.dataset.isValid = t.toString();
  }
  adjustDimension(e, t) {
    const i = this.dimensionWidgetList.indexOf(e);
    if (i === -1)
      return;
    this.updatePosition();
    const r = this.position;
    if (!r.valid)
      return;
    const a = r.coordinateSpace.value.bounds, l = Float32Array.from(r.value);
    let d = Math.floor(l[i] + t);
    if (t > 0) {
      const u = a.upperBounds[i];
      kt(u) && (d = Math.min(d, Math.ceil(u - 1)));
    } else {
      const u = a.lowerBounds[i];
      kt(u) && (d = Math.max(d, Math.floor(u)));
    }
    l[i] = d + 0.5, this.position.value = l, this.updateView();
  }
  updatePosition() {
    const e = this.dimensionWidgetList, t = this.position, i = t.value;
    if (i === void 0)
      return;
    const r = e.length;
    for (let s = 0; s < r; ++s) {
      const a = e[s];
      a.modified = false;
      const l = Number(a.coordinate.value);
      kt(l) && (i[s] = l + (jn(l) ? 0.5 : 0));
    }
    t.value = i;
  }
  updateNames() {
    const e = this.dimensionWidgetList, t = this.position.coordinateSpace, i = t.value, r = e.map((d) => d.nameElement.value);
    if (this.combiner.getRenameValidity(r).includes(false))
      return false;
    const s = i.names;
    if (Fe(s, r))
      return false;
    const a = i.timestamps.map((d, u) => s[u] === r[u] ? d : Date.now()), l = RZr(RZr({}, i), { names: r, timestamps: a });
    return t.value = l, true;
  }
  updateScales() {
    const e = this.dimensionWidgetList, t = this.position.coordinateSpace, i = t.value, r = e.map((g) => pc(g.scaleElement.value));
    if (r.includes(void 0))
      return false;
    const s = Float64Array.from(r, (g) => g.scale), a = De(r, (g) => g.unit), l = i.scales, d = i.units;
    if (Fe(l, s) && Fe(d, a))
      return false;
    const u = i.timestamps.map((g, v) => s[v] === l[v] && a[v] === d[v] ? g : Date.now()), f = mt({
      valid: i.valid,
      rank: i.rank,
      scales: s,
      units: a,
      timestamps: u,
      ids: i.ids,
      names: i.names,
      boundingBoxes: i.boundingBoxes,
      coordinateArrays: i.coordinateArrays
    });
    return t.value = f, true;
  }
  getPositionText() {
    const e = this.position;
    return e.valid ? e.value.map((t) => Math.floor(t)).join(", ") : "";
  }
  updateView() {
    this.updateDimensions();
    const e = this.position.value, t = this.dimensionWidgetList, i = t.length;
    if (e === void 0)
      return;
    const r = this.coordinateSpace;
    for (let s = 0; s < i; ++s) {
      const a = t[s], l = a.coordinate, d = Math.floor(e[s]), u = d.toString();
      ex(l, u), l.value = u;
      const f = mu(r, s);
      let g = "";
      if (f != null) {
        const y = f.coordinates, w = pN(y, d, (C, b) => C - b);
        w !== y.length && (g = f.labels[w]);
      }
      const v = a.coordinateLabel;
      v.textContent = g;
    }
  }
  disposed() {
    this.closeDropdown(), Ft(this.element), super.disposed();
  }
};
var t$ = class extends Z {
  constructor(e, t, i) {
    super(), this.element = e, this.mouseState = t, this.coordinateSpace = i, this.tempPosition = _e(), e.className = "neuroglancer-mouse-position-widget";
    const r = this.registerCancellable(Ct(() => this.updateView()));
    this.registerDisposer(t.changed.add(r)), this.registerDisposer(i.changed.add(r));
  }
  updateView() {
    let e = "";
    const t = this.mouseState, i = this.coordinateSpace.value;
    if (t.active && i !== void 0) {
      const r = t.position, s = i.rank, a = i.names;
      for (let l = 0; l < s; ++l)
        l !== 0 && (e += "  "), e += `${a[l]} ${Math.floor(r[l])}`;
    }
    this.element.textContent = e;
  }
  disposed() {
    Ft(this.element), super.disposed();
  }
};
var n$ = class extends Z {
  constructor(e, t) {
    var i;
    super(), this.layer = e, this.panel = t, this.element = document.createElement("div"), this.layerNumberElement = document.createElement("div"), this.labelElement = document.createElement("div"), this.visibleProgress = document.createElement("div"), this.prefetchProgress = document.createElement("div"), this.labelElementText = document.createTextNode(""), this.valueElement = document.createElement("div"), this.maxLength = 0, this.prevValueText = "";
    const r = this.element, s = this.labelElement, a = this.layerNumberElement, l = this.valueElement, d = this.visibleProgress, u = this.prefetchProgress, f = this.labelElementText;
    r.className = "neuroglancer-layer-item neuroglancer-noselect", r.appendChild(d), r.appendChild(u), s.className = "neuroglancer-layer-item-label", s.appendChild(f), d.className = "neuroglancer-layer-item-visible-progress", u.className = "neuroglancer-layer-item-prefetch-progress", a.className = "neuroglancer-layer-item-number", l.className = "neuroglancer-layer-item-value";
    const g = document.createElement("div");
    g.className = "neuroglancer-layer-item-value-container";
    const v = document.createElement("div");
    v.className = "neuroglancer-layer-item-button-container";
    const y = Cy();
    y.title = "Remove layer from this layer group";
    const w = Y3();
    w.title = "Refresh data", this.registerEventListener(w, "click", (E) => {
      E.stopPropagation();
      const L = this.layer.layer;
      if (L && L.dataSources && L.dataSources[0].loadState) {
        const R = L.dataSources[0].loadState;
        if (R instanceof fy) {
          const _ = R.dataSource;
          if (_ && _.subsources[0] && _.subsources[0].subsource) {
            const A = _.subsources[0].subsource.annotation;
            (A == null ? void 0 : A.invalidateCache) && A.invalidateCache();
          }
        }
      }
    }), y.addEventListener("click", (E) => {
      this.panel.layerManager === this.panel.manager.rootLayers ? this.layer.setArchived(true) : this.layer.containers.size > 2 ? this.panel.layerManager.removeManagedLayer(this.layer) : this.layer.setArchived(true), E.stopPropagation();
    });
    const C = Cs();
    C.title = "Delete this layer", C.addEventListener("click", (E) => {
      ll(this.layer), E.stopPropagation();
    }), r.appendChild(a), g.appendChild(l), g.appendChild(v), v.appendChild(y), v.appendChild(C), r.appendChild(s), !((i = e.layer) === null || i === void 0) && i.allowingRefresh && r.appendChild(w), r.appendChild(g);
    const b = this.registerDisposer(new uf(e.localPosition, e.localCoordinateSpaceCombiner, { copyButton: false }));
    r.appendChild(b.element), b.element.addEventListener("click", (E) => {
      E.stopPropagation();
    }), b.element.addEventListener("dblclick", (E) => {
      E.stopPropagation();
    }), r.addEventListener("click", (E) => {
      E.ctrlKey ? t.selectedLayer.toggle(e) : E.altKey ? e.pickEnabled = !e.pickEnabled : e.setVisible(!e.visible);
    }), r.addEventListener("contextmenu", (E) => {
      t.selectedLayer.layer = e, t.selectedLayer.visible = true, E.stopPropagation(), E.preventDefault();
    }), OI(t, r, e, { getLayoutSpec: () => t.getLayoutSpecForDrag() }), df(this.panel, r, this.layer);
  }
  update() {
    const e = this.layer, t = this.element;
    this.labelElementText.textContent = e.name, t.dataset.visible = e.visible.toString(), t.dataset.selected = (e === this.panel.selectedLayer.layer).toString(), t.dataset.pick = e.pickEnabled.toString();
    let i = `Click to ${e.visible ? "hide" : "show"}, control+click to show side panel`;
    e.supportsPickOption && (i += `, alt+click to ${e.pickEnabled ? "disable" : "enable"} spatial object selection`), i += ", drag to move, shift+drag to copy", t.title = i;
  }
  disposed() {
    this.element.remove(), super.disposed();
  }
};
var i$ = class extends Z {
  constructor(e, t, i, r, s, a) {
    super(), this.display = e, this.manager = t, this.viewerNavigationState = i, this.selectedLayer = r, this.getLayoutSpecForDrag = s, this.showLayerHoverValues = a, this.layerWidgets = new de(), this.element = document.createElement("div"), this.layerUpdateNeeded = true, this.valueUpdateNeeded = false, this.layerWidgetInsertionPoint = document.createElement("div"), this.positionWidget = this.registerDisposer(new uf(this.viewerNavigationState.position.value, this.manager.root.coordinateSpaceCombiner)), this.dragEnterCount = 0, this.scheduleUpdate = this.registerCancellable(Ct(() => this.update())), this.registerDisposer(r);
    const l = this.element;
    l.className = "neuroglancer-layer-panel", this.registerDisposer(t.layerSelectedValues.changed.add(() => {
      this.handleLayerValuesChanged();
    })), this.registerDisposer(t.layerManager.layersChanged.add(() => {
      this.handleLayersChanged();
    })), this.registerDisposer(r.changed.add(() => {
      this.handleLayersChanged();
    })), this.registerDisposer(a.changed.add(() => {
      this.handleLayerItemValueChanged();
    })), this.element.dataset.showHoverValues = this.showLayerHoverValues.value.toString(), this.layerWidgetInsertionPoint.style.display = "none", this.element.appendChild(this.layerWidgetInsertionPoint);
    let d = Tt({
      svg: Hu,
      title: "Click to add layer, control+click/right click/⌘+click to add local annotation layer."
    });
    d.classList.add("neuroglancer-layer-add-button");
    let u = this.dropZone = document.createElement("div");
    u.className = "neuroglancer-layer-panel-drop-zone";
    const f = (v) => {
      if (v.ctrlKey || v.metaKey || v.type === "contextmenu") {
        const y = XI(this.manager, "annotation", { type: "annotation", source: "local://annotations" });
        this.manager.add(y), this.selectedLayer.layer = y, this.selectedLayer.visible = true;
      } else
        this.addLayerMenu();
    };
    this.registerEventListener(d, "click", f), this.registerEventListener(d, "contextmenu", f), l.appendChild(d), l.appendChild(u), this.registerDisposer($G(d)), l.appendChild(this.positionWidget.element);
    const g = () => {
      const v = this.viewerNavigationState.position.link.value;
      this.positionWidget.element.style.display = v === Wt.LINKED ? "none" : "";
    };
    this.registerDisposer(this.viewerNavigationState.position.link.changed.add(g)), g(), this.update(), this.updateChunkStatistics(), VI(this), df(this, u, void 0), this.registerDisposer(e.updateStarted.add(() => this.updateLayers())), this.registerDisposer(t.chunkManager.layerChunkStatisticsUpdated.add(this.registerCancellable(Ct(() => this.updateChunkStatistics()))));
  }
  get layerManager() {
    return this.manager.layerManager;
  }
  disposed() {
    this.layerWidgets.forEach((e) => e.dispose()), this.layerWidgets = void 0, Ft(this.element), super.disposed();
  }
  handleLayersChanged() {
    this.layerUpdateNeeded = true, this.handleLayerValuesChanged();
  }
  handleLayerValuesChanged() {
    this.valueUpdateNeeded || (this.valueUpdateNeeded = true, this.scheduleUpdate());
  }
  handleLayerItemValueChanged() {
    this.element.dataset.showHoverValues = this.showLayerHoverValues.value.toString();
  }
  update() {
    if (this.valueUpdateNeeded = false, this.updateLayers(), this.showLayerHoverValues.value === false)
      return;
    let e = this.manager.layerSelectedValues;
    for (let i of this.layerWidgets) {
      var t = ce(i, 2);
      let r = t[0], s = t[1], a = r.layer, l = "";
      if (a !== null) {
        let d = e.get(a);
        if (d !== void 0) {
          const u = d.value;
          u !== void 0 && (l = "" + u);
        }
      }
      if (l !== s.prevValueText) {
        if (s.prevValueText = l, l.length > s.maxLength) {
          const d = s.maxLength = l.length;
          s.valueElement.style.width = `${d}ch`;
        }
        s.valueElement.textContent = l;
      }
    }
  }
  updateChunkStatistics() {
    for (const t of this.layerWidgets) {
      var e = ce(t, 2);
      const i = e[0], r = e[1];
      let s = 0, a = 0, l = 0, d = 0;
      const u = i.layer;
      if (u !== null)
        for (const f of u.renderLayers) {
          const g = f.layerChunkProgressInfo;
          s += g.numVisibleChunksNeeded, a += g.numVisibleChunksAvailable, l += g.numPrefetchChunksNeeded, d += g.numPrefetchChunksAvailable;
        }
      r.visibleProgress.style.width = `${a / Math.max(1, s) * 100}%`, r.prefetchProgress.style.width = `${d / Math.max(1, l) * 100}%`;
    }
  }
  updateLayers() {
    var e;
    if (!this.layerUpdateNeeded)
      return;
    this.layerUpdateNeeded = false;
    let t = this.element, i = new je(), r = this.layerWidgetInsertionPoint.nextElementSibling;
    this.manager.rootLayers.updateNonArchivedLayerIndices();
    for (const l of this.manager.layerManager.managedLayers) {
      if (l.archived && !(!((e = this.dropLayers) === null || e === void 0) && e.layers.has(l)))
        continue;
      i.add(l);
      let d = this.layerWidgets.get(l);
      const u = l.nonArchivedLayerIndex;
      d === void 0 && (d = new n$(l, this), this.layerWidgets.set(l, d)), d.layerNumberElement.textContent = "" + (1 + u), d.update();
      var s = d;
      let f = s.element;
      f !== r && t.insertBefore(d.element, r), r = f.nextElementSibling;
    }
    for (let l of this.layerWidgets) {
      var a = ce(l, 2);
      let d = a[0], u = a[1];
      i.has(d) || (this.layerWidgets.delete(d), u.dispose());
    }
  }
  addLayerMenu() {
    sL(this.manager, this.selectedLayer);
  }
};
function BI(n, e) {
  const t = Vi(n, "drop", (a) => {
    if (a.preventDefault(), a.dataTransfer.types.indexOf(gu) !== -1) {
      a.stopPropagation();
      const l = pe(JSON.parse(a.dataTransfer.getData(gu))), d = K(l, "dimensions", zv), u = K(l, "position", (y) => Je(y, Lt));
      if (u.length !== d.length)
        throw new Error("length mismatch between position and dimensions");
      const f = u.length, g = e.coordinateSpace.value.names, v = e.value;
      for (let y = 0; y < f; ++y) {
        const w = g.indexOf(d[y]);
        w !== -1 && (v[w] = u[y]);
      }
      e.changed.dispatch();
    }
  }), i = (a) => {
    a.dataTransfer.types.indexOf(gu) !== -1 && (a.dataTransfer.dropEffect = "link", a.preventDefault(), a.stopPropagation());
  }, r = Vi(n, "dragenter", i), s = Vi(n, "dragover", i);
  return () => {
    r(), s(), t();
  };
}
var FI = class extends Z {
  constructor(e) {
    super(), this.model = e, this.element = document.createElement("select"), this.valueIndexMap = new de();
    const t = this.element, i = this.valueIndexMap;
    let r = 0;
    for (const s of un(e.enumType))
      if (isNaN(Number(s))) {
        const a = document.createElement("option");
        a.textContent = a.value = s.toLowerCase(), t.appendChild(a), i.set(e.enumType[s], r), ++r;
      }
    this.registerDisposer(e.changed.add(() => this.updateView())), this.registerEventListener(t, "change", () => this.updateModel()), this.registerEventListener(t, "wheel", (s) => {
      s.preventDefault(), s.stopPropagation(), this.adjustViaWheel(s);
    }), this.updateView();
  }
  adjustViaWheel(e) {
    const t = this.element;
    let i = e.deltaY;
    i > 0 ? (t.selectedIndex = (t.options.length + t.selectedIndex - 1) % t.options.length, this.updateModel()) : i < 0 && (t.selectedIndex = (t.options.length + t.selectedIndex + 1) % t.options.length, this.updateModel());
  }
  updateView() {
    const e = this.element;
    e.selectedIndex = this.valueIndexMap.get(this.model.value);
  }
  updateModel() {
    this.model.restoreState(this.element.value);
  }
};
var Vy = "neuroglancer-layer-group-viewer";
function nx(n) {
  return n.dataTransfer.types.indexOf(Vy) !== -1;
}
var Qi;
function r$(n) {
  if (Qi && Qi.viewer.layerSpecification.rootLayers === n.rootLayers)
    return Qi.viewer;
}
function s$(n, e) {
  const t = r$(e);
  let i, r = false;
  return t === void 0 || t.layerSpecification === t.layerSpecification.root ? i = "copy" : (r = true, i = "move"), NI(n, i, r);
}
var a$ = class extends Z {
  constructor(e) {
    super(), this.relativeDisplayScales = new e3(e.navigationState.pose.relativeDisplayScales.addRef()), this.displayDimensions = new n3(e.navigationState.pose.displayDimensions.addRef()), this.position = new wk(e.navigationState.position.addRef()), this.crossSectionOrientation = new om(e.navigationState.pose.orientation.addRef()), this.displayDimensionRenderInfo = this.registerDisposer(new Ek(this.relativeDisplayScales.value, this.displayDimensions.value)), this.crossSectionScale = new lm(e.navigationState.zoomFactor.addRef(), this.displayDimensionRenderInfo.addRef()), this.crossSectionDepthRange = new nw(e.navigationState.depthRange.addRef(), this.displayDimensionRenderInfo), this.projectionDepthRange = new nw(e.perspectiveNavigationState.depthRange.addRef(), this.displayDimensionRenderInfo), this.navigationState = this.registerDisposer(new Vo(new Oo(this.position.value, this.displayDimensionRenderInfo.addRef(), this.crossSectionOrientation.value), this.crossSectionScale.value, this.crossSectionDepthRange.value)), this.projectionOrientation = new om(e.perspectiveNavigationState.pose.orientation.addRef()), this.projectionScale = new lm(e.perspectiveNavigationState.zoomFactor.addRef(), this.displayDimensionRenderInfo.addRef()), this.projectionNavigationState = this.registerDisposer(new Vo(new Oo(this.position.value.addRef(), this.displayDimensionRenderInfo.addRef(), this.projectionOrientation.value), this.projectionScale.value, this.projectionDepthRange.value));
  }
  copyToParent() {
    for (const e of [this.relativeDisplayScales, this.displayDimensions, this.position, this.crossSectionOrientation, this.crossSectionScale, this.projectionOrientation, this.projectionScale])
      e.copyToPeer();
  }
  register(e) {
    e.add("dimensionRenderScales", this.relativeDisplayScales), e.add("displayDimensions", this.displayDimensions), e.add("position", Tc(this.position)), e.add("crossSectionOrientation", this.crossSectionOrientation), e.add("crossSectionScale", this.crossSectionScale), e.add("crossSectionDepth", this.crossSectionDepthRange), e.add("projectionOrientation", this.projectionOrientation), e.add("projectionScale", this.projectionScale), e.add("projectionDepth", this.projectionDepthRange);
  }
};
function o$(n, e) {
  const t = new VG(n), i = t.element;
  i.classList.add("neuroglancer-layer-group-viewer-context-menu");
  const r = document.createElement("button");
  r.textContent = "Remove layer group", i.appendChild(r), t.registerEventListener(r, "click", () => {
    e.layerSpecification.layerManager.clear();
  });
  const s = e.viewerNavigationState;
  for (const l of [["Render scale factors", s.relativeDisplayScales.link], ["Render dimensions", s.displayDimensions.link], ["Position", s.position.link], ["Cross-section orientation", s.crossSectionOrientation.link], ["Cross-section zoom", s.crossSectionScale.link], ["Cross-section depth range", s.crossSectionDepthRange.link], ["3-D projection orientation", s.projectionOrientation.link], ["3-D projection zoom", s.projectionScale.link], ["3-D projection depth range", s.projectionDepthRange.link]]) {
    var a = ce(l, 2);
    const d = a[0], u = a[1], f = t.registerDisposer(new FI(u)), g = document.createElement("label");
    g.style.display = "flex", g.style.flexDirection = "row", g.style.whiteSpace = "nowrap", g.textContent = d, g.appendChild(f.element), i.appendChild(g);
  }
  return t;
}
var Zu = class extends Z {
  constructor(e, t, i = {}) {
    super(), this.element = e, this.viewerState = t, this.state = new $h(), this.options = RZr({ showLayerPanel: new en(true), showViewerMenu: false, showLayerHoverValues: new en(true) }, i), this.layerSpecification = this.registerDisposer(t.layerSpecification), this.viewerNavigationState = this.registerDisposer(new a$(t)), this.viewerNavigationState.register(this.state), this.layerSpecification instanceof eL ? this.state.add("layers", this.layerSpecification) : this.state.add("layers", {
      changed: this.layerSpecification.changed,
      toJSON: () => this.layerSpecification.layerManager.managedLayers.map((r) => r.name),
      reset: () => {
        throw new Error("not implemented");
      },
      restoreState: () => {
        throw new Error("not implemented");
      }
    }), e.classList.add("neuroglancer-layer-group-viewer"), this.registerDisposer(new sf(e)), this.layout = this.registerDisposer(new yG(this, "xy")), this.state.add("layout", this.layout), this.registerActionBindings(), this.registerDisposer(this.layerManager.useDirectly()), this.registerDisposer(BI(e, this.navigationState.position)), this.registerDisposer(this.options.showLayerPanel.changed.add(this.registerCancellable(lt(() => this.updateUI(), 0)))), this.makeUI();
  }
  get perspectiveNavigationState() {
    return this.viewerNavigationState.projectionNavigationState;
  }
  get navigationState() {
    return this.viewerNavigationState.navigationState;
  }
  get selectionDetailsState() {
    return this.layerSpecification.root.selectionState;
  }
  // FIXME: don't make viewerState a property, just make these things properties directly
  get display() {
    return this.viewerState.display;
  }
  get selectedLayer() {
    return this.viewerState.selectedLayer;
  }
  get layerManager() {
    return this.layerSpecification.layerManager;
  }
  get chunkManager() {
    return this.layerSpecification.chunkManager;
  }
  get mouseState() {
    return this.viewerState.mouseState;
  }
  get showAxisLines() {
    return this.viewerState.showAxisLines;
  }
  get wireFrame() {
    return this.viewerState.wireFrame;
  }
  get showScaleBar() {
    return this.viewerState.showScaleBar;
  }
  get showPerspectiveSliceViews() {
    return this.viewerState.showPerspectiveSliceViews;
  }
  get inputEventBindings() {
    return this.viewerState.inputEventBindings;
  }
  get visibility() {
    return this.viewerState.visibility;
  }
  get visibleLayerRoles() {
    return this.viewerState.visibleLayerRoles;
  }
  get crossSectionBackgroundColor() {
    return this.viewerState.crossSectionBackgroundColor;
  }
  get perspectiveViewBackgroundColor() {
    return this.viewerState.perspectiveViewBackgroundColor;
  }
  get scaleBarOptions() {
    return this.viewerState.scaleBarOptions;
  }
  get changed() {
    return this.state.changed;
  }
  bindAction(e, t) {
    this.registerDisposer(be(this.element, e, t));
  }
  registerActionBindings() {
    this.bindAction("add-layer", () => {
      this.layerPanel && this.layerPanel.addLayerMenu();
    }), this.bindAction("t-", () => {
      this.navigationState.pose.translateNonDisplayDimension(0, -1);
    }), this.bindAction("t+", () => {
      this.navigationState.pose.translateNonDisplayDimension(0, 1);
    });
  }
  toJSON() {
    return RZr({ type: "viewer" }, this.state.toJSON());
  }
  reset() {
    this.state.reset();
  }
  restoreState(e) {
    this.state.restoreState(e), In(e, "crossSectionZoom", Tc(this.viewerNavigationState.crossSectionScale)), In(e, "perspectiveZoom", Tc(this.viewerNavigationState.projectionScale)), In(e, "perspectiveOrientation", this.viewerNavigationState.projectionOrientation);
  }
  makeUI() {
    this.element.style.flex = "1", this.element.style.display = "flex", this.element.style.flexDirection = "column", this.element.appendChild(this.layout.element), this.updateUI();
  }
  updateUI() {
    const e = this.options, t = e.showLayerPanel.value;
    if (this.layerPanel !== void 0 && !t) {
      this.layerPanel.dispose(), this.layerPanel = void 0;
      return;
    }
    if (t && this.layerPanel === void 0) {
      const i = this.layerPanel = new i$(this.display, this.layerSpecification, this.viewerNavigationState, this.viewerState.selectedLayer.addRef(), () => this.layout.toJSON(), this.options.showLayerHoverValues);
      if (e.showViewerMenu ? (i.registerDisposer(o$(i.element, this)), i.element.title = "Right click for options, drag to move/copy layer group.") : i.element.title = "Drag to move/copy layer group.", typeof NEUROGLANCER_SHOW_LAYER_BAR_EXTRA_BUTTONS < "u" && NEUROGLANCER_SHOW_LAYER_BAR_EXTRA_BUTTONS === true) {
        {
          const s = document.createElement("button");
          s.textContent = "Clear segments", s.title = 'De-select all objects ("x")', s.addEventListener("click", (a) => {
            Ok(a, a, { action: "clear-segments" });
          }), i.element.appendChild(s);
        }
        for (const s of ["3d", "xy", "xz", "yz"]) {
          const a = document.createElement("button");
          a.textContent = s, a.title = `Switch to ${s} layout`, a.addEventListener("click", () => {
            let l;
            this.layout.name === s ? s !== "3d" ? l = `${s}-3d` : l = "4panel" : l = s, this.layout.name = l;
          }), i.element.appendChild(a);
        }
      }
      i.element.draggable = true;
      const r = i.element;
      r.addEventListener("dragstart", (s) => {
        or(i.element, "drag", "Drag layer group to the left/top/right/bottom edge of a layer group, or to another layer bar/panel (including in another Neuroglancer window)"), RI(s, {
          manager: this.layerSpecification,
          layers: this.layerManager.managedLayers,
          layoutSpec: this.layout.toJSON()
        });
        const a = () => {
          Qi && Qi.viewer === this && (Qi = void 0), this.unregisterDisposer(a);
        };
        Qi = { viewer: this, disposer: a }, this.registerDisposer(a);
        const l = this.toJSON();
        delete l.layers, s.dataTransfer.setData(Vy, se(l)), i.element.style.backgroundColor = "black", setTimeout(() => {
          i.element.style.backgroundColor = "";
        }, 0);
      }), i.element.addEventListener("dragend", () => {
        Ln(r, "drag"), cf(), Qi !== void 0 && Qi.viewer === this && Qi.disposer();
      }), this.element.insertBefore(r, this.element.firstChild);
    }
  }
  disposed() {
    it(this.element);
    const e = this.layerPanel;
    e !== void 0 && (e.dispose(), this.layerPanel = void 0), super.disposed();
  }
};
var ix = NZr("layoutComponentContainer");
var vu = class extends Z {
  constructor(e, t, i) {
    super(), this.viewer = e, this.parent = i, this.changed = new Ee(), this.element = document.createElement("div");
    const r = this.element;
    r.style.display = "flex", r.style.flex = "1", r.style.position = "relative", r.style.alignItems = "stretch", r[ix] = this, this.setSpecification(t);
    const s = [], a = (d) => {
      const u = document.createElement("div");
      u.className = "neuroglancer-layout-split-drop-zone";
      let f;
      switch (u.style[d] = "0", d) {
        case "left":
        case "right":
          f = "row", u.style.width = "10px", u.style.height = "100%";
          break;
        case "top":
        case "bottom":
          f = "column", u.style.height = "10px", u.style.width = "100%";
          break;
      }
      u.style.display = "none", s.push({ element: u, direction: f, orientation: d }), r.appendChild(u), zI(u, this.viewer.layerSpecification, () => this.split(d).newContainer.component, f === "row" ? "column" : "row");
    };
    a("left"), a("right"), a("top"), a("bottom");
    let l = false;
    r.addEventListener("dragenter", (d) => {
      if (!l && Ku(d) !== void 0) {
        l = true;
        for (const u of s) {
          const f = u.element, g = u.direction, v = u.orientation;
          if (i !== void 0 && g === i.direction && ((v === "left" || v === "top") && i.get(0) !== this || (v === "bottom" || v === "right") && i.get(i.length - 1) !== this))
            continue;
          const y = this.component;
          y instanceof Lm && y.direction === g || (f.style.display = "block");
        }
      }
    }, true), r.addEventListener(
      "drop",
      (d) => {
        if (l) {
          l = false;
          for (const u of s) {
            const f = u.element;
            f.style.display = "none";
          }
        }
      },
      /*capture=*/
      true
    ), r.addEventListener("dragleave", (d) => {
      const u = d.relatedTarget;
      if (l && !(u instanceof HTMLElement && this.element.contains(u))) {
        l = false;
        for (const f of s) {
          const g = f.element;
          g.style.display = "none";
        }
      }
    }, true);
  }
  unsetComponent() {
    const e = this.componentValue;
    e !== void 0 && (e.changed.remove(this.changed.dispatch), this.element.removeChild(e.element), e.dispose());
  }
  get component() {
    return this.componentValue;
  }
  setComponent(e) {
    if (this.unsetComponent(), this.componentValue = e, e.changed.add(this.changed.dispatch), this.element.appendChild(e.element), e instanceof Zu) {
      const t = e.layerManager, i = e.registerCancellable(lt(() => {
        t.managedLayers.length === 0 && this.dispose();
      }, 0));
      e.registerDisposer(t.layersChanged.add(() => {
        t.managedLayers.length === 0 && i();
      })), i();
    } else if (e instanceof Lm) {
      const t = e.registerCancellable(lt(() => {
        const i = e.length;
        if (i === 0 && this.parent !== void 0)
          this.dispose();
        else if (i === 1) {
          const r = e.get(0).component;
          let s;
          if (this.parent === void 0 && r instanceof Zu) {
            s = r.layout.specification.toJSON(), r.viewerNavigationState.copyToParent();
            const a = r.layerManager.managedLayers, l = new je(a), d = r.layerSpecification;
            d.rootLayers.filter((g) => l.has(g) || g.archived);
            const u = [], f = d.rootLayers.managedLayers;
            for (let g = 0, v = f.length; g < v; ++g)
              l.has(f[g]) && u.push(g);
            for (let g = 0, v = a.length; g < v; ++g)
              f[u[g]] = a[g];
            d.rootLayers.layersChanged.dispatch();
          } else
            s = r.toJSON();
          this.setSpecification(s);
        }
      }, 0));
      e.registerDisposer(e.changed.add(() => {
        e.length < 2 && t();
      })), t();
    }
    this.changed.dispatch();
  }
  toJSON() {
    return this.component.toJSON();
  }
  setSpecification(e) {
    this.setComponent(l$(this, e));
  }
  static getFromElement(e) {
    return e[ix];
  }
  disposed() {
    this.unsetComponent(), this.componentValue = void 0, super.disposed();
  }
  split(e) {
    const t = {
      type: "viewer"
    }, i = this.parent;
    if (i !== void 0) {
      if (e === "left" && i.direction === "row" || e === "top" && i.direction === "column")
        return { newContainer: i.insertChild(t, this), existingContainer: this };
      if (e === "right" && i.direction === "row" || e === "bottom" && i.direction === "column")
        return { newContainer: i.insertChild(t), existingContainer: this };
    }
    let r;
    const s = this.component;
    s instanceof Im ? r = s.layerGroupViewer.toJSON() : r = s.toJSON();
    let a, l;
    const d = e === "left" || e === "right" ? "row" : "column";
    switch (e) {
      case "left":
      case "top":
        a = { type: d, children: [t, r] }, l = 0;
        break;
      case "right":
      case "bottom":
        a = { type: d, children: [r, t] }, l = 1;
        break;
    }
    this.setSpecification(a);
    const u = this.component;
    return {
      newContainer: u.get(l),
      existingContainer: u.get(1 - l)
    };
  }
};
function UI(n) {
  return {
    mouseState: n.mouseState,
    showAxisLines: n.showAxisLines,
    wireFrame: n.wireFrame,
    showScaleBar: n.showScaleBar,
    scaleBarOptions: n.scaleBarOptions,
    showPerspectiveSliceViews: n.showPerspectiveSliceViews,
    inputEventBindings: n.inputEventBindings,
    visibility: n.visibility,
    selectedLayer: n.selectedLayer,
    visibleLayerRoles: n.visibleLayerRoles,
    navigationState: n.navigationState.addRef(),
    perspectiveNavigationState: n.perspectiveNavigationState.addRef(),
    crossSectionBackgroundColor: n.crossSectionBackgroundColor,
    perspectiveViewBackgroundColor: n.perspectiveViewBackgroundColor
  };
}
var Im = class extends Z {
  constructor(e, t, i) {
    super(), this.element = e, this.layerGroupViewer = this.registerDisposer(new Zu(e, RZr({ display: i.display, layerSpecification: i.layerSpecification.addRef() }, UI(i)), {
      showLayerPanel: i.uiControlVisibility.showLayerPanel,
      showViewerMenu: false,
      showLayerHoverValues: i.uiControlVisibility.showLayerHoverValues
    })), this.layerGroupViewer.layout.restoreState(t);
  }
  toJSON() {
    return this.layerGroupViewer.layout.specification.toJSON();
  }
  get changed() {
    return this.layerGroupViewer.layout.changed;
  }
};
function zI(n, e, t, i) {
  n.addEventListener("dragenter", (r) => {
    Ku(r) !== void 0 && n.classList.add("neuroglancer-drag-over");
  }), n.addEventListener("dragleave", () => {
    Ln(n, "drop"), n.classList.remove("neuroglancer-drag-over");
  }), n.addEventListener("dragover", (r) => {
    const s = (a, l) => {
      a.dropEffectMessage && (l += ` (${a.dropEffectMessage})`), or(n, "drop", l), r.stopPropagation(), r.preventDefault();
    };
    if (nx(r)) {
      const a = s$(r, e);
      Oy(r, a.dropEffect), s(a, `Drop to ${a.dropEffect} layer group as new ${i}`);
      return;
    }
    if (Ku(r) !== void 0) {
      const a = WG(
        r,
        e,
        /*targetIsLayerListPanel=*/
        false,
        /*newTarget=*/
        true
      );
      s(a, `Drop to ${a.dropEffect} layer as new ${i}`);
      return;
    }
  }), n.addEventListener("drop", (r) => {
    n.classList.remove("neuroglancer-drag-over"), Ln(n, "drop");
    let s, a;
    if (nx(r)) {
      r.stopPropagation();
      try {
        a = JSON.parse(r.dataTransfer.getData(Vy));
      } catch {
        return;
      }
      if (s = wm(r, e, { forceCopy: false, newTarget: true }), s === void 0)
        return;
    } else {
      if (s = wm(r, e, { forceCopy: Cm() === "copy", newTarget: true }), s === void 0)
        return;
      a = s.layoutSpec;
    }
    if (!s.initializeExternalLayers(r)) {
      if (!s.moveSupported)
        for (const u of s.layers.keys())
          u.dispose();
      return;
    }
    r.preventDefault();
    const l = r.dataTransfer.dropEffect = Cm();
    cf(l);
    const d = t();
    s.updateArchiveStates(r);
    for (const u of s.layers.keys())
      d.layerSpecification.add(u);
    try {
      d.restoreState(a);
    } catch {
      d.layout.reset();
    }
  });
}
var Lm = class extends Z {
  constructor(e, t, i, r) {
    super(), this.element = e, this.direction = t, this.container = r, this.changed = new Ee(), e.classList.add("neuroglancer-stack-layout"), e.classList.add(`neuroglancer-stack-layout-${t}`), e.style.display = "flex", e.style.flexDirection = t, e.appendChild(this.makeDropPlaceholder(this));
    for (const s of i)
      this.insertChild(s);
  }
  get length() {
    return (this.element.childElementCount - 1) / 2;
  }
  makeDropPlaceholder(e) {
    const t = document.createElement("div");
    return t.className = "neuroglancer-stack-layout-drop-placeholder", zI(t, this.viewer.layerSpecification, () => {
      const i = t.nextElementSibling;
      let r;
      return i !== null && (r = vu.getFromElement(i)), this.insertChild({ type: "viewer", layers: [] }, r).component;
    }, this.direction === "row" ? "column" : "row"), e.registerDisposer(() => {
      Ft(t);
    }), t;
  }
  get viewer() {
    return this.container.viewer;
  }
  get(e) {
    return vu.getFromElement(this.element.children[e * 2 + 1]);
  }
  insertChild(e, t) {
    const i = new vu(this.viewer, e, this), r = this.makeDropPlaceholder(i);
    i.element.classList.add("neuroglancer-stack-layout-child"), i.registerDisposer(i.changed.add(this.changed.dispatch)), i.registerDisposer(() => {
      this.element.removeChild(i.element), this.changed.dispatch();
    });
    const s = t !== void 0 ? t.element : null;
    return this.element.insertBefore(i.element, s), this.element.insertBefore(r, s), this.changed.dispatch(), i;
  }
  disposed() {
    this.clear(), super.disposed();
  }
  clear() {
    for (; this.length !== 0; )
      this.get(0).dispose();
  }
  *[wZr]() {
    const e = this.length;
    for (let t = 0; t < e; ++t)
      yield this.get(t);
  }
  toJSON() {
    return {
      type: this.direction,
      children: De(this).map((e) => e.toJSON())
    };
  }
};
function l$(n, e) {
  const t = document.createElement("div");
  if (t.style.flex = "1", t.style.width = "0px", typeof e == "string") {
    if (n.parent !== void 0)
      throw new Error(`Invalid layout component specification: ${se(e)}`);
    return new Im(t, e, n.viewer);
  }
  pe(e);
  const i = K(e, "type", Le);
  switch (i) {
    case "row":
    case "column":
      return new Lm(t, i, K(e, "children", (r) => {
        const s = Je(r, (a) => a);
        if (n.parent === void 0 && s.length === 0)
          throw new Error("Stack layout requires at least one child.");
        return s;
      }), n);
    case "viewer": {
      const r = n.viewer, s = new eL(r.layerSpecification.addRef()), a = new Zu(t, RZr({ display: r.display, layerSpecification: s }, UI(r)), {
        showLayerPanel: r.uiControlVisibility.showLayerPanel,
        showViewerMenu: true,
        showLayerHoverValues: r.uiControlVisibility.showLayerHoverValues
      });
      try {
        a.restoreState(e);
      } catch (l) {
        throw a.dispose(), l;
      }
      return a;
    }
    default:
      return new Im(t, e, n.viewer);
  }
}
var c$ = class extends Z {
  constructor(e, t) {
    super(), this.viewer = e, this.defaultSpecification = t, this.container = this.registerDisposer(new vu(this.viewer, this.defaultSpecification, void 0));
  }
  get changed() {
    return this.container.changed;
  }
  get element() {
    return this.container.element;
  }
  reset() {
    this.container.setSpecification(this.defaultSpecification);
  }
  restoreState(e) {
    this.container.setSpecification(e);
  }
  disposed() {
    super.disposed();
  }
  toJSON() {
    return this.container.toJSON();
  }
};
var Dm = 0;
var d$ = vt.fromObject({
  escape: { action: "close" }
});
var hf = class extends Z {
  constructor() {
    super(), this.keyMap = new vt(), this.keyMap.addParent(d$, Number.NEGATIVE_INFINITY), ++Dm;
    let e = this.container = document.createElement("div");
    e.className = "overlay";
    let t = this.content = document.createElement("div");
    this.registerDisposer(new sf(t)), t.className = "overlay-content", e.appendChild(t), document.body.appendChild(e), this.registerDisposer(new Wi(this.container, this.keyMap)), this.registerEventListener(e, "action:close", () => {
      this.dispose();
    }), t.focus();
  }
  disposed() {
    --Dm, document.body.removeChild(this.container), super.disposed();
  }
};
var u$ = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiBhcmlhLWxhYmVsbGVkYnk9ImV5ZUNyb3NzZWRJY29uVGl0bGUiPgoJPHRpdGxlIGlkPSJleWVDcm9zc2VkSWNvblRpdGxlIj5IaWRkZW4gKGNyb3NzZWQgZXllKTwvdGl0bGU+Cgk8cGF0aCBkPSJNMjIgMTJDMjIgMTIgMTkgMTggMTIgMThDNSAxOCAyIDEyIDIgMTJDMiAxMiA1IDYgMTIgNkMxOSA2IDIyIDEyIDIyIDEyWiIvPgoJPGNpcmNsZSBjeD0iMTIiIGN5PSIxMiIgcj0iMyIvPgoJPHBhdGggZD0iTTMgMjFMMjAgNCIvPgo8L3N2Zz4=";
var h$ = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiBhcmlhLWxhYmVsbGVkYnk9ImV5ZUljb25UaXRsZSI+Cgk8dGl0bGUgaWQ9ImV5ZUljb25UaXRsZSI+VmlzaWJsZSAoZXllKTwvdGl0bGU+Cgk8cGF0aCBkPSJNMjIgMTJDMjIgMTIgMTkgMTggMTIgMThDNSAxOCAyIDEyIDIgMTJDMiAxMiA1IDYgMTIgNkMxOSA2IDIyIDEyIDIyIDEyWiIvPgoJPGNpcmNsZSBjeD0iMTIiIGN5PSIxMiIgcj0iMyIvPgo8L3N2Zz4=";
var f$ = "data:image/svg+xml;base64,PHN2ZyByb2xlPSJpbWciIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjI0IiBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIGFyaWEtbGFiZWxsZWRieT0iY3Vyc29ySWNvblRpdGxlIj4KICAgIDx0aXRsZSBpZD0iY3Vyc29ySWNvblRpdGxlIj5DdXJzb3I8L3RpdGxlPiAgICAKICAgIDxwb2x5Z29uIHBvaW50cz0iNyAyMCA3IDQgMTkgMTYgMTIgMTYgNyAyMSIvPgo8L3N2Zz4=";
var p$ = vt.fromObject({
  escape: { action: "cancel" }
});
var GI = class extends Z {
  constructor(e) {
    super(), this.layer = e, this.element = document.createElement("input");
    const t = this.element;
    t.classList.add("neuroglancer-layer-side-panel-name"), t.spellcheck = false, t.autocomplete = "off";
    const i = this.registerDisposer(new Wi(t, p$));
    i.allShortcutsAreGlobal = true, be(t, "cancel", (r) => {
      this.updateView(), t.blur(), r.stopPropagation(), r.preventDefault();
    }), t.title = "Rename layer", this.registerDisposer(e.layerChanged.add(() => this.updateView())), t.addEventListener("change", () => this.updateModel()), t.addEventListener("blur", () => this.updateModel()), this.updateView();
  }
  updateView() {
    this.element.value = this.layer.name;
  }
  updateModel() {
    iL(this.layer, this.element.value);
  }
};
var g$ = class extends Z {
  constructor(e) {
    super(), this.layer = e, this.element = document.createElement("select"), this.measureElement = document.createElement("div");
    const t = this.element, i = this.measureElement;
    t.classList.add("neuroglancer-layer-side-panel-type"), i.classList.add("neuroglancer-layer-side-panel-type-measure"), t.title = "Change layer type", document.body.appendChild(i);
    for (const s of Qu) {
      var r = ce(s, 2);
      const a = r[0], l = r[1];
      if (l.type !== a)
        continue;
      const d = document.createElement("option");
      d.textContent = l.typeAbbreviation, d.value = a, t.appendChild(d);
    }
    t.addEventListener("change", () => {
      const s = t.value, a = Qu.get(s);
      $y(this.layer.managedLayer, a);
    }), this.updateView();
  }
  updateView() {
    const e = this.layer.type, t = this.element, i = this.measureElement;
    i.textContent = this.layer.constructor.typeAbbreviation, t.value = e, t.style.width = `${i.offsetWidth}px`;
  }
  disposed() {
    this.measureElement.remove();
  }
};
var Xu = class _Xu extends wa {
  constructor(e, t) {
    super(e, t.location), this.panelState = t;
    const i = this.layer = t.layer, r = this.element;
    var s = this.addTitleBar({});
    const a = s.titleBar;
    a.classList.add("neuroglancer-layer-side-panel-title"), a.appendChild(this.registerDisposer(new g$(i)).element), a.appendChild(this.registerDisposer(new GI(i.managedLayer)).element), this.registerDisposer(Vr((u) => {
      r.dataset.neuroglancerLayerVisible = u.toString();
    }, {
      get value() {
        return i.managedLayer.visible;
      },
      changed: i.managedLayer.layerChanged
    }));
    const l = this.registerDisposer(new tr({
      get value() {
        return i.managedLayer.pickEnabled;
      },
      set value(u) {
        i.managedLayer.pickEnabled = u;
      },
      changed: i.managedLayer.layerChanged
    }, {
      svg: f$,
      enableTitle: "Spatial object selection: disabled",
      disableTitle: "Spatial object selection: enabled"
    }));
    this.registerDisposer(new pi({
      get value() {
        return i.managedLayer.supportsPickOption;
      },
      changed: i.managedLayer.layerChanged
    }, l.element)), a.appendChild(l.element);
    const d = {
      get value() {
        return t !== i.panels.panels[0];
      },
      set value(u) {
        u ? t.pin() : t.unpin();
      },
      changed: i.manager.root.layerManager.layersChanged
    };
    a.appendChild(this.registerDisposer(new tr(d, {
      // Note: \ufe0e forces text display, as otherwise the pin icon
      // may as an emoji with color.
      text: "📌︎",
      enableTitle: "Pin panel to this layer",
      disableTitle: "Unpin panel to this layer"
    })).element), this.registerDisposer(Vr((u) => {
      r.dataset.neuroglancerLayerPanelPinned = u.toString();
    }, d)), a.appendChild(Cs({
      title: "Delete layer",
      onClick: () => {
        ll(this.layer.managedLayer);
      }
    })), this.tabView = new XU({
      makeTab: (u) => i.tabs.options.get(u).getter(),
      selectedTab: t.selectedTab,
      tabs: this.registerDisposer(new BE({
        get value() {
          return t.tabs.map((u) => ({
            id: u,
            label: i.tabs.options.get(u).label
          }));
        },
        changed: t.tabsChanged
      })),
      handleTabElement: (u, f) => {
        f.draggable = true, f.addEventListener("dragstart", (g) => {
          g.stopPropagation(), g.dataTransfer.setData("neuroglancer-side-panel", "");
          let v = "Drag tab to dock as new panel to the left/right/top/bottom of another panel";
          t.panels.panels.find((w) => w !== t && w.location.visible) && (v += `, or move tab to other ${se(i.managedLayer.name)} panel`), or(f, "drag", v), this.sidePanelManager.startDrag({
            dropAsNewPanel: (w) => {
              this.panelState.splitOffTab(u, RZr(RZr({}, lI), w));
            },
            canDropAsTabs: (w) => w instanceof _Xu && w.layer === this.layer && w !== this ? 1 : 0,
            dropAsTab: (w) => {
              this.panelState.moveTabTo(u, w.panelState);
            }
          }, g);
        }), f.addEventListener("dragend", (g) => {
          Ln(f, "drag"), this.sidePanelManager.endDrag();
        });
      }
    }, this.visibility), this.tabView.element.style.flex = "1", this.tabView.element.classList.add("neuroglancer-layer-side-panel-tab-view"), this.tabView.element.style.position = "relative", this.tabView.element.appendChild(this.makeTabDropZone()), this.addBody(this.tabView.element), this.registerDisposer(t.tabsChanged.add(() => {
      t.tabs.length === 0 && (this.location.visible = false);
    }));
  }
  makeDragSource() {
    return RZr(RZr({}, super.makeDragSource()), { canDropAsTabs: (e) => e instanceof _Xu && e.layer === this.layer && e !== this ? this.panelState.tabs.length : 0, dropAsTab: (e) => {
      this.panelState.mergeInto(e.panelState);
    } });
  }
  makeTabDropZone() {
    const e = document.createElement("div");
    return e.className = "neuroglancer-side-panel-drop-zone", e.style.position = "absolute", e.style.left = "20px", e.style.right = "20px", e.style.bottom = "20px", e.style.top = "20px", e.addEventListener("dragenter", (t) => {
      var i;
      const r = this.sidePanelManager.dragSource, s = (i = r == null ? void 0 : r.canDropAsTabs) === null || i === void 0 ? void 0 : i.call(r, this);
      s && (e.classList.add(So), or(e, "drop", `Move ${s} ${s === 1 ? "tab" : "tabs"} to this panel`), t.preventDefault());
    }), e.addEventListener("dragleave", () => {
      Ln(e, "drop"), e.classList.remove(So);
    }), e.addEventListener("dragover", (t) => {
      var i;
      const r = this.sidePanelManager.dragSource;
      !((i = r == null ? void 0 : r.canDropAsTabs) === null || i === void 0) && i.call(r, this) && t.preventDefault();
    }), e.addEventListener("drop", (t) => {
      var i;
      Ln(e, "drop");
      const r = this.sidePanelManager.dragSource;
      !((i = r == null ? void 0 : r.canDropAsTabs) === null || i === void 0) && i.call(r, this) && (e.classList.remove(So), r.dropAsTab(this), t.preventDefault(), t.stopPropagation());
    }), e;
  }
};
var m$ = class extends Z {
  constructor(e, t) {
    super(), this.sidePanelManager = e, this.selectedLayerState = t, this.layerSidePanels = new de(), this.generation = 0, this.layersNeedUpdate = true;
    const i = () => {
      this.layersNeedUpdate = true, this.sidePanelManager.display.scheduleRedraw();
    };
    this.registerDisposer(t.changed.add(i)), this.registerDisposer(t.layerManager.layersChanged.add(i)), this.registerDisposer(e.beforeRender.add(() => this.update()));
  }
  getSelectedUserLayer() {
    var e, t;
    return (t = (e = this.selectedLayerState.layer) === null || e === void 0 ? void 0 : e.layer) !== null && t !== void 0 ? t : void 0;
  }
  update() {
    var e;
    if (!this.layersNeedUpdate)
      return;
    const t = this.selectedLayerState.layerManager;
    let i = ++this.generation;
    this.layersNeedUpdate = false;
    const r = this.layerSidePanels, s = (l) => {
      let d = r.get(l);
      d === void 0 ? (d = {
        generation: i,
        unregister: this.sidePanelManager.registerPanel({
          location: l.location,
          makePanel: () => new Xu(this.sidePanelManager, l)
        })
      }, r.set(l, d)) : d.generation = i;
    };
    {
      const l = this.getSelectedUserLayer(), d = this.selectedLayerState.location;
      if (l === void 0 || !d.visible)
        this.placeholderSelectedLayerPanel === void 0 && (this.placeholderSelectedLayerPanel = this.sidePanelManager.registerPanel({ location: d, makePanel: () => new wa(this.sidePanelManager, d) }));
      else {
        (e = this.placeholderSelectedLayerPanel) === null || e === void 0 || e.call(this), this.placeholderSelectedLayerPanel = void 0;
        const u = l.panels.panels[0];
        u.location.value = d.value, s(u);
      }
    }
    for (const l of t.managedLayers) {
      const d = l.layer;
      if (d === null)
        continue;
      const u = d.panels.panels;
      for (let f = 1, g = u.length; f < g; ++f)
        s(u[f]);
    }
    for (const l of r) {
      var a = ce(l, 2);
      const d = a[0], u = a[1];
      u.generation !== i && (u.unregister(), r.delete(d));
    }
  }
  disposed() {
    var e;
    (e = this.placeholderSelectedLayerPanel) === null || e === void 0 || e.call(this);
    for (const t of this.layerSidePanels.values()) {
      const i = t.unregister;
      i();
    }
  }
};
var v$ = RZr(RZr({}, Ca), { side: "left", row: 0 });
var y$ = class {
  constructor() {
    this.location = new Ns(v$);
  }
  get changed() {
    return this.location.changed;
  }
  restoreState(e) {
    e !== void 0 && this.location.restoreState(e);
  }
  reset() {
    this.location.reset();
  }
  toJSON() {
    return ya(this.location.toJSON());
  }
};
var S$ = class extends Z {
  constructor(e) {
    super(), this.layer = e, this.element = document.createElement("div");
    const t = this.element, i = Tt({
      svg: h$,
      title: "Hide layer",
      onClick: () => {
        this.layer.setVisible(false);
      }
    }), r = Tt({
      svg: u$,
      title: "Show layer",
      onClick: () => {
        this.layer.setVisible(true);
      }
    });
    t.appendChild(r), t.appendChild(i);
    const s = () => {
      const a = this.layer.visible;
      i.style.display = a ? "" : "none", r.style.display = a ? "none" : "";
    };
    s(), this.registerDisposer(e.layerChanged.add(s));
  }
};
function b$(n) {
  const e = n.manager.root.selectedLayer, t = new tr({
    get value() {
      return e.layer === n && e.visible;
    },
    set value(i) {
      i ? (e.layer = n, e.visible = true) : e.visible = false;
    },
    changed: e.changed
  }, {
    backgroundScheme: "dark",
    enableTitle: "Show layer side panel",
    disableTitle: "Hide layer side panel",
    svg: fI
  });
  return t.element.classList.add("neuroglancer-layer-list-panel-item-controls"), t;
}
var C$ = class extends Z {
  constructor(e, t) {
    super(), this.panel = e, this.layer = t, this.element = document.createElement("div"), this.numberElement = document.createElement("div"), this.generation = -1;
    const i = this.element, r = this.numberElement;
    i.classList.add("neuroglancer-layer-list-panel-item"), r.classList.add("neuroglancer-layer-list-panel-item-number"), i.appendChild(this.registerDisposer(new Rs({
      get value() {
        return !t.archived;
      },
      set value(a) {
        t.setArchived(!a);
      },
      changed: t.layerChanged
    }, {
      enableTitle: "Archive layer (disable and remove from layer groups)",
      disableTitle: "Unarchive layer (enable and add to all layer groups)"
    })).element), i.appendChild(r), i.appendChild(this.registerDisposer(new S$(t)).element), i.appendChild(this.registerDisposer(new GI(t)).element), i.appendChild(this.registerDisposer(b$(t)).element);
    const s = Cs({
      title: "Delete layer",
      onClick: () => {
        ll(this.layer);
      }
    });
    s.classList.add("neuroglancer-layer-list-panel-item-delete"), i.appendChild(s), OI(e, i, t, { isLayerListPanel: true, getLayoutSpec: () => {
    } }), df(
      e,
      i,
      t,
      /*allowArchived=*/
      true
    ), i.addEventListener("click", (a) => {
      a.ctrlKey ? (e.selectedLayer.toggle(t), a.preventDefault()) : a.altKey && (t.pickEnabled = !t.pickEnabled, a.preventDefault());
    }), i.addEventListener("contextmenu", (a) => {
      e.selectedLayer.toggle(t), a.stopPropagation(), a.preventDefault();
    });
  }
};
var w$ = class extends wa {
  constructor(e, t, i) {
    super(e, i.location), this.manager = t, this.state = i, this.items = new de(), this.itemContainer = document.createElement("div"), this.layerDropZone = document.createElement("div"), this.dragEnterCount = 0, this.generation = -1;
    const r = this.itemContainer, s = this.layerDropZone;
    var a = this.addTitleBar({ title: "" });
    const l = a.titleElement;
    this.titleElement = l, r.classList.add("neuroglancer-layer-list-panel-items"), this.addBody(r), s.style.flex = "1";
    const d = this.registerCancellable(Ct(() => this.render()));
    this.visibility.changed.add(d), this.registerDisposer(this.layerManager.layersChanged.add(d)), this.registerDisposer(this.selectedLayer.changed.add(d)), VI(this), df(
      this,
      s,
      void 0,
      /*allowArchived=*/
      true
    ), this.render();
  }
  get layerManager() {
    return this.manager.layerManager;
  }
  get selectedLayer() {
    return this.manager.selectedLayer;
  }
  render() {
    const e = this, t = this.selectedLayer.layer, i = ++this.generation;
    let r = 0, s = 0, a = 0;
    this.layerManager.updateNonArchivedLayerIndices();
    function* l() {
      const u = e.items;
      let f = 0;
      for (const y of e.layerManager.managedLayers)
        y.archived || ++f;
      const g = `${(f + 1).toString().length}ch`;
      for (const y of e.layerManager.managedLayers) {
        y.visible ? ++r : y.archived ? ++a : ++s;
        let w = u.get(y);
        w === void 0 && (w = e.registerDisposer(new C$(e, y)), u.set(y, w)), w.generation = i;
        const C = y.nonArchivedLayerIndex;
        w.numberElement.style.width = g, C === -1 ? w.numberElement.style.visibility = "hidden" : (w.numberElement.style.visibility = "", w.numberElement.textContent = `${C + 1}`), w.element.dataset.selected = (y === t).toString(), w.element.dataset.archived = y.archived.toString(), yield w.element;
      }
      for (const y of u) {
        var v = ce(y, 2);
        const w = v[0], C = v[1];
        i !== C.generation && (u.delete(w), e.unregisterDisposer(C), C.dispose());
      }
      yield e.layerDropZone;
    }
    ar(this.itemContainer, l());
    let d = "Layers";
    if (r || s || a) {
      d += " (";
      let u = "";
      r + s && (d += `${r}/${s + r} visible`, u = ", "), a && (d += `${u}${a} archived`), d += ")";
    }
    this.titleElement.textContent = d;
  }
};
var x$ = class extends Z {
  constructor(e) {
    super(), this.layerManager = e, this.element = document.createElement("div");
    const t = this.registerCancellable(Ct(() => this.render()));
    this.registerDisposer(e.layersChanged.add(t)), this.render();
  }
  render() {
    let e = 0;
    const t = this.layerManager.managedLayers;
    for (const r of t)
      r.archived && ++e;
    const i = this.element;
    if (e !== 0) {
      const r = t.length;
      i.textContent = `${r - e}/${r}`;
    } else
      i.textContent = "";
  }
};
var sg = { exports: {} };
var rx;
function sl() {
  return rx || (rx = 1, function(n, e) {
    (function(t, i) {
      n.exports = i();
    })(ao, function() {
      var t = navigator.userAgent, i = navigator.platform, r = /gecko\/\d/i.test(t), s = /MSIE \d/.test(t), a = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(t), l = /Edge\/(\d+)/.exec(t), d = s || a || l, u = d && (s ? document.documentMode || 6 : +(l || a)[1]), f = !l && /WebKit\//.test(t), g = f && /Qt\/\d+\.\d+/.test(t), v = !l && /Chrome\/(\d+)/.exec(t), y = v && +v[1], w = /Opera\//.test(t), C = /Apple Computer/.test(navigator.vendor), b = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(t), E = /PhantomJS/.test(t), L = C && (/Mobile\/\w+/.test(t) || navigator.maxTouchPoints > 2), R = /Android/.test(t), _ = L || R || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(t), A = L || /Mac/.test(i), I = /\bCrOS\b/.test(t), P = /win/i.test(i), N = w && t.match(/Version\/(\d*\.\d*)/);
      N && (N = Number(N[1])), N && N >= 15 && (w = false, f = true);
      var O = A && (g || w && (N == null || N < 12.11)), B = r || d && u >= 9;
      function j(o) {
        return new RegExp("(^|\\s)" + o + "(?:$|\\s)\\s*");
      }
      var U = function(o, c) {
        var p = o.className, h = j(c).exec(p);
        if (h) {
          var m = p.slice(h.index + h[0].length);
          o.className = p.slice(0, h.index) + (m ? h[1] + m : "");
        }
      };
      function V(o) {
        for (var c = o.childNodes.length; c > 0; --c)
          o.removeChild(o.firstChild);
        return o;
      }
      function G(o, c) {
        return V(o).appendChild(c);
      }
      function F(o, c, p, h) {
        var m = document.createElement(o);
        if (p && (m.className = p), h && (m.style.cssText = h), typeof c == "string")
          m.appendChild(document.createTextNode(c));
        else if (c)
          for (var S = 0; S < c.length; ++S)
            m.appendChild(c[S]);
        return m;
      }
      function ue(o, c, p, h) {
        var m = F(o, c, p, h);
        return m.setAttribute("role", "presentation"), m;
      }
      var ae;
      document.createRange ? ae = function(o, c, p, h) {
        var m = document.createRange();
        return m.setEnd(h || o, p), m.setStart(o, c), m;
      } : ae = function(o, c, p) {
        var h = document.body.createTextRange();
        try {
          h.moveToElementText(o.parentNode);
        } catch {
          return h;
        }
        return h.collapse(true), h.moveEnd("character", p), h.moveStart("character", c), h;
      };
      function Ie(o, c) {
        if (c.nodeType == 3 && (c = c.parentNode), o.contains)
          return o.contains(c);
        do
          if (c.nodeType == 11 && (c = c.host), c == o)
            return true;
        while (c = c.parentNode);
      }
      function le(o) {
        var c = o.ownerDocument || o, p;
        try {
          p = o.activeElement;
        } catch {
          p = c.body || null;
        }
        for (; p && p.shadowRoot && p.shadowRoot.activeElement; )
          p = p.shadowRoot.activeElement;
        return p;
      }
      function Te(o, c) {
        var p = o.className;
        j(c).test(p) || (o.className += (p ? " " : "") + c);
      }
      function Ue(o, c) {
        for (var p = o.split(" "), h = 0; h < p.length; h++)
          p[h] && !j(p[h]).test(c) && (c += " " + p[h]);
        return c;
      }
      var Ye = function(o) {
        o.select();
      };
      L ? Ye = function(o) {
        o.selectionStart = 0, o.selectionEnd = o.value.length;
      } : d && (Ye = function(o) {
        try {
          o.select();
        } catch {
        }
      });
      function Ze(o) {
        return o.display.wrapper.ownerDocument;
      }
      function rt(o) {
        return Xe(o.display.wrapper);
      }
      function Xe(o) {
        return o.getRootNode ? o.getRootNode() : o.ownerDocument;
      }
      function Be(o) {
        return Ze(o).defaultView;
      }
      function Ae(o) {
        var c = Array.prototype.slice.call(arguments, 1);
        return function() {
          return o.apply(null, c);
        };
      }
      function ze(o, c, p) {
        c || (c = {});
        for (var h in o)
          o.hasOwnProperty(h) && (p !== false || !c.hasOwnProperty(h)) && (c[h] = o[h]);
        return c;
      }
      function We(o, c, p, h, m) {
        c == null && (c = o.search(/[^\s\u00a0]/), c == -1 && (c = o.length));
        for (var S = h || 0, x = m || 0; ; ) {
          var T = o.indexOf("	", S);
          if (T < 0 || T >= c)
            return x + (c - S);
          x += T - S, x += p - x % p, S = T + 1;
        }
      }
      var $e = function() {
        this.id = null, this.f = null, this.time = 0, this.handler = Ae(this.onTimeout, this);
      };
      $e.prototype.onTimeout = function(o) {
        o.id = 0, o.time <= +/* @__PURE__ */ new Date() ? o.f() : setTimeout(o.handler, o.time - +/* @__PURE__ */ new Date());
      }, $e.prototype.set = function(o, c) {
        this.f = c;
        var p = +/* @__PURE__ */ new Date() + o;
        (!this.id || p < this.time) && (clearTimeout(this.id), this.id = setTimeout(this.handler, o), this.time = p);
      };
      function Pe(o, c) {
        for (var p = 0; p < o.length; ++p)
          if (o[p] == c)
            return p;
        return -1;
      }
      var bt = 50, ci = { toString: function() {
        return "CodeMirror.Pass";
      } }, tn = { scroll: false }, X = { origin: "*mouse" }, ne = { origin: "+move" };
      function te(o, c, p) {
        for (var h = 0, m = 0; ; ) {
          var S = o.indexOf("	", h);
          S == -1 && (S = o.length);
          var x = S - h;
          if (S == o.length || m + x >= c)
            return h + Math.min(x, c - m);
          if (m += S - h, m += p - m % p, h = S + 1, m >= c)
            return h;
        }
      }
      var ge = [""];
      function we(o) {
        for (; ge.length <= o; )
          ge.push(me(ge) + " ");
        return ge[o];
      }
      function me(o) {
        return o[o.length - 1];
      }
      function Ge(o, c) {
        for (var p = [], h = 0; h < o.length; h++)
          p[h] = c(o[h], h);
        return p;
      }
      function tt(o, c, p) {
        for (var h = 0, m = p(c); h < o.length && p(o[h]) <= m; )
          h++;
        o.splice(h, 0, c);
      }
      function ht() {
      }
      function ft(o, c) {
        var p;
        return Object.create ? p = Object.create(o) : (ht.prototype = o, p = new ht()), c && ze(c, p), p;
      }
      var st = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
      function zt(o) {
        return /\w/.test(o) || o > "" && (o.toUpperCase() != o.toLowerCase() || st.test(o));
      }
      function pt(o, c) {
        return c ? c.source.indexOf("\\w") > -1 && zt(o) ? true : c.test(o) : zt(o);
      }
      function Dt(o) {
        for (var c in o)
          if (o.hasOwnProperty(c) && o[c])
            return false;
        return true;
      }
      var Gt = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
      function qe(o) {
        return o.charCodeAt(0) >= 768 && Gt.test(o);
      }
      function Rt(o, c, p) {
        for (; (p < 0 ? c > 0 : c < o.length) && qe(o.charAt(c)); )
          c += p;
        return c;
      }
      function Pt(o, c, p) {
        for (var h = c > p ? -1 : 1; ; ) {
          if (c == p)
            return c;
          var m = (c + p) / 2, S = h < 0 ? Math.ceil(m) : Math.floor(m);
          if (S == c)
            return o(S) ? c : p;
          o(S) ? p = S : c = S + h;
        }
      }
      function di(o, c, p, h) {
        if (!o)
          return h(c, p, "ltr", 0);
        for (var m = false, S = 0; S < o.length; ++S) {
          var x = o[S];
          (x.from < p && x.to > c || c == p && x.to == c) && (h(Math.max(x.from, c), Math.min(x.to, p), x.level == 1 ? "rtl" : "ltr", S), m = true);
        }
        m || h(c, p, "ltr");
      }
      var ji = null;
      function Zr(o, c, p) {
        var h;
        ji = null;
        for (var m = 0; m < o.length; ++m) {
          var S = o[m];
          if (S.from < c && S.to > c)
            return m;
          S.to == c && (S.from != S.to && p == "before" ? h = m : ji = m), S.from == c && (S.from != S.to && p != "before" ? h = m : ji = m);
        }
        return h ?? ji;
      }
      var yf = /* @__PURE__ */ function() {
        var o = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN", c = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111";
        function p(D) {
          return D <= 247 ? o.charAt(D) : 1424 <= D && D <= 1524 ? "R" : 1536 <= D && D <= 1785 ? c.charAt(D - 1536) : 1774 <= D && D <= 2220 ? "r" : 8192 <= D && D <= 8203 ? "w" : D == 8204 ? "b" : "L";
        }
        var h = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/, m = /[stwN]/, S = /[LRr]/, x = /[Lb1n]/, T = /[1n]/;
        function k(D, z, W) {
          this.level = D, this.from = z, this.to = W;
        }
        return function(D, z) {
          var W = z == "ltr" ? "L" : "R";
          if (D.length == 0 || z == "ltr" && !h.test(D))
            return false;
          for (var q = D.length, Y = [], ee = 0; ee < q; ++ee)
            Y.push(p(D.charCodeAt(ee)));
          for (var oe = 0, fe = W; oe < q; ++oe) {
            var ve = Y[oe];
            ve == "m" ? Y[oe] = fe : fe = ve;
          }
          for (var xe = 0, ye = W; xe < q; ++xe) {
            var ke = Y[xe];
            ke == "1" && ye == "r" ? Y[xe] = "n" : S.test(ke) && (ye = ke, ke == "r" && (Y[xe] = "R"));
          }
          for (var Ve = 1, Ne = Y[0]; Ve < q - 1; ++Ve) {
            var Ke = Y[Ve];
            Ke == "+" && Ne == "1" && Y[Ve + 1] == "1" ? Y[Ve] = "1" : Ke == "," && Ne == Y[Ve + 1] && (Ne == "1" || Ne == "n") && (Y[Ve] = Ne), Ne = Ke;
          }
          for (var xt = 0; xt < q; ++xt) {
            var on = Y[xt];
            if (on == ",")
              Y[xt] = "N";
            else if (on == "%") {
              var Mt = void 0;
              for (Mt = xt + 1; Mt < q && Y[Mt] == "%"; ++Mt)
                ;
              for (var qn = xt && Y[xt - 1] == "!" || Mt < q && Y[Mt] == "1" ? "1" : "N", Bn = xt; Bn < Mt; ++Bn)
                Y[Bn] = qn;
              xt = Mt - 1;
            }
          }
          for (var Yt = 0, Fn = W; Yt < q; ++Yt) {
            var fn = Y[Yt];
            Fn == "L" && fn == "1" ? Y[Yt] = "L" : S.test(fn) && (Fn = fn);
          }
          for (var Qt = 0; Qt < q; ++Qt)
            if (m.test(Y[Qt])) {
              var qt = void 0;
              for (qt = Qt + 1; qt < q && m.test(Y[qt]); ++qt)
                ;
              for (var Vt = (Qt ? Y[Qt - 1] : W) == "L", Un = (qt < q ? Y[qt] : W) == "L", Za = Vt == Un ? Vt ? "L" : "R" : W, ds = Qt; ds < qt; ++ds)
                Y[ds] = Za;
              Qt = qt - 1;
            }
          for (var Cn = [], Zi, ln = 0; ln < q; )
            if (x.test(Y[ln])) {
              var hp = ln;
              for (++ln; ln < q && x.test(Y[ln]); ++ln)
                ;
              Cn.push(new k(0, hp, ln));
            } else {
              var Er = ln, Hs = Cn.length, js = z == "rtl" ? 1 : 0;
              for (++ln; ln < q && Y[ln] != "L"; ++ln)
                ;
              for (var Tn = Er; Tn < ln; )
                if (T.test(Y[Tn])) {
                  Er < Tn && (Cn.splice(Hs, 0, new k(1, Er, Tn)), Hs += js);
                  var Xa = Tn;
                  for (++Tn; Tn < ln && T.test(Y[Tn]); ++Tn)
                    ;
                  Cn.splice(Hs, 0, new k(2, Xa, Tn)), Hs += js, Er = Tn;
                } else
                  ++Tn;
              Er < ln && Cn.splice(Hs, 0, new k(1, Er, ln));
            }
          return z == "ltr" && (Cn[0].level == 1 && (Zi = D.match(/^\s+/)) && (Cn[0].from = Zi[0].length, Cn.unshift(new k(0, 0, Zi[0].length))), me(Cn).level == 1 && (Zi = D.match(/\s+$/)) && (me(Cn).to -= Zi[0].length, Cn.push(new k(0, q - Zi[0].length, q)))), z == "rtl" ? Cn.reverse() : Cn;
        };
      }();
      function Qe(o, c) {
        var p = o.order;
        return p == null && (p = o.order = yf(o.text, c)), p;
      }
      var ad = [], Oe = function(o, c, p) {
        if (o.addEventListener)
          o.addEventListener(c, p, false);
        else if (o.attachEvent)
          o.attachEvent("on" + c, p);
        else {
          var h = o._handlers || (o._handlers = {});
          h[c] = (h[c] || ad).concat(p);
        }
      };
      function vr(o, c) {
        return o._handlers && o._handlers[c] || ad;
      }
      function yn(o, c, p) {
        if (o.removeEventListener)
          o.removeEventListener(c, p, false);
        else if (o.detachEvent)
          o.detachEvent("on" + c, p);
        else {
          var h = o._handlers, m = h && h[c];
          if (m) {
            var S = Pe(m, p);
            S > -1 && (h[c] = m.slice(0, S).concat(m.slice(S + 1)));
          }
        }
      }
      function Nt(o, c) {
        var p = vr(o, c);
        if (p.length)
          for (var h = Array.prototype.slice.call(arguments, 2), m = 0; m < p.length; ++m)
            p[m].apply(null, h);
      }
      function _t(o, c, p) {
        return typeof c == "string" && (c = { type: c, preventDefault: function() {
          this.defaultPrevented = true;
        } }), Nt(o, p || c.type, o, c), Nn(c) || c.codemirrorIgnore;
      }
      function ui(o) {
        var c = o._handlers && o._handlers.cursorActivity;
        if (c)
          for (var p = o.curOp.cursorActivityHandlers || (o.curOp.cursorActivityHandlers = []), h = 0; h < c.length; ++h)
            Pe(p, c[h]) == -1 && p.push(c[h]);
      }
      function Jn(o, c) {
        return vr(o, c).length > 0;
      }
      function Ii(o) {
        o.prototype.on = function(c, p) {
          Oe(this, c, p);
        }, o.prototype.off = function(c, p) {
          yn(this, c, p);
        };
      }
      function Sn(o) {
        o.preventDefault ? o.preventDefault() : o.returnValue = false;
      }
      function ka(o) {
        o.stopPropagation ? o.stopPropagation() : o.cancelBubble = true;
      }
      function Nn(o) {
        return o.defaultPrevented != null ? o.defaultPrevented : o.returnValue == false;
      }
      function Xr(o) {
        Sn(o), ka(o);
      }
      function dl(o) {
        return o.target || o.srcElement;
      }
      function Li(o) {
        var c = o.which;
        return c == null && (o.button & 1 ? c = 1 : o.button & 2 ? c = 3 : o.button & 4 && (c = 2)), A && o.ctrlKey && c == 1 && (c = 3), c;
      }
      var Sf = function() {
        if (d && u < 9)
          return false;
        var o = F("div");
        return "draggable" in o || "dragDrop" in o;
      }(), Ia;
      function od(o) {
        if (Ia == null) {
          var c = F("span", "​");
          G(o, F("span", [c, document.createTextNode("x")])), o.firstChild.offsetHeight != 0 && (Ia = c.offsetWidth <= 1 && c.offsetHeight > 2 && !(d && u < 8));
        }
        var p = Ia ? F("span", "​") : F("span", " ", null, "display: inline-block; width: 1px; margin-right: -1px");
        return p.setAttribute("cm-text", ""), p;
      }
      var ul;
      function Qr(o) {
        if (ul != null)
          return ul;
        var c = G(o, document.createTextNode("AخA")), p = ae(c, 0, 1).getBoundingClientRect(), h = ae(c, 1, 2).getBoundingClientRect();
        return V(o), !p || p.left == p.right ? false : ul = h.right - p.right < 3;
      }
      var hi = `

b`.split(/\n/).length != 3 ? function(o) {
        for (var c = 0, p = [], h = o.length; c <= h; ) {
          var m = o.indexOf(`
`, c);
          m == -1 && (m = o.length);
          var S = o.slice(c, o.charAt(m - 1) == "\r" ? m - 1 : m), x = S.indexOf("\r");
          x != -1 ? (p.push(S.slice(0, x)), c += x + 1) : (p.push(S), c = m + 1);
        }
        return p;
      } : function(o) {
        return o.split(/\r\n?|\n/);
      }, es = window.getSelection ? function(o) {
        try {
          return o.selectionStart != o.selectionEnd;
        } catch {
          return false;
        }
      } : function(o) {
        var c;
        try {
          c = o.ownerDocument.selection.createRange();
        } catch {
        }
        return !c || c.parentElement() != o ? false : c.compareEndPoints("StartToEnd", c) != 0;
      }, ld = function() {
        var o = F("div");
        return "oncopy" in o ? true : (o.setAttribute("oncopy", "return;"), typeof o.oncopy == "function");
      }(), Di = null;
      function bf(o) {
        if (Di != null)
          return Di;
        var c = G(o, F("span", "x")), p = c.getBoundingClientRect(), h = ae(c, 0, 1).getBoundingClientRect();
        return Di = Math.abs(p.left - h.left) > 1;
      }
      var La = {}, Pi = {};
      function Ai(o, c) {
        arguments.length > 2 && (c.dependencies = Array.prototype.slice.call(arguments, 2)), La[o] = c;
      }
      function Os(o, c) {
        Pi[o] = c;
      }
      function Da(o) {
        if (typeof o == "string" && Pi.hasOwnProperty(o))
          o = Pi[o];
        else if (o && typeof o.name == "string" && Pi.hasOwnProperty(o.name)) {
          var c = Pi[o.name];
          typeof c == "string" && (c = { name: c }), o = ft(c, o), o.name = c.name;
        } else {
          if (typeof o == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(o))
            return Da("application/xml");
          if (typeof o == "string" && /^[\w\-]+\/[\w\-]+\+json$/.test(o))
            return Da("application/json");
        }
        return typeof o == "string" ? { name: o } : o || { name: "null" };
      }
      function Pa(o, c) {
        c = Da(c);
        var p = La[c.name];
        if (!p)
          return Pa(o, "text/plain");
        var h = p(o, c);
        if (ts.hasOwnProperty(c.name)) {
          var m = ts[c.name];
          for (var S in m)
            m.hasOwnProperty(S) && (h.hasOwnProperty(S) && (h["_" + S] = h[S]), h[S] = m[S]);
        }
        if (h.name = c.name, c.helperType && (h.helperType = c.helperType), c.modeProps)
          for (var x in c.modeProps)
            h[x] = c.modeProps[x];
        return h;
      }
      var ts = {};
      function Aa(o, c) {
        var p = ts.hasOwnProperty(o) ? ts[o] : ts[o] = {};
        ze(c, p);
      }
      function Ji(o, c) {
        if (c === true)
          return c;
        if (o.copyState)
          return o.copyState(c);
        var p = {};
        for (var h in c) {
          var m = c[h];
          m instanceof Array && (m = m.concat([])), p[h] = m;
        }
        return p;
      }
      function hl2(o, c) {
        for (var p; o.innerMode && (p = o.innerMode(c), !(!p || p.mode == o)); )
          c = p.state, o = p.mode;
        return p || { mode: o, state: c };
      }
      function Ra(o, c, p) {
        return o.startState ? o.startState(c, p) : true;
      }
      var Ot = function(o, c, p) {
        this.pos = this.start = 0, this.string = o, this.tabSize = c || 8, this.lastColumnPos = this.lastColumnValue = 0, this.lineStart = 0, this.lineOracle = p;
      };
      Ot.prototype.eol = function() {
        return this.pos >= this.string.length;
      }, Ot.prototype.sol = function() {
        return this.pos == this.lineStart;
      }, Ot.prototype.peek = function() {
        return this.string.charAt(this.pos) || void 0;
      }, Ot.prototype.next = function() {
        if (this.pos < this.string.length)
          return this.string.charAt(this.pos++);
      }, Ot.prototype.eat = function(o) {
        var c = this.string.charAt(this.pos), p;
        if (typeof o == "string" ? p = c == o : p = c && (o.test ? o.test(c) : o(c)), p)
          return ++this.pos, c;
      }, Ot.prototype.eatWhile = function(o) {
        for (var c = this.pos; this.eat(o); )
          ;
        return this.pos > c;
      }, Ot.prototype.eatSpace = function() {
        for (var o = this.pos; /[\s\u00a0]/.test(this.string.charAt(this.pos)); )
          ++this.pos;
        return this.pos > o;
      }, Ot.prototype.skipToEnd = function() {
        this.pos = this.string.length;
      }, Ot.prototype.skipTo = function(o) {
        var c = this.string.indexOf(o, this.pos);
        if (c > -1)
          return this.pos = c, true;
      }, Ot.prototype.backUp = function(o) {
        this.pos -= o;
      }, Ot.prototype.column = function() {
        return this.lastColumnPos < this.start && (this.lastColumnValue = We(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue), this.lastColumnPos = this.start), this.lastColumnValue - (this.lineStart ? We(this.string, this.lineStart, this.tabSize) : 0);
      }, Ot.prototype.indentation = function() {
        return We(this.string, null, this.tabSize) - (this.lineStart ? We(this.string, this.lineStart, this.tabSize) : 0);
      }, Ot.prototype.match = function(o, c, p) {
        if (typeof o == "string") {
          var h = function(x) {
            return p ? x.toLowerCase() : x;
          }, m = this.string.substr(this.pos, o.length);
          if (h(m) == h(o))
            return c !== false && (this.pos += o.length), true;
        } else {
          var S = this.string.slice(this.pos).match(o);
          return S && S.index > 0 ? null : (S && c !== false && (this.pos += S[0].length), S);
        }
      }, Ot.prototype.current = function() {
        return this.string.slice(this.start, this.pos);
      }, Ot.prototype.hideFirstChars = function(o, c) {
        this.lineStart += o;
        try {
          return c();
        } finally {
          this.lineStart -= o;
        }
      }, Ot.prototype.lookAhead = function(o) {
        var c = this.lineOracle;
        return c && c.lookAhead(o);
      }, Ot.prototype.baseToken = function() {
        var o = this.lineOracle;
        return o && o.baseToken(this.pos);
      };
      function Re(o, c) {
        if (c -= o.first, c < 0 || c >= o.size)
          throw new Error("There is no line " + (c + o.first) + " in the document.");
        for (var p = o; !p.lines; )
          for (var h = 0; ; ++h) {
            var m = p.children[h], S = m.chunkSize();
            if (c < S) {
              p = m;
              break;
            }
            c -= S;
          }
        return p.lines[c];
      }
      function yr(o, c, p) {
        var h = [], m = c.line;
        return o.iter(c.line, p.line + 1, function(S) {
          var x = S.text;
          m == p.line && (x = x.slice(0, p.ch)), m == c.line && (x = x.slice(c.ch)), h.push(x), ++m;
        }), h;
      }
      function fl(o, c, p) {
        var h = [];
        return o.iter(c, p, function(m) {
          h.push(m.text);
        }), h;
      }
      function ei(o, c) {
        var p = c - o.height;
        if (p)
          for (var h = o; h; h = h.parent)
            h.height += p;
      }
      function M(o) {
        if (o.parent == null)
          return null;
        for (var c = o.parent, p = Pe(c.lines, o), h = c.parent; h; c = h, h = h.parent)
          for (var m = 0; h.children[m] != c; ++m)
            p += h.children[m].chunkSize();
        return p + c.first;
      }
      function $(o, c) {
        var p = o.first;
        e:
          do {
            for (var h = 0; h < o.children.length; ++h) {
              var m = o.children[h], S = m.height;
              if (c < S) {
                o = m;
                continue e;
              }
              c -= S, p += m.chunkSize();
            }
            return p;
          } while (!o.lines);
        for (var x = 0; x < o.lines.length; ++x) {
          var T = o.lines[x], k = T.height;
          if (c < k)
            break;
          c -= k;
        }
        return p + x;
      }
      function ie(o, c) {
        return c >= o.first && c < o.first + o.size;
      }
      function he(o, c) {
        return String(o.lineNumberFormatter(c + o.firstLineNumber));
      }
      function Q(o, c, p) {
        if (p === void 0 && (p = null), !(this instanceof Q))
          return new Q(o, c, p);
        this.line = o, this.ch = c, this.sticky = p;
      }
      function Se(o, c) {
        return o.line - c.line || o.ch - c.ch;
      }
      function ct(o, c) {
        return o.sticky == c.sticky && Se(o, c) == 0;
      }
      function nn(o) {
        return Q(o.line, o.ch);
      }
      function _n(o, c) {
        return Se(o, c) < 0 ? c : o;
      }
      function Ma(o, c) {
        return Se(o, c) < 0 ? o : c;
      }
      function yS(o, c) {
        return Math.max(o.first, Math.min(c, o.first + o.size - 1));
      }
      function He(o, c) {
        if (c.line < o.first)
          return Q(o.first, 0);
        var p = o.first + o.size - 1;
        return c.line > p ? Q(p, Re(o, p).text.length) : fP(c, Re(o, c.line).text.length);
      }
      function fP(o, c) {
        var p = o.ch;
        return p == null || p > c ? Q(o.line, c) : p < 0 ? Q(o.line, 0) : o;
      }
      function SS(o, c) {
        for (var p = [], h = 0; h < c.length; h++)
          p[h] = He(o, c[h]);
        return p;
      }
      var cd = function(o, c) {
        this.state = o, this.lookAhead = c;
      }, Yi = function(o, c, p, h) {
        this.state = c, this.doc = o, this.line = p, this.maxLookAhead = h || 0, this.baseTokens = null, this.baseTokenPos = 1;
      };
      Yi.prototype.lookAhead = function(o) {
        var c = this.doc.getLine(this.line + o);
        return c != null && o > this.maxLookAhead && (this.maxLookAhead = o), c;
      }, Yi.prototype.baseToken = function(o) {
        if (!this.baseTokens)
          return null;
        for (; this.baseTokens[this.baseTokenPos] <= o; )
          this.baseTokenPos += 2;
        var c = this.baseTokens[this.baseTokenPos + 1];
        return {
          type: c && c.replace(/( |^)overlay .*/, ""),
          size: this.baseTokens[this.baseTokenPos] - o
        };
      }, Yi.prototype.nextLine = function() {
        this.line++, this.maxLookAhead > 0 && this.maxLookAhead--;
      }, Yi.fromSaved = function(o, c, p) {
        return c instanceof cd ? new Yi(o, Ji(o.mode, c.state), p, c.lookAhead) : new Yi(o, Ji(o.mode, c), p);
      }, Yi.prototype.save = function(o) {
        var c = o !== false ? Ji(this.doc.mode, this.state) : this.state;
        return this.maxLookAhead > 0 ? new cd(c, this.maxLookAhead) : c;
      };
      function bS(o, c, p, h) {
        var m = [o.state.modeGen], S = {};
        kS(
          o,
          c.text,
          o.doc.mode,
          p,
          function(D, z) {
            return m.push(D, z);
          },
          S,
          h
        );
        for (var x = p.state, T = function(D) {
          p.baseTokens = m;
          var z = o.state.overlays[D], W = 1, q = 0;
          p.state = true, kS(o, c.text, z.mode, p, function(Y, ee) {
            for (var oe = W; q < Y; ) {
              var fe = m[W];
              fe > Y && m.splice(W, 1, Y, m[W + 1], fe), W += 2, q = Math.min(Y, fe);
            }
            if (ee)
              if (z.opaque)
                m.splice(oe, W - oe, Y, "overlay " + ee), W = oe + 2;
              else
                for (; oe < W; oe += 2) {
                  var ve = m[oe + 1];
                  m[oe + 1] = (ve ? ve + " " : "") + "overlay " + ee;
                }
          }, S), p.state = x, p.baseTokens = null, p.baseTokenPos = 1;
        }, k = 0; k < o.state.overlays.length; ++k)
          T(k);
        return { styles: m, classes: S.bgClass || S.textClass ? S : null };
      }
      function CS(o, c, p) {
        if (!c.styles || c.styles[0] != o.state.modeGen) {
          var h = pl(o, M(c)), m = c.text.length > o.options.maxHighlightLength && Ji(o.doc.mode, h.state), S = bS(o, c, h);
          m && (h.state = m), c.stateAfter = h.save(!m), c.styles = S.styles, S.classes ? c.styleClasses = S.classes : c.styleClasses && (c.styleClasses = null), p === o.doc.highlightFrontier && (o.doc.modeFrontier = Math.max(o.doc.modeFrontier, ++o.doc.highlightFrontier));
        }
        return c.styles;
      }
      function pl(o, c, p) {
        var h = o.doc, m = o.display;
        if (!h.mode.startState)
          return new Yi(h, true, c);
        var S = pP(o, c, p), x = S > h.first && Re(h, S - 1).stateAfter, T = x ? Yi.fromSaved(h, x, S) : new Yi(h, Ra(h.mode), S);
        return h.iter(S, c, function(k) {
          Cf(o, k.text, T);
          var D = T.line;
          k.stateAfter = D == c - 1 || D % 5 == 0 || D >= m.viewFrom && D < m.viewTo ? T.save() : null, T.nextLine();
        }), p && (h.modeFrontier = T.line), T;
      }
      function Cf(o, c, p, h) {
        var m = o.doc.mode, S = new Ot(c, o.options.tabSize, p);
        for (S.start = S.pos = h || 0, c == "" && wS(m, p.state); !S.eol(); )
          wf(m, S, p.state), S.start = S.pos;
      }
      function wS(o, c) {
        if (o.blankLine)
          return o.blankLine(c);
        if (o.innerMode) {
          var p = hl2(o, c);
          if (p.mode.blankLine)
            return p.mode.blankLine(p.state);
        }
      }
      function wf(o, c, p, h) {
        for (var m = 0; m < 10; m++) {
          h && (h[0] = hl2(o, p).mode);
          var S = o.token(c, p);
          if (c.pos > c.start)
            return S;
        }
        throw new Error("Mode " + o.name + " failed to advance stream.");
      }
      var xS = function(o, c, p) {
        this.start = o.start, this.end = o.pos, this.string = o.current(), this.type = c || null, this.state = p;
      };
      function ES(o, c, p, h) {
        var m = o.doc, S = m.mode, x;
        c = He(m, c);
        var T = Re(m, c.line), k = pl(o, c.line, p), D = new Ot(T.text, o.options.tabSize, k), z;
        for (h && (z = []); (h || D.pos < c.ch) && !D.eol(); )
          D.start = D.pos, x = wf(S, D, k.state), h && z.push(new xS(D, x, Ji(m.mode, k.state)));
        return h ? z : new xS(D, x, k.state);
      }
      function TS(o, c) {
        if (o)
          for (; ; ) {
            var p = o.match(/(?:^|\s+)line-(background-)?(\S+)/);
            if (!p)
              break;
            o = o.slice(0, p.index) + o.slice(p.index + p[0].length);
            var h = p[1] ? "bgClass" : "textClass";
            c[h] == null ? c[h] = p[2] : new RegExp("(?:^|\\s)" + p[2] + "(?:$|\\s)").test(c[h]) || (c[h] += " " + p[2]);
          }
        return o;
      }
      function kS(o, c, p, h, m, S, x) {
        var T = p.flattenSpans;
        T == null && (T = o.options.flattenSpans);
        var k = 0, D = null, z = new Ot(c, o.options.tabSize, h), W, q = o.options.addModeClass && [null];
        for (c == "" && TS(wS(p, h.state), S); !z.eol(); ) {
          if (z.pos > o.options.maxHighlightLength ? (T = false, x && Cf(o, c, h, z.pos), z.pos = c.length, W = null) : W = TS(wf(p, z, h.state, q), S), q) {
            var Y = q[0].name;
            Y && (W = "m-" + (W ? Y + " " + W : Y));
          }
          if (!T || D != W) {
            for (; k < z.start; )
              k = Math.min(z.start, k + 5e3), m(k, D);
            D = W;
          }
          z.start = z.pos;
        }
        for (; k < z.pos; ) {
          var ee = Math.min(z.pos, k + 5e3);
          m(ee, D), k = ee;
        }
      }
      function pP(o, c, p) {
        for (var h, m, S = o.doc, x = p ? -1 : c - (o.doc.mode.innerMode ? 1e3 : 100), T = c; T > x; --T) {
          if (T <= S.first)
            return S.first;
          var k = Re(S, T - 1), D = k.stateAfter;
          if (D && (!p || T + (D instanceof cd ? D.lookAhead : 0) <= S.modeFrontier))
            return T;
          var z = We(k.text, null, o.options.tabSize);
          (m == null || h > z) && (m = T - 1, h = z);
        }
        return m;
      }
      function gP(o, c) {
        if (o.modeFrontier = Math.min(o.modeFrontier, c), !(o.highlightFrontier < c - 10)) {
          for (var p = o.first, h = c - 1; h > p; h--) {
            var m = Re(o, h).stateAfter;
            if (m && (!(m instanceof cd) || h + m.lookAhead < c)) {
              p = h + 1;
              break;
            }
          }
          o.highlightFrontier = Math.min(o.highlightFrontier, p);
        }
      }
      var IS = false, Sr = false;
      function mP() {
        IS = true;
      }
      function vP() {
        Sr = true;
      }
      function dd(o, c, p) {
        this.marker = o, this.from = c, this.to = p;
      }
      function gl(o, c) {
        if (o)
          for (var p = 0; p < o.length; ++p) {
            var h = o[p];
            if (h.marker == c)
              return h;
          }
      }
      function yP(o, c) {
        for (var p, h = 0; h < o.length; ++h)
          o[h] != c && (p || (p = [])).push(o[h]);
        return p;
      }
      function SP(o, c, p) {
        var h = p && window.WeakSet && (p.markedSpans || (p.markedSpans = /* @__PURE__ */ new WeakSet()));
        h && o.markedSpans && h.has(o.markedSpans) ? o.markedSpans.push(c) : (o.markedSpans = o.markedSpans ? o.markedSpans.concat([c]) : [c], h && h.add(o.markedSpans)), c.marker.attachLine(o);
      }
      function bP(o, c, p) {
        var h;
        if (o)
          for (var m = 0; m < o.length; ++m) {
            var S = o[m], x = S.marker, T = S.from == null || (x.inclusiveLeft ? S.from <= c : S.from < c);
            if (T || S.from == c && x.type == "bookmark" && (!p || !S.marker.insertLeft)) {
              var k = S.to == null || (x.inclusiveRight ? S.to >= c : S.to > c);
              (h || (h = [])).push(new dd(x, S.from, k ? null : S.to));
            }
          }
        return h;
      }
      function CP(o, c, p) {
        var h;
        if (o)
          for (var m = 0; m < o.length; ++m) {
            var S = o[m], x = S.marker, T = S.to == null || (x.inclusiveRight ? S.to >= c : S.to > c);
            if (T || S.from == c && x.type == "bookmark" && (!p || S.marker.insertLeft)) {
              var k = S.from == null || (x.inclusiveLeft ? S.from <= c : S.from < c);
              (h || (h = [])).push(new dd(
                x,
                k ? null : S.from - c,
                S.to == null ? null : S.to - c
              ));
            }
          }
        return h;
      }
      function xf(o, c) {
        if (c.full)
          return null;
        var p = ie(o, c.from.line) && Re(o, c.from.line).markedSpans, h = ie(o, c.to.line) && Re(o, c.to.line).markedSpans;
        if (!p && !h)
          return null;
        var m = c.from.ch, S = c.to.ch, x = Se(c.from, c.to) == 0, T = bP(p, m, x), k = CP(h, S, x), D = c.text.length == 1, z = me(c.text).length + (D ? m : 0);
        if (T)
          for (var W = 0; W < T.length; ++W) {
            var q = T[W];
            if (q.to == null) {
              var Y = gl(k, q.marker);
              Y ? D && (q.to = Y.to == null ? null : Y.to + z) : q.to = m;
            }
          }
        if (k)
          for (var ee = 0; ee < k.length; ++ee) {
            var oe = k[ee];
            if (oe.to != null && (oe.to += z), oe.from == null) {
              var fe = gl(T, oe.marker);
              fe || (oe.from = z, D && (T || (T = [])).push(oe));
            } else
              oe.from += z, D && (T || (T = [])).push(oe);
          }
        T && (T = LS(T)), k && k != T && (k = LS(k));
        var ve = [T];
        if (!D) {
          var xe = c.text.length - 2, ye;
          if (xe > 0 && T)
            for (var ke = 0; ke < T.length; ++ke)
              T[ke].to == null && (ye || (ye = [])).push(new dd(T[ke].marker, null, null));
          for (var Ve = 0; Ve < xe; ++Ve)
            ve.push(ye);
          ve.push(k);
        }
        return ve;
      }
      function LS(o) {
        for (var c = 0; c < o.length; ++c) {
          var p = o[c];
          p.from != null && p.from == p.to && p.marker.clearWhenEmpty !== false && o.splice(c--, 1);
        }
        return o.length ? o : null;
      }
      function wP(o, c, p) {
        var h = null;
        if (o.iter(c.line, p.line + 1, function(Y) {
          if (Y.markedSpans)
            for (var ee = 0; ee < Y.markedSpans.length; ++ee) {
              var oe = Y.markedSpans[ee].marker;
              oe.readOnly && (!h || Pe(h, oe) == -1) && (h || (h = [])).push(oe);
            }
        }), !h)
          return null;
        for (var m = [{ from: c, to: p }], S = 0; S < h.length; ++S)
          for (var x = h[S], T = x.find(0), k = 0; k < m.length; ++k) {
            var D = m[k];
            if (!(Se(D.to, T.from) < 0 || Se(D.from, T.to) > 0)) {
              var z = [k, 1], W = Se(D.from, T.from), q = Se(D.to, T.to);
              (W < 0 || !x.inclusiveLeft && !W) && z.push({ from: D.from, to: T.from }), (q > 0 || !x.inclusiveRight && !q) && z.push({ from: T.to, to: D.to }), m.splice.apply(m, z), k += z.length - 3;
            }
          }
        return m;
      }
      function DS(o) {
        var c = o.markedSpans;
        if (c) {
          for (var p = 0; p < c.length; ++p)
            c[p].marker.detachLine(o);
          o.markedSpans = null;
        }
      }
      function PS(o, c) {
        if (c) {
          for (var p = 0; p < c.length; ++p)
            c[p].marker.attachLine(o);
          o.markedSpans = c;
        }
      }
      function ud(o) {
        return o.inclusiveLeft ? -1 : 0;
      }
      function hd(o) {
        return o.inclusiveRight ? 1 : 0;
      }
      function Ef(o, c) {
        var p = o.lines.length - c.lines.length;
        if (p != 0)
          return p;
        var h = o.find(), m = c.find(), S = Se(h.from, m.from) || ud(o) - ud(c);
        if (S)
          return -S;
        var x = Se(h.to, m.to) || hd(o) - hd(c);
        return x || c.id - o.id;
      }
      function AS(o, c) {
        var p = Sr && o.markedSpans, h;
        if (p)
          for (var m = void 0, S = 0; S < p.length; ++S)
            m = p[S], m.marker.collapsed && (c ? m.from : m.to) == null && (!h || Ef(h, m.marker) < 0) && (h = m.marker);
        return h;
      }
      function RS(o) {
        return AS(o, true);
      }
      function fd(o) {
        return AS(o, false);
      }
      function xP(o, c) {
        var p = Sr && o.markedSpans, h;
        if (p)
          for (var m = 0; m < p.length; ++m) {
            var S = p[m];
            S.marker.collapsed && (S.from == null || S.from < c) && (S.to == null || S.to > c) && (!h || Ef(h, S.marker) < 0) && (h = S.marker);
          }
        return h;
      }
      function MS(o, c, p, h, m) {
        var S = Re(o, c), x = Sr && S.markedSpans;
        if (x)
          for (var T = 0; T < x.length; ++T) {
            var k = x[T];
            if (k.marker.collapsed) {
              var D = k.marker.find(0), z = Se(D.from, p) || ud(k.marker) - ud(m), W = Se(D.to, h) || hd(k.marker) - hd(m);
              if (!(z >= 0 && W <= 0 || z <= 0 && W >= 0) && (z <= 0 && (k.marker.inclusiveRight && m.inclusiveLeft ? Se(D.to, p) >= 0 : Se(D.to, p) > 0) || z >= 0 && (k.marker.inclusiveRight && m.inclusiveLeft ? Se(D.from, h) <= 0 : Se(D.from, h) < 0)))
                return true;
            }
          }
      }
      function Ri(o) {
        for (var c; c = RS(o); )
          o = c.find(-1, true).line;
        return o;
      }
      function EP(o) {
        for (var c; c = fd(o); )
          o = c.find(1, true).line;
        return o;
      }
      function TP(o) {
        for (var c, p; c = fd(o); )
          o = c.find(1, true).line, (p || (p = [])).push(o);
        return p;
      }
      function Tf(o, c) {
        var p = Re(o, c), h = Ri(p);
        return p == h ? c : M(h);
      }
      function NS(o, c) {
        if (c > o.lastLine())
          return c;
        var p = Re(o, c), h;
        if (!ns(o, p))
          return c;
        for (; h = fd(p); )
          p = h.find(1, true).line;
        return M(p) + 1;
      }
      function ns(o, c) {
        var p = Sr && c.markedSpans;
        if (p) {
          for (var h = void 0, m = 0; m < p.length; ++m)
            if (h = p[m], !!h.marker.collapsed) {
              if (h.from == null)
                return true;
              if (!h.marker.widgetNode && h.from == 0 && h.marker.inclusiveLeft && kf(o, c, h))
                return true;
            }
        }
      }
      function kf(o, c, p) {
        if (p.to == null) {
          var h = p.marker.find(1, true);
          return kf(o, h.line, gl(h.line.markedSpans, p.marker));
        }
        if (p.marker.inclusiveRight && p.to == c.text.length)
          return true;
        for (var m = void 0, S = 0; S < c.markedSpans.length; ++S)
          if (m = c.markedSpans[S], m.marker.collapsed && !m.marker.widgetNode && m.from == p.to && (m.to == null || m.to != p.from) && (m.marker.inclusiveLeft || p.marker.inclusiveRight) && kf(o, c, m))
            return true;
      }
      function br(o) {
        o = Ri(o);
        for (var c = 0, p = o.parent, h = 0; h < p.lines.length; ++h) {
          var m = p.lines[h];
          if (m == o)
            break;
          c += m.height;
        }
        for (var S = p.parent; S; p = S, S = p.parent)
          for (var x = 0; x < S.children.length; ++x) {
            var T = S.children[x];
            if (T == p)
              break;
            c += T.height;
          }
        return c;
      }
      function pd(o) {
        if (o.height == 0)
          return 0;
        for (var c = o.text.length, p, h = o; p = RS(h); ) {
          var m = p.find(0, true);
          h = m.from.line, c += m.from.ch - m.to.ch;
        }
        for (h = o; p = fd(h); ) {
          var S = p.find(0, true);
          c -= h.text.length - S.from.ch, h = S.to.line, c += h.text.length - S.to.ch;
        }
        return c;
      }
      function If(o) {
        var c = o.display, p = o.doc;
        c.maxLine = Re(p, p.first), c.maxLineLength = pd(c.maxLine), c.maxLineChanged = true, p.iter(function(h) {
          var m = pd(h);
          m > c.maxLineLength && (c.maxLineLength = m, c.maxLine = h);
        });
      }
      var Na = function(o, c, p) {
        this.text = o, PS(this, c), this.height = p ? p(this) : 1;
      };
      Na.prototype.lineNo = function() {
        return M(this);
      }, Ii(Na);
      function kP(o, c, p, h) {
        o.text = c, o.stateAfter && (o.stateAfter = null), o.styles && (o.styles = null), o.order != null && (o.order = null), DS(o), PS(o, p);
        var m = h ? h(o) : 1;
        m != o.height && ei(o, m);
      }
      function IP(o) {
        o.parent = null, DS(o);
      }
      var LP = {}, DP = {};
      function _S(o, c) {
        if (!o || /^\s*$/.test(o))
          return null;
        var p = c.addModeClass ? DP : LP;
        return p[o] || (p[o] = o.replace(/\S+/g, "cm-$&"));
      }
      function OS(o, c) {
        var p = ue("span", null, null, f ? "padding-right: .1px" : null), h = {
          pre: ue("pre", [p], "CodeMirror-line"),
          content: p,
          col: 0,
          pos: 0,
          cm: o,
          trailingSpace: false,
          splitSpaces: o.getOption("lineWrapping")
        };
        c.measure = {};
        for (var m = 0; m <= (c.rest ? c.rest.length : 0); m++) {
          var S = m ? c.rest[m - 1] : c.line, x = void 0;
          h.pos = 0, h.addToken = AP, Qr(o.display.measure) && (x = Qe(S, o.doc.direction)) && (h.addToken = MP(h.addToken, x)), h.map = [];
          var T = c != o.display.externalMeasured && M(S);
          NP(S, h, CS(o, S, T)), S.styleClasses && (S.styleClasses.bgClass && (h.bgClass = Ue(S.styleClasses.bgClass, h.bgClass || "")), S.styleClasses.textClass && (h.textClass = Ue(S.styleClasses.textClass, h.textClass || ""))), h.map.length == 0 && h.map.push(0, 0, h.content.appendChild(od(o.display.measure))), m == 0 ? (c.measure.map = h.map, c.measure.cache = {}) : ((c.measure.maps || (c.measure.maps = [])).push(h.map), (c.measure.caches || (c.measure.caches = [])).push({}));
        }
        if (f) {
          var k = h.content.lastChild;
          (/\bcm-tab\b/.test(k.className) || k.querySelector && k.querySelector(".cm-tab")) && (h.content.className = "cm-tab-wrap-hack");
        }
        return Nt(o, "renderLine", o, c.line, h.pre), h.pre.className && (h.textClass = Ue(h.pre.className, h.textClass || "")), h;
      }
      function PP(o) {
        var c = F("span", "•", "cm-invalidchar");
        return c.title = "\\u" + o.charCodeAt(0).toString(16), c.setAttribute("aria-label", c.title), c;
      }
      function AP(o, c, p, h, m, S, x) {
        if (c) {
          var T = o.splitSpaces ? RP(c, o.trailingSpace) : c, k = o.cm.state.specialChars, D = false, z;
          if (!k.test(c))
            o.col += c.length, z = document.createTextNode(T), o.map.push(o.pos, o.pos + c.length, z), d && u < 9 && (D = true), o.pos += c.length;
          else {
            z = document.createDocumentFragment();
            for (var W = 0; ; ) {
              k.lastIndex = W;
              var q = k.exec(c), Y = q ? q.index - W : c.length - W;
              if (Y) {
                var ee = document.createTextNode(T.slice(W, W + Y));
                d && u < 9 ? z.appendChild(F("span", [ee])) : z.appendChild(ee), o.map.push(o.pos, o.pos + Y, ee), o.col += Y, o.pos += Y;
              }
              if (!q)
                break;
              W += Y + 1;
              var oe = void 0;
              if (q[0] == "	") {
                var fe = o.cm.options.tabSize, ve = fe - o.col % fe;
                oe = z.appendChild(F("span", we(ve), "cm-tab")), oe.setAttribute("role", "presentation"), oe.setAttribute("cm-text", "	"), o.col += ve;
              } else
                q[0] == "\r" || q[0] == `
` ? (oe = z.appendChild(F("span", q[0] == "\r" ? "␍" : "␤", "cm-invalidchar")), oe.setAttribute("cm-text", q[0]), o.col += 1) : (oe = o.cm.options.specialCharPlaceholder(q[0]), oe.setAttribute("cm-text", q[0]), d && u < 9 ? z.appendChild(F("span", [oe])) : z.appendChild(oe), o.col += 1);
              o.map.push(o.pos, o.pos + 1, oe), o.pos++;
            }
          }
          if (o.trailingSpace = T.charCodeAt(c.length - 1) == 32, p || h || m || D || S || x) {
            var xe = p || "";
            h && (xe += h), m && (xe += m);
            var ye = F("span", [z], xe, S);
            if (x)
              for (var ke in x)
                x.hasOwnProperty(ke) && ke != "style" && ke != "class" && ye.setAttribute(ke, x[ke]);
            return o.content.appendChild(ye);
          }
          o.content.appendChild(z);
        }
      }
      function RP(o, c) {
        if (o.length > 1 && !/  /.test(o))
          return o;
        for (var p = c, h = "", m = 0; m < o.length; m++) {
          var S = o.charAt(m);
          S == " " && p && (m == o.length - 1 || o.charCodeAt(m + 1) == 32) && (S = " "), h += S, p = S == " ";
        }
        return h;
      }
      function MP(o, c) {
        return function(p, h, m, S, x, T, k) {
          m = m ? m + " cm-force-border" : "cm-force-border";
          for (var D = p.pos, z = D + h.length; ; ) {
            for (var W = void 0, q = 0; q < c.length && (W = c[q], !(W.to > D && W.from <= D)); q++)
              ;
            if (W.to >= z)
              return o(p, h, m, S, x, T, k);
            o(p, h.slice(0, W.to - D), m, S, null, T, k), S = null, h = h.slice(W.to - D), D = W.to;
          }
        };
      }
      function VS(o, c, p, h) {
        var m = !h && p.widgetNode;
        m && o.map.push(o.pos, o.pos + c, m), !h && o.cm.display.input.needsContentAttribute && (m || (m = o.content.appendChild(document.createElement("span"))), m.setAttribute("cm-marker", p.id)), m && (o.cm.display.input.setUneditable(m), o.content.appendChild(m)), o.pos += c, o.trailingSpace = false;
      }
      function NP(o, c, p) {
        var h = o.markedSpans, m = o.text, S = 0;
        if (!h) {
          for (var x = 1; x < p.length; x += 2)
            c.addToken(c, m.slice(S, S = p[x]), _S(p[x + 1], c.cm.options));
          return;
        }
        for (var T = m.length, k = 0, D = 1, z = "", W, q, Y = 0, ee, oe, fe, ve, xe; ; ) {
          if (Y == k) {
            ee = oe = fe = q = "", xe = null, ve = null, Y = 1 / 0;
            for (var ye = [], ke = void 0, Ve = 0; Ve < h.length; ++Ve) {
              var Ne = h[Ve], Ke = Ne.marker;
              if (Ke.type == "bookmark" && Ne.from == k && Ke.widgetNode)
                ye.push(Ke);
              else if (Ne.from <= k && (Ne.to == null || Ne.to > k || Ke.collapsed && Ne.to == k && Ne.from == k)) {
                if (Ne.to != null && Ne.to != k && Y > Ne.to && (Y = Ne.to, oe = ""), Ke.className && (ee += " " + Ke.className), Ke.css && (q = (q ? q + ";" : "") + Ke.css), Ke.startStyle && Ne.from == k && (fe += " " + Ke.startStyle), Ke.endStyle && Ne.to == Y && (ke || (ke = [])).push(Ke.endStyle, Ne.to), Ke.title && ((xe || (xe = {})).title = Ke.title), Ke.attributes)
                  for (var xt in Ke.attributes)
                    (xe || (xe = {}))[xt] = Ke.attributes[xt];
                Ke.collapsed && (!ve || Ef(ve.marker, Ke) < 0) && (ve = Ne);
              } else
                Ne.from > k && Y > Ne.from && (Y = Ne.from);
            }
            if (ke)
              for (var on = 0; on < ke.length; on += 2)
                ke[on + 1] == Y && (oe += " " + ke[on]);
            if (!ve || ve.from == k)
              for (var Mt = 0; Mt < ye.length; ++Mt)
                VS(c, 0, ye[Mt]);
            if (ve && (ve.from || 0) == k) {
              if (VS(
                c,
                (ve.to == null ? T + 1 : ve.to) - k,
                ve.marker,
                ve.from == null
              ), ve.to == null)
                return;
              ve.to == k && (ve = false);
            }
          }
          if (k >= T)
            break;
          for (var qn = Math.min(T, Y); ; ) {
            if (z) {
              var Bn = k + z.length;
              if (!ve) {
                var Yt = Bn > qn ? z.slice(0, qn - k) : z;
                c.addToken(
                  c,
                  Yt,
                  W ? W + ee : ee,
                  fe,
                  k + Yt.length == Y ? oe : "",
                  q,
                  xe
                );
              }
              if (Bn >= qn) {
                z = z.slice(qn - k), k = qn;
                break;
              }
              k = Bn, fe = "";
            }
            z = m.slice(S, S = p[D++]), W = _S(p[D++], c.cm.options);
          }
        }
      }
      function BS(o, c, p) {
        this.line = c, this.rest = TP(c), this.size = this.rest ? M(me(this.rest)) - p + 1 : 1, this.node = this.text = null, this.hidden = ns(o, c);
      }
      function gd(o, c, p) {
        for (var h = [], m, S = c; S < p; S = m) {
          var x = new BS(o.doc, Re(o.doc, S), S);
          m = S + x.size, h.push(x);
        }
        return h;
      }
      var _a = null;
      function _P(o) {
        _a ? _a.ops.push(o) : o.ownsGroup = _a = {
          ops: [o],
          delayedCallbacks: []
        };
      }
      function OP(o) {
        var c = o.delayedCallbacks, p = 0;
        do {
          for (; p < c.length; p++)
            c[p].call(null);
          for (var h = 0; h < o.ops.length; h++) {
            var m = o.ops[h];
            if (m.cursorActivityHandlers)
              for (; m.cursorActivityCalled < m.cursorActivityHandlers.length; )
                m.cursorActivityHandlers[m.cursorActivityCalled++].call(null, m.cm);
          }
        } while (p < c.length);
      }
      function VP(o, c) {
        var p = o.ownsGroup;
        if (p)
          try {
            OP(p);
          } finally {
            _a = null, c(p);
          }
      }
      var ml = null;
      function rn(o, c) {
        var p = vr(o, c);
        if (p.length) {
          var h = Array.prototype.slice.call(arguments, 2), m;
          _a ? m = _a.delayedCallbacks : ml ? m = ml : (m = ml = [], setTimeout(BP, 0));
          for (var S = function(T) {
            m.push(function() {
              return p[T].apply(null, h);
            });
          }, x = 0; x < p.length; ++x)
            S(x);
        }
      }
      function BP() {
        var o = ml;
        ml = null;
        for (var c = 0; c < o.length; ++c)
          o[c]();
      }
      function FS(o, c, p, h) {
        for (var m = 0; m < c.changes.length; m++) {
          var S = c.changes[m];
          S == "text" ? UP(o, c) : S == "gutter" ? zS(o, c, p, h) : S == "class" ? Lf(o, c) : S == "widget" && zP(o, c, h);
        }
        c.changes = null;
      }
      function vl(o) {
        return o.node == o.text && (o.node = F("div", null, null, "position: relative"), o.text.parentNode && o.text.parentNode.replaceChild(o.node, o.text), o.node.appendChild(o.text), d && u < 8 && (o.node.style.zIndex = 2)), o.node;
      }
      function FP(o, c) {
        var p = c.bgClass ? c.bgClass + " " + (c.line.bgClass || "") : c.line.bgClass;
        if (p && (p += " CodeMirror-linebackground"), c.background)
          p ? c.background.className = p : (c.background.parentNode.removeChild(c.background), c.background = null);
        else if (p) {
          var h = vl(c);
          c.background = h.insertBefore(F("div", null, p), h.firstChild), o.display.input.setUneditable(c.background);
        }
      }
      function US(o, c) {
        var p = o.display.externalMeasured;
        return p && p.line == c.line ? (o.display.externalMeasured = null, c.measure = p.measure, p.built) : OS(o, c);
      }
      function UP(o, c) {
        var p = c.text.className, h = US(o, c);
        c.text == c.node && (c.node = h.pre), c.text.parentNode.replaceChild(h.pre, c.text), c.text = h.pre, h.bgClass != c.bgClass || h.textClass != c.textClass ? (c.bgClass = h.bgClass, c.textClass = h.textClass, Lf(o, c)) : p && (c.text.className = p);
      }
      function Lf(o, c) {
        FP(o, c), c.line.wrapClass ? vl(c).className = c.line.wrapClass : c.node != c.text && (c.node.className = "");
        var p = c.textClass ? c.textClass + " " + (c.line.textClass || "") : c.line.textClass;
        c.text.className = p || "";
      }
      function zS(o, c, p, h) {
        if (c.gutter && (c.node.removeChild(c.gutter), c.gutter = null), c.gutterBackground && (c.node.removeChild(c.gutterBackground), c.gutterBackground = null), c.line.gutterClass) {
          var m = vl(c);
          c.gutterBackground = F(
            "div",
            null,
            "CodeMirror-gutter-background " + c.line.gutterClass,
            "left: " + (o.options.fixedGutter ? h.fixedPos : -h.gutterTotalWidth) + "px; width: " + h.gutterTotalWidth + "px"
          ), o.display.input.setUneditable(c.gutterBackground), m.insertBefore(c.gutterBackground, c.text);
        }
        var S = c.line.gutterMarkers;
        if (o.options.lineNumbers || S) {
          var x = vl(c), T = c.gutter = F("div", null, "CodeMirror-gutter-wrapper", "left: " + (o.options.fixedGutter ? h.fixedPos : -h.gutterTotalWidth) + "px");
          if (T.setAttribute("aria-hidden", "true"), o.display.input.setUneditable(T), x.insertBefore(T, c.text), c.line.gutterClass && (T.className += " " + c.line.gutterClass), o.options.lineNumbers && (!S || !S["CodeMirror-linenumbers"]) && (c.lineNumber = T.appendChild(
            F(
              "div",
              he(o.options, p),
              "CodeMirror-linenumber CodeMirror-gutter-elt",
              "left: " + h.gutterLeft["CodeMirror-linenumbers"] + "px; width: " + o.display.lineNumInnerWidth + "px"
            )
          )), S)
            for (var k = 0; k < o.display.gutterSpecs.length; ++k) {
              var D = o.display.gutterSpecs[k].className, z = S.hasOwnProperty(D) && S[D];
              z && T.appendChild(F(
                "div",
                [z],
                "CodeMirror-gutter-elt",
                "left: " + h.gutterLeft[D] + "px; width: " + h.gutterWidth[D] + "px"
              ));
            }
        }
      }
      function zP(o, c, p) {
        c.alignable && (c.alignable = null);
        for (var h = j("CodeMirror-linewidget"), m = c.node.firstChild, S = void 0; m; m = S)
          S = m.nextSibling, h.test(m.className) && c.node.removeChild(m);
        GS(o, c, p);
      }
      function GP(o, c, p, h) {
        var m = US(o, c);
        return c.text = c.node = m.pre, m.bgClass && (c.bgClass = m.bgClass), m.textClass && (c.textClass = m.textClass), Lf(o, c), zS(o, c, p, h), GS(o, c, h), c.node;
      }
      function GS(o, c, p) {
        if ($S(o, c.line, c, p, true), c.rest)
          for (var h = 0; h < c.rest.length; h++)
            $S(o, c.rest[h], c, p, false);
      }
      function $S(o, c, p, h, m) {
        if (c.widgets)
          for (var S = vl(p), x = 0, T = c.widgets; x < T.length; ++x) {
            var k = T[x], D = F("div", [k.node], "CodeMirror-linewidget" + (k.className ? " " + k.className : ""));
            k.handleMouseEvents || D.setAttribute("cm-ignore-events", "true"), $P(k, D, p, h), o.display.input.setUneditable(D), m && k.above ? S.insertBefore(D, p.gutter || p.text) : S.appendChild(D), rn(k, "redraw");
          }
      }
      function $P(o, c, p, h) {
        if (o.noHScroll) {
          (p.alignable || (p.alignable = [])).push(c);
          var m = h.wrapperWidth;
          c.style.left = h.fixedPos + "px", o.coverGutter || (m -= h.gutterTotalWidth, c.style.paddingLeft = h.gutterTotalWidth + "px"), c.style.width = m + "px";
        }
        o.coverGutter && (c.style.zIndex = 5, c.style.position = "relative", o.noHScroll || (c.style.marginLeft = -h.gutterTotalWidth + "px"));
      }
      function yl(o) {
        if (o.height != null)
          return o.height;
        var c = o.doc.cm;
        if (!c)
          return 0;
        if (!Ie(document.body, o.node)) {
          var p = "position: relative;";
          o.coverGutter && (p += "margin-left: -" + c.display.gutters.offsetWidth + "px;"), o.noHScroll && (p += "width: " + c.display.wrapper.clientWidth + "px;"), G(c.display.measure, F("div", [o.node], null, p));
        }
        return o.height = o.node.parentNode.offsetHeight;
      }
      function Cr(o, c) {
        for (var p = dl(c); p != o.wrapper; p = p.parentNode)
          if (!p || p.nodeType == 1 && p.getAttribute("cm-ignore-events") == "true" || p.parentNode == o.sizer && p != o.mover)
            return true;
      }
      function md(o) {
        return o.lineSpace.offsetTop;
      }
      function Df(o) {
        return o.mover.offsetHeight - o.lineSpace.offsetHeight;
      }
      function WS(o) {
        if (o.cachedPaddingH)
          return o.cachedPaddingH;
        var c = G(o.measure, F("pre", "x", "CodeMirror-line-like")), p = window.getComputedStyle ? window.getComputedStyle(c) : c.currentStyle, h = { left: parseInt(p.paddingLeft), right: parseInt(p.paddingRight) };
        return !isNaN(h.left) && !isNaN(h.right) && (o.cachedPaddingH = h), h;
      }
      function qi(o) {
        return bt - o.display.nativeBarWidth;
      }
      function Vs(o) {
        return o.display.scroller.clientWidth - qi(o) - o.display.barWidth;
      }
      function Pf(o) {
        return o.display.scroller.clientHeight - qi(o) - o.display.barHeight;
      }
      function WP(o, c, p) {
        var h = o.options.lineWrapping, m = h && Vs(o);
        if (!c.measure.heights || h && c.measure.width != m) {
          var S = c.measure.heights = [];
          if (h) {
            c.measure.width = m;
            for (var x = c.text.firstChild.getClientRects(), T = 0; T < x.length - 1; T++) {
              var k = x[T], D = x[T + 1];
              Math.abs(k.bottom - D.bottom) > 2 && S.push((k.bottom + D.top) / 2 - p.top);
            }
          }
          S.push(p.bottom - p.top);
        }
      }
      function HS(o, c, p) {
        if (o.line == c)
          return { map: o.measure.map, cache: o.measure.cache };
        if (o.rest) {
          for (var h = 0; h < o.rest.length; h++)
            if (o.rest[h] == c)
              return { map: o.measure.maps[h], cache: o.measure.caches[h] };
          for (var m = 0; m < o.rest.length; m++)
            if (M(o.rest[m]) > p)
              return { map: o.measure.maps[m], cache: o.measure.caches[m], before: true };
        }
      }
      function HP(o, c) {
        c = Ri(c);
        var p = M(c), h = o.display.externalMeasured = new BS(o.doc, c, p);
        h.lineN = p;
        var m = h.built = OS(o, h);
        return h.text = m.pre, G(o.display.lineMeasure, m.pre), h;
      }
      function jS(o, c, p, h) {
        return Ki(o, Oa(o, c), p, h);
      }
      function Af(o, c) {
        if (c >= o.display.viewFrom && c < o.display.viewTo)
          return o.display.view[Us(o, c)];
        var p = o.display.externalMeasured;
        if (p && c >= p.lineN && c < p.lineN + p.size)
          return p;
      }
      function Oa(o, c) {
        var p = M(c), h = Af(o, p);
        h && !h.text ? h = null : h && h.changes && (FS(o, h, p, Of(o)), o.curOp.forceUpdate = true), h || (h = HP(o, c));
        var m = HS(h, c, p);
        return {
          line: c,
          view: h,
          rect: null,
          map: m.map,
          cache: m.cache,
          before: m.before,
          hasHeights: false
        };
      }
      function Ki(o, c, p, h, m) {
        c.before && (p = -1);
        var S = p + (h || ""), x;
        return c.cache.hasOwnProperty(S) ? x = c.cache[S] : (c.rect || (c.rect = c.view.text.getBoundingClientRect()), c.hasHeights || (WP(o, c.view, c.rect), c.hasHeights = true), x = JP(o, c, p, h), x.bogus || (c.cache[S] = x)), {
          left: x.left,
          right: x.right,
          top: m ? x.rtop : x.top,
          bottom: m ? x.rbottom : x.bottom
        };
      }
      var JS = { left: 0, right: 0, top: 0, bottom: 0 };
      function YS(o, c, p) {
        for (var h, m, S, x, T, k, D = 0; D < o.length; D += 3)
          if (T = o[D], k = o[D + 1], c < T ? (m = 0, S = 1, x = "left") : c < k ? (m = c - T, S = m + 1) : (D == o.length - 3 || c == k && o[D + 3] > c) && (S = k - T, m = S - 1, c >= k && (x = "right")), m != null) {
            if (h = o[D + 2], T == k && p == (h.insertLeft ? "left" : "right") && (x = p), p == "left" && m == 0)
              for (; D && o[D - 2] == o[D - 3] && o[D - 1].insertLeft; )
                h = o[(D -= 3) + 2], x = "left";
            if (p == "right" && m == k - T)
              for (; D < o.length - 3 && o[D + 3] == o[D + 4] && !o[D + 5].insertLeft; )
                h = o[(D += 3) + 2], x = "right";
            break;
          }
        return { node: h, start: m, end: S, collapse: x, coverStart: T, coverEnd: k };
      }
      function jP(o, c) {
        var p = JS;
        if (c == "left")
          for (var h = 0; h < o.length && (p = o[h]).left == p.right; h++)
            ;
        else
          for (var m = o.length - 1; m >= 0 && (p = o[m]).left == p.right; m--)
            ;
        return p;
      }
      function JP(o, c, p, h) {
        var m = YS(c.map, p, h), S = m.node, x = m.start, T = m.end, k = m.collapse, D;
        if (S.nodeType == 3) {
          for (var z = 0; z < 4; z++) {
            for (; x && qe(c.line.text.charAt(m.coverStart + x)); )
              --x;
            for (; m.coverStart + T < m.coverEnd && qe(c.line.text.charAt(m.coverStart + T)); )
              ++T;
            if (d && u < 9 && x == 0 && T == m.coverEnd - m.coverStart ? D = S.parentNode.getBoundingClientRect() : D = jP(ae(S, x, T).getClientRects(), h), D.left || D.right || x == 0)
              break;
            T = x, x = x - 1, k = "right";
          }
          d && u < 11 && (D = YP(o.display.measure, D));
        } else {
          x > 0 && (k = h = "right");
          var W;
          o.options.lineWrapping && (W = S.getClientRects()).length > 1 ? D = W[h == "right" ? W.length - 1 : 0] : D = S.getBoundingClientRect();
        }
        if (d && u < 9 && !x && (!D || !D.left && !D.right)) {
          var q = S.parentNode.getClientRects()[0];
          q ? D = { left: q.left, right: q.left + Ba(o.display), top: q.top, bottom: q.bottom } : D = JS;
        }
        for (var Y = D.top - c.rect.top, ee = D.bottom - c.rect.top, oe = (Y + ee) / 2, fe = c.view.measure.heights, ve = 0; ve < fe.length - 1 && !(oe < fe[ve]); ve++)
          ;
        var xe = ve ? fe[ve - 1] : 0, ye = fe[ve], ke = {
          left: (k == "right" ? D.right : D.left) - c.rect.left,
          right: (k == "left" ? D.left : D.right) - c.rect.left,
          top: xe,
          bottom: ye
        };
        return !D.left && !D.right && (ke.bogus = true), o.options.singleCursorHeightPerLine || (ke.rtop = Y, ke.rbottom = ee), ke;
      }
      function YP(o, c) {
        if (!window.screen || screen.logicalXDPI == null || screen.logicalXDPI == screen.deviceXDPI || !bf(o))
          return c;
        var p = screen.logicalXDPI / screen.deviceXDPI, h = screen.logicalYDPI / screen.deviceYDPI;
        return {
          left: c.left * p,
          right: c.right * p,
          top: c.top * h,
          bottom: c.bottom * h
        };
      }
      function qS(o) {
        if (o.measure && (o.measure.cache = {}, o.measure.heights = null, o.rest))
          for (var c = 0; c < o.rest.length; c++)
            o.measure.caches[c] = {};
      }
      function KS(o) {
        o.display.externalMeasure = null, V(o.display.lineMeasure);
        for (var c = 0; c < o.display.view.length; c++)
          qS(o.display.view[c]);
      }
      function Sl(o) {
        KS(o), o.display.cachedCharWidth = o.display.cachedTextHeight = o.display.cachedPaddingH = null, o.options.lineWrapping || (o.display.maxLineChanged = true), o.display.lineNumChars = null;
      }
      function ZS(o) {
        return v && R ? -(o.body.getBoundingClientRect().left - parseInt(getComputedStyle(o.body).marginLeft)) : o.defaultView.pageXOffset || (o.documentElement || o.body).scrollLeft;
      }
      function XS(o) {
        return v && R ? -(o.body.getBoundingClientRect().top - parseInt(getComputedStyle(o.body).marginTop)) : o.defaultView.pageYOffset || (o.documentElement || o.body).scrollTop;
      }
      function Rf(o) {
        var c = Ri(o), p = c.widgets, h = 0;
        if (p)
          for (var m = 0; m < p.length; ++m)
            p[m].above && (h += yl(p[m]));
        return h;
      }
      function vd(o, c, p, h, m) {
        if (!m) {
          var S = Rf(c);
          p.top += S, p.bottom += S;
        }
        if (h == "line")
          return p;
        h || (h = "local");
        var x = br(c);
        if (h == "local" ? x += md(o.display) : x -= o.display.viewOffset, h == "page" || h == "window") {
          var T = o.display.lineSpace.getBoundingClientRect();
          x += T.top + (h == "window" ? 0 : XS(Ze(o)));
          var k = T.left + (h == "window" ? 0 : ZS(Ze(o)));
          p.left += k, p.right += k;
        }
        return p.top += x, p.bottom += x, p;
      }
      function QS(o, c, p) {
        if (p == "div")
          return c;
        var h = c.left, m = c.top;
        if (p == "page")
          h -= ZS(Ze(o)), m -= XS(Ze(o));
        else if (p == "local" || !p) {
          var S = o.display.sizer.getBoundingClientRect();
          h += S.left, m += S.top;
        }
        var x = o.display.lineSpace.getBoundingClientRect();
        return { left: h - x.left, top: m - x.top };
      }
      function yd(o, c, p, h, m) {
        return h || (h = Re(o.doc, c.line)), vd(o, h, jS(o, h, c.ch, m), p);
      }
      function Mi(o, c, p, h, m, S) {
        h = h || Re(o.doc, c.line), m || (m = Oa(o, h));
        function x(ee, oe) {
          var fe = Ki(o, m, ee, oe ? "right" : "left", S);
          return oe ? fe.left = fe.right : fe.right = fe.left, vd(o, h, fe, p);
        }
        var T = Qe(h, o.doc.direction), k = c.ch, D = c.sticky;
        if (k >= h.text.length ? (k = h.text.length, D = "before") : k <= 0 && (k = 0, D = "after"), !T)
          return x(D == "before" ? k - 1 : k, D == "before");
        function z(ee, oe, fe) {
          var ve = T[oe], xe = ve.level == 1;
          return x(fe ? ee - 1 : ee, xe != fe);
        }
        var W = Zr(T, k, D), q = ji, Y = z(k, W, D == "before");
        return q != null && (Y.other = z(k, q, D != "before")), Y;
      }
      function e0(o, c) {
        var p = 0;
        c = He(o.doc, c), o.options.lineWrapping || (p = Ba(o.display) * c.ch);
        var h = Re(o.doc, c.line), m = br(h) + md(o.display);
        return { left: p, right: p, top: m, bottom: m + h.height };
      }
      function Mf(o, c, p, h, m) {
        var S = Q(o, c, p);
        return S.xRel = m, h && (S.outside = h), S;
      }
      function Nf(o, c, p) {
        var h = o.doc;
        if (p += o.display.viewOffset, p < 0)
          return Mf(h.first, 0, null, -1, -1);
        var m = $(h, p), S = h.first + h.size - 1;
        if (m > S)
          return Mf(h.first + h.size - 1, Re(h, S).text.length, null, 1, 1);
        c < 0 && (c = 0);
        for (var x = Re(h, m); ; ) {
          var T = qP(o, x, m, c, p), k = xP(x, T.ch + (T.xRel > 0 || T.outside > 0 ? 1 : 0));
          if (!k)
            return T;
          var D = k.find(1);
          if (D.line == m)
            return D;
          x = Re(h, m = D.line);
        }
      }
      function t0(o, c, p, h) {
        h -= Rf(c);
        var m = c.text.length, S = Pt(function(x) {
          return Ki(o, p, x - 1).bottom <= h;
        }, m, 0);
        return m = Pt(function(x) {
          return Ki(o, p, x).top > h;
        }, S, m), { begin: S, end: m };
      }
      function n0(o, c, p, h) {
        p || (p = Oa(o, c));
        var m = vd(o, c, Ki(o, p, h), "line").top;
        return t0(o, c, p, m);
      }
      function _f(o, c, p, h) {
        return o.bottom <= p ? false : o.top > p ? true : (h ? o.left : o.right) > c;
      }
      function qP(o, c, p, h, m) {
        m -= br(c);
        var S = Oa(o, c), x = Rf(c), T = 0, k = c.text.length, D = true, z = Qe(c, o.doc.direction);
        if (z) {
          var W = (o.options.lineWrapping ? ZP : KP)(o, c, p, S, z, h, m);
          D = W.level != 1, T = D ? W.from : W.to - 1, k = D ? W.to : W.from - 1;
        }
        var q = null, Y = null, ee = Pt(function(Ve) {
          var Ne = Ki(o, S, Ve);
          return Ne.top += x, Ne.bottom += x, _f(Ne, h, m, false) ? (Ne.top <= m && Ne.left <= h && (q = Ve, Y = Ne), true) : false;
        }, T, k), oe, fe, ve = false;
        if (Y) {
          var xe = h - Y.left < Y.right - h, ye = xe == D;
          ee = q + (ye ? 0 : 1), fe = ye ? "after" : "before", oe = xe ? Y.left : Y.right;
        } else {
          !D && (ee == k || ee == T) && ee++, fe = ee == 0 ? "after" : ee == c.text.length ? "before" : Ki(o, S, ee - (D ? 1 : 0)).bottom + x <= m == D ? "after" : "before";
          var ke = Mi(o, Q(p, ee, fe), "line", c, S);
          oe = ke.left, ve = m < ke.top ? -1 : m >= ke.bottom ? 1 : 0;
        }
        return ee = Rt(c.text, ee, 1), Mf(p, ee, fe, ve, h - oe);
      }
      function KP(o, c, p, h, m, S, x) {
        var T = Pt(function(W) {
          var q = m[W], Y = q.level != 1;
          return _f(Mi(
            o,
            Q(p, Y ? q.to : q.from, Y ? "before" : "after"),
            "line",
            c,
            h
          ), S, x, true);
        }, 0, m.length - 1), k = m[T];
        if (T > 0) {
          var D = k.level != 1, z = Mi(
            o,
            Q(p, D ? k.from : k.to, D ? "after" : "before"),
            "line",
            c,
            h
          );
          _f(z, S, x, true) && z.top > x && (k = m[T - 1]);
        }
        return k;
      }
      function ZP(o, c, p, h, m, S, x) {
        var T = t0(o, c, h, x), k = T.begin, D = T.end;
        /\s/.test(c.text.charAt(D - 1)) && D--;
        for (var z = null, W = null, q = 0; q < m.length; q++) {
          var Y = m[q];
          if (!(Y.from >= D || Y.to <= k)) {
            var ee = Y.level != 1, oe = Ki(o, h, ee ? Math.min(D, Y.to) - 1 : Math.max(k, Y.from)).right, fe = oe < S ? S - oe + 1e9 : oe - S;
            (!z || W > fe) && (z = Y, W = fe);
          }
        }
        return z || (z = m[m.length - 1]), z.from < k && (z = { from: k, to: z.to, level: z.level }), z.to > D && (z = { from: z.from, to: D, level: z.level }), z;
      }
      var Bs;
      function Va(o) {
        if (o.cachedTextHeight != null)
          return o.cachedTextHeight;
        if (Bs == null) {
          Bs = F("pre", null, "CodeMirror-line-like");
          for (var c = 0; c < 49; ++c)
            Bs.appendChild(document.createTextNode("x")), Bs.appendChild(F("br"));
          Bs.appendChild(document.createTextNode("x"));
        }
        G(o.measure, Bs);
        var p = Bs.offsetHeight / 50;
        return p > 3 && (o.cachedTextHeight = p), V(o.measure), p || 1;
      }
      function Ba(o) {
        if (o.cachedCharWidth != null)
          return o.cachedCharWidth;
        var c = F("span", "xxxxxxxxxx"), p = F("pre", [c], "CodeMirror-line-like");
        G(o.measure, p);
        var h = c.getBoundingClientRect(), m = (h.right - h.left) / 10;
        return m > 2 && (o.cachedCharWidth = m), m || 10;
      }
      function Of(o) {
        for (var c = o.display, p = {}, h = {}, m = c.gutters.clientLeft, S = c.gutters.firstChild, x = 0; S; S = S.nextSibling, ++x) {
          var T = o.display.gutterSpecs[x].className;
          p[T] = S.offsetLeft + S.clientLeft + m, h[T] = S.clientWidth;
        }
        return {
          fixedPos: Vf(c),
          gutterTotalWidth: c.gutters.offsetWidth,
          gutterLeft: p,
          gutterWidth: h,
          wrapperWidth: c.wrapper.clientWidth
        };
      }
      function Vf(o) {
        return o.scroller.getBoundingClientRect().left - o.sizer.getBoundingClientRect().left;
      }
      function i0(o) {
        var c = Va(o.display), p = o.options.lineWrapping, h = p && Math.max(5, o.display.scroller.clientWidth / Ba(o.display) - 3);
        return function(m) {
          if (ns(o.doc, m))
            return 0;
          var S = 0;
          if (m.widgets)
            for (var x = 0; x < m.widgets.length; x++)
              m.widgets[x].height && (S += m.widgets[x].height);
          return p ? S + (Math.ceil(m.text.length / h) || 1) * c : S + c;
        };
      }
      function Bf(o) {
        var c = o.doc, p = i0(o);
        c.iter(function(h) {
          var m = p(h);
          m != h.height && ei(h, m);
        });
      }
      function Fs(o, c, p, h) {
        var m = o.display;
        if (!p && dl(c).getAttribute("cm-not-content") == "true")
          return null;
        var S, x, T = m.lineSpace.getBoundingClientRect();
        try {
          S = c.clientX - T.left, x = c.clientY - T.top;
        } catch {
          return null;
        }
        var k = Nf(o, S, x), D;
        if (h && k.xRel > 0 && (D = Re(o.doc, k.line).text).length == k.ch) {
          var z = We(D, D.length, o.options.tabSize) - D.length;
          k = Q(k.line, Math.max(0, Math.round((S - WS(o.display).left) / Ba(o.display)) - z));
        }
        return k;
      }
      function Us(o, c) {
        if (c >= o.display.viewTo || (c -= o.display.viewFrom, c < 0))
          return null;
        for (var p = o.display.view, h = 0; h < p.length; h++)
          if (c -= p[h].size, c < 0)
            return h;
      }
      function On(o, c, p, h) {
        c == null && (c = o.doc.first), p == null && (p = o.doc.first + o.doc.size), h || (h = 0);
        var m = o.display;
        if (h && p < m.viewTo && (m.updateLineNumbers == null || m.updateLineNumbers > c) && (m.updateLineNumbers = c), o.curOp.viewChanged = true, c >= m.viewTo)
          Sr && Tf(o.doc, c) < m.viewTo && rs(o);
        else if (p <= m.viewFrom)
          Sr && NS(o.doc, p + h) > m.viewFrom ? rs(o) : (m.viewFrom += h, m.viewTo += h);
        else if (c <= m.viewFrom && p >= m.viewTo)
          rs(o);
        else if (c <= m.viewFrom) {
          var S = Sd(o, p, p + h, 1);
          S ? (m.view = m.view.slice(S.index), m.viewFrom = S.lineN, m.viewTo += h) : rs(o);
        } else if (p >= m.viewTo) {
          var x = Sd(o, c, c, -1);
          x ? (m.view = m.view.slice(0, x.index), m.viewTo = x.lineN) : rs(o);
        } else {
          var T = Sd(o, c, c, -1), k = Sd(o, p, p + h, 1);
          T && k ? (m.view = m.view.slice(0, T.index).concat(gd(o, T.lineN, k.lineN)).concat(m.view.slice(k.index)), m.viewTo += h) : rs(o);
        }
        var D = m.externalMeasured;
        D && (p < D.lineN ? D.lineN += h : c < D.lineN + D.size && (m.externalMeasured = null));
      }
      function is(o, c, p) {
        o.curOp.viewChanged = true;
        var h = o.display, m = o.display.externalMeasured;
        if (m && c >= m.lineN && c < m.lineN + m.size && (h.externalMeasured = null), !(c < h.viewFrom || c >= h.viewTo)) {
          var S = h.view[Us(o, c)];
          if (S.node != null) {
            var x = S.changes || (S.changes = []);
            Pe(x, p) == -1 && x.push(p);
          }
        }
      }
      function rs(o) {
        o.display.viewFrom = o.display.viewTo = o.doc.first, o.display.view = [], o.display.viewOffset = 0;
      }
      function Sd(o, c, p, h) {
        var m = Us(o, c), S, x = o.display.view;
        if (!Sr || p == o.doc.first + o.doc.size)
          return { index: m, lineN: p };
        for (var T = o.display.viewFrom, k = 0; k < m; k++)
          T += x[k].size;
        if (T != c) {
          if (h > 0) {
            if (m == x.length - 1)
              return null;
            S = T + x[m].size - c, m++;
          } else
            S = T - c;
          c += S, p += S;
        }
        for (; Tf(o.doc, p) != p; ) {
          if (m == (h < 0 ? 0 : x.length - 1))
            return null;
          p += h * x[m - (h < 0 ? 1 : 0)].size, m += h;
        }
        return { index: m, lineN: p };
      }
      function XP(o, c, p) {
        var h = o.display, m = h.view;
        m.length == 0 || c >= h.viewTo || p <= h.viewFrom ? (h.view = gd(o, c, p), h.viewFrom = c) : (h.viewFrom > c ? h.view = gd(o, c, h.viewFrom).concat(h.view) : h.viewFrom < c && (h.view = h.view.slice(Us(o, c))), h.viewFrom = c, h.viewTo < p ? h.view = h.view.concat(gd(o, h.viewTo, p)) : h.viewTo > p && (h.view = h.view.slice(0, Us(o, p)))), h.viewTo = p;
      }
      function r0(o) {
        for (var c = o.display.view, p = 0, h = 0; h < c.length; h++) {
          var m = c[h];
          !m.hidden && (!m.node || m.changes) && ++p;
        }
        return p;
      }
      function bl(o) {
        o.display.input.showSelection(o.display.input.prepareSelection());
      }
      function s0(o, c) {
        c === void 0 && (c = true);
        var p = o.doc, h = {}, m = h.cursors = document.createDocumentFragment(), S = h.selection = document.createDocumentFragment(), x = o.options.$customCursor;
        x && (c = true);
        for (var T = 0; T < p.sel.ranges.length; T++)
          if (!(!c && T == p.sel.primIndex)) {
            var k = p.sel.ranges[T];
            if (!(k.from().line >= o.display.viewTo || k.to().line < o.display.viewFrom)) {
              var D = k.empty();
              if (x) {
                var z = x(o, k);
                z && Ff(o, z, m);
              } else
                (D || o.options.showCursorWhenSelecting) && Ff(o, k.head, m);
              D || QP(o, k, S);
            }
          }
        return h;
      }
      function Ff(o, c, p) {
        var h = Mi(o, c, "div", null, null, !o.options.singleCursorHeightPerLine), m = p.appendChild(F("div", " ", "CodeMirror-cursor"));
        if (m.style.left = h.left + "px", m.style.top = h.top + "px", m.style.height = Math.max(0, h.bottom - h.top) * o.options.cursorHeight + "px", /\bcm-fat-cursor\b/.test(o.getWrapperElement().className)) {
          var S = yd(o, c, "div", null, null), x = S.right - S.left;
          m.style.width = (x > 0 ? x : o.defaultCharWidth()) + "px";
        }
        if (h.other) {
          var T = p.appendChild(F("div", " ", "CodeMirror-cursor CodeMirror-secondarycursor"));
          T.style.display = "", T.style.left = h.other.left + "px", T.style.top = h.other.top + "px", T.style.height = (h.other.bottom - h.other.top) * 0.85 + "px";
        }
      }
      function bd(o, c) {
        return o.top - c.top || o.left - c.left;
      }
      function QP(o, c, p) {
        var h = o.display, m = o.doc, S = document.createDocumentFragment(), x = WS(o.display), T = x.left, k = Math.max(h.sizerWidth, Vs(o) - h.sizer.offsetLeft) - x.right, D = m.direction == "ltr";
        function z(ye, ke, Ve, Ne) {
          ke < 0 && (ke = 0), ke = Math.round(ke), Ne = Math.round(Ne), S.appendChild(F("div", null, "CodeMirror-selected", "position: absolute; left: " + ye + `px;
                             top: ` + ke + "px; width: " + (Ve ?? k - ye) + `px;
                             height: ` + (Ne - ke) + "px"));
        }
        function W(ye, ke, Ve) {
          var Ne = Re(m, ye), Ke = Ne.text.length, xt, on;
          function Mt(Yt, Fn) {
            return yd(o, Q(ye, Yt), "div", Ne, Fn);
          }
          function qn(Yt, Fn, fn) {
            var Qt = n0(o, Ne, null, Yt), qt = Fn == "ltr" == (fn == "after") ? "left" : "right", Vt = fn == "after" ? Qt.begin : Qt.end - (/\s/.test(Ne.text.charAt(Qt.end - 1)) ? 2 : 1);
            return Mt(Vt, qt)[qt];
          }
          var Bn = Qe(Ne, m.direction);
          return di(Bn, ke || 0, Ve ?? Ke, function(Yt, Fn, fn, Qt) {
            var qt = fn == "ltr", Vt = Mt(Yt, qt ? "left" : "right"), Un = Mt(Fn - 1, qt ? "right" : "left"), Za = ke == null && Yt == 0, ds = Ve == null && Fn == Ke, Cn = Qt == 0, Zi = !Bn || Qt == Bn.length - 1;
            if (Un.top - Vt.top <= 3) {
              var ln = (D ? Za : ds) && Cn, hp = (D ? ds : Za) && Zi, Er = ln ? T : (qt ? Vt : Un).left, Hs = hp ? k : (qt ? Un : Vt).right;
              z(Er, Vt.top, Hs - Er, Vt.bottom);
            } else {
              var js, Tn, Xa, fp;
              qt ? (js = D && Za && Cn ? T : Vt.left, Tn = D ? k : qn(Yt, fn, "before"), Xa = D ? T : qn(Fn, fn, "after"), fp = D && ds && Zi ? k : Un.right) : (js = D ? qn(Yt, fn, "before") : T, Tn = !D && Za && Cn ? k : Vt.right, Xa = !D && ds && Zi ? T : Un.left, fp = D ? qn(Fn, fn, "after") : k), z(js, Vt.top, Tn - js, Vt.bottom), Vt.bottom < Un.top && z(T, Vt.bottom, null, Un.top), z(Xa, Un.top, fp - Xa, Un.bottom);
            }
            (!xt || bd(Vt, xt) < 0) && (xt = Vt), bd(Un, xt) < 0 && (xt = Un), (!on || bd(Vt, on) < 0) && (on = Vt), bd(Un, on) < 0 && (on = Un);
          }), { start: xt, end: on };
        }
        var q = c.from(), Y = c.to();
        if (q.line == Y.line)
          W(q.line, q.ch, Y.ch);
        else {
          var ee = Re(m, q.line), oe = Re(m, Y.line), fe = Ri(ee) == Ri(oe), ve = W(q.line, q.ch, fe ? ee.text.length + 1 : null).end, xe = W(Y.line, fe ? 0 : null, Y.ch).start;
          fe && (ve.top < xe.top - 2 ? (z(ve.right, ve.top, null, ve.bottom), z(T, xe.top, xe.left, xe.bottom)) : z(ve.right, ve.top, xe.left - ve.right, ve.bottom)), ve.bottom < xe.top && z(T, ve.bottom, null, xe.top);
        }
        p.appendChild(S);
      }
      function Uf(o) {
        if (o.state.focused) {
          var c = o.display;
          clearInterval(c.blinker);
          var p = true;
          c.cursorDiv.style.visibility = "", o.options.cursorBlinkRate > 0 ? c.blinker = setInterval(function() {
            o.hasFocus() || Fa(o), c.cursorDiv.style.visibility = (p = !p) ? "" : "hidden";
          }, o.options.cursorBlinkRate) : o.options.cursorBlinkRate < 0 && (c.cursorDiv.style.visibility = "hidden");
        }
      }
      function a0(o) {
        o.hasFocus() || (o.display.input.focus(), o.state.focused || Gf(o));
      }
      function zf(o) {
        o.state.delayingBlurEvent = true, setTimeout(function() {
          o.state.delayingBlurEvent && (o.state.delayingBlurEvent = false, o.state.focused && Fa(o));
        }, 100);
      }
      function Gf(o, c) {
        o.state.delayingBlurEvent && !o.state.draggingText && (o.state.delayingBlurEvent = false), o.options.readOnly != "nocursor" && (o.state.focused || (Nt(o, "focus", o, c), o.state.focused = true, Te(o.display.wrapper, "CodeMirror-focused"), !o.curOp && o.display.selForContextMenu != o.doc.sel && (o.display.input.reset(), f && setTimeout(function() {
          return o.display.input.reset(true);
        }, 20)), o.display.input.receivedFocus()), Uf(o));
      }
      function Fa(o, c) {
        o.state.delayingBlurEvent || (o.state.focused && (Nt(o, "blur", o, c), o.state.focused = false, U(o.display.wrapper, "CodeMirror-focused")), clearInterval(o.display.blinker), setTimeout(function() {
          o.state.focused || (o.display.shift = false);
        }, 150));
      }
      function Cd(o) {
        for (var c = o.display, p = c.lineDiv.offsetTop, h = Math.max(0, c.scroller.getBoundingClientRect().top), m = c.lineDiv.getBoundingClientRect().top, S = 0, x = 0; x < c.view.length; x++) {
          var T = c.view[x], k = o.options.lineWrapping, D = void 0, z = 0;
          if (!T.hidden) {
            if (m += T.line.height, d && u < 8) {
              var W = T.node.offsetTop + T.node.offsetHeight;
              D = W - p, p = W;
            } else {
              var q = T.node.getBoundingClientRect();
              D = q.bottom - q.top, !k && T.text.firstChild && (z = T.text.firstChild.getBoundingClientRect().right - q.left - 1);
            }
            var Y = T.line.height - D;
            if ((Y > 5e-3 || Y < -5e-3) && (m < h && (S -= Y), ei(T.line, D), o0(T.line), T.rest))
              for (var ee = 0; ee < T.rest.length; ee++)
                o0(T.rest[ee]);
            if (z > o.display.sizerWidth) {
              var oe = Math.ceil(z / Ba(o.display));
              oe > o.display.maxLineLength && (o.display.maxLineLength = oe, o.display.maxLine = T.line, o.display.maxLineChanged = true);
            }
          }
        }
        Math.abs(S) > 2 && (c.scroller.scrollTop += S);
      }
      function o0(o) {
        if (o.widgets)
          for (var c = 0; c < o.widgets.length; ++c) {
            var p = o.widgets[c], h = p.node.parentNode;
            h && (p.height = h.offsetHeight);
          }
      }
      function wd(o, c, p) {
        var h = p && p.top != null ? Math.max(0, p.top) : o.scroller.scrollTop;
        h = Math.floor(h - md(o));
        var m = p && p.bottom != null ? p.bottom : h + o.wrapper.clientHeight, S = $(c, h), x = $(c, m);
        if (p && p.ensure) {
          var T = p.ensure.from.line, k = p.ensure.to.line;
          T < S ? (S = T, x = $(c, br(Re(c, T)) + o.wrapper.clientHeight)) : Math.min(k, c.lastLine()) >= x && (S = $(c, br(Re(c, k)) - o.wrapper.clientHeight), x = k);
        }
        return { from: S, to: Math.max(x, S + 1) };
      }
      function eA(o, c) {
        if (!_t(o, "scrollCursorIntoView")) {
          var p = o.display, h = p.sizer.getBoundingClientRect(), m = null, S = p.wrapper.ownerDocument;
          if (c.top + h.top < 0 ? m = true : c.bottom + h.top > (S.defaultView.innerHeight || S.documentElement.clientHeight) && (m = false), m != null && !E) {
            var x = F("div", "​", null, `position: absolute;
                         top: ` + (c.top - p.viewOffset - md(o.display)) + `px;
                         height: ` + (c.bottom - c.top + qi(o) + p.barHeight) + `px;
                         left: ` + c.left + "px; width: " + Math.max(2, c.right - c.left) + "px;");
            o.display.lineSpace.appendChild(x), x.scrollIntoView(m), o.display.lineSpace.removeChild(x);
          }
        }
      }
      function tA(o, c, p, h) {
        h == null && (h = 0);
        var m;
        !o.options.lineWrapping && c == p && (p = c.sticky == "before" ? Q(c.line, c.ch + 1, "before") : c, c = c.ch ? Q(c.line, c.sticky == "before" ? c.ch - 1 : c.ch, "after") : c);
        for (var S = 0; S < 5; S++) {
          var x = false, T = Mi(o, c), k = !p || p == c ? T : Mi(o, p);
          m = {
            left: Math.min(T.left, k.left),
            top: Math.min(T.top, k.top) - h,
            right: Math.max(T.left, k.left),
            bottom: Math.max(T.bottom, k.bottom) + h
          };
          var D = $f(o, m), z = o.doc.scrollTop, W = o.doc.scrollLeft;
          if (D.scrollTop != null && (wl(o, D.scrollTop), Math.abs(o.doc.scrollTop - z) > 1 && (x = true)), D.scrollLeft != null && (zs(o, D.scrollLeft), Math.abs(o.doc.scrollLeft - W) > 1 && (x = true)), !x)
            break;
        }
        return m;
      }
      function nA(o, c) {
        var p = $f(o, c);
        p.scrollTop != null && wl(o, p.scrollTop), p.scrollLeft != null && zs(o, p.scrollLeft);
      }
      function $f(o, c) {
        var p = o.display, h = Va(o.display);
        c.top < 0 && (c.top = 0);
        var m = o.curOp && o.curOp.scrollTop != null ? o.curOp.scrollTop : p.scroller.scrollTop, S = Pf(o), x = {};
        c.bottom - c.top > S && (c.bottom = c.top + S);
        var T = o.doc.height + Df(p), k = c.top < h, D = c.bottom > T - h;
        if (c.top < m)
          x.scrollTop = k ? 0 : c.top;
        else if (c.bottom > m + S) {
          var z = Math.min(c.top, (D ? T : c.bottom) - S);
          z != m && (x.scrollTop = z);
        }
        var W = o.options.fixedGutter ? 0 : p.gutters.offsetWidth, q = o.curOp && o.curOp.scrollLeft != null ? o.curOp.scrollLeft : p.scroller.scrollLeft - W, Y = Vs(o) - p.gutters.offsetWidth, ee = c.right - c.left > Y;
        return ee && (c.right = c.left + Y), c.left < 10 ? x.scrollLeft = 0 : c.left < q ? x.scrollLeft = Math.max(0, c.left + W - (ee ? 0 : 10)) : c.right > Y + q - 3 && (x.scrollLeft = c.right + (ee ? 0 : 10) - Y), x;
      }
      function Wf(o, c) {
        c != null && (xd(o), o.curOp.scrollTop = (o.curOp.scrollTop == null ? o.doc.scrollTop : o.curOp.scrollTop) + c);
      }
      function Ua(o) {
        xd(o);
        var c = o.getCursor();
        o.curOp.scrollToPos = { from: c, to: c, margin: o.options.cursorScrollMargin };
      }
      function Cl(o, c, p) {
        (c != null || p != null) && xd(o), c != null && (o.curOp.scrollLeft = c), p != null && (o.curOp.scrollTop = p);
      }
      function iA(o, c) {
        xd(o), o.curOp.scrollToPos = c;
      }
      function xd(o) {
        var c = o.curOp.scrollToPos;
        if (c) {
          o.curOp.scrollToPos = null;
          var p = e0(o, c.from), h = e0(o, c.to);
          l0(o, p, h, c.margin);
        }
      }
      function l0(o, c, p, h) {
        var m = $f(o, {
          left: Math.min(c.left, p.left),
          top: Math.min(c.top, p.top) - h,
          right: Math.max(c.right, p.right),
          bottom: Math.max(c.bottom, p.bottom) + h
        });
        Cl(o, m.scrollLeft, m.scrollTop);
      }
      function wl(o, c) {
        Math.abs(o.doc.scrollTop - c) < 2 || (r || jf(o, { top: c }), c0(o, c, true), r && jf(o), Tl(o, 100));
      }
      function c0(o, c, p) {
        c = Math.max(0, Math.min(o.display.scroller.scrollHeight - o.display.scroller.clientHeight, c)), !(o.display.scroller.scrollTop == c && !p) && (o.doc.scrollTop = c, o.display.scrollbars.setScrollTop(c), o.display.scroller.scrollTop != c && (o.display.scroller.scrollTop = c));
      }
      function zs(o, c, p, h) {
        c = Math.max(0, Math.min(c, o.display.scroller.scrollWidth - o.display.scroller.clientWidth)), !((p ? c == o.doc.scrollLeft : Math.abs(o.doc.scrollLeft - c) < 2) && !h) && (o.doc.scrollLeft = c, p0(o), o.display.scroller.scrollLeft != c && (o.display.scroller.scrollLeft = c), o.display.scrollbars.setScrollLeft(c));
      }
      function xl(o) {
        var c = o.display, p = c.gutters.offsetWidth, h = Math.round(o.doc.height + Df(o.display));
        return {
          clientHeight: c.scroller.clientHeight,
          viewHeight: c.wrapper.clientHeight,
          scrollWidth: c.scroller.scrollWidth,
          clientWidth: c.scroller.clientWidth,
          viewWidth: c.wrapper.clientWidth,
          barLeft: o.options.fixedGutter ? p : 0,
          docHeight: h,
          scrollHeight: h + qi(o) + c.barHeight,
          nativeBarWidth: c.nativeBarWidth,
          gutterWidth: p
        };
      }
      var Gs2 = function(o, c, p) {
        this.cm = p;
        var h = this.vert = F("div", [F("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar"), m = this.horiz = F("div", [F("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
        h.tabIndex = m.tabIndex = -1, o(h), o(m), Oe(h, "scroll", function() {
          h.clientHeight && c(h.scrollTop, "vertical");
        }), Oe(m, "scroll", function() {
          m.clientWidth && c(m.scrollLeft, "horizontal");
        }), this.checkedZeroWidth = false, d && u < 8 && (this.horiz.style.minHeight = this.vert.style.minWidth = "18px");
      };
      Gs2.prototype.update = function(o) {
        var c = o.scrollWidth > o.clientWidth + 1, p = o.scrollHeight > o.clientHeight + 1, h = o.nativeBarWidth;
        if (p) {
          this.vert.style.display = "block", this.vert.style.bottom = c ? h + "px" : "0";
          var m = o.viewHeight - (c ? h : 0);
          this.vert.firstChild.style.height = Math.max(0, o.scrollHeight - o.clientHeight + m) + "px";
        } else
          this.vert.scrollTop = 0, this.vert.style.display = "", this.vert.firstChild.style.height = "0";
        if (c) {
          this.horiz.style.display = "block", this.horiz.style.right = p ? h + "px" : "0", this.horiz.style.left = o.barLeft + "px";
          var S = o.viewWidth - o.barLeft - (p ? h : 0);
          this.horiz.firstChild.style.width = Math.max(0, o.scrollWidth - o.clientWidth + S) + "px";
        } else
          this.horiz.style.display = "", this.horiz.firstChild.style.width = "0";
        return !this.checkedZeroWidth && o.clientHeight > 0 && (h == 0 && this.zeroWidthHack(), this.checkedZeroWidth = true), { right: p ? h : 0, bottom: c ? h : 0 };
      }, Gs2.prototype.setScrollLeft = function(o) {
        this.horiz.scrollLeft != o && (this.horiz.scrollLeft = o), this.disableHoriz && this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz");
      }, Gs2.prototype.setScrollTop = function(o) {
        this.vert.scrollTop != o && (this.vert.scrollTop = o), this.disableVert && this.enableZeroWidthBar(this.vert, this.disableVert, "vert");
      }, Gs2.prototype.zeroWidthHack = function() {
        var o = A && !b ? "12px" : "18px";
        this.horiz.style.height = this.vert.style.width = o, this.horiz.style.visibility = this.vert.style.visibility = "hidden", this.disableHoriz = new $e(), this.disableVert = new $e();
      }, Gs2.prototype.enableZeroWidthBar = function(o, c, p) {
        o.style.visibility = "";
        function h() {
          var m = o.getBoundingClientRect(), S = p == "vert" ? document.elementFromPoint(m.right - 1, (m.top + m.bottom) / 2) : document.elementFromPoint((m.right + m.left) / 2, m.bottom - 1);
          S != o ? o.style.visibility = "hidden" : c.set(1e3, h);
        }
        c.set(1e3, h);
      }, Gs2.prototype.clear = function() {
        var o = this.horiz.parentNode;
        o.removeChild(this.horiz), o.removeChild(this.vert);
      };
      var El = function() {
      };
      El.prototype.update = function() {
        return { bottom: 0, right: 0 };
      }, El.prototype.setScrollLeft = function() {
      }, El.prototype.setScrollTop = function() {
      }, El.prototype.clear = function() {
      };
      function za(o, c) {
        c || (c = xl(o));
        var p = o.display.barWidth, h = o.display.barHeight;
        d0(o, c);
        for (var m = 0; m < 4 && p != o.display.barWidth || h != o.display.barHeight; m++)
          p != o.display.barWidth && o.options.lineWrapping && Cd(o), d0(o, xl(o)), p = o.display.barWidth, h = o.display.barHeight;
      }
      function d0(o, c) {
        var p = o.display, h = p.scrollbars.update(c);
        p.sizer.style.paddingRight = (p.barWidth = h.right) + "px", p.sizer.style.paddingBottom = (p.barHeight = h.bottom) + "px", p.heightForcer.style.borderBottom = h.bottom + "px solid transparent", h.right && h.bottom ? (p.scrollbarFiller.style.display = "block", p.scrollbarFiller.style.height = h.bottom + "px", p.scrollbarFiller.style.width = h.right + "px") : p.scrollbarFiller.style.display = "", h.bottom && o.options.coverGutterNextToScrollbar && o.options.fixedGutter ? (p.gutterFiller.style.display = "block", p.gutterFiller.style.height = h.bottom + "px", p.gutterFiller.style.width = c.gutterWidth + "px") : p.gutterFiller.style.display = "";
      }
      var u0 = { native: Gs2, null: El };
      function h0(o) {
        o.display.scrollbars && (o.display.scrollbars.clear(), o.display.scrollbars.addClass && U(o.display.wrapper, o.display.scrollbars.addClass)), o.display.scrollbars = new u0[o.options.scrollbarStyle](function(c) {
          o.display.wrapper.insertBefore(c, o.display.scrollbarFiller), Oe(c, "mousedown", function() {
            o.state.focused && setTimeout(function() {
              return o.display.input.focus();
            }, 0);
          }), c.setAttribute("cm-not-content", "true");
        }, function(c, p) {
          p == "horizontal" ? zs(o, c) : wl(o, c);
        }, o), o.display.scrollbars.addClass && Te(o.display.wrapper, o.display.scrollbars.addClass);
      }
      var rA = 0;
      function $s(o) {
        o.curOp = {
          cm: o,
          viewChanged: false,
          // Flag that indicates that lines might need to be redrawn
          startHeight: o.doc.height,
          // Used to detect need to update scrollbar
          forceUpdate: false,
          // Used to force a redraw
          updateInput: 0,
          // Whether to reset the input textarea
          typing: false,
          // Whether this reset should be careful to leave existing text (for compositing)
          changeObjs: null,
          // Accumulated changes, for firing change events
          cursorActivityHandlers: null,
          // Set of handlers to fire cursorActivity on
          cursorActivityCalled: 0,
          // Tracks which cursorActivity handlers have been called already
          selectionChanged: false,
          // Whether the selection needs to be redrawn
          updateMaxLine: false,
          // Set when the widest line needs to be determined anew
          scrollLeft: null,
          scrollTop: null,
          // Intermediate scroll position, not pushed to DOM yet
          scrollToPos: null,
          // Used to scroll to a specific position
          focus: false,
          id: ++rA,
          // Unique ID
          markArrays: null
          // Used by addMarkedSpan
        }, _P(o.curOp);
      }
      function Ws(o) {
        var c = o.curOp;
        c && VP(c, function(p) {
          for (var h = 0; h < p.ops.length; h++)
            p.ops[h].cm.curOp = null;
          sA(p);
        });
      }
      function sA(o) {
        for (var c = o.ops, p = 0; p < c.length; p++)
          aA(c[p]);
        for (var h = 0; h < c.length; h++)
          oA(c[h]);
        for (var m = 0; m < c.length; m++)
          lA(c[m]);
        for (var S = 0; S < c.length; S++)
          cA(c[S]);
        for (var x = 0; x < c.length; x++)
          dA(c[x]);
      }
      function aA(o) {
        var c = o.cm, p = c.display;
        hA(c), o.updateMaxLine && If(c), o.mustUpdate = o.viewChanged || o.forceUpdate || o.scrollTop != null || o.scrollToPos && (o.scrollToPos.from.line < p.viewFrom || o.scrollToPos.to.line >= p.viewTo) || p.maxLineChanged && c.options.lineWrapping, o.update = o.mustUpdate && new Ed(c, o.mustUpdate && { top: o.scrollTop, ensure: o.scrollToPos }, o.forceUpdate);
      }
      function oA(o) {
        o.updatedDisplay = o.mustUpdate && Hf(o.cm, o.update);
      }
      function lA(o) {
        var c = o.cm, p = c.display;
        o.updatedDisplay && Cd(c), o.barMeasure = xl(c), p.maxLineChanged && !c.options.lineWrapping && (o.adjustWidthTo = jS(c, p.maxLine, p.maxLine.text.length).left + 3, c.display.sizerWidth = o.adjustWidthTo, o.barMeasure.scrollWidth = Math.max(p.scroller.clientWidth, p.sizer.offsetLeft + o.adjustWidthTo + qi(c) + c.display.barWidth), o.maxScrollLeft = Math.max(0, p.sizer.offsetLeft + o.adjustWidthTo - Vs(c))), (o.updatedDisplay || o.selectionChanged) && (o.preparedSelection = p.input.prepareSelection());
      }
      function cA(o) {
        var c = o.cm;
        o.adjustWidthTo != null && (c.display.sizer.style.minWidth = o.adjustWidthTo + "px", o.maxScrollLeft < c.doc.scrollLeft && zs(c, Math.min(c.display.scroller.scrollLeft, o.maxScrollLeft), true), c.display.maxLineChanged = false);
        var p = o.focus && o.focus == le(rt(c));
        o.preparedSelection && c.display.input.showSelection(o.preparedSelection, p), (o.updatedDisplay || o.startHeight != c.doc.height) && za(c, o.barMeasure), o.updatedDisplay && Yf(c, o.barMeasure), o.selectionChanged && Uf(c), c.state.focused && o.updateInput && c.display.input.reset(o.typing), p && a0(o.cm);
      }
      function dA(o) {
        var c = o.cm, p = c.display, h = c.doc;
        if (o.updatedDisplay && f0(c, o.update), p.wheelStartX != null && (o.scrollTop != null || o.scrollLeft != null || o.scrollToPos) && (p.wheelStartX = p.wheelStartY = null), o.scrollTop != null && c0(c, o.scrollTop, o.forceScroll), o.scrollLeft != null && zs(c, o.scrollLeft, true, true), o.scrollToPos) {
          var m = tA(
            c,
            He(h, o.scrollToPos.from),
            He(h, o.scrollToPos.to),
            o.scrollToPos.margin
          );
          eA(c, m);
        }
        var S = o.maybeHiddenMarkers, x = o.maybeUnhiddenMarkers;
        if (S)
          for (var T = 0; T < S.length; ++T)
            S[T].lines.length || Nt(S[T], "hide");
        if (x)
          for (var k = 0; k < x.length; ++k)
            x[k].lines.length && Nt(x[k], "unhide");
        p.wrapper.offsetHeight && (h.scrollTop = c.display.scroller.scrollTop), o.changeObjs && Nt(c, "changes", c, o.changeObjs), o.update && o.update.finish();
      }
      function Yn(o, c) {
        if (o.curOp)
          return c();
        $s(o);
        try {
          return c();
        } finally {
          Ws(o);
        }
      }
      function sn(o, c) {
        return function() {
          if (o.curOp)
            return c.apply(o, arguments);
          $s(o);
          try {
            return c.apply(o, arguments);
          } finally {
            Ws(o);
          }
        };
      }
      function En(o) {
        return function() {
          if (this.curOp)
            return o.apply(this, arguments);
          $s(this);
          try {
            return o.apply(this, arguments);
          } finally {
            Ws(this);
          }
        };
      }
      function an(o) {
        return function() {
          var c = this.cm;
          if (!c || c.curOp)
            return o.apply(this, arguments);
          $s(c);
          try {
            return o.apply(this, arguments);
          } finally {
            Ws(c);
          }
        };
      }
      function Tl(o, c) {
        o.doc.highlightFrontier < o.display.viewTo && o.state.highlight.set(c, Ae(uA, o));
      }
      function uA(o) {
        var c = o.doc;
        if (!(c.highlightFrontier >= o.display.viewTo)) {
          var p = +/* @__PURE__ */ new Date() + o.options.workTime, h = pl(o, c.highlightFrontier), m = [];
          c.iter(h.line, Math.min(c.first + c.size, o.display.viewTo + 500), function(S) {
            if (h.line >= o.display.viewFrom) {
              var x = S.styles, T = S.text.length > o.options.maxHighlightLength ? Ji(c.mode, h.state) : null, k = bS(o, S, h, true);
              T && (h.state = T), S.styles = k.styles;
              var D = S.styleClasses, z = k.classes;
              z ? S.styleClasses = z : D && (S.styleClasses = null);
              for (var W = !x || x.length != S.styles.length || D != z && (!D || !z || D.bgClass != z.bgClass || D.textClass != z.textClass), q = 0; !W && q < x.length; ++q)
                W = x[q] != S.styles[q];
              W && m.push(h.line), S.stateAfter = h.save(), h.nextLine();
            } else
              S.text.length <= o.options.maxHighlightLength && Cf(o, S.text, h), S.stateAfter = h.line % 5 == 0 ? h.save() : null, h.nextLine();
            if (+/* @__PURE__ */ new Date() > p)
              return Tl(o, o.options.workDelay), true;
          }), c.highlightFrontier = h.line, c.modeFrontier = Math.max(c.modeFrontier, h.line), m.length && Yn(o, function() {
            for (var S = 0; S < m.length; S++)
              is(o, m[S], "text");
          });
        }
      }
      var Ed = function(o, c, p) {
        var h = o.display;
        this.viewport = c, this.visible = wd(h, o.doc, c), this.editorIsHidden = !h.wrapper.offsetWidth, this.wrapperHeight = h.wrapper.clientHeight, this.wrapperWidth = h.wrapper.clientWidth, this.oldDisplayWidth = Vs(o), this.force = p, this.dims = Of(o), this.events = [];
      };
      Ed.prototype.signal = function(o, c) {
        Jn(o, c) && this.events.push(arguments);
      }, Ed.prototype.finish = function() {
        for (var o = 0; o < this.events.length; o++)
          Nt.apply(null, this.events[o]);
      };
      function hA(o) {
        var c = o.display;
        !c.scrollbarsClipped && c.scroller.offsetWidth && (c.nativeBarWidth = c.scroller.offsetWidth - c.scroller.clientWidth, c.heightForcer.style.height = qi(o) + "px", c.sizer.style.marginBottom = -c.nativeBarWidth + "px", c.sizer.style.borderRightWidth = qi(o) + "px", c.scrollbarsClipped = true);
      }
      function fA(o) {
        if (o.hasFocus())
          return null;
        var c = le(rt(o));
        if (!c || !Ie(o.display.lineDiv, c))
          return null;
        var p = { activeElt: c };
        if (window.getSelection) {
          var h = Be(o).getSelection();
          h.anchorNode && h.extend && Ie(o.display.lineDiv, h.anchorNode) && (p.anchorNode = h.anchorNode, p.anchorOffset = h.anchorOffset, p.focusNode = h.focusNode, p.focusOffset = h.focusOffset);
        }
        return p;
      }
      function pA(o) {
        if (!(!o || !o.activeElt || o.activeElt == le(Xe(o.activeElt))) && (o.activeElt.focus(), !/^(INPUT|TEXTAREA)$/.test(o.activeElt.nodeName) && o.anchorNode && Ie(document.body, o.anchorNode) && Ie(document.body, o.focusNode))) {
          var c = o.activeElt.ownerDocument, p = c.defaultView.getSelection(), h = c.createRange();
          h.setEnd(o.anchorNode, o.anchorOffset), h.collapse(false), p.removeAllRanges(), p.addRange(h), p.extend(o.focusNode, o.focusOffset);
        }
      }
      function Hf(o, c) {
        var p = o.display, h = o.doc;
        if (c.editorIsHidden)
          return rs(o), false;
        if (!c.force && c.visible.from >= p.viewFrom && c.visible.to <= p.viewTo && (p.updateLineNumbers == null || p.updateLineNumbers >= p.viewTo) && p.renderedView == p.view && r0(o) == 0)
          return false;
        g0(o) && (rs(o), c.dims = Of(o));
        var m = h.first + h.size, S = Math.max(c.visible.from - o.options.viewportMargin, h.first), x = Math.min(m, c.visible.to + o.options.viewportMargin);
        p.viewFrom < S && S - p.viewFrom < 20 && (S = Math.max(h.first, p.viewFrom)), p.viewTo > x && p.viewTo - x < 20 && (x = Math.min(m, p.viewTo)), Sr && (S = Tf(o.doc, S), x = NS(o.doc, x));
        var T = S != p.viewFrom || x != p.viewTo || p.lastWrapHeight != c.wrapperHeight || p.lastWrapWidth != c.wrapperWidth;
        XP(o, S, x), p.viewOffset = br(Re(o.doc, p.viewFrom)), o.display.mover.style.top = p.viewOffset + "px";
        var k = r0(o);
        if (!T && k == 0 && !c.force && p.renderedView == p.view && (p.updateLineNumbers == null || p.updateLineNumbers >= p.viewTo))
          return false;
        var D = fA(o);
        return k > 4 && (p.lineDiv.style.display = "none"), gA(o, p.updateLineNumbers, c.dims), k > 4 && (p.lineDiv.style.display = ""), p.renderedView = p.view, pA(D), V(p.cursorDiv), V(p.selectionDiv), p.gutters.style.height = p.sizer.style.minHeight = 0, T && (p.lastWrapHeight = c.wrapperHeight, p.lastWrapWidth = c.wrapperWidth, Tl(o, 400)), p.updateLineNumbers = null, true;
      }
      function f0(o, c) {
        for (var p = c.viewport, h = true; ; h = false) {
          if (!h || !o.options.lineWrapping || c.oldDisplayWidth == Vs(o)) {
            if (p && p.top != null && (p = { top: Math.min(o.doc.height + Df(o.display) - Pf(o), p.top) }), c.visible = wd(o.display, o.doc, p), c.visible.from >= o.display.viewFrom && c.visible.to <= o.display.viewTo)
              break;
          } else
            h && (c.visible = wd(o.display, o.doc, p));
          if (!Hf(o, c))
            break;
          Cd(o);
          var m = xl(o);
          bl(o), za(o, m), Yf(o, m), c.force = false;
        }
        c.signal(o, "update", o), (o.display.viewFrom != o.display.reportedViewFrom || o.display.viewTo != o.display.reportedViewTo) && (c.signal(o, "viewportChange", o, o.display.viewFrom, o.display.viewTo), o.display.reportedViewFrom = o.display.viewFrom, o.display.reportedViewTo = o.display.viewTo);
      }
      function jf(o, c) {
        var p = new Ed(o, c);
        if (Hf(o, p)) {
          Cd(o), f0(o, p);
          var h = xl(o);
          bl(o), za(o, h), Yf(o, h), p.finish();
        }
      }
      function gA(o, c, p) {
        var h = o.display, m = o.options.lineNumbers, S = h.lineDiv, x = S.firstChild;
        function T(ee) {
          var oe = ee.nextSibling;
          return f && A && o.display.currentWheelTarget == ee ? ee.style.display = "none" : ee.parentNode.removeChild(ee), oe;
        }
        for (var k = h.view, D = h.viewFrom, z = 0; z < k.length; z++) {
          var W = k[z];
          if (!W.hidden)
            if (!W.node || W.node.parentNode != S) {
              var q = GP(o, W, D, p);
              S.insertBefore(q, x);
            } else {
              for (; x != W.node; )
                x = T(x);
              var Y = m && c != null && c <= D && W.lineNumber;
              W.changes && (Pe(W.changes, "gutter") > -1 && (Y = false), FS(o, W, D, p)), Y && (V(W.lineNumber), W.lineNumber.appendChild(document.createTextNode(he(o.options, D)))), x = W.node.nextSibling;
            }
          D += W.size;
        }
        for (; x; )
          x = T(x);
      }
      function Jf(o) {
        var c = o.gutters.offsetWidth;
        o.sizer.style.marginLeft = c + "px", rn(o, "gutterChanged", o);
      }
      function Yf(o, c) {
        o.display.sizer.style.minHeight = c.docHeight + "px", o.display.heightForcer.style.top = c.docHeight + "px", o.display.gutters.style.height = c.docHeight + o.display.barHeight + qi(o) + "px";
      }
      function p0(o) {
        var c = o.display, p = c.view;
        if (!(!c.alignWidgets && (!c.gutters.firstChild || !o.options.fixedGutter))) {
          for (var h = Vf(c) - c.scroller.scrollLeft + o.doc.scrollLeft, m = c.gutters.offsetWidth, S = h + "px", x = 0; x < p.length; x++)
            if (!p[x].hidden) {
              o.options.fixedGutter && (p[x].gutter && (p[x].gutter.style.left = S), p[x].gutterBackground && (p[x].gutterBackground.style.left = S));
              var T = p[x].alignable;
              if (T)
                for (var k = 0; k < T.length; k++)
                  T[k].style.left = S;
            }
          o.options.fixedGutter && (c.gutters.style.left = h + m + "px");
        }
      }
      function g0(o) {
        if (!o.options.lineNumbers)
          return false;
        var c = o.doc, p = he(o.options, c.first + c.size - 1), h = o.display;
        if (p.length != h.lineNumChars) {
          var m = h.measure.appendChild(F(
            "div",
            [F("div", p)],
            "CodeMirror-linenumber CodeMirror-gutter-elt"
          )), S = m.firstChild.offsetWidth, x = m.offsetWidth - S;
          return h.lineGutter.style.width = "", h.lineNumInnerWidth = Math.max(S, h.lineGutter.offsetWidth - x) + 1, h.lineNumWidth = h.lineNumInnerWidth + x, h.lineNumChars = h.lineNumInnerWidth ? p.length : -1, h.lineGutter.style.width = h.lineNumWidth + "px", Jf(o.display), true;
        }
        return false;
      }
      function qf(o, c) {
        for (var p = [], h = false, m = 0; m < o.length; m++) {
          var S = o[m], x = null;
          if (typeof S != "string" && (x = S.style, S = S.className), S == "CodeMirror-linenumbers")
            if (c)
              h = true;
            else
              continue;
          p.push({ className: S, style: x });
        }
        return c && !h && p.push({ className: "CodeMirror-linenumbers", style: null }), p;
      }
      function m0(o) {
        var c = o.gutters, p = o.gutterSpecs;
        V(c), o.lineGutter = null;
        for (var h = 0; h < p.length; ++h) {
          var m = p[h], S = m.className, x = m.style, T = c.appendChild(F("div", null, "CodeMirror-gutter " + S));
          x && (T.style.cssText = x), S == "CodeMirror-linenumbers" && (o.lineGutter = T, T.style.width = (o.lineNumWidth || 1) + "px");
        }
        c.style.display = p.length ? "" : "none", Jf(o);
      }
      function kl(o) {
        m0(o.display), On(o), p0(o);
      }
      function mA(o, c, p, h) {
        var m = this;
        this.input = p, m.scrollbarFiller = F("div", null, "CodeMirror-scrollbar-filler"), m.scrollbarFiller.setAttribute("cm-not-content", "true"), m.gutterFiller = F("div", null, "CodeMirror-gutter-filler"), m.gutterFiller.setAttribute("cm-not-content", "true"), m.lineDiv = ue("div", null, "CodeMirror-code"), m.selectionDiv = F("div", null, null, "position: relative; z-index: 1"), m.cursorDiv = F("div", null, "CodeMirror-cursors"), m.measure = F("div", null, "CodeMirror-measure"), m.lineMeasure = F("div", null, "CodeMirror-measure"), m.lineSpace = ue(
          "div",
          [m.measure, m.lineMeasure, m.selectionDiv, m.cursorDiv, m.lineDiv],
          null,
          "position: relative; outline: none"
        );
        var S = ue("div", [m.lineSpace], "CodeMirror-lines");
        m.mover = F("div", [S], null, "position: relative"), m.sizer = F("div", [m.mover], "CodeMirror-sizer"), m.sizerWidth = null, m.heightForcer = F("div", null, null, "position: absolute; height: " + bt + "px; width: 1px;"), m.gutters = F("div", null, "CodeMirror-gutters"), m.lineGutter = null, m.scroller = F("div", [m.sizer, m.heightForcer, m.gutters], "CodeMirror-scroll"), m.scroller.setAttribute("tabIndex", "-1"), m.wrapper = F("div", [m.scrollbarFiller, m.gutterFiller, m.scroller], "CodeMirror"), v && y >= 105 && (m.wrapper.style.clipPath = "inset(0px)"), m.wrapper.setAttribute("translate", "no"), d && u < 8 && (m.gutters.style.zIndex = -1, m.scroller.style.paddingRight = 0), !f && !(r && _) && (m.scroller.draggable = true), o && (o.appendChild ? o.appendChild(m.wrapper) : o(m.wrapper)), m.viewFrom = m.viewTo = c.first, m.reportedViewFrom = m.reportedViewTo = c.first, m.view = [], m.renderedView = null, m.externalMeasured = null, m.viewOffset = 0, m.lastWrapHeight = m.lastWrapWidth = 0, m.updateLineNumbers = null, m.nativeBarWidth = m.barHeight = m.barWidth = 0, m.scrollbarsClipped = false, m.lineNumWidth = m.lineNumInnerWidth = m.lineNumChars = null, m.alignWidgets = false, m.cachedCharWidth = m.cachedTextHeight = m.cachedPaddingH = null, m.maxLine = null, m.maxLineLength = 0, m.maxLineChanged = false, m.wheelDX = m.wheelDY = m.wheelStartX = m.wheelStartY = null, m.shift = false, m.selForContextMenu = null, m.activeTouch = null, m.gutterSpecs = qf(h.gutters, h.lineNumbers), m0(m), p.init(m);
      }
      var Td = 0, wr = null;
      d ? wr = -0.53 : r ? wr = 15 : v ? wr = -0.7 : C && (wr = -1 / 3);
      function v0(o) {
        var c = o.wheelDeltaX, p = o.wheelDeltaY;
        return c == null && o.detail && o.axis == o.HORIZONTAL_AXIS && (c = o.detail), p == null && o.detail && o.axis == o.VERTICAL_AXIS ? p = o.detail : p == null && (p = o.wheelDelta), { x: c, y: p };
      }
      function vA(o) {
        var c = v0(o);
        return c.x *= wr, c.y *= wr, c;
      }
      function y0(o, c) {
        v && y == 102 && (o.display.chromeScrollHack == null ? o.display.sizer.style.pointerEvents = "none" : clearTimeout(o.display.chromeScrollHack), o.display.chromeScrollHack = setTimeout(function() {
          o.display.chromeScrollHack = null, o.display.sizer.style.pointerEvents = "";
        }, 100));
        var p = v0(c), h = p.x, m = p.y, S = wr;
        c.deltaMode === 0 && (h = c.deltaX, m = c.deltaY, S = 1);
        var x = o.display, T = x.scroller, k = T.scrollWidth > T.clientWidth, D = T.scrollHeight > T.clientHeight;
        if (h && k || m && D) {
          if (m && A && f) {
            e:
              for (var z = c.target, W = x.view; z != T; z = z.parentNode)
                for (var q = 0; q < W.length; q++)
                  if (W[q].node == z) {
                    o.display.currentWheelTarget = z;
                    break e;
                  }
          }
          if (h && !r && !w && S != null) {
            m && D && wl(o, Math.max(0, T.scrollTop + m * S)), zs(o, Math.max(0, T.scrollLeft + h * S)), (!m || m && D) && Sn(c), x.wheelStartX = null;
            return;
          }
          if (m && S != null) {
            var Y = m * S, ee = o.doc.scrollTop, oe = ee + x.wrapper.clientHeight;
            Y < 0 ? ee = Math.max(0, ee + Y - 50) : oe = Math.min(o.doc.height, oe + Y + 50), jf(o, { top: ee, bottom: oe });
          }
          Td < 20 && c.deltaMode !== 0 && (x.wheelStartX == null ? (x.wheelStartX = T.scrollLeft, x.wheelStartY = T.scrollTop, x.wheelDX = h, x.wheelDY = m, setTimeout(function() {
            if (x.wheelStartX != null) {
              var fe = T.scrollLeft - x.wheelStartX, ve = T.scrollTop - x.wheelStartY, xe = ve && x.wheelDY && ve / x.wheelDY || fe && x.wheelDX && fe / x.wheelDX;
              x.wheelStartX = x.wheelStartY = null, xe && (wr = (wr * Td + xe) / (Td + 1), ++Td);
            }
          }, 200)) : (x.wheelDX += h, x.wheelDY += m));
        }
      }
      var ti = function(o, c) {
        this.ranges = o, this.primIndex = c;
      };
      ti.prototype.primary = function() {
        return this.ranges[this.primIndex];
      }, ti.prototype.equals = function(o) {
        if (o == this)
          return true;
        if (o.primIndex != this.primIndex || o.ranges.length != this.ranges.length)
          return false;
        for (var c = 0; c < this.ranges.length; c++) {
          var p = this.ranges[c], h = o.ranges[c];
          if (!ct(p.anchor, h.anchor) || !ct(p.head, h.head))
            return false;
        }
        return true;
      }, ti.prototype.deepCopy = function() {
        for (var o = [], c = 0; c < this.ranges.length; c++)
          o[c] = new dt(nn(this.ranges[c].anchor), nn(this.ranges[c].head));
        return new ti(o, this.primIndex);
      }, ti.prototype.somethingSelected = function() {
        for (var o = 0; o < this.ranges.length; o++)
          if (!this.ranges[o].empty())
            return true;
        return false;
      }, ti.prototype.contains = function(o, c) {
        c || (c = o);
        for (var p = 0; p < this.ranges.length; p++) {
          var h = this.ranges[p];
          if (Se(c, h.from()) >= 0 && Se(o, h.to()) <= 0)
            return p;
        }
        return -1;
      };
      var dt = function(o, c) {
        this.anchor = o, this.head = c;
      };
      dt.prototype.from = function() {
        return Ma(this.anchor, this.head);
      }, dt.prototype.to = function() {
        return _n(this.anchor, this.head);
      }, dt.prototype.empty = function() {
        return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;
      };
      function Ni(o, c, p) {
        var h = o && o.options.selectionsMayTouch, m = c[p];
        c.sort(function(q, Y) {
          return Se(q.from(), Y.from());
        }), p = Pe(c, m);
        for (var S = 1; S < c.length; S++) {
          var x = c[S], T = c[S - 1], k = Se(T.to(), x.from());
          if (h && !x.empty() ? k > 0 : k >= 0) {
            var D = Ma(T.from(), x.from()), z = _n(T.to(), x.to()), W = T.empty() ? x.from() == x.head : T.from() == T.head;
            S <= p && --p, c.splice(--S, 2, new dt(W ? z : D, W ? D : z));
          }
        }
        return new ti(c, p);
      }
      function ss(o, c) {
        return new ti([new dt(o, c || o)], 0);
      }
      function as(o) {
        return o.text ? Q(
          o.from.line + o.text.length - 1,
          me(o.text).length + (o.text.length == 1 ? o.from.ch : 0)
        ) : o.to;
      }
      function S0(o, c) {
        if (Se(o, c.from) < 0)
          return o;
        if (Se(o, c.to) <= 0)
          return as(c);
        var p = o.line + c.text.length - (c.to.line - c.from.line) - 1, h = o.ch;
        return o.line == c.to.line && (h += as(c).ch - c.to.ch), Q(p, h);
      }
      function Kf(o, c) {
        for (var p = [], h = 0; h < o.sel.ranges.length; h++) {
          var m = o.sel.ranges[h];
          p.push(new dt(
            S0(m.anchor, c),
            S0(m.head, c)
          ));
        }
        return Ni(o.cm, p, o.sel.primIndex);
      }
      function b0(o, c, p) {
        return o.line == c.line ? Q(p.line, o.ch - c.ch + p.ch) : Q(p.line + (o.line - c.line), o.ch);
      }
      function yA(o, c, p) {
        for (var h = [], m = Q(o.first, 0), S = m, x = 0; x < c.length; x++) {
          var T = c[x], k = b0(T.from, m, S), D = b0(as(T), m, S);
          if (m = T.to, S = D, p == "around") {
            var z = o.sel.ranges[x], W = Se(z.head, z.anchor) < 0;
            h[x] = new dt(W ? D : k, W ? k : D);
          } else
            h[x] = new dt(k, k);
        }
        return new ti(h, o.sel.primIndex);
      }
      function Zf(o) {
        o.doc.mode = Pa(o.options, o.doc.modeOption), Il(o);
      }
      function Il(o) {
        o.doc.iter(function(c) {
          c.stateAfter && (c.stateAfter = null), c.styles && (c.styles = null);
        }), o.doc.modeFrontier = o.doc.highlightFrontier = o.doc.first, Tl(o, 100), o.state.modeGen++, o.curOp && On(o);
      }
      function C0(o, c) {
        return c.from.ch == 0 && c.to.ch == 0 && me(c.text) == "" && (!o.cm || o.cm.options.wholeLineUpdateBefore);
      }
      function Xf(o, c, p, h) {
        function m(xe) {
          return p ? p[xe] : null;
        }
        function S(xe, ye, ke) {
          kP(xe, ye, ke, h), rn(xe, "change", xe, c);
        }
        function x(xe, ye) {
          for (var ke = [], Ve = xe; Ve < ye; ++Ve)
            ke.push(new Na(D[Ve], m(Ve), h));
          return ke;
        }
        var T = c.from, k = c.to, D = c.text, z = Re(o, T.line), W = Re(o, k.line), q = me(D), Y = m(D.length - 1), ee = k.line - T.line;
        if (c.full)
          o.insert(0, x(0, D.length)), o.remove(D.length, o.size - D.length);
        else if (C0(o, c)) {
          var oe = x(0, D.length - 1);
          S(W, W.text, Y), ee && o.remove(T.line, ee), oe.length && o.insert(T.line, oe);
        } else if (z == W)
          if (D.length == 1)
            S(z, z.text.slice(0, T.ch) + q + z.text.slice(k.ch), Y);
          else {
            var fe = x(1, D.length - 1);
            fe.push(new Na(q + z.text.slice(k.ch), Y, h)), S(z, z.text.slice(0, T.ch) + D[0], m(0)), o.insert(T.line + 1, fe);
          }
        else if (D.length == 1)
          S(z, z.text.slice(0, T.ch) + D[0] + W.text.slice(k.ch), m(0)), o.remove(T.line + 1, ee);
        else {
          S(z, z.text.slice(0, T.ch) + D[0], m(0)), S(W, q + W.text.slice(k.ch), Y);
          var ve = x(1, D.length - 1);
          ee > 1 && o.remove(T.line + 1, ee - 1), o.insert(T.line + 1, ve);
        }
        rn(o, "change", o, c);
      }
      function os(o, c, p) {
        function h(m, S, x) {
          if (m.linked)
            for (var T = 0; T < m.linked.length; ++T) {
              var k = m.linked[T];
              if (k.doc != S) {
                var D = x && k.sharedHist;
                p && !D || (c(k.doc, D), h(k.doc, m, D));
              }
            }
        }
        h(o, null, true);
      }
      function w0(o, c) {
        if (c.cm)
          throw new Error("This document is already in use.");
        o.doc = c, c.cm = o, Bf(o), Zf(o), x0(o), o.options.direction = c.direction, o.options.lineWrapping || If(o), o.options.mode = c.modeOption, On(o);
      }
      function x0(o) {
        (o.doc.direction == "rtl" ? Te : U)(o.display.lineDiv, "CodeMirror-rtl");
      }
      function SA(o) {
        Yn(o, function() {
          x0(o), On(o);
        });
      }
      function kd(o) {
        this.done = [], this.undone = [], this.undoDepth = o ? o.undoDepth : 1 / 0, this.lastModTime = this.lastSelTime = 0, this.lastOp = this.lastSelOp = null, this.lastOrigin = this.lastSelOrigin = null, this.generation = this.maxGeneration = o ? o.maxGeneration : 1;
      }
      function Qf(o, c) {
        var p = { from: nn(c.from), to: as(c), text: yr(o, c.from, c.to) };
        return k0(o, p, c.from.line, c.to.line + 1), os(o, function(h) {
          return k0(h, p, c.from.line, c.to.line + 1);
        }, true), p;
      }
      function E0(o) {
        for (; o.length; ) {
          var c = me(o);
          if (c.ranges)
            o.pop();
          else
            break;
        }
      }
      function bA(o, c) {
        if (c)
          return E0(o.done), me(o.done);
        if (o.done.length && !me(o.done).ranges)
          return me(o.done);
        if (o.done.length > 1 && !o.done[o.done.length - 2].ranges)
          return o.done.pop(), me(o.done);
      }
      function T0(o, c, p, h) {
        var m = o.history;
        m.undone.length = 0;
        var S = +/* @__PURE__ */ new Date(), x, T;
        if ((m.lastOp == h || m.lastOrigin == c.origin && c.origin && (c.origin.charAt(0) == "+" && m.lastModTime > S - (o.cm ? o.cm.options.historyEventDelay : 500) || c.origin.charAt(0) == "*")) && (x = bA(m, m.lastOp == h)))
          T = me(x.changes), Se(c.from, c.to) == 0 && Se(c.from, T.to) == 0 ? T.to = as(c) : x.changes.push(Qf(o, c));
        else {
          var k = me(m.done);
          for ((!k || !k.ranges) && Id(o.sel, m.done), x = {
            changes: [Qf(o, c)],
            generation: m.generation
          }, m.done.push(x); m.done.length > m.undoDepth; )
            m.done.shift(), m.done[0].ranges || m.done.shift();
        }
        m.done.push(p), m.generation = ++m.maxGeneration, m.lastModTime = m.lastSelTime = S, m.lastOp = m.lastSelOp = h, m.lastOrigin = m.lastSelOrigin = c.origin, T || Nt(o, "historyAdded");
      }
      function CA(o, c, p, h) {
        var m = c.charAt(0);
        return m == "*" || m == "+" && p.ranges.length == h.ranges.length && p.somethingSelected() == h.somethingSelected() && /* @__PURE__ */ new Date() - o.history.lastSelTime <= (o.cm ? o.cm.options.historyEventDelay : 500);
      }
      function wA(o, c, p, h) {
        var m = o.history, S = h && h.origin;
        p == m.lastSelOp || S && m.lastSelOrigin == S && (m.lastModTime == m.lastSelTime && m.lastOrigin == S || CA(o, S, me(m.done), c)) ? m.done[m.done.length - 1] = c : Id(c, m.done), m.lastSelTime = +/* @__PURE__ */ new Date(), m.lastSelOrigin = S, m.lastSelOp = p, h && h.clearRedo !== false && E0(m.undone);
      }
      function Id(o, c) {
        var p = me(c);
        p && p.ranges && p.equals(o) || c.push(o);
      }
      function k0(o, c, p, h) {
        var m = c["spans_" + o.id], S = 0;
        o.iter(Math.max(o.first, p), Math.min(o.first + o.size, h), function(x) {
          x.markedSpans && ((m || (m = c["spans_" + o.id] = {}))[S] = x.markedSpans), ++S;
        });
      }
      function xA(o) {
        if (!o)
          return null;
        for (var c, p = 0; p < o.length; ++p)
          o[p].marker.explicitlyCleared ? c || (c = o.slice(0, p)) : c && c.push(o[p]);
        return c ? c.length ? c : null : o;
      }
      function EA(o, c) {
        var p = c["spans_" + o.id];
        if (!p)
          return null;
        for (var h = [], m = 0; m < c.text.length; ++m)
          h.push(xA(p[m]));
        return h;
      }
      function I0(o, c) {
        var p = EA(o, c), h = xf(o, c);
        if (!p)
          return h;
        if (!h)
          return p;
        for (var m = 0; m < p.length; ++m) {
          var S = p[m], x = h[m];
          if (S && x)
            e:
              for (var T = 0; T < x.length; ++T) {
                for (var k = x[T], D = 0; D < S.length; ++D)
                  if (S[D].marker == k.marker)
                    continue e;
                S.push(k);
              }
          else
            x && (p[m] = x);
        }
        return p;
      }
      function Ga(o, c, p) {
        for (var h = [], m = 0; m < o.length; ++m) {
          var S = o[m];
          if (S.ranges) {
            h.push(p ? ti.prototype.deepCopy.call(S) : S);
            continue;
          }
          var x = S.changes, T = [];
          h.push({ changes: T });
          for (var k = 0; k < x.length; ++k) {
            var D = x[k], z = void 0;
            if (T.push({ from: D.from, to: D.to, text: D.text }), c)
              for (var W in D)
                (z = W.match(/^spans_(\d+)$/)) && Pe(c, Number(z[1])) > -1 && (me(T)[W] = D[W], delete D[W]);
          }
        }
        return h;
      }
      function ep(o, c, p, h) {
        if (h) {
          var m = o.anchor;
          if (p) {
            var S = Se(c, m) < 0;
            S != Se(p, m) < 0 ? (m = c, c = p) : S != Se(c, p) < 0 && (c = p);
          }
          return new dt(m, c);
        } else
          return new dt(p || c, c);
      }
      function Ld(o, c, p, h, m) {
        m == null && (m = o.cm && (o.cm.display.shift || o.extend)), bn(o, new ti([ep(o.sel.primary(), c, p, m)], 0), h);
      }
      function L0(o, c, p) {
        for (var h = [], m = o.cm && (o.cm.display.shift || o.extend), S = 0; S < o.sel.ranges.length; S++)
          h[S] = ep(o.sel.ranges[S], c[S], null, m);
        var x = Ni(o.cm, h, o.sel.primIndex);
        bn(o, x, p);
      }
      function tp(o, c, p, h) {
        var m = o.sel.ranges.slice(0);
        m[c] = p, bn(o, Ni(o.cm, m, o.sel.primIndex), h);
      }
      function D0(o, c, p, h) {
        bn(o, ss(c, p), h);
      }
      function TA(o, c, p) {
        var h = {
          ranges: c.ranges,
          update: function(m) {
            this.ranges = [];
            for (var S = 0; S < m.length; S++)
              this.ranges[S] = new dt(
                He(o, m[S].anchor),
                He(o, m[S].head)
              );
          },
          origin: p && p.origin
        };
        return Nt(o, "beforeSelectionChange", o, h), o.cm && Nt(o.cm, "beforeSelectionChange", o.cm, h), h.ranges != c.ranges ? Ni(o.cm, h.ranges, h.ranges.length - 1) : c;
      }
      function P0(o, c, p) {
        var h = o.history.done, m = me(h);
        m && m.ranges ? (h[h.length - 1] = c, Dd(o, c, p)) : bn(o, c, p);
      }
      function bn(o, c, p) {
        Dd(o, c, p), wA(o, o.sel, o.cm ? o.cm.curOp.id : NaN, p);
      }
      function Dd(o, c, p) {
        (Jn(o, "beforeSelectionChange") || o.cm && Jn(o.cm, "beforeSelectionChange")) && (c = TA(o, c, p));
        var h = p && p.bias || (Se(c.primary().head, o.sel.primary().head) < 0 ? -1 : 1);
        A0(o, M0(o, c, h, true)), !(p && p.scroll === false) && o.cm && o.cm.getOption("readOnly") != "nocursor" && Ua(o.cm);
      }
      function A0(o, c) {
        c.equals(o.sel) || (o.sel = c, o.cm && (o.cm.curOp.updateInput = 1, o.cm.curOp.selectionChanged = true, ui(o.cm)), rn(o, "cursorActivity", o));
      }
      function R0(o) {
        A0(o, M0(o, o.sel, null, false));
      }
      function M0(o, c, p, h) {
        for (var m, S = 0; S < c.ranges.length; S++) {
          var x = c.ranges[S], T = c.ranges.length == o.sel.ranges.length && o.sel.ranges[S], k = Pd(o, x.anchor, T && T.anchor, p, h), D = x.head == x.anchor ? k : Pd(o, x.head, T && T.head, p, h);
          (m || k != x.anchor || D != x.head) && (m || (m = c.ranges.slice(0, S)), m[S] = new dt(k, D));
        }
        return m ? Ni(o.cm, m, c.primIndex) : c;
      }
      function $a(o, c, p, h, m) {
        var S = Re(o, c.line);
        if (S.markedSpans)
          for (var x = 0; x < S.markedSpans.length; ++x) {
            var T = S.markedSpans[x], k = T.marker, D = "selectLeft" in k ? !k.selectLeft : k.inclusiveLeft, z = "selectRight" in k ? !k.selectRight : k.inclusiveRight;
            if ((T.from == null || (D ? T.from <= c.ch : T.from < c.ch)) && (T.to == null || (z ? T.to >= c.ch : T.to > c.ch))) {
              if (m && (Nt(k, "beforeCursorEnter"), k.explicitlyCleared))
                if (S.markedSpans) {
                  --x;
                  continue;
                } else
                  break;
              if (!k.atomic)
                continue;
              if (p) {
                var W = k.find(h < 0 ? 1 : -1), q = void 0;
                if ((h < 0 ? z : D) && (W = N0(o, W, -h, W && W.line == c.line ? S : null)), W && W.line == c.line && (q = Se(W, p)) && (h < 0 ? q < 0 : q > 0))
                  return $a(o, W, c, h, m);
              }
              var Y = k.find(h < 0 ? -1 : 1);
              return (h < 0 ? D : z) && (Y = N0(o, Y, h, Y.line == c.line ? S : null)), Y ? $a(o, Y, c, h, m) : null;
            }
          }
        return c;
      }
      function Pd(o, c, p, h, m) {
        var S = h || 1, x = $a(o, c, p, S, m) || !m && $a(o, c, p, S, true) || $a(o, c, p, -S, m) || !m && $a(o, c, p, -S, true);
        return x || (o.cantEdit = true, Q(o.first, 0));
      }
      function N0(o, c, p, h) {
        return p < 0 && c.ch == 0 ? c.line > o.first ? He(o, Q(c.line - 1)) : null : p > 0 && c.ch == (h || Re(o, c.line)).text.length ? c.line < o.first + o.size - 1 ? Q(c.line + 1, 0) : null : new Q(c.line, c.ch + p);
      }
      function _0(o) {
        o.setSelection(Q(o.firstLine(), 0), Q(o.lastLine()), tn);
      }
      function O0(o, c, p) {
        var h = {
          canceled: false,
          from: c.from,
          to: c.to,
          text: c.text,
          origin: c.origin,
          cancel: function() {
            return h.canceled = true;
          }
        };
        return p && (h.update = function(m, S, x, T) {
          m && (h.from = He(o, m)), S && (h.to = He(o, S)), x && (h.text = x), T !== void 0 && (h.origin = T);
        }), Nt(o, "beforeChange", o, h), o.cm && Nt(o.cm, "beforeChange", o.cm, h), h.canceled ? (o.cm && (o.cm.curOp.updateInput = 2), null) : { from: h.from, to: h.to, text: h.text, origin: h.origin };
      }
      function Wa(o, c, p) {
        if (o.cm) {
          if (!o.cm.curOp)
            return sn(o.cm, Wa)(o, c, p);
          if (o.cm.state.suppressEdits)
            return;
        }
        if (!((Jn(o, "beforeChange") || o.cm && Jn(o.cm, "beforeChange")) && (c = O0(o, c, true), !c))) {
          var h = IS && !p && wP(o, c.from, c.to);
          if (h)
            for (var m = h.length - 1; m >= 0; --m)
              V0(o, { from: h[m].from, to: h[m].to, text: m ? [""] : c.text, origin: c.origin });
          else
            V0(o, c);
        }
      }
      function V0(o, c) {
        if (!(c.text.length == 1 && c.text[0] == "" && Se(c.from, c.to) == 0)) {
          var p = Kf(o, c);
          T0(o, c, p, o.cm ? o.cm.curOp.id : NaN), Ll(o, c, p, xf(o, c));
          var h = [];
          os(o, function(m, S) {
            !S && Pe(h, m.history) == -1 && (z0(m.history, c), h.push(m.history)), Ll(m, c, null, xf(m, c));
          });
        }
      }
      function Ad(o, c, p) {
        var h = o.cm && o.cm.state.suppressEdits;
        if (!(h && !p)) {
          for (var m = o.history, S, x = o.sel, T = c == "undo" ? m.done : m.undone, k = c == "undo" ? m.undone : m.done, D = 0; D < T.length && (S = T[D], !(p ? S.ranges && !S.equals(o.sel) : !S.ranges)); D++)
            ;
          if (D != T.length) {
            for (m.lastOrigin = m.lastSelOrigin = null; ; )
              if (S = T.pop(), S.ranges) {
                if (Id(S, k), p && !S.equals(o.sel)) {
                  bn(o, S, { clearRedo: false });
                  return;
                }
                x = S;
              } else if (h) {
                T.push(S);
                return;
              } else
                break;
            var z = [];
            Id(x, k), k.push({ changes: z, generation: m.generation }), m.generation = S.generation || ++m.maxGeneration;
            for (var W = Jn(o, "beforeChange") || o.cm && Jn(o.cm, "beforeChange"), q = function(oe) {
              var fe = S.changes[oe];
              if (fe.origin = c, W && !O0(o, fe, false))
                return T.length = 0, {};
              z.push(Qf(o, fe));
              var ve = oe ? Kf(o, fe) : me(T);
              Ll(o, fe, ve, I0(o, fe)), !oe && o.cm && o.cm.scrollIntoView({ from: fe.from, to: as(fe) });
              var xe = [];
              os(o, function(ye, ke) {
                !ke && Pe(xe, ye.history) == -1 && (z0(ye.history, fe), xe.push(ye.history)), Ll(ye, fe, null, I0(ye, fe));
              });
            }, Y = S.changes.length - 1; Y >= 0; --Y) {
              var ee = q(Y);
              if (ee)
                return ee.v;
            }
          }
        }
      }
      function B0(o, c) {
        if (c != 0 && (o.first += c, o.sel = new ti(Ge(o.sel.ranges, function(m) {
          return new dt(
            Q(m.anchor.line + c, m.anchor.ch),
            Q(m.head.line + c, m.head.ch)
          );
        }), o.sel.primIndex), o.cm)) {
          On(o.cm, o.first, o.first - c, c);
          for (var p = o.cm.display, h = p.viewFrom; h < p.viewTo; h++)
            is(o.cm, h, "gutter");
        }
      }
      function Ll(o, c, p, h) {
        if (o.cm && !o.cm.curOp)
          return sn(o.cm, Ll)(o, c, p, h);
        if (c.to.line < o.first) {
          B0(o, c.text.length - 1 - (c.to.line - c.from.line));
          return;
        }
        if (!(c.from.line > o.lastLine())) {
          if (c.from.line < o.first) {
            var m = c.text.length - 1 - (o.first - c.from.line);
            B0(o, m), c = {
              from: Q(o.first, 0),
              to: Q(c.to.line + m, c.to.ch),
              text: [me(c.text)],
              origin: c.origin
            };
          }
          var S = o.lastLine();
          c.to.line > S && (c = {
            from: c.from,
            to: Q(S, Re(o, S).text.length),
            text: [c.text[0]],
            origin: c.origin
          }), c.removed = yr(o, c.from, c.to), p || (p = Kf(o, c)), o.cm ? kA(o.cm, c, h) : Xf(o, c, h), Dd(o, p, tn), o.cantEdit && Pd(o, Q(o.firstLine(), 0)) && (o.cantEdit = false);
        }
      }
      function kA(o, c, p) {
        var h = o.doc, m = o.display, S = c.from, x = c.to, T = false, k = S.line;
        o.options.lineWrapping || (k = M(Ri(Re(h, S.line))), h.iter(k, x.line + 1, function(Y) {
          if (Y == m.maxLine)
            return T = true, true;
        })), h.sel.contains(c.from, c.to) > -1 && ui(o), Xf(h, c, p, i0(o)), o.options.lineWrapping || (h.iter(k, S.line + c.text.length, function(Y) {
          var ee = pd(Y);
          ee > m.maxLineLength && (m.maxLine = Y, m.maxLineLength = ee, m.maxLineChanged = true, T = false);
        }), T && (o.curOp.updateMaxLine = true)), gP(h, S.line), Tl(o, 400);
        var D = c.text.length - (x.line - S.line) - 1;
        c.full ? On(o) : S.line == x.line && c.text.length == 1 && !C0(o.doc, c) ? is(o, S.line, "text") : On(o, S.line, x.line + 1, D);
        var z = Jn(o, "changes"), W = Jn(o, "change");
        if (W || z) {
          var q = {
            from: S,
            to: x,
            text: c.text,
            removed: c.removed,
            origin: c.origin
          };
          W && rn(o, "change", o, q), z && (o.curOp.changeObjs || (o.curOp.changeObjs = [])).push(q);
        }
        o.display.selForContextMenu = null;
      }
      function Ha(o, c, p, h, m) {
        var S;
        h || (h = p), Se(h, p) < 0 && (S = [h, p], p = S[0], h = S[1]), typeof c == "string" && (c = o.splitLines(c)), Wa(o, { from: p, to: h, text: c, origin: m });
      }
      function F0(o, c, p, h) {
        p < o.line ? o.line += h : c < o.line && (o.line = c, o.ch = 0);
      }
      function U0(o, c, p, h) {
        for (var m = 0; m < o.length; ++m) {
          var S = o[m], x = true;
          if (S.ranges) {
            S.copied || (S = o[m] = S.deepCopy(), S.copied = true);
            for (var T = 0; T < S.ranges.length; T++)
              F0(S.ranges[T].anchor, c, p, h), F0(S.ranges[T].head, c, p, h);
            continue;
          }
          for (var k = 0; k < S.changes.length; ++k) {
            var D = S.changes[k];
            if (p < D.from.line)
              D.from = Q(D.from.line + h, D.from.ch), D.to = Q(D.to.line + h, D.to.ch);
            else if (c <= D.to.line) {
              x = false;
              break;
            }
          }
          x || (o.splice(0, m + 1), m = 0);
        }
      }
      function z0(o, c) {
        var p = c.from.line, h = c.to.line, m = c.text.length - (h - p) - 1;
        U0(o.done, p, h, m), U0(o.undone, p, h, m);
      }
      function Dl(o, c, p, h) {
        var m = c, S = c;
        return typeof c == "number" ? S = Re(o, yS(o, c)) : m = M(c), m == null ? null : (h(S, m) && o.cm && is(o.cm, m, p), S);
      }
      function Pl(o) {
        this.lines = o, this.parent = null;
        for (var c = 0, p = 0; p < o.length; ++p)
          o[p].parent = this, c += o[p].height;
        this.height = c;
      }
      Pl.prototype = {
        chunkSize: function() {
          return this.lines.length;
        },
        // Remove the n lines at offset 'at'.
        removeInner: function(o, c) {
          for (var p = o, h = o + c; p < h; ++p) {
            var m = this.lines[p];
            this.height -= m.height, IP(m), rn(m, "delete");
          }
          this.lines.splice(o, c);
        },
        // Helper used to collapse a small branch into a single leaf.
        collapse: function(o) {
          o.push.apply(o, this.lines);
        },
        // Insert the given array of lines at offset 'at', count them as
        // having the given height.
        insertInner: function(o, c, p) {
          this.height += p, this.lines = this.lines.slice(0, o).concat(c).concat(this.lines.slice(o));
          for (var h = 0; h < c.length; ++h)
            c[h].parent = this;
        },
        // Used to iterate over a part of the tree.
        iterN: function(o, c, p) {
          for (var h = o + c; o < h; ++o)
            if (p(this.lines[o]))
              return true;
        }
      };
      function Al(o) {
        this.children = o;
        for (var c = 0, p = 0, h = 0; h < o.length; ++h) {
          var m = o[h];
          c += m.chunkSize(), p += m.height, m.parent = this;
        }
        this.size = c, this.height = p, this.parent = null;
      }
      Al.prototype = {
        chunkSize: function() {
          return this.size;
        },
        removeInner: function(o, c) {
          this.size -= c;
          for (var p = 0; p < this.children.length; ++p) {
            var h = this.children[p], m = h.chunkSize();
            if (o < m) {
              var S = Math.min(c, m - o), x = h.height;
              if (h.removeInner(o, S), this.height -= x - h.height, m == S && (this.children.splice(p--, 1), h.parent = null), (c -= S) == 0)
                break;
              o = 0;
            } else
              o -= m;
          }
          if (this.size - c < 25 && (this.children.length > 1 || !(this.children[0] instanceof Pl))) {
            var T = [];
            this.collapse(T), this.children = [new Pl(T)], this.children[0].parent = this;
          }
        },
        collapse: function(o) {
          for (var c = 0; c < this.children.length; ++c)
            this.children[c].collapse(o);
        },
        insertInner: function(o, c, p) {
          this.size += c.length, this.height += p;
          for (var h = 0; h < this.children.length; ++h) {
            var m = this.children[h], S = m.chunkSize();
            if (o <= S) {
              if (m.insertInner(o, c, p), m.lines && m.lines.length > 50) {
                for (var x = m.lines.length % 25 + 25, T = x; T < m.lines.length; ) {
                  var k = new Pl(m.lines.slice(T, T += 25));
                  m.height -= k.height, this.children.splice(++h, 0, k), k.parent = this;
                }
                m.lines = m.lines.slice(0, x), this.maybeSpill();
              }
              break;
            }
            o -= S;
          }
        },
        // When a node has grown, check whether it should be split.
        maybeSpill: function() {
          if (!(this.children.length <= 10)) {
            var o = this;
            do {
              var c = o.children.splice(o.children.length - 5, 5), p = new Al(c);
              if (o.parent) {
                o.size -= p.size, o.height -= p.height;
                var m = Pe(o.parent.children, o);
                o.parent.children.splice(m + 1, 0, p);
              } else {
                var h = new Al(o.children);
                h.parent = o, o.children = [h, p], o = h;
              }
              p.parent = o.parent;
            } while (o.children.length > 10);
            o.parent.maybeSpill();
          }
        },
        iterN: function(o, c, p) {
          for (var h = 0; h < this.children.length; ++h) {
            var m = this.children[h], S = m.chunkSize();
            if (o < S) {
              var x = Math.min(c, S - o);
              if (m.iterN(o, x, p))
                return true;
              if ((c -= x) == 0)
                break;
              o = 0;
            } else
              o -= S;
          }
        }
      };
      var Rl = function(o, c, p) {
        if (p)
          for (var h in p)
            p.hasOwnProperty(h) && (this[h] = p[h]);
        this.doc = o, this.node = c;
      };
      Rl.prototype.clear = function() {
        var o = this.doc.cm, c = this.line.widgets, p = this.line, h = M(p);
        if (!(h == null || !c)) {
          for (var m = 0; m < c.length; ++m)
            c[m] == this && c.splice(m--, 1);
          c.length || (p.widgets = null);
          var S = yl(this);
          ei(p, Math.max(0, p.height - S)), o && (Yn(o, function() {
            G0(o, p, -S), is(o, h, "widget");
          }), rn(o, "lineWidgetCleared", o, this, h));
        }
      }, Rl.prototype.changed = function() {
        var o = this, c = this.height, p = this.doc.cm, h = this.line;
        this.height = null;
        var m = yl(this) - c;
        m && (ns(this.doc, h) || ei(h, h.height + m), p && Yn(p, function() {
          p.curOp.forceUpdate = true, G0(p, h, m), rn(p, "lineWidgetChanged", p, o, M(h));
        }));
      }, Ii(Rl);
      function G0(o, c, p) {
        br(c) < (o.curOp && o.curOp.scrollTop || o.doc.scrollTop) && Wf(o, p);
      }
      function IA(o, c, p, h) {
        var m = new Rl(o, p, h), S = o.cm;
        return S && m.noHScroll && (S.display.alignWidgets = true), Dl(o, c, "widget", function(x) {
          var T = x.widgets || (x.widgets = []);
          if (m.insertAt == null ? T.push(m) : T.splice(Math.min(T.length, Math.max(0, m.insertAt)), 0, m), m.line = x, S && !ns(o, x)) {
            var k = br(x) < o.scrollTop;
            ei(x, x.height + yl(m)), k && Wf(S, m.height), S.curOp.forceUpdate = true;
          }
          return true;
        }), S && rn(S, "lineWidgetAdded", S, m, typeof c == "number" ? c : M(c)), m;
      }
      var $0 = 0, ls = function(o, c) {
        this.lines = [], this.type = c, this.doc = o, this.id = ++$0;
      };
      ls.prototype.clear = function() {
        if (!this.explicitlyCleared) {
          var o = this.doc.cm, c = o && !o.curOp;
          if (c && $s(o), Jn(this, "clear")) {
            var p = this.find();
            p && rn(this, "clear", p.from, p.to);
          }
          for (var h = null, m = null, S = 0; S < this.lines.length; ++S) {
            var x = this.lines[S], T = gl(x.markedSpans, this);
            o && !this.collapsed ? is(o, M(x), "text") : o && (T.to != null && (m = M(x)), T.from != null && (h = M(x))), x.markedSpans = yP(x.markedSpans, T), T.from == null && this.collapsed && !ns(this.doc, x) && o && ei(x, Va(o.display));
          }
          if (o && this.collapsed && !o.options.lineWrapping)
            for (var k = 0; k < this.lines.length; ++k) {
              var D = Ri(this.lines[k]), z = pd(D);
              z > o.display.maxLineLength && (o.display.maxLine = D, o.display.maxLineLength = z, o.display.maxLineChanged = true);
            }
          h != null && o && this.collapsed && On(o, h, m + 1), this.lines.length = 0, this.explicitlyCleared = true, this.atomic && this.doc.cantEdit && (this.doc.cantEdit = false, o && R0(o.doc)), o && rn(o, "markerCleared", o, this, h, m), c && Ws(o), this.parent && this.parent.clear();
        }
      }, ls.prototype.find = function(o, c) {
        o == null && this.type == "bookmark" && (o = 1);
        for (var p, h, m = 0; m < this.lines.length; ++m) {
          var S = this.lines[m], x = gl(S.markedSpans, this);
          if (x.from != null && (p = Q(c ? S : M(S), x.from), o == -1))
            return p;
          if (x.to != null && (h = Q(c ? S : M(S), x.to), o == 1))
            return h;
        }
        return p && { from: p, to: h };
      }, ls.prototype.changed = function() {
        var o = this, c = this.find(-1, true), p = this, h = this.doc.cm;
        !c || !h || Yn(h, function() {
          var m = c.line, S = M(c.line), x = Af(h, S);
          if (x && (qS(x), h.curOp.selectionChanged = h.curOp.forceUpdate = true), h.curOp.updateMaxLine = true, !ns(p.doc, m) && p.height != null) {
            var T = p.height;
            p.height = null;
            var k = yl(p) - T;
            k && ei(m, m.height + k);
          }
          rn(h, "markerChanged", h, o);
        });
      }, ls.prototype.attachLine = function(o) {
        if (!this.lines.length && this.doc.cm) {
          var c = this.doc.cm.curOp;
          (!c.maybeHiddenMarkers || Pe(c.maybeHiddenMarkers, this) == -1) && (c.maybeUnhiddenMarkers || (c.maybeUnhiddenMarkers = [])).push(this);
        }
        this.lines.push(o);
      }, ls.prototype.detachLine = function(o) {
        if (this.lines.splice(Pe(this.lines, o), 1), !this.lines.length && this.doc.cm) {
          var c = this.doc.cm.curOp;
          (c.maybeHiddenMarkers || (c.maybeHiddenMarkers = [])).push(this);
        }
      }, Ii(ls);
      function ja(o, c, p, h, m) {
        if (h && h.shared)
          return LA(o, c, p, h, m);
        if (o.cm && !o.cm.curOp)
          return sn(o.cm, ja)(o, c, p, h, m);
        var S = new ls(o, m), x = Se(c, p);
        if (h && ze(h, S, false), x > 0 || x == 0 && S.clearWhenEmpty !== false)
          return S;
        if (S.replacedWith && (S.collapsed = true, S.widgetNode = ue("span", [S.replacedWith], "CodeMirror-widget"), h.handleMouseEvents || S.widgetNode.setAttribute("cm-ignore-events", "true"), h.insertLeft && (S.widgetNode.insertLeft = true)), S.collapsed) {
          if (MS(o, c.line, c, p, S) || c.line != p.line && MS(o, p.line, c, p, S))
            throw new Error("Inserting collapsed marker partially overlapping an existing one");
          vP();
        }
        S.addToHistory && T0(o, { from: c, to: p, origin: "markText" }, o.sel, NaN);
        var T = c.line, k = o.cm, D;
        if (o.iter(T, p.line + 1, function(W) {
          k && S.collapsed && !k.options.lineWrapping && Ri(W) == k.display.maxLine && (D = true), S.collapsed && T != c.line && ei(W, 0), SP(W, new dd(
            S,
            T == c.line ? c.ch : null,
            T == p.line ? p.ch : null
          ), o.cm && o.cm.curOp), ++T;
        }), S.collapsed && o.iter(c.line, p.line + 1, function(W) {
          ns(o, W) && ei(W, 0);
        }), S.clearOnEnter && Oe(S, "beforeCursorEnter", function() {
          return S.clear();
        }), S.readOnly && (mP(), (o.history.done.length || o.history.undone.length) && o.clearHistory()), S.collapsed && (S.id = ++$0, S.atomic = true), k) {
          if (D && (k.curOp.updateMaxLine = true), S.collapsed)
            On(k, c.line, p.line + 1);
          else if (S.className || S.startStyle || S.endStyle || S.css || S.attributes || S.title)
            for (var z = c.line; z <= p.line; z++)
              is(k, z, "text");
          S.atomic && R0(k.doc), rn(k, "markerAdded", k, S);
        }
        return S;
      }
      var Ml = function(o, c) {
        this.markers = o, this.primary = c;
        for (var p = 0; p < o.length; ++p)
          o[p].parent = this;
      };
      Ml.prototype.clear = function() {
        if (!this.explicitlyCleared) {
          this.explicitlyCleared = true;
          for (var o = 0; o < this.markers.length; ++o)
            this.markers[o].clear();
          rn(this, "clear");
        }
      }, Ml.prototype.find = function(o, c) {
        return this.primary.find(o, c);
      }, Ii(Ml);
      function LA(o, c, p, h, m) {
        h = ze(h), h.shared = false;
        var S = [ja(o, c, p, h, m)], x = S[0], T = h.widgetNode;
        return os(o, function(k) {
          T && (h.widgetNode = T.cloneNode(true)), S.push(ja(k, He(k, c), He(k, p), h, m));
          for (var D = 0; D < k.linked.length; ++D)
            if (k.linked[D].isParent)
              return;
          x = me(S);
        }), new Ml(S, x);
      }
      function W0(o) {
        return o.findMarks(Q(o.first, 0), o.clipPos(Q(o.lastLine())), function(c) {
          return c.parent;
        });
      }
      function DA(o, c) {
        for (var p = 0; p < c.length; p++) {
          var h = c[p], m = h.find(), S = o.clipPos(m.from), x = o.clipPos(m.to);
          if (Se(S, x)) {
            var T = ja(o, S, x, h.primary, h.primary.type);
            h.markers.push(T), T.parent = h;
          }
        }
      }
      function PA(o) {
        for (var c = function(h) {
          var m = o[h], S = [m.primary.doc];
          os(m.primary.doc, function(k) {
            return S.push(k);
          });
          for (var x = 0; x < m.markers.length; x++) {
            var T = m.markers[x];
            Pe(S, T.doc) == -1 && (T.parent = null, m.markers.splice(x--, 1));
          }
        }, p = 0; p < o.length; p++)
          c(p);
      }
      var AA = 0, Vn = function(o, c, p, h, m) {
        if (!(this instanceof Vn))
          return new Vn(o, c, p, h, m);
        p == null && (p = 0), Al.call(this, [new Pl([new Na("", null)])]), this.first = p, this.scrollTop = this.scrollLeft = 0, this.cantEdit = false, this.cleanGeneration = 1, this.modeFrontier = this.highlightFrontier = p;
        var S = Q(p, 0);
        this.sel = ss(S), this.history = new kd(null), this.id = ++AA, this.modeOption = c, this.lineSep = h, this.direction = m == "rtl" ? "rtl" : "ltr", this.extend = false, typeof o == "string" && (o = this.splitLines(o)), Xf(this, { from: S, to: S, text: o }), bn(this, ss(S), tn);
      };
      Vn.prototype = ft(Al.prototype, {
        constructor: Vn,
        // Iterate over the document. Supports two forms -- with only one
        // argument, it calls that for each line in the document. With
        // three, it iterates over the range given by the first two (with
        // the second being non-inclusive).
        iter: function(o, c, p) {
          p ? this.iterN(o - this.first, c - o, p) : this.iterN(this.first, this.first + this.size, o);
        },
        // Non-public interface for adding and removing lines.
        insert: function(o, c) {
          for (var p = 0, h = 0; h < c.length; ++h)
            p += c[h].height;
          this.insertInner(o - this.first, c, p);
        },
        remove: function(o, c) {
          this.removeInner(o - this.first, c);
        },
        // From here, the methods are part of the public interface. Most
        // are also available from CodeMirror (editor) instances.
        getValue: function(o) {
          var c = fl(this, this.first, this.first + this.size);
          return o === false ? c : c.join(o || this.lineSeparator());
        },
        setValue: an(function(o) {
          var c = Q(this.first, 0), p = this.first + this.size - 1;
          Wa(this, {
            from: c,
            to: Q(p, Re(this, p).text.length),
            text: this.splitLines(o),
            origin: "setValue",
            full: true
          }, true), this.cm && Cl(this.cm, 0, 0), bn(this, ss(c), tn);
        }),
        replaceRange: function(o, c, p, h) {
          c = He(this, c), p = p ? He(this, p) : c, Ha(this, o, c, p, h);
        },
        getRange: function(o, c, p) {
          var h = yr(this, He(this, o), He(this, c));
          return p === false ? h : p === "" ? h.join("") : h.join(p || this.lineSeparator());
        },
        getLine: function(o) {
          var c = this.getLineHandle(o);
          return c && c.text;
        },
        getLineHandle: function(o) {
          if (ie(this, o))
            return Re(this, o);
        },
        getLineNumber: function(o) {
          return M(o);
        },
        getLineHandleVisualStart: function(o) {
          return typeof o == "number" && (o = Re(this, o)), Ri(o);
        },
        lineCount: function() {
          return this.size;
        },
        firstLine: function() {
          return this.first;
        },
        lastLine: function() {
          return this.first + this.size - 1;
        },
        clipPos: function(o) {
          return He(this, o);
        },
        getCursor: function(o) {
          var c = this.sel.primary(), p;
          return o == null || o == "head" ? p = c.head : o == "anchor" ? p = c.anchor : o == "end" || o == "to" || o === false ? p = c.to() : p = c.from(), p;
        },
        listSelections: function() {
          return this.sel.ranges;
        },
        somethingSelected: function() {
          return this.sel.somethingSelected();
        },
        setCursor: an(function(o, c, p) {
          D0(this, He(this, typeof o == "number" ? Q(o, c || 0) : o), null, p);
        }),
        setSelection: an(function(o, c, p) {
          D0(this, He(this, o), He(this, c || o), p);
        }),
        extendSelection: an(function(o, c, p) {
          Ld(this, He(this, o), c && He(this, c), p);
        }),
        extendSelections: an(function(o, c) {
          L0(this, SS(this, o), c);
        }),
        extendSelectionsBy: an(function(o, c) {
          var p = Ge(this.sel.ranges, o);
          L0(this, SS(this, p), c);
        }),
        setSelections: an(function(o, c, p) {
          if (o.length) {
            for (var h = [], m = 0; m < o.length; m++)
              h[m] = new dt(
                He(this, o[m].anchor),
                He(this, o[m].head || o[m].anchor)
              );
            c == null && (c = Math.min(o.length - 1, this.sel.primIndex)), bn(this, Ni(this.cm, h, c), p);
          }
        }),
        addSelection: an(function(o, c, p) {
          var h = this.sel.ranges.slice(0);
          h.push(new dt(He(this, o), He(this, c || o))), bn(this, Ni(this.cm, h, h.length - 1), p);
        }),
        getSelection: function(o) {
          for (var c = this.sel.ranges, p, h = 0; h < c.length; h++) {
            var m = yr(this, c[h].from(), c[h].to());
            p = p ? p.concat(m) : m;
          }
          return o === false ? p : p.join(o || this.lineSeparator());
        },
        getSelections: function(o) {
          for (var c = [], p = this.sel.ranges, h = 0; h < p.length; h++) {
            var m = yr(this, p[h].from(), p[h].to());
            o !== false && (m = m.join(o || this.lineSeparator())), c[h] = m;
          }
          return c;
        },
        replaceSelection: function(o, c, p) {
          for (var h = [], m = 0; m < this.sel.ranges.length; m++)
            h[m] = o;
          this.replaceSelections(h, c, p || "+input");
        },
        replaceSelections: an(function(o, c, p) {
          for (var h = [], m = this.sel, S = 0; S < m.ranges.length; S++) {
            var x = m.ranges[S];
            h[S] = { from: x.from(), to: x.to(), text: this.splitLines(o[S]), origin: p };
          }
          for (var T = c && c != "end" && yA(this, h, c), k = h.length - 1; k >= 0; k--)
            Wa(this, h[k]);
          T ? P0(this, T) : this.cm && Ua(this.cm);
        }),
        undo: an(function() {
          Ad(this, "undo");
        }),
        redo: an(function() {
          Ad(this, "redo");
        }),
        undoSelection: an(function() {
          Ad(this, "undo", true);
        }),
        redoSelection: an(function() {
          Ad(this, "redo", true);
        }),
        setExtending: function(o) {
          this.extend = o;
        },
        getExtending: function() {
          return this.extend;
        },
        historySize: function() {
          for (var o = this.history, c = 0, p = 0, h = 0; h < o.done.length; h++)
            o.done[h].ranges || ++c;
          for (var m = 0; m < o.undone.length; m++)
            o.undone[m].ranges || ++p;
          return { undo: c, redo: p };
        },
        clearHistory: function() {
          var o = this;
          this.history = new kd(this.history), os(this, function(c) {
            return c.history = o.history;
          }, true);
        },
        markClean: function() {
          this.cleanGeneration = this.changeGeneration(true);
        },
        changeGeneration: function(o) {
          return o && (this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null), this.history.generation;
        },
        isClean: function(o) {
          return this.history.generation == (o || this.cleanGeneration);
        },
        getHistory: function() {
          return {
            done: Ga(this.history.done),
            undone: Ga(this.history.undone)
          };
        },
        setHistory: function(o) {
          var c = this.history = new kd(this.history);
          c.done = Ga(o.done.slice(0), null, true), c.undone = Ga(o.undone.slice(0), null, true);
        },
        setGutterMarker: an(function(o, c, p) {
          return Dl(this, o, "gutter", function(h) {
            var m = h.gutterMarkers || (h.gutterMarkers = {});
            return m[c] = p, !p && Dt(m) && (h.gutterMarkers = null), true;
          });
        }),
        clearGutter: an(function(o) {
          var c = this;
          this.iter(function(p) {
            p.gutterMarkers && p.gutterMarkers[o] && Dl(c, p, "gutter", function() {
              return p.gutterMarkers[o] = null, Dt(p.gutterMarkers) && (p.gutterMarkers = null), true;
            });
          });
        }),
        lineInfo: function(o) {
          var c;
          if (typeof o == "number") {
            if (!ie(this, o) || (c = o, o = Re(this, o), !o))
              return null;
          } else if (c = M(o), c == null)
            return null;
          return {
            line: c,
            handle: o,
            text: o.text,
            gutterMarkers: o.gutterMarkers,
            textClass: o.textClass,
            bgClass: o.bgClass,
            wrapClass: o.wrapClass,
            widgets: o.widgets
          };
        },
        addLineClass: an(function(o, c, p) {
          return Dl(this, o, c == "gutter" ? "gutter" : "class", function(h) {
            var m = c == "text" ? "textClass" : c == "background" ? "bgClass" : c == "gutter" ? "gutterClass" : "wrapClass";
            if (!h[m])
              h[m] = p;
            else {
              if (j(p).test(h[m]))
                return false;
              h[m] += " " + p;
            }
            return true;
          });
        }),
        removeLineClass: an(function(o, c, p) {
          return Dl(this, o, c == "gutter" ? "gutter" : "class", function(h) {
            var m = c == "text" ? "textClass" : c == "background" ? "bgClass" : c == "gutter" ? "gutterClass" : "wrapClass", S = h[m];
            if (S)
              if (p == null)
                h[m] = null;
              else {
                var x = S.match(j(p));
                if (!x)
                  return false;
                var T = x.index + x[0].length;
                h[m] = S.slice(0, x.index) + (!x.index || T == S.length ? "" : " ") + S.slice(T) || null;
              }
            else
              return false;
            return true;
          });
        }),
        addLineWidget: an(function(o, c, p) {
          return IA(this, o, c, p);
        }),
        removeLineWidget: function(o) {
          o.clear();
        },
        markText: function(o, c, p) {
          return ja(this, He(this, o), He(this, c), p, p && p.type || "range");
        },
        setBookmark: function(o, c) {
          var p = {
            replacedWith: c && (c.nodeType == null ? c.widget : c),
            insertLeft: c && c.insertLeft,
            clearWhenEmpty: false,
            shared: c && c.shared,
            handleMouseEvents: c && c.handleMouseEvents
          };
          return o = He(this, o), ja(this, o, o, p, "bookmark");
        },
        findMarksAt: function(o) {
          o = He(this, o);
          var c = [], p = Re(this, o.line).markedSpans;
          if (p)
            for (var h = 0; h < p.length; ++h) {
              var m = p[h];
              (m.from == null || m.from <= o.ch) && (m.to == null || m.to >= o.ch) && c.push(m.marker.parent || m.marker);
            }
          return c;
        },
        findMarks: function(o, c, p) {
          o = He(this, o), c = He(this, c);
          var h = [], m = o.line;
          return this.iter(o.line, c.line + 1, function(S) {
            var x = S.markedSpans;
            if (x)
              for (var T = 0; T < x.length; T++) {
                var k = x[T];
                !(k.to != null && m == o.line && o.ch >= k.to || k.from == null && m != o.line || k.from != null && m == c.line && k.from >= c.ch) && (!p || p(k.marker)) && h.push(k.marker.parent || k.marker);
              }
            ++m;
          }), h;
        },
        getAllMarks: function() {
          var o = [];
          return this.iter(function(c) {
            var p = c.markedSpans;
            if (p)
              for (var h = 0; h < p.length; ++h)
                p[h].from != null && o.push(p[h].marker);
          }), o;
        },
        posFromIndex: function(o) {
          var c, p = this.first, h = this.lineSeparator().length;
          return this.iter(function(m) {
            var S = m.text.length + h;
            if (S > o)
              return c = o, true;
            o -= S, ++p;
          }), He(this, Q(p, c));
        },
        indexFromPos: function(o) {
          o = He(this, o);
          var c = o.ch;
          if (o.line < this.first || o.ch < 0)
            return 0;
          var p = this.lineSeparator().length;
          return this.iter(this.first, o.line, function(h) {
            c += h.text.length + p;
          }), c;
        },
        copy: function(o) {
          var c = new Vn(
            fl(this, this.first, this.first + this.size),
            this.modeOption,
            this.first,
            this.lineSep,
            this.direction
          );
          return c.scrollTop = this.scrollTop, c.scrollLeft = this.scrollLeft, c.sel = this.sel, c.extend = false, o && (c.history.undoDepth = this.history.undoDepth, c.setHistory(this.getHistory())), c;
        },
        linkedDoc: function(o) {
          o || (o = {});
          var c = this.first, p = this.first + this.size;
          o.from != null && o.from > c && (c = o.from), o.to != null && o.to < p && (p = o.to);
          var h = new Vn(fl(this, c, p), o.mode || this.modeOption, c, this.lineSep, this.direction);
          return o.sharedHist && (h.history = this.history), (this.linked || (this.linked = [])).push({ doc: h, sharedHist: o.sharedHist }), h.linked = [{ doc: this, isParent: true, sharedHist: o.sharedHist }], DA(h, W0(this)), h;
        },
        unlinkDoc: function(o) {
          if (o instanceof At && (o = o.doc), this.linked)
            for (var c = 0; c < this.linked.length; ++c) {
              var p = this.linked[c];
              if (p.doc == o) {
                this.linked.splice(c, 1), o.unlinkDoc(this), PA(W0(this));
                break;
              }
            }
          if (o.history == this.history) {
            var h = [o.id];
            os(o, function(m) {
              return h.push(m.id);
            }, true), o.history = new kd(null), o.history.done = Ga(this.history.done, h), o.history.undone = Ga(this.history.undone, h);
          }
        },
        iterLinkedDocs: function(o) {
          os(this, o);
        },
        getMode: function() {
          return this.mode;
        },
        getEditor: function() {
          return this.cm;
        },
        splitLines: function(o) {
          return this.lineSep ? o.split(this.lineSep) : hi(o);
        },
        lineSeparator: function() {
          return this.lineSep || `
`;
        },
        setDirection: an(function(o) {
          o != "rtl" && (o = "ltr"), o != this.direction && (this.direction = o, this.iter(function(c) {
            return c.order = null;
          }), this.cm && SA(this.cm));
        })
      }), Vn.prototype.eachLine = Vn.prototype.iter;
      var H0 = 0;
      function RA(o) {
        var c = this;
        if (j0(c), !(_t(c, o) || Cr(c.display, o))) {
          Sn(o), d && (H0 = +/* @__PURE__ */ new Date());
          var p = Fs(c, o, true), h = o.dataTransfer.files;
          if (!(!p || c.isReadOnly()))
            if (h && h.length && window.FileReader && window.File)
              for (var m = h.length, S = Array(m), x = 0, T = function() {
                ++x == m && sn(c, function() {
                  p = He(c.doc, p);
                  var Y = {
                    from: p,
                    to: p,
                    text: c.doc.splitLines(
                      S.filter(function(ee) {
                        return ee != null;
                      }).join(c.doc.lineSeparator())
                    ),
                    origin: "paste"
                  };
                  Wa(c.doc, Y), P0(c.doc, ss(He(c.doc, p), He(c.doc, as(Y))));
                })();
              }, k = function(Y, ee) {
                if (c.options.allowDropFileTypes && Pe(c.options.allowDropFileTypes, Y.type) == -1) {
                  T();
                  return;
                }
                var oe = new FileReader();
                oe.onerror = function() {
                  return T();
                }, oe.onload = function() {
                  var fe = oe.result;
                  if (/[\x00-\x08\x0e-\x1f]{2}/.test(fe)) {
                    T();
                    return;
                  }
                  S[ee] = fe, T();
                }, oe.readAsText(Y);
              }, D = 0; D < h.length; D++)
                k(h[D], D);
            else {
              if (c.state.draggingText && c.doc.sel.contains(p) > -1) {
                c.state.draggingText(o), setTimeout(function() {
                  return c.display.input.focus();
                }, 20);
                return;
              }
              try {
                var z = o.dataTransfer.getData("Text");
                if (z) {
                  var W;
                  if (c.state.draggingText && !c.state.draggingText.copy && (W = c.listSelections()), Dd(c.doc, ss(p, p)), W)
                    for (var q = 0; q < W.length; ++q)
                      Ha(c.doc, "", W[q].anchor, W[q].head, "drag");
                  c.replaceSelection(z, "around", "paste"), c.display.input.focus();
                }
              } catch {
              }
            }
        }
      }
      function MA(o, c) {
        if (d && (!o.state.draggingText || +/* @__PURE__ */ new Date() - H0 < 100)) {
          Xr(c);
          return;
        }
        if (!(_t(o, c) || Cr(o.display, c)) && (c.dataTransfer.setData("Text", o.getSelection()), c.dataTransfer.effectAllowed = "copyMove", c.dataTransfer.setDragImage && !C)) {
          var p = F("img", null, null, "position: fixed; left: 0; top: 0;");
          p.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==", w && (p.width = p.height = 1, o.display.wrapper.appendChild(p), p._top = p.offsetTop), c.dataTransfer.setDragImage(p, 0, 0), w && p.parentNode.removeChild(p);
        }
      }
      function NA(o, c) {
        var p = Fs(o, c);
        if (p) {
          var h = document.createDocumentFragment();
          Ff(o, p, h), o.display.dragCursor || (o.display.dragCursor = F("div", null, "CodeMirror-cursors CodeMirror-dragcursors"), o.display.lineSpace.insertBefore(o.display.dragCursor, o.display.cursorDiv)), G(o.display.dragCursor, h);
        }
      }
      function j0(o) {
        o.display.dragCursor && (o.display.lineSpace.removeChild(o.display.dragCursor), o.display.dragCursor = null);
      }
      function J0(o) {
        if (document.getElementsByClassName) {
          for (var c = document.getElementsByClassName("CodeMirror"), p = [], h = 0; h < c.length; h++) {
            var m = c[h].CodeMirror;
            m && p.push(m);
          }
          p.length && p[0].operation(function() {
            for (var S = 0; S < p.length; S++)
              o(p[S]);
          });
        }
      }
      var Y0 = false;
      function _A() {
        Y0 || (OA(), Y0 = true);
      }
      function OA() {
        var o;
        Oe(window, "resize", function() {
          o == null && (o = setTimeout(function() {
            o = null, J0(VA);
          }, 100));
        }), Oe(window, "blur", function() {
          return J0(Fa);
        });
      }
      function VA(o) {
        var c = o.display;
        c.cachedCharWidth = c.cachedTextHeight = c.cachedPaddingH = null, c.scrollbarsClipped = false, o.setSize();
      }
      for (var cs = {
        3: "Pause",
        8: "Backspace",
        9: "Tab",
        13: "Enter",
        16: "Shift",
        17: "Ctrl",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Esc",
        32: "Space",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "Left",
        38: "Up",
        39: "Right",
        40: "Down",
        44: "PrintScrn",
        45: "Insert",
        46: "Delete",
        59: ";",
        61: "=",
        91: "Mod",
        92: "Mod",
        93: "Mod",
        106: "*",
        107: "=",
        109: "-",
        110: ".",
        111: "/",
        145: "ScrollLock",
        173: "-",
        186: ";",
        187: "=",
        188: ",",
        189: "-",
        190: ".",
        191: "/",
        192: "`",
        219: "[",
        220: "\\",
        221: "]",
        222: "'",
        224: "Mod",
        63232: "Up",
        63233: "Down",
        63234: "Left",
        63235: "Right",
        63272: "Delete",
        63273: "Home",
        63275: "End",
        63276: "PageUp",
        63277: "PageDown",
        63302: "Insert"
      }, Nl = 0; Nl < 10; Nl++)
        cs[Nl + 48] = cs[Nl + 96] = String(Nl);
      for (var Rd = 65; Rd <= 90; Rd++)
        cs[Rd] = String.fromCharCode(Rd);
      for (var _l = 1; _l <= 12; _l++)
        cs[_l + 111] = cs[_l + 63235] = "F" + _l;
      var xr = {};
      xr.basic = {
        Left: "goCharLeft",
        Right: "goCharRight",
        Up: "goLineUp",
        Down: "goLineDown",
        End: "goLineEnd",
        Home: "goLineStartSmart",
        PageUp: "goPageUp",
        PageDown: "goPageDown",
        Delete: "delCharAfter",
        Backspace: "delCharBefore",
        "Shift-Backspace": "delCharBefore",
        Tab: "defaultTab",
        "Shift-Tab": "indentAuto",
        Enter: "newlineAndIndent",
        Insert: "toggleOverwrite",
        Esc: "singleSelection"
      }, xr.pcDefault = {
        "Ctrl-A": "selectAll",
        "Ctrl-D": "deleteLine",
        "Ctrl-Z": "undo",
        "Shift-Ctrl-Z": "redo",
        "Ctrl-Y": "redo",
        "Ctrl-Home": "goDocStart",
        "Ctrl-End": "goDocEnd",
        "Ctrl-Up": "goLineUp",
        "Ctrl-Down": "goLineDown",
        "Ctrl-Left": "goGroupLeft",
        "Ctrl-Right": "goGroupRight",
        "Alt-Left": "goLineStart",
        "Alt-Right": "goLineEnd",
        "Ctrl-Backspace": "delGroupBefore",
        "Ctrl-Delete": "delGroupAfter",
        "Ctrl-S": "save",
        "Ctrl-F": "find",
        "Ctrl-G": "findNext",
        "Shift-Ctrl-G": "findPrev",
        "Shift-Ctrl-F": "replace",
        "Shift-Ctrl-R": "replaceAll",
        "Ctrl-[": "indentLess",
        "Ctrl-]": "indentMore",
        "Ctrl-U": "undoSelection",
        "Shift-Ctrl-U": "redoSelection",
        "Alt-U": "redoSelection",
        fallthrough: "basic"
      }, xr.emacsy = {
        "Ctrl-F": "goCharRight",
        "Ctrl-B": "goCharLeft",
        "Ctrl-P": "goLineUp",
        "Ctrl-N": "goLineDown",
        "Ctrl-A": "goLineStart",
        "Ctrl-E": "goLineEnd",
        "Ctrl-V": "goPageDown",
        "Shift-Ctrl-V": "goPageUp",
        "Ctrl-D": "delCharAfter",
        "Ctrl-H": "delCharBefore",
        "Alt-Backspace": "delWordBefore",
        "Ctrl-K": "killLine",
        "Ctrl-T": "transposeChars",
        "Ctrl-O": "openLine"
      }, xr.macDefault = {
        "Cmd-A": "selectAll",
        "Cmd-D": "deleteLine",
        "Cmd-Z": "undo",
        "Shift-Cmd-Z": "redo",
        "Cmd-Y": "redo",
        "Cmd-Home": "goDocStart",
        "Cmd-Up": "goDocStart",
        "Cmd-End": "goDocEnd",
        "Cmd-Down": "goDocEnd",
        "Alt-Left": "goGroupLeft",
        "Alt-Right": "goGroupRight",
        "Cmd-Left": "goLineLeft",
        "Cmd-Right": "goLineRight",
        "Alt-Backspace": "delGroupBefore",
        "Ctrl-Alt-Backspace": "delGroupAfter",
        "Alt-Delete": "delGroupAfter",
        "Cmd-S": "save",
        "Cmd-F": "find",
        "Cmd-G": "findNext",
        "Shift-Cmd-G": "findPrev",
        "Cmd-Alt-F": "replace",
        "Shift-Cmd-Alt-F": "replaceAll",
        "Cmd-[": "indentLess",
        "Cmd-]": "indentMore",
        "Cmd-Backspace": "delWrappedLineLeft",
        "Cmd-Delete": "delWrappedLineRight",
        "Cmd-U": "undoSelection",
        "Shift-Cmd-U": "redoSelection",
        "Ctrl-Up": "goDocStart",
        "Ctrl-Down": "goDocEnd",
        fallthrough: ["basic", "emacsy"]
      }, xr.default = A ? xr.macDefault : xr.pcDefault;
      function BA(o) {
        var c = o.split(/-(?!$)/);
        o = c[c.length - 1];
        for (var p, h, m, S, x = 0; x < c.length - 1; x++) {
          var T = c[x];
          if (/^(cmd|meta|m)$/i.test(T))
            S = true;
          else if (/^a(lt)?$/i.test(T))
            p = true;
          else if (/^(c|ctrl|control)$/i.test(T))
            h = true;
          else if (/^s(hift)?$/i.test(T))
            m = true;
          else
            throw new Error("Unrecognized modifier name: " + T);
        }
        return p && (o = "Alt-" + o), h && (o = "Ctrl-" + o), S && (o = "Cmd-" + o), m && (o = "Shift-" + o), o;
      }
      function FA(o) {
        var c = {};
        for (var p in o)
          if (o.hasOwnProperty(p)) {
            var h = o[p];
            if (/^(name|fallthrough|(de|at)tach)$/.test(p))
              continue;
            if (h == "...") {
              delete o[p];
              continue;
            }
            for (var m = Ge(p.split(" "), BA), S = 0; S < m.length; S++) {
              var x = void 0, T = void 0;
              S == m.length - 1 ? (T = m.join(" "), x = h) : (T = m.slice(0, S + 1).join(" "), x = "...");
              var k = c[T];
              if (!k)
                c[T] = x;
              else if (k != x)
                throw new Error("Inconsistent bindings for " + T);
            }
            delete o[p];
          }
        for (var D in c)
          o[D] = c[D];
        return o;
      }
      function Ja(o, c, p, h) {
        c = Md(c);
        var m = c.call ? c.call(o, h) : c[o];
        if (m === false)
          return "nothing";
        if (m === "...")
          return "multi";
        if (m != null && p(m))
          return "handled";
        if (c.fallthrough) {
          if (Object.prototype.toString.call(c.fallthrough) != "[object Array]")
            return Ja(o, c.fallthrough, p, h);
          for (var S = 0; S < c.fallthrough.length; S++) {
            var x = Ja(o, c.fallthrough[S], p, h);
            if (x)
              return x;
          }
        }
      }
      function q0(o) {
        var c = typeof o == "string" ? o : cs[o.keyCode];
        return c == "Ctrl" || c == "Alt" || c == "Shift" || c == "Mod";
      }
      function K0(o, c, p) {
        var h = o;
        return c.altKey && h != "Alt" && (o = "Alt-" + o), (O ? c.metaKey : c.ctrlKey) && h != "Ctrl" && (o = "Ctrl-" + o), (O ? c.ctrlKey : c.metaKey) && h != "Mod" && (o = "Cmd-" + o), !p && c.shiftKey && h != "Shift" && (o = "Shift-" + o), o;
      }
      function Z0(o, c) {
        if (w && o.keyCode == 34 && o.char)
          return false;
        var p = cs[o.keyCode];
        return p == null || o.altGraphKey ? false : (o.keyCode == 3 && o.code && (p = o.code), K0(p, o, c));
      }
      function Md(o) {
        return typeof o == "string" ? xr[o] : o;
      }
      function Ya(o, c) {
        for (var p = o.doc.sel.ranges, h = [], m = 0; m < p.length; m++) {
          for (var S = c(p[m]); h.length && Se(S.from, me(h).to) <= 0; ) {
            var x = h.pop();
            if (Se(x.from, S.from) < 0) {
              S.from = x.from;
              break;
            }
          }
          h.push(S);
        }
        Yn(o, function() {
          for (var T = h.length - 1; T >= 0; T--)
            Ha(o.doc, "", h[T].from, h[T].to, "+delete");
          Ua(o);
        });
      }
      function np(o, c, p) {
        var h = Rt(o.text, c + p, p);
        return h < 0 || h > o.text.length ? null : h;
      }
      function ip(o, c, p) {
        var h = np(o, c.ch, p);
        return h == null ? null : new Q(c.line, h, p < 0 ? "after" : "before");
      }
      function rp(o, c, p, h, m) {
        if (o) {
          c.doc.direction == "rtl" && (m = -m);
          var S = Qe(p, c.doc.direction);
          if (S) {
            var x = m < 0 ? me(S) : S[0], T = m < 0 == (x.level == 1), k = T ? "after" : "before", D;
            if (x.level > 0 || c.doc.direction == "rtl") {
              var z = Oa(c, p);
              D = m < 0 ? p.text.length - 1 : 0;
              var W = Ki(c, z, D).top;
              D = Pt(function(q) {
                return Ki(c, z, q).top == W;
              }, m < 0 == (x.level == 1) ? x.from : x.to - 1, D), k == "before" && (D = np(p, D, 1));
            } else
              D = m < 0 ? x.to : x.from;
            return new Q(h, D, k);
          }
        }
        return new Q(h, m < 0 ? p.text.length : 0, m < 0 ? "before" : "after");
      }
      function UA(o, c, p, h) {
        var m = Qe(c, o.doc.direction);
        if (!m)
          return ip(c, p, h);
        p.ch >= c.text.length ? (p.ch = c.text.length, p.sticky = "before") : p.ch <= 0 && (p.ch = 0, p.sticky = "after");
        var S = Zr(m, p.ch, p.sticky), x = m[S];
        if (o.doc.direction == "ltr" && x.level % 2 == 0 && (h > 0 ? x.to > p.ch : x.from < p.ch))
          return ip(c, p, h);
        var T = function(ve, xe) {
          return np(c, ve instanceof Q ? ve.ch : ve, xe);
        }, k, D = function(ve) {
          return o.options.lineWrapping ? (k = k || Oa(o, c), n0(o, c, k, ve)) : { begin: 0, end: c.text.length };
        }, z = D(p.sticky == "before" ? T(p, -1) : p.ch);
        if (o.doc.direction == "rtl" || x.level == 1) {
          var W = x.level == 1 == h < 0, q = T(p, W ? 1 : -1);
          if (q != null && (W ? q <= x.to && q <= z.end : q >= x.from && q >= z.begin)) {
            var Y = W ? "before" : "after";
            return new Q(p.line, q, Y);
          }
        }
        var ee = function(ve, xe, ye) {
          for (var ke = function(xt, on) {
            return on ? new Q(p.line, T(xt, 1), "before") : new Q(p.line, xt, "after");
          }; ve >= 0 && ve < m.length; ve += xe) {
            var Ve = m[ve], Ne = xe > 0 == (Ve.level != 1), Ke = Ne ? ye.begin : T(ye.end, -1);
            if (Ve.from <= Ke && Ke < Ve.to || (Ke = Ne ? Ve.from : T(Ve.to, -1), ye.begin <= Ke && Ke < ye.end))
              return ke(Ke, Ne);
          }
        }, oe = ee(S + h, h, z);
        if (oe)
          return oe;
        var fe = h > 0 ? z.end : T(z.begin, -1);
        return fe != null && !(h > 0 && fe == c.text.length) && (oe = ee(h > 0 ? 0 : m.length - 1, h, D(fe)), oe) ? oe : null;
      }
      var Ol = {
        selectAll: _0,
        singleSelection: function(o) {
          return o.setSelection(o.getCursor("anchor"), o.getCursor("head"), tn);
        },
        killLine: function(o) {
          return Ya(o, function(c) {
            if (c.empty()) {
              var p = Re(o.doc, c.head.line).text.length;
              return c.head.ch == p && c.head.line < o.lastLine() ? { from: c.head, to: Q(c.head.line + 1, 0) } : { from: c.head, to: Q(c.head.line, p) };
            } else
              return { from: c.from(), to: c.to() };
          });
        },
        deleteLine: function(o) {
          return Ya(o, function(c) {
            return {
              from: Q(c.from().line, 0),
              to: He(o.doc, Q(c.to().line + 1, 0))
            };
          });
        },
        delLineLeft: function(o) {
          return Ya(o, function(c) {
            return {
              from: Q(c.from().line, 0),
              to: c.from()
            };
          });
        },
        delWrappedLineLeft: function(o) {
          return Ya(o, function(c) {
            var p = o.charCoords(c.head, "div").top + 5, h = o.coordsChar({ left: 0, top: p }, "div");
            return { from: h, to: c.from() };
          });
        },
        delWrappedLineRight: function(o) {
          return Ya(o, function(c) {
            var p = o.charCoords(c.head, "div").top + 5, h = o.coordsChar({ left: o.display.lineDiv.offsetWidth + 100, top: p }, "div");
            return { from: c.from(), to: h };
          });
        },
        undo: function(o) {
          return o.undo();
        },
        redo: function(o) {
          return o.redo();
        },
        undoSelection: function(o) {
          return o.undoSelection();
        },
        redoSelection: function(o) {
          return o.redoSelection();
        },
        goDocStart: function(o) {
          return o.extendSelection(Q(o.firstLine(), 0));
        },
        goDocEnd: function(o) {
          return o.extendSelection(Q(o.lastLine()));
        },
        goLineStart: function(o) {
          return o.extendSelectionsBy(
            function(c) {
              return X0(o, c.head.line);
            },
            { origin: "+move", bias: 1 }
          );
        },
        goLineStartSmart: function(o) {
          return o.extendSelectionsBy(
            function(c) {
              return Q0(o, c.head);
            },
            { origin: "+move", bias: 1 }
          );
        },
        goLineEnd: function(o) {
          return o.extendSelectionsBy(
            function(c) {
              return zA(o, c.head.line);
            },
            { origin: "+move", bias: -1 }
          );
        },
        goLineRight: function(o) {
          return o.extendSelectionsBy(function(c) {
            var p = o.cursorCoords(c.head, "div").top + 5;
            return o.coordsChar({ left: o.display.lineDiv.offsetWidth + 100, top: p }, "div");
          }, ne);
        },
        goLineLeft: function(o) {
          return o.extendSelectionsBy(function(c) {
            var p = o.cursorCoords(c.head, "div").top + 5;
            return o.coordsChar({ left: 0, top: p }, "div");
          }, ne);
        },
        goLineLeftSmart: function(o) {
          return o.extendSelectionsBy(function(c) {
            var p = o.cursorCoords(c.head, "div").top + 5, h = o.coordsChar({ left: 0, top: p }, "div");
            return h.ch < o.getLine(h.line).search(/\S/) ? Q0(o, c.head) : h;
          }, ne);
        },
        goLineUp: function(o) {
          return o.moveV(-1, "line");
        },
        goLineDown: function(o) {
          return o.moveV(1, "line");
        },
        goPageUp: function(o) {
          return o.moveV(-1, "page");
        },
        goPageDown: function(o) {
          return o.moveV(1, "page");
        },
        goCharLeft: function(o) {
          return o.moveH(-1, "char");
        },
        goCharRight: function(o) {
          return o.moveH(1, "char");
        },
        goColumnLeft: function(o) {
          return o.moveH(-1, "column");
        },
        goColumnRight: function(o) {
          return o.moveH(1, "column");
        },
        goWordLeft: function(o) {
          return o.moveH(-1, "word");
        },
        goGroupRight: function(o) {
          return o.moveH(1, "group");
        },
        goGroupLeft: function(o) {
          return o.moveH(-1, "group");
        },
        goWordRight: function(o) {
          return o.moveH(1, "word");
        },
        delCharBefore: function(o) {
          return o.deleteH(-1, "codepoint");
        },
        delCharAfter: function(o) {
          return o.deleteH(1, "char");
        },
        delWordBefore: function(o) {
          return o.deleteH(-1, "word");
        },
        delWordAfter: function(o) {
          return o.deleteH(1, "word");
        },
        delGroupBefore: function(o) {
          return o.deleteH(-1, "group");
        },
        delGroupAfter: function(o) {
          return o.deleteH(1, "group");
        },
        indentAuto: function(o) {
          return o.indentSelection("smart");
        },
        indentMore: function(o) {
          return o.indentSelection("add");
        },
        indentLess: function(o) {
          return o.indentSelection("subtract");
        },
        insertTab: function(o) {
          return o.replaceSelection("	");
        },
        insertSoftTab: function(o) {
          for (var c = [], p = o.listSelections(), h = o.options.tabSize, m = 0; m < p.length; m++) {
            var S = p[m].from(), x = We(o.getLine(S.line), S.ch, h);
            c.push(we(h - x % h));
          }
          o.replaceSelections(c);
        },
        defaultTab: function(o) {
          o.somethingSelected() ? o.indentSelection("add") : o.execCommand("insertTab");
        },
        // Swap the two chars left and right of each selection's head.
        // Move cursor behind the two swapped characters afterwards.
        //
        // Doesn't consider line feeds a character.
        // Doesn't scan more than one line above to find a character.
        // Doesn't do anything on an empty line.
        // Doesn't do anything with non-empty selections.
        transposeChars: function(o) {
          return Yn(o, function() {
            for (var c = o.listSelections(), p = [], h = 0; h < c.length; h++)
              if (c[h].empty()) {
                var m = c[h].head, S = Re(o.doc, m.line).text;
                if (S) {
                  if (m.ch == S.length && (m = new Q(m.line, m.ch - 1)), m.ch > 0)
                    m = new Q(m.line, m.ch + 1), o.replaceRange(
                      S.charAt(m.ch - 1) + S.charAt(m.ch - 2),
                      Q(m.line, m.ch - 2),
                      m,
                      "+transpose"
                    );
                  else if (m.line > o.doc.first) {
                    var x = Re(o.doc, m.line - 1).text;
                    x && (m = new Q(m.line, 1), o.replaceRange(
                      S.charAt(0) + o.doc.lineSeparator() + x.charAt(x.length - 1),
                      Q(m.line - 1, x.length - 1),
                      m,
                      "+transpose"
                    ));
                  }
                }
                p.push(new dt(m, m));
              }
            o.setSelections(p);
          });
        },
        newlineAndIndent: function(o) {
          return Yn(o, function() {
            for (var c = o.listSelections(), p = c.length - 1; p >= 0; p--)
              o.replaceRange(o.doc.lineSeparator(), c[p].anchor, c[p].head, "+input");
            c = o.listSelections();
            for (var h = 0; h < c.length; h++)
              o.indentLine(c[h].from().line, null, true);
            Ua(o);
          });
        },
        openLine: function(o) {
          return o.replaceSelection(`
`, "start");
        },
        toggleOverwrite: function(o) {
          return o.toggleOverwrite();
        }
      };
      function X0(o, c) {
        var p = Re(o.doc, c), h = Ri(p);
        return h != p && (c = M(h)), rp(true, o, h, c, 1);
      }
      function zA(o, c) {
        var p = Re(o.doc, c), h = EP(p);
        return h != p && (c = M(h)), rp(true, o, p, c, -1);
      }
      function Q0(o, c) {
        var p = X0(o, c.line), h = Re(o.doc, p.line), m = Qe(h, o.doc.direction);
        if (!m || m[0].level == 0) {
          var S = Math.max(p.ch, h.text.search(/\S/)), x = c.line == p.line && c.ch <= S && c.ch;
          return Q(p.line, x ? 0 : S, p.sticky);
        }
        return p;
      }
      function Nd(o, c, p) {
        if (typeof c == "string" && (c = Ol[c], !c))
          return false;
        o.display.input.ensurePolled();
        var h = o.display.shift, m = false;
        try {
          o.isReadOnly() && (o.state.suppressEdits = true), p && (o.display.shift = false), m = c(o) != ci;
        } finally {
          o.display.shift = h, o.state.suppressEdits = false;
        }
        return m;
      }
      function GA(o, c, p) {
        for (var h = 0; h < o.state.keyMaps.length; h++) {
          var m = Ja(c, o.state.keyMaps[h], p, o);
          if (m)
            return m;
        }
        return o.options.extraKeys && Ja(c, o.options.extraKeys, p, o) || Ja(c, o.options.keyMap, p, o);
      }
      var $A = new $e();
      function Vl(o, c, p, h) {
        var m = o.state.keySeq;
        if (m) {
          if (q0(c))
            return "handled";
          if (/\'$/.test(c) ? o.state.keySeq = null : $A.set(50, function() {
            o.state.keySeq == m && (o.state.keySeq = null, o.display.input.reset());
          }), eb(o, m + " " + c, p, h))
            return true;
        }
        return eb(o, c, p, h);
      }
      function eb(o, c, p, h) {
        var m = GA(o, c, h);
        return m == "multi" && (o.state.keySeq = c), m == "handled" && rn(o, "keyHandled", o, c, p), (m == "handled" || m == "multi") && (Sn(p), Uf(o)), !!m;
      }
      function tb(o, c) {
        var p = Z0(c, true);
        return p ? c.shiftKey && !o.state.keySeq ? Vl(o, "Shift-" + p, c, function(h) {
          return Nd(o, h, true);
        }) || Vl(o, p, c, function(h) {
          if (typeof h == "string" ? /^go[A-Z]/.test(h) : h.motion)
            return Nd(o, h);
        }) : Vl(o, p, c, function(h) {
          return Nd(o, h);
        }) : false;
      }
      function WA(o, c, p) {
        return Vl(o, "'" + p + "'", c, function(h) {
          return Nd(o, h, true);
        });
      }
      var sp = null;
      function nb(o) {
        var c = this;
        if (!(o.target && o.target != c.display.input.getField()) && (c.curOp.focus = le(rt(c)), !_t(c, o))) {
          d && u < 11 && o.keyCode == 27 && (o.returnValue = false);
          var p = o.keyCode;
          c.display.shift = p == 16 || o.shiftKey;
          var h = tb(c, o);
          w && (sp = h ? p : null, !h && p == 88 && !ld && (A ? o.metaKey : o.ctrlKey) && c.replaceSelection("", null, "cut")), r && !A && !h && p == 46 && o.shiftKey && !o.ctrlKey && document.execCommand && document.execCommand("cut"), p == 18 && !/\bCodeMirror-crosshair\b/.test(c.display.lineDiv.className) && HA(c);
        }
      }
      function HA(o) {
        var c = o.display.lineDiv;
        Te(c, "CodeMirror-crosshair");
        function p(h) {
          (h.keyCode == 18 || !h.altKey) && (U(c, "CodeMirror-crosshair"), yn(document, "keyup", p), yn(document, "mouseover", p));
        }
        Oe(document, "keyup", p), Oe(document, "mouseover", p);
      }
      function ib(o) {
        o.keyCode == 16 && (this.doc.sel.shift = false), _t(this, o);
      }
      function rb(o) {
        var c = this;
        if (!(o.target && o.target != c.display.input.getField()) && !(Cr(c.display, o) || _t(c, o) || o.ctrlKey && !o.altKey || A && o.metaKey)) {
          var p = o.keyCode, h = o.charCode;
          if (w && p == sp) {
            sp = null, Sn(o);
            return;
          }
          if (!(w && (!o.which || o.which < 10) && tb(c, o))) {
            var m = String.fromCharCode(h ?? p);
            m != "\b" && (WA(c, o, m) || c.display.input.onKeyPress(o));
          }
        }
      }
      var jA = 400, ap = function(o, c, p) {
        this.time = o, this.pos = c, this.button = p;
      };
      ap.prototype.compare = function(o, c, p) {
        return this.time + jA > o && Se(c, this.pos) == 0 && p == this.button;
      };
      var Bl, Fl;
      function JA(o, c) {
        var p = +/* @__PURE__ */ new Date();
        return Fl && Fl.compare(p, o, c) ? (Bl = Fl = null, "triple") : Bl && Bl.compare(p, o, c) ? (Fl = new ap(p, o, c), Bl = null, "double") : (Bl = new ap(p, o, c), Fl = null, "single");
      }
      function sb(o) {
        var c = this, p = c.display;
        if (!(_t(c, o) || p.activeTouch && p.input.supportsTouch())) {
          if (p.input.ensurePolled(), p.shift = o.shiftKey, Cr(p, o)) {
            f || (p.scroller.draggable = false, setTimeout(function() {
              return p.scroller.draggable = true;
            }, 100));
            return;
          }
          if (!op(c, o)) {
            var h = Fs(c, o), m = Li(o), S = h ? JA(h, m) : "single";
            Be(c).focus(), m == 1 && c.state.selectingText && c.state.selectingText(o), !(h && YA(c, m, h, S, o)) && (m == 1 ? h ? KA(c, h, S, o) : dl(o) == p.scroller && Sn(o) : m == 2 ? (h && Ld(c.doc, h), setTimeout(function() {
              return p.input.focus();
            }, 20)) : m == 3 && (B ? c.display.input.onContextMenu(o) : zf(c)));
          }
        }
      }
      function YA(o, c, p, h, m) {
        var S = "Click";
        return h == "double" ? S = "Double" + S : h == "triple" && (S = "Triple" + S), S = (c == 1 ? "Left" : c == 2 ? "Middle" : "Right") + S, Vl(o, K0(S, m), m, function(x) {
          if (typeof x == "string" && (x = Ol[x]), !x)
            return false;
          var T = false;
          try {
            o.isReadOnly() && (o.state.suppressEdits = true), T = x(o, p) != ci;
          } finally {
            o.state.suppressEdits = false;
          }
          return T;
        });
      }
      function qA(o, c, p) {
        var h = o.getOption("configureMouse"), m = h ? h(o, c, p) : {};
        if (m.unit == null) {
          var S = I ? p.shiftKey && p.metaKey : p.altKey;
          m.unit = S ? "rectangle" : c == "single" ? "char" : c == "double" ? "word" : "line";
        }
        return (m.extend == null || o.doc.extend) && (m.extend = o.doc.extend || p.shiftKey), m.addNew == null && (m.addNew = A ? p.metaKey : p.ctrlKey), m.moveOnDrag == null && (m.moveOnDrag = !(A ? p.altKey : p.ctrlKey)), m;
      }
      function KA(o, c, p, h) {
        d ? setTimeout(Ae(a0, o), 0) : o.curOp.focus = le(rt(o));
        var m = qA(o, p, h), S = o.doc.sel, x;
        o.options.dragDrop && Sf && !o.isReadOnly() && p == "single" && (x = S.contains(c)) > -1 && (Se((x = S.ranges[x]).from(), c) < 0 || c.xRel > 0) && (Se(x.to(), c) > 0 || c.xRel < 0) ? ZA(o, h, c, m) : XA(o, h, c, m);
      }
      function ZA(o, c, p, h) {
        var m = o.display, S = false, x = sn(o, function(D) {
          f && (m.scroller.draggable = false), o.state.draggingText = false, o.state.delayingBlurEvent && (o.hasFocus() ? o.state.delayingBlurEvent = false : zf(o)), yn(m.wrapper.ownerDocument, "mouseup", x), yn(m.wrapper.ownerDocument, "mousemove", T), yn(m.scroller, "dragstart", k), yn(m.scroller, "drop", x), S || (Sn(D), h.addNew || Ld(o.doc, p, null, null, h.extend), f && !C || d && u == 9 ? setTimeout(function() {
            m.wrapper.ownerDocument.body.focus({ preventScroll: true }), m.input.focus();
          }, 20) : m.input.focus());
        }), T = function(D) {
          S = S || Math.abs(c.clientX - D.clientX) + Math.abs(c.clientY - D.clientY) >= 10;
        }, k = function() {
          return S = true;
        };
        f && (m.scroller.draggable = true), o.state.draggingText = x, x.copy = !h.moveOnDrag, Oe(m.wrapper.ownerDocument, "mouseup", x), Oe(m.wrapper.ownerDocument, "mousemove", T), Oe(m.scroller, "dragstart", k), Oe(m.scroller, "drop", x), o.state.delayingBlurEvent = true, setTimeout(function() {
          return m.input.focus();
        }, 20), m.scroller.dragDrop && m.scroller.dragDrop();
      }
      function ab(o, c, p) {
        if (p == "char")
          return new dt(c, c);
        if (p == "word")
          return o.findWordAt(c);
        if (p == "line")
          return new dt(Q(c.line, 0), He(o.doc, Q(c.line + 1, 0)));
        var h = p(o, c);
        return new dt(h.from, h.to);
      }
      function XA(o, c, p, h) {
        d && zf(o);
        var m = o.display, S = o.doc;
        Sn(c);
        var x, T, k = S.sel, D = k.ranges;
        if (h.addNew && !h.extend ? (T = S.sel.contains(p), T > -1 ? x = D[T] : x = new dt(p, p)) : (x = S.sel.primary(), T = S.sel.primIndex), h.unit == "rectangle")
          h.addNew || (x = new dt(p, p)), p = Fs(o, c, true, true), T = -1;
        else {
          var z = ab(o, p, h.unit);
          h.extend ? x = ep(x, z.anchor, z.head, h.extend) : x = z;
        }
        h.addNew ? T == -1 ? (T = D.length, bn(
          S,
          Ni(o, D.concat([x]), T),
          { scroll: false, origin: "*mouse" }
        )) : D.length > 1 && D[T].empty() && h.unit == "char" && !h.extend ? (bn(
          S,
          Ni(o, D.slice(0, T).concat(D.slice(T + 1)), 0),
          { scroll: false, origin: "*mouse" }
        ), k = S.sel) : tp(S, T, x, X) : (T = 0, bn(S, new ti([x], 0), X), k = S.sel);
        var W = p;
        function q(ye) {
          if (Se(W, ye) != 0)
            if (W = ye, h.unit == "rectangle") {
              for (var ke = [], Ve = o.options.tabSize, Ne = We(Re(S, p.line).text, p.ch, Ve), Ke = We(Re(S, ye.line).text, ye.ch, Ve), xt = Math.min(Ne, Ke), on = Math.max(Ne, Ke), Mt = Math.min(p.line, ye.line), qn = Math.min(o.lastLine(), Math.max(p.line, ye.line)); Mt <= qn; Mt++) {
                var Bn = Re(S, Mt).text, Yt = te(Bn, xt, Ve);
                xt == on ? ke.push(new dt(Q(Mt, Yt), Q(Mt, Yt))) : Bn.length > Yt && ke.push(new dt(Q(Mt, Yt), Q(Mt, te(Bn, on, Ve))));
              }
              ke.length || ke.push(new dt(p, p)), bn(
                S,
                Ni(o, k.ranges.slice(0, T).concat(ke), T),
                { origin: "*mouse", scroll: false }
              ), o.scrollIntoView(ye);
            } else {
              var Fn = x, fn = ab(o, ye, h.unit), Qt = Fn.anchor, qt;
              Se(fn.anchor, Qt) > 0 ? (qt = fn.head, Qt = Ma(Fn.from(), fn.anchor)) : (qt = fn.anchor, Qt = _n(Fn.to(), fn.head));
              var Vt = k.ranges.slice(0);
              Vt[T] = QA(o, new dt(He(S, Qt), qt)), bn(S, Ni(o, Vt, T), X);
            }
        }
        var Y = m.wrapper.getBoundingClientRect(), ee = 0;
        function oe(ye) {
          var ke = ++ee, Ve = Fs(o, ye, true, h.unit == "rectangle");
          if (Ve)
            if (Se(Ve, W) != 0) {
              o.curOp.focus = le(rt(o)), q(Ve);
              var Ne = wd(m, S);
              (Ve.line >= Ne.to || Ve.line < Ne.from) && setTimeout(sn(o, function() {
                ee == ke && oe(ye);
              }), 150);
            } else {
              var Ke = ye.clientY < Y.top ? -20 : ye.clientY > Y.bottom ? 20 : 0;
              Ke && setTimeout(sn(o, function() {
                ee == ke && (m.scroller.scrollTop += Ke, oe(ye));
              }), 50);
            }
        }
        function fe(ye) {
          o.state.selectingText = false, ee = 1 / 0, ye && (Sn(ye), m.input.focus()), yn(m.wrapper.ownerDocument, "mousemove", ve), yn(m.wrapper.ownerDocument, "mouseup", xe), S.history.lastSelOrigin = null;
        }
        var ve = sn(o, function(ye) {
          ye.buttons === 0 || !Li(ye) ? fe(ye) : oe(ye);
        }), xe = sn(o, fe);
        o.state.selectingText = xe, Oe(m.wrapper.ownerDocument, "mousemove", ve), Oe(m.wrapper.ownerDocument, "mouseup", xe);
      }
      function QA(o, c) {
        var p = c.anchor, h = c.head, m = Re(o.doc, p.line);
        if (Se(p, h) == 0 && p.sticky == h.sticky)
          return c;
        var S = Qe(m);
        if (!S)
          return c;
        var x = Zr(S, p.ch, p.sticky), T = S[x];
        if (T.from != p.ch && T.to != p.ch)
          return c;
        var k = x + (T.from == p.ch == (T.level != 1) ? 0 : 1);
        if (k == 0 || k == S.length)
          return c;
        var D;
        if (h.line != p.line)
          D = (h.line - p.line) * (o.doc.direction == "ltr" ? 1 : -1) > 0;
        else {
          var z = Zr(S, h.ch, h.sticky), W = z - x || (h.ch - p.ch) * (T.level == 1 ? -1 : 1);
          z == k - 1 || z == k ? D = W < 0 : D = W > 0;
        }
        var q = S[k + (D ? -1 : 0)], Y = D == (q.level == 1), ee = Y ? q.from : q.to, oe = Y ? "after" : "before";
        return p.ch == ee && p.sticky == oe ? c : new dt(new Q(p.line, ee, oe), h);
      }
      function ob(o, c, p, h) {
        var m, S;
        if (c.touches)
          m = c.touches[0].clientX, S = c.touches[0].clientY;
        else
          try {
            m = c.clientX, S = c.clientY;
          } catch {
            return false;
          }
        if (m >= Math.floor(o.display.gutters.getBoundingClientRect().right))
          return false;
        h && Sn(c);
        var x = o.display, T = x.lineDiv.getBoundingClientRect();
        if (S > T.bottom || !Jn(o, p))
          return Nn(c);
        S -= T.top - x.viewOffset;
        for (var k = 0; k < o.display.gutterSpecs.length; ++k) {
          var D = x.gutters.childNodes[k];
          if (D && D.getBoundingClientRect().right >= m) {
            var z = $(o.doc, S), W = o.display.gutterSpecs[k];
            return Nt(o, p, o, z, W.className, c), Nn(c);
          }
        }
      }
      function op(o, c) {
        return ob(o, c, "gutterClick", true);
      }
      function lb(o, c) {
        Cr(o.display, c) || eR(o, c) || _t(o, c, "contextmenu") || B || o.display.input.onContextMenu(c);
      }
      function eR(o, c) {
        return Jn(o, "gutterContextMenu") ? ob(o, c, "gutterContextMenu", false) : false;
      }
      function cb(o) {
        o.display.wrapper.className = o.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") + o.options.theme.replace(/(^|\s)\s*/g, " cm-s-"), Sl(o);
      }
      var qa = { toString: function() {
        return "CodeMirror.Init";
      } }, db = {}, _d = {};
      function tR(o) {
        var c = o.optionHandlers;
        function p(h, m, S, x) {
          o.defaults[h] = m, S && (c[h] = x ? function(T, k, D) {
            D != qa && S(T, k, D);
          } : S);
        }
        o.defineOption = p, o.Init = qa, p("value", "", function(h, m) {
          return h.setValue(m);
        }, true), p("mode", null, function(h, m) {
          h.doc.modeOption = m, Zf(h);
        }, true), p("indentUnit", 2, Zf, true), p("indentWithTabs", false), p("smartIndent", true), p("tabSize", 4, function(h) {
          Il(h), Sl(h), On(h);
        }, true), p("lineSeparator", null, function(h, m) {
          if (h.doc.lineSep = m, !!m) {
            var S = [], x = h.doc.first;
            h.doc.iter(function(k) {
              for (var D = 0; ; ) {
                var z = k.text.indexOf(m, D);
                if (z == -1)
                  break;
                D = z + m.length, S.push(Q(x, z));
              }
              x++;
            });
            for (var T = S.length - 1; T >= 0; T--)
              Ha(h.doc, m, S[T], Q(S[T].line, S[T].ch + m.length));
          }
        }), p("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b\u200e\u200f\u2028\u2029\u202d\u202e\u2066\u2067\u2069\ufeff\ufff9-\ufffc]/g, function(h, m, S) {
          h.state.specialChars = new RegExp(m.source + (m.test("	") ? "" : "|	"), "g"), S != qa && h.refresh();
        }), p("specialCharPlaceholder", PP, function(h) {
          return h.refresh();
        }, true), p("electricChars", true), p("inputStyle", _ ? "contenteditable" : "textarea", function() {
          throw new Error("inputStyle can not (yet) be changed in a running editor");
        }, true), p("spellcheck", false, function(h, m) {
          return h.getInputField().spellcheck = m;
        }, true), p("autocorrect", false, function(h, m) {
          return h.getInputField().autocorrect = m;
        }, true), p("autocapitalize", false, function(h, m) {
          return h.getInputField().autocapitalize = m;
        }, true), p("rtlMoveVisually", !P), p("wholeLineUpdateBefore", true), p("theme", "default", function(h) {
          cb(h), kl(h);
        }, true), p("keyMap", "default", function(h, m, S) {
          var x = Md(m), T = S != qa && Md(S);
          T && T.detach && T.detach(h, x), x.attach && x.attach(h, T || null);
        }), p("extraKeys", null), p("configureMouse", null), p("lineWrapping", false, iR, true), p("gutters", [], function(h, m) {
          h.display.gutterSpecs = qf(m, h.options.lineNumbers), kl(h);
        }, true), p("fixedGutter", true, function(h, m) {
          h.display.gutters.style.left = m ? Vf(h.display) + "px" : "0", h.refresh();
        }, true), p("coverGutterNextToScrollbar", false, function(h) {
          return za(h);
        }, true), p("scrollbarStyle", "native", function(h) {
          h0(h), za(h), h.display.scrollbars.setScrollTop(h.doc.scrollTop), h.display.scrollbars.setScrollLeft(h.doc.scrollLeft);
        }, true), p("lineNumbers", false, function(h, m) {
          h.display.gutterSpecs = qf(h.options.gutters, m), kl(h);
        }, true), p("firstLineNumber", 1, kl, true), p("lineNumberFormatter", function(h) {
          return h;
        }, kl, true), p("showCursorWhenSelecting", false, bl, true), p("resetSelectionOnContextMenu", true), p("lineWiseCopyCut", true), p("pasteLinesPerSelection", true), p("selectionsMayTouch", false), p("readOnly", false, function(h, m) {
          m == "nocursor" && (Fa(h), h.display.input.blur()), h.display.input.readOnlyChanged(m);
        }), p("screenReaderLabel", null, function(h, m) {
          m = m === "" ? null : m, h.display.input.screenReaderLabelChanged(m);
        }), p("disableInput", false, function(h, m) {
          m || h.display.input.reset();
        }, true), p("dragDrop", true, nR), p("allowDropFileTypes", null), p("cursorBlinkRate", 530), p("cursorScrollMargin", 0), p("cursorHeight", 1, bl, true), p("singleCursorHeightPerLine", true, bl, true), p("workTime", 100), p("workDelay", 100), p("flattenSpans", true, Il, true), p("addModeClass", false, Il, true), p("pollInterval", 100), p("undoDepth", 200, function(h, m) {
          return h.doc.history.undoDepth = m;
        }), p("historyEventDelay", 1250), p("viewportMargin", 10, function(h) {
          return h.refresh();
        }, true), p("maxHighlightLength", 1e4, Il, true), p("moveInputWithCursor", true, function(h, m) {
          m || h.display.input.resetPosition();
        }), p("tabindex", null, function(h, m) {
          return h.display.input.getField().tabIndex = m || "";
        }), p("autofocus", null), p("direction", "ltr", function(h, m) {
          return h.doc.setDirection(m);
        }, true), p("phrases", null);
      }
      function nR(o, c, p) {
        var h = p && p != qa;
        if (!c != !h) {
          var m = o.display.dragFunctions, S = c ? Oe : yn;
          S(o.display.scroller, "dragstart", m.start), S(o.display.scroller, "dragenter", m.enter), S(o.display.scroller, "dragover", m.over), S(o.display.scroller, "dragleave", m.leave), S(o.display.scroller, "drop", m.drop);
        }
      }
      function iR(o) {
        o.options.lineWrapping ? (Te(o.display.wrapper, "CodeMirror-wrap"), o.display.sizer.style.minWidth = "", o.display.sizerWidth = null) : (U(o.display.wrapper, "CodeMirror-wrap"), If(o)), Bf(o), On(o), Sl(o), setTimeout(function() {
          return za(o);
        }, 100);
      }
      function At(o, c) {
        var p = this;
        if (!(this instanceof At))
          return new At(o, c);
        this.options = c = c ? ze(c) : {}, ze(db, c, false);
        var h = c.value;
        typeof h == "string" ? h = new Vn(h, c.mode, null, c.lineSeparator, c.direction) : c.mode && (h.modeOption = c.mode), this.doc = h;
        var m = new At.inputStyles[c.inputStyle](this), S = this.display = new mA(o, h, m, c);
        S.wrapper.CodeMirror = this, cb(this), c.lineWrapping && (this.display.wrapper.className += " CodeMirror-wrap"), h0(this), this.state = {
          keyMaps: [],
          // stores maps added by addKeyMap
          overlays: [],
          // highlighting overlays, as added by addOverlay
          modeGen: 0,
          // bumped when mode/overlay changes, used to invalidate highlighting info
          overwrite: false,
          delayingBlurEvent: false,
          focused: false,
          suppressEdits: false,
          // used to disable editing during key handlers when in readOnly mode
          pasteIncoming: -1,
          cutIncoming: -1,
          // help recognize paste/cut edits in input.poll
          selectingText: false,
          draggingText: false,
          highlight: new $e(),
          // stores highlight worker timeout
          keySeq: null,
          // Unfinished key sequence
          specialChars: null
        }, c.autofocus && !_ && S.input.focus(), d && u < 11 && setTimeout(function() {
          return p.display.input.reset(true);
        }, 20), rR(this), _A(), $s(this), this.curOp.forceUpdate = true, w0(this, h), c.autofocus && !_ || this.hasFocus() ? setTimeout(function() {
          p.hasFocus() && !p.state.focused && Gf(p);
        }, 20) : Fa(this);
        for (var x in _d)
          _d.hasOwnProperty(x) && _d[x](this, c[x], qa);
        g0(this), c.finishInit && c.finishInit(this);
        for (var T = 0; T < lp.length; ++T)
          lp[T](this);
        Ws(this), f && c.lineWrapping && getComputedStyle(S.lineDiv).textRendering == "optimizelegibility" && (S.lineDiv.style.textRendering = "auto");
      }
      At.defaults = db, At.optionHandlers = _d;
      function rR(o) {
        var c = o.display;
        Oe(c.scroller, "mousedown", sn(o, sb)), d && u < 11 ? Oe(c.scroller, "dblclick", sn(o, function(k) {
          if (!_t(o, k)) {
            var D = Fs(o, k);
            if (!(!D || op(o, k) || Cr(o.display, k))) {
              Sn(k);
              var z = o.findWordAt(D);
              Ld(o.doc, z.anchor, z.head);
            }
          }
        })) : Oe(c.scroller, "dblclick", function(k) {
          return _t(o, k) || Sn(k);
        }), Oe(c.scroller, "contextmenu", function(k) {
          return lb(o, k);
        }), Oe(c.input.getField(), "contextmenu", function(k) {
          c.scroller.contains(k.target) || lb(o, k);
        });
        var p, h = { end: 0 };
        function m() {
          c.activeTouch && (p = setTimeout(function() {
            return c.activeTouch = null;
          }, 1e3), h = c.activeTouch, h.end = +/* @__PURE__ */ new Date());
        }
        function S(k) {
          if (k.touches.length != 1)
            return false;
          var D = k.touches[0];
          return D.radiusX <= 1 && D.radiusY <= 1;
        }
        function x(k, D) {
          if (D.left == null)
            return true;
          var z = D.left - k.left, W = D.top - k.top;
          return z * z + W * W > 20 * 20;
        }
        Oe(c.scroller, "touchstart", function(k) {
          if (!_t(o, k) && !S(k) && !op(o, k)) {
            c.input.ensurePolled(), clearTimeout(p);
            var D = +/* @__PURE__ */ new Date();
            c.activeTouch = {
              start: D,
              moved: false,
              prev: D - h.end <= 300 ? h : null
            }, k.touches.length == 1 && (c.activeTouch.left = k.touches[0].pageX, c.activeTouch.top = k.touches[0].pageY);
          }
        }), Oe(c.scroller, "touchmove", function() {
          c.activeTouch && (c.activeTouch.moved = true);
        }), Oe(c.scroller, "touchend", function(k) {
          var D = c.activeTouch;
          if (D && !Cr(c, k) && D.left != null && !D.moved && /* @__PURE__ */ new Date() - D.start < 300) {
            var z = o.coordsChar(c.activeTouch, "page"), W;
            !D.prev || x(D, D.prev) ? W = new dt(z, z) : !D.prev.prev || x(D, D.prev.prev) ? W = o.findWordAt(z) : W = new dt(Q(z.line, 0), He(o.doc, Q(z.line + 1, 0))), o.setSelection(W.anchor, W.head), o.focus(), Sn(k);
          }
          m();
        }), Oe(c.scroller, "touchcancel", m), Oe(c.scroller, "scroll", function() {
          c.scroller.clientHeight && (wl(o, c.scroller.scrollTop), zs(o, c.scroller.scrollLeft, true), Nt(o, "scroll", o));
        }), Oe(c.scroller, "mousewheel", function(k) {
          return y0(o, k);
        }), Oe(c.scroller, "DOMMouseScroll", function(k) {
          return y0(o, k);
        }), Oe(c.wrapper, "scroll", function() {
          return c.wrapper.scrollTop = c.wrapper.scrollLeft = 0;
        }), c.dragFunctions = {
          enter: function(k) {
            _t(o, k) || Xr(k);
          },
          over: function(k) {
            _t(o, k) || (NA(o, k), Xr(k));
          },
          start: function(k) {
            return MA(o, k);
          },
          drop: sn(o, RA),
          leave: function(k) {
            _t(o, k) || j0(o);
          }
        };
        var T = c.input.getField();
        Oe(T, "keyup", function(k) {
          return ib.call(o, k);
        }), Oe(T, "keydown", sn(o, nb)), Oe(T, "keypress", sn(o, rb)), Oe(T, "focus", function(k) {
          return Gf(o, k);
        }), Oe(T, "blur", function(k) {
          return Fa(o, k);
        });
      }
      var lp = [];
      At.defineInitHook = function(o) {
        return lp.push(o);
      };
      function Ul(o, c, p, h) {
        var m = o.doc, S;
        p == null && (p = "add"), p == "smart" && (m.mode.indent ? S = pl(o, c).state : p = "prev");
        var x = o.options.tabSize, T = Re(m, c), k = We(T.text, null, x);
        T.stateAfter && (T.stateAfter = null);
        var D = T.text.match(/^\s*/)[0], z;
        if (!h && !/\S/.test(T.text))
          z = 0, p = "not";
        else if (p == "smart" && (z = m.mode.indent(S, T.text.slice(D.length), T.text), z == ci || z > 150)) {
          if (!h)
            return;
          p = "prev";
        }
        p == "prev" ? c > m.first ? z = We(Re(m, c - 1).text, null, x) : z = 0 : p == "add" ? z = k + o.options.indentUnit : p == "subtract" ? z = k - o.options.indentUnit : typeof p == "number" && (z = k + p), z = Math.max(0, z);
        var W = "", q = 0;
        if (o.options.indentWithTabs)
          for (var Y = Math.floor(z / x); Y; --Y)
            q += x, W += "	";
        if (q < z && (W += we(z - q)), W != D)
          return Ha(m, W, Q(c, 0), Q(c, D.length), "+input"), T.stateAfter = null, true;
        for (var ee = 0; ee < m.sel.ranges.length; ee++) {
          var oe = m.sel.ranges[ee];
          if (oe.head.line == c && oe.head.ch < D.length) {
            var fe = Q(c, D.length);
            tp(m, ee, new dt(fe, fe));
            break;
          }
        }
      }
      var _i = null;
      function Od(o) {
        _i = o;
      }
      function cp(o, c, p, h, m) {
        var S = o.doc;
        o.display.shift = false, h || (h = S.sel);
        var x = +/* @__PURE__ */ new Date() - 200, T = m == "paste" || o.state.pasteIncoming > x, k = hi(c), D = null;
        if (T && h.ranges.length > 1)
          if (_i && _i.text.join(`
`) == c) {
            if (h.ranges.length % _i.text.length == 0) {
              D = [];
              for (var z = 0; z < _i.text.length; z++)
                D.push(S.splitLines(_i.text[z]));
            }
          } else
            k.length == h.ranges.length && o.options.pasteLinesPerSelection && (D = Ge(k, function(ve) {
              return [ve];
            }));
        for (var W = o.curOp.updateInput, q = h.ranges.length - 1; q >= 0; q--) {
          var Y = h.ranges[q], ee = Y.from(), oe = Y.to();
          Y.empty() && (p && p > 0 ? ee = Q(ee.line, ee.ch - p) : o.state.overwrite && !T ? oe = Q(oe.line, Math.min(Re(S, oe.line).text.length, oe.ch + me(k).length)) : T && _i && _i.lineWise && _i.text.join(`
`) == k.join(`
`) && (ee = oe = Q(ee.line, 0)));
          var fe = {
            from: ee,
            to: oe,
            text: D ? D[q % D.length] : k,
            origin: m || (T ? "paste" : o.state.cutIncoming > x ? "cut" : "+input")
          };
          Wa(o.doc, fe), rn(o, "inputRead", o, fe);
        }
        c && !T && hb(o, c), Ua(o), o.curOp.updateInput < 2 && (o.curOp.updateInput = W), o.curOp.typing = true, o.state.pasteIncoming = o.state.cutIncoming = -1;
      }
      function ub(o, c) {
        var p = o.clipboardData && o.clipboardData.getData("Text");
        if (p)
          return o.preventDefault(), !c.isReadOnly() && !c.options.disableInput && c.hasFocus() && Yn(c, function() {
            return cp(c, p, 0, null, "paste");
          }), true;
      }
      function hb(o, c) {
        if (!(!o.options.electricChars || !o.options.smartIndent))
          for (var p = o.doc.sel, h = p.ranges.length - 1; h >= 0; h--) {
            var m = p.ranges[h];
            if (!(m.head.ch > 100 || h && p.ranges[h - 1].head.line == m.head.line)) {
              var S = o.getModeAt(m.head), x = false;
              if (S.electricChars) {
                for (var T = 0; T < S.electricChars.length; T++)
                  if (c.indexOf(S.electricChars.charAt(T)) > -1) {
                    x = Ul(o, m.head.line, "smart");
                    break;
                  }
              } else
                S.electricInput && S.electricInput.test(Re(o.doc, m.head.line).text.slice(0, m.head.ch)) && (x = Ul(o, m.head.line, "smart"));
              x && rn(o, "electricInput", o, m.head.line);
            }
          }
      }
      function fb(o) {
        for (var c = [], p = [], h = 0; h < o.doc.sel.ranges.length; h++) {
          var m = o.doc.sel.ranges[h].head.line, S = { anchor: Q(m, 0), head: Q(m + 1, 0) };
          p.push(S), c.push(o.getRange(S.anchor, S.head));
        }
        return { text: c, ranges: p };
      }
      function dp(o, c, p, h) {
        o.setAttribute("autocorrect", p ? "on" : "off"), o.setAttribute("autocapitalize", h ? "on" : "off"), o.setAttribute("spellcheck", !!c);
      }
      function pb() {
        var o = F("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; min-height: 1em; outline: none"), c = F("div", [o], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
        return f ? o.style.width = "1000px" : o.setAttribute("wrap", "off"), L && (o.style.border = "1px solid black"), c;
      }
      function sR(o) {
        var c = o.optionHandlers, p = o.helpers = {};
        o.prototype = {
          constructor: o,
          focus: function() {
            Be(this).focus(), this.display.input.focus();
          },
          setOption: function(h, m) {
            var S = this.options, x = S[h];
            S[h] == m && h != "mode" || (S[h] = m, c.hasOwnProperty(h) && sn(this, c[h])(this, m, x), Nt(this, "optionChange", this, h));
          },
          getOption: function(h) {
            return this.options[h];
          },
          getDoc: function() {
            return this.doc;
          },
          addKeyMap: function(h, m) {
            this.state.keyMaps[m ? "push" : "unshift"](Md(h));
          },
          removeKeyMap: function(h) {
            for (var m = this.state.keyMaps, S = 0; S < m.length; ++S)
              if (m[S] == h || m[S].name == h)
                return m.splice(S, 1), true;
          },
          addOverlay: En(function(h, m) {
            var S = h.token ? h : o.getMode(this.options, h);
            if (S.startState)
              throw new Error("Overlays may not be stateful.");
            tt(
              this.state.overlays,
              {
                mode: S,
                modeSpec: h,
                opaque: m && m.opaque,
                priority: m && m.priority || 0
              },
              function(x) {
                return x.priority;
              }
            ), this.state.modeGen++, On(this);
          }),
          removeOverlay: En(function(h) {
            for (var m = this.state.overlays, S = 0; S < m.length; ++S) {
              var x = m[S].modeSpec;
              if (x == h || typeof h == "string" && x.name == h) {
                m.splice(S, 1), this.state.modeGen++, On(this);
                return;
              }
            }
          }),
          indentLine: En(function(h, m, S) {
            typeof m != "string" && typeof m != "number" && (m == null ? m = this.options.smartIndent ? "smart" : "prev" : m = m ? "add" : "subtract"), ie(this.doc, h) && Ul(this, h, m, S);
          }),
          indentSelection: En(function(h) {
            for (var m = this.doc.sel.ranges, S = -1, x = 0; x < m.length; x++) {
              var T = m[x];
              if (T.empty())
                T.head.line > S && (Ul(this, T.head.line, h, true), S = T.head.line, x == this.doc.sel.primIndex && Ua(this));
              else {
                var k = T.from(), D = T.to(), z = Math.max(S, k.line);
                S = Math.min(this.lastLine(), D.line - (D.ch ? 0 : 1)) + 1;
                for (var W = z; W < S; ++W)
                  Ul(this, W, h);
                var q = this.doc.sel.ranges;
                k.ch == 0 && m.length == q.length && q[x].from().ch > 0 && tp(this.doc, x, new dt(k, q[x].to()), tn);
              }
            }
          }),
          // Fetch the parser token for a given character. Useful for hacks
          // that want to inspect the mode state (say, for completion).
          getTokenAt: function(h, m) {
            return ES(this, h, m);
          },
          getLineTokens: function(h, m) {
            return ES(this, Q(h), m, true);
          },
          getTokenTypeAt: function(h) {
            h = He(this.doc, h);
            var m = CS(this, Re(this.doc, h.line)), S = 0, x = (m.length - 1) / 2, T = h.ch, k;
            if (T == 0)
              k = m[2];
            else
              for (; ; ) {
                var D = S + x >> 1;
                if ((D ? m[D * 2 - 1] : 0) >= T)
                  x = D;
                else if (m[D * 2 + 1] < T)
                  S = D + 1;
                else {
                  k = m[D * 2 + 2];
                  break;
                }
              }
            var z = k ? k.indexOf("overlay ") : -1;
            return z < 0 ? k : z == 0 ? null : k.slice(0, z - 1);
          },
          getModeAt: function(h) {
            var m = this.doc.mode;
            return m.innerMode ? o.innerMode(m, this.getTokenAt(h).state).mode : m;
          },
          getHelper: function(h, m) {
            return this.getHelpers(h, m)[0];
          },
          getHelpers: function(h, m) {
            var S = [];
            if (!p.hasOwnProperty(m))
              return S;
            var x = p[m], T = this.getModeAt(h);
            if (typeof T[m] == "string")
              x[T[m]] && S.push(x[T[m]]);
            else if (T[m])
              for (var k = 0; k < T[m].length; k++) {
                var D = x[T[m][k]];
                D && S.push(D);
              }
            else
              T.helperType && x[T.helperType] ? S.push(x[T.helperType]) : x[T.name] && S.push(x[T.name]);
            for (var z = 0; z < x._global.length; z++) {
              var W = x._global[z];
              W.pred(T, this) && Pe(S, W.val) == -1 && S.push(W.val);
            }
            return S;
          },
          getStateAfter: function(h, m) {
            var S = this.doc;
            return h = yS(S, h ?? S.first + S.size - 1), pl(this, h + 1, m).state;
          },
          cursorCoords: function(h, m) {
            var S, x = this.doc.sel.primary();
            return h == null ? S = x.head : typeof h == "object" ? S = He(this.doc, h) : S = h ? x.from() : x.to(), Mi(this, S, m || "page");
          },
          charCoords: function(h, m) {
            return yd(this, He(this.doc, h), m || "page");
          },
          coordsChar: function(h, m) {
            return h = QS(this, h, m || "page"), Nf(this, h.left, h.top);
          },
          lineAtHeight: function(h, m) {
            return h = QS(this, { top: h, left: 0 }, m || "page").top, $(this.doc, h + this.display.viewOffset);
          },
          heightAtLine: function(h, m, S) {
            var x = false, T;
            if (typeof h == "number") {
              var k = this.doc.first + this.doc.size - 1;
              h < this.doc.first ? h = this.doc.first : h > k && (h = k, x = true), T = Re(this.doc, h);
            } else
              T = h;
            return vd(this, T, { top: 0, left: 0 }, m || "page", S || x).top + (x ? this.doc.height - br(T) : 0);
          },
          defaultTextHeight: function() {
            return Va(this.display);
          },
          defaultCharWidth: function() {
            return Ba(this.display);
          },
          getViewport: function() {
            return { from: this.display.viewFrom, to: this.display.viewTo };
          },
          addWidget: function(h, m, S, x, T) {
            var k = this.display;
            h = Mi(this, He(this.doc, h));
            var D = h.bottom, z = h.left;
            if (m.style.position = "absolute", m.setAttribute("cm-ignore-events", "true"), this.display.input.setUneditable(m), k.sizer.appendChild(m), x == "over")
              D = h.top;
            else if (x == "above" || x == "near") {
              var W = Math.max(k.wrapper.clientHeight, this.doc.height), q = Math.max(k.sizer.clientWidth, k.lineSpace.clientWidth);
              (x == "above" || h.bottom + m.offsetHeight > W) && h.top > m.offsetHeight ? D = h.top - m.offsetHeight : h.bottom + m.offsetHeight <= W && (D = h.bottom), z + m.offsetWidth > q && (z = q - m.offsetWidth);
            }
            m.style.top = D + "px", m.style.left = m.style.right = "", T == "right" ? (z = k.sizer.clientWidth - m.offsetWidth, m.style.right = "0px") : (T == "left" ? z = 0 : T == "middle" && (z = (k.sizer.clientWidth - m.offsetWidth) / 2), m.style.left = z + "px"), S && nA(this, { left: z, top: D, right: z + m.offsetWidth, bottom: D + m.offsetHeight });
          },
          triggerOnKeyDown: En(nb),
          triggerOnKeyPress: En(rb),
          triggerOnKeyUp: ib,
          triggerOnMouseDown: En(sb),
          execCommand: function(h) {
            if (Ol.hasOwnProperty(h))
              return Ol[h].call(null, this);
          },
          triggerElectric: En(function(h) {
            hb(this, h);
          }),
          findPosH: function(h, m, S, x) {
            var T = 1;
            m < 0 && (T = -1, m = -m);
            for (var k = He(this.doc, h), D = 0; D < m && (k = up(this.doc, k, T, S, x), !k.hitSide); ++D)
              ;
            return k;
          },
          moveH: En(function(h, m) {
            var S = this;
            this.extendSelectionsBy(function(x) {
              return S.display.shift || S.doc.extend || x.empty() ? up(S.doc, x.head, h, m, S.options.rtlMoveVisually) : h < 0 ? x.from() : x.to();
            }, ne);
          }),
          deleteH: En(function(h, m) {
            var S = this.doc.sel, x = this.doc;
            S.somethingSelected() ? x.replaceSelection("", null, "+delete") : Ya(this, function(T) {
              var k = up(x, T.head, h, m, false);
              return h < 0 ? { from: k, to: T.head } : { from: T.head, to: k };
            });
          }),
          findPosV: function(h, m, S, x) {
            var T = 1, k = x;
            m < 0 && (T = -1, m = -m);
            for (var D = He(this.doc, h), z = 0; z < m; ++z) {
              var W = Mi(this, D, "div");
              if (k == null ? k = W.left : W.left = k, D = gb(this, W, T, S), D.hitSide)
                break;
            }
            return D;
          },
          moveV: En(function(h, m) {
            var S = this, x = this.doc, T = [], k = !this.display.shift && !x.extend && x.sel.somethingSelected();
            if (x.extendSelectionsBy(function(z) {
              if (k)
                return h < 0 ? z.from() : z.to();
              var W = Mi(S, z.head, "div");
              z.goalColumn != null && (W.left = z.goalColumn), T.push(W.left);
              var q = gb(S, W, h, m);
              return m == "page" && z == x.sel.primary() && Wf(S, yd(S, q, "div").top - W.top), q;
            }, ne), T.length)
              for (var D = 0; D < x.sel.ranges.length; D++)
                x.sel.ranges[D].goalColumn = T[D];
          }),
          // Find the word at the given position (as returned by coordsChar).
          findWordAt: function(h) {
            var m = this.doc, S = Re(m, h.line).text, x = h.ch, T = h.ch;
            if (S) {
              var k = this.getHelper(h, "wordChars");
              (h.sticky == "before" || T == S.length) && x ? --x : ++T;
              for (var D = S.charAt(x), z = pt(D, k) ? function(W) {
                return pt(W, k);
              } : /\s/.test(D) ? function(W) {
                return /\s/.test(W);
              } : function(W) {
                return !/\s/.test(W) && !pt(W);
              }; x > 0 && z(S.charAt(x - 1)); )
                --x;
              for (; T < S.length && z(S.charAt(T)); )
                ++T;
            }
            return new dt(Q(h.line, x), Q(h.line, T));
          },
          toggleOverwrite: function(h) {
            h != null && h == this.state.overwrite || ((this.state.overwrite = !this.state.overwrite) ? Te(this.display.cursorDiv, "CodeMirror-overwrite") : U(this.display.cursorDiv, "CodeMirror-overwrite"), Nt(this, "overwriteToggle", this, this.state.overwrite));
          },
          hasFocus: function() {
            return this.display.input.getField() == le(rt(this));
          },
          isReadOnly: function() {
            return !!(this.options.readOnly || this.doc.cantEdit);
          },
          scrollTo: En(function(h, m) {
            Cl(this, h, m);
          }),
          getScrollInfo: function() {
            var h = this.display.scroller;
            return {
              left: h.scrollLeft,
              top: h.scrollTop,
              height: h.scrollHeight - qi(this) - this.display.barHeight,
              width: h.scrollWidth - qi(this) - this.display.barWidth,
              clientHeight: Pf(this),
              clientWidth: Vs(this)
            };
          },
          scrollIntoView: En(function(h, m) {
            h == null ? (h = { from: this.doc.sel.primary().head, to: null }, m == null && (m = this.options.cursorScrollMargin)) : typeof h == "number" ? h = { from: Q(h, 0), to: null } : h.from == null && (h = { from: h, to: null }), h.to || (h.to = h.from), h.margin = m || 0, h.from.line != null ? iA(this, h) : l0(this, h.from, h.to, h.margin);
          }),
          setSize: En(function(h, m) {
            var S = this, x = function(k) {
              return typeof k == "number" || /^\d+$/.test(String(k)) ? k + "px" : k;
            };
            h != null && (this.display.wrapper.style.width = x(h)), m != null && (this.display.wrapper.style.height = x(m)), this.options.lineWrapping && KS(this);
            var T = this.display.viewFrom;
            this.doc.iter(T, this.display.viewTo, function(k) {
              if (k.widgets) {
                for (var D = 0; D < k.widgets.length; D++)
                  if (k.widgets[D].noHScroll) {
                    is(S, T, "widget");
                    break;
                  }
              }
              ++T;
            }), this.curOp.forceUpdate = true, Nt(this, "refresh", this);
          }),
          operation: function(h) {
            return Yn(this, h);
          },
          startOperation: function() {
            return $s(this);
          },
          endOperation: function() {
            return Ws(this);
          },
          refresh: En(function() {
            var h = this.display.cachedTextHeight;
            On(this), this.curOp.forceUpdate = true, Sl(this), Cl(this, this.doc.scrollLeft, this.doc.scrollTop), Jf(this.display), (h == null || Math.abs(h - Va(this.display)) > 0.5 || this.options.lineWrapping) && Bf(this), Nt(this, "refresh", this);
          }),
          swapDoc: En(function(h) {
            var m = this.doc;
            return m.cm = null, this.state.selectingText && this.state.selectingText(), w0(this, h), Sl(this), this.display.input.reset(), Cl(this, h.scrollLeft, h.scrollTop), this.curOp.forceScroll = true, rn(this, "swapDoc", this, m), m;
          }),
          phrase: function(h) {
            var m = this.options.phrases;
            return m && Object.prototype.hasOwnProperty.call(m, h) ? m[h] : h;
          },
          getInputField: function() {
            return this.display.input.getField();
          },
          getWrapperElement: function() {
            return this.display.wrapper;
          },
          getScrollerElement: function() {
            return this.display.scroller;
          },
          getGutterElement: function() {
            return this.display.gutters;
          }
        }, Ii(o), o.registerHelper = function(h, m, S) {
          p.hasOwnProperty(h) || (p[h] = o[h] = { _global: [] }), p[h][m] = S;
        }, o.registerGlobalHelper = function(h, m, S, x) {
          o.registerHelper(h, m, x), p[h]._global.push({ pred: S, val: x });
        };
      }
      function up(o, c, p, h, m) {
        var S = c, x = p, T = Re(o, c.line), k = m && o.direction == "rtl" ? -p : p;
        function D() {
          var xe = c.line + k;
          return xe < o.first || xe >= o.first + o.size ? false : (c = new Q(xe, c.ch, c.sticky), T = Re(o, xe));
        }
        function z(xe) {
          var ye;
          if (h == "codepoint") {
            var ke = T.text.charCodeAt(c.ch + (p > 0 ? 0 : -1));
            if (isNaN(ke))
              ye = null;
            else {
              var Ve = p > 0 ? ke >= 55296 && ke < 56320 : ke >= 56320 && ke < 57343;
              ye = new Q(c.line, Math.max(0, Math.min(T.text.length, c.ch + p * (Ve ? 2 : 1))), -p);
            }
          } else
            m ? ye = UA(o.cm, T, c, p) : ye = ip(T, c, p);
          if (ye == null)
            if (!xe && D())
              c = rp(m, o.cm, T, c.line, k);
            else
              return false;
          else
            c = ye;
          return true;
        }
        if (h == "char" || h == "codepoint")
          z();
        else if (h == "column")
          z(true);
        else if (h == "word" || h == "group")
          for (var W = null, q = h == "group", Y = o.cm && o.cm.getHelper(c, "wordChars"), ee = true; !(p < 0 && !z(!ee)); ee = false) {
            var oe = T.text.charAt(c.ch) || `
`, fe = pt(oe, Y) ? "w" : q && oe == `
` ? "n" : !q || /\s/.test(oe) ? null : "p";
            if (q && !ee && !fe && (fe = "s"), W && W != fe) {
              p < 0 && (p = 1, z(), c.sticky = "after");
              break;
            }
            if (fe && (W = fe), p > 0 && !z(!ee))
              break;
          }
        var ve = Pd(o, c, S, x, true);
        return ct(S, ve) && (ve.hitSide = true), ve;
      }
      function gb(o, c, p, h) {
        var m = o.doc, S = c.left, x;
        if (h == "page") {
          var T = Math.min(o.display.wrapper.clientHeight, Be(o).innerHeight || m(o).documentElement.clientHeight), k = Math.max(T - 0.5 * Va(o.display), 3);
          x = (p > 0 ? c.bottom : c.top) + p * k;
        } else
          h == "line" && (x = p > 0 ? c.bottom + 3 : c.top - 3);
        for (var D; D = Nf(o, S, x), !!D.outside; ) {
          if (p < 0 ? x <= 0 : x >= m.height) {
            D.hitSide = true;
            break;
          }
          x += p * 5;
        }
        return D;
      }
      var yt = function(o) {
        this.cm = o, this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null, this.polling = new $e(), this.composing = null, this.gracePeriod = false, this.readDOMTimeout = null;
      };
      yt.prototype.init = function(o) {
        var c = this, p = this, h = p.cm, m = p.div = o.lineDiv;
        m.contentEditable = true, dp(m, h.options.spellcheck, h.options.autocorrect, h.options.autocapitalize);
        function S(T) {
          for (var k = T.target; k; k = k.parentNode) {
            if (k == m)
              return true;
            if (/\bCodeMirror-(?:line)?widget\b/.test(k.className))
              break;
          }
          return false;
        }
        Oe(m, "paste", function(T) {
          !S(T) || _t(h, T) || ub(T, h) || u <= 11 && setTimeout(sn(h, function() {
            return c.updateFromDOM();
          }), 20);
        }), Oe(m, "compositionstart", function(T) {
          c.composing = { data: T.data, done: false };
        }), Oe(m, "compositionupdate", function(T) {
          c.composing || (c.composing = { data: T.data, done: false });
        }), Oe(m, "compositionend", function(T) {
          c.composing && (T.data != c.composing.data && c.readFromDOMSoon(), c.composing.done = true);
        }), Oe(m, "touchstart", function() {
          return p.forceCompositionEnd();
        }), Oe(m, "input", function() {
          c.composing || c.readFromDOMSoon();
        });
        function x(T) {
          if (!(!S(T) || _t(h, T))) {
            if (h.somethingSelected())
              Od({ lineWise: false, text: h.getSelections() }), T.type == "cut" && h.replaceSelection("", null, "cut");
            else if (h.options.lineWiseCopyCut) {
              var k = fb(h);
              Od({ lineWise: true, text: k.text }), T.type == "cut" && h.operation(function() {
                h.setSelections(k.ranges, 0, tn), h.replaceSelection("", null, "cut");
              });
            } else
              return;
            if (T.clipboardData) {
              T.clipboardData.clearData();
              var D = _i.text.join(`
`);
              if (T.clipboardData.setData("Text", D), T.clipboardData.getData("Text") == D) {
                T.preventDefault();
                return;
              }
            }
            var z = pb(), W = z.firstChild;
            dp(W), h.display.lineSpace.insertBefore(z, h.display.lineSpace.firstChild), W.value = _i.text.join(`
`);
            var q = le(Xe(m));
            Ye(W), setTimeout(function() {
              h.display.lineSpace.removeChild(z), q.focus(), q == m && p.showPrimarySelection();
            }, 50);
          }
        }
        Oe(m, "copy", x), Oe(m, "cut", x);
      }, yt.prototype.screenReaderLabelChanged = function(o) {
        o ? this.div.setAttribute("aria-label", o) : this.div.removeAttribute("aria-label");
      }, yt.prototype.prepareSelection = function() {
        var o = s0(this.cm, false);
        return o.focus = le(Xe(this.div)) == this.div, o;
      }, yt.prototype.showSelection = function(o, c) {
        !o || !this.cm.display.view.length || ((o.focus || c) && this.showPrimarySelection(), this.showMultipleSelections(o));
      }, yt.prototype.getSelection = function() {
        return this.cm.display.wrapper.ownerDocument.getSelection();
      }, yt.prototype.showPrimarySelection = function() {
        var o = this.getSelection(), c = this.cm, p = c.doc.sel.primary(), h = p.from(), m = p.to();
        if (c.display.viewTo == c.display.viewFrom || h.line >= c.display.viewTo || m.line < c.display.viewFrom) {
          o.removeAllRanges();
          return;
        }
        var S = Vd(c, o.anchorNode, o.anchorOffset), x = Vd(c, o.focusNode, o.focusOffset);
        if (!(S && !S.bad && x && !x.bad && Se(Ma(S, x), h) == 0 && Se(_n(S, x), m) == 0)) {
          var T = c.display.view, k = h.line >= c.display.viewFrom && mb(c, h) || { node: T[0].measure.map[2], offset: 0 }, D = m.line < c.display.viewTo && mb(c, m);
          if (!D) {
            var z = T[T.length - 1].measure, W = z.maps ? z.maps[z.maps.length - 1] : z.map;
            D = { node: W[W.length - 1], offset: W[W.length - 2] - W[W.length - 3] };
          }
          if (!k || !D) {
            o.removeAllRanges();
            return;
          }
          var q = o.rangeCount && o.getRangeAt(0), Y;
          try {
            Y = ae(k.node, k.offset, D.offset, D.node);
          } catch {
          }
          Y && (!r && c.state.focused ? (o.collapse(k.node, k.offset), Y.collapsed || (o.removeAllRanges(), o.addRange(Y))) : (o.removeAllRanges(), o.addRange(Y)), q && o.anchorNode == null ? o.addRange(q) : r && this.startGracePeriod()), this.rememberSelection();
        }
      }, yt.prototype.startGracePeriod = function() {
        var o = this;
        clearTimeout(this.gracePeriod), this.gracePeriod = setTimeout(function() {
          o.gracePeriod = false, o.selectionChanged() && o.cm.operation(function() {
            return o.cm.curOp.selectionChanged = true;
          });
        }, 20);
      }, yt.prototype.showMultipleSelections = function(o) {
        G(this.cm.display.cursorDiv, o.cursors), G(this.cm.display.selectionDiv, o.selection);
      }, yt.prototype.rememberSelection = function() {
        var o = this.getSelection();
        this.lastAnchorNode = o.anchorNode, this.lastAnchorOffset = o.anchorOffset, this.lastFocusNode = o.focusNode, this.lastFocusOffset = o.focusOffset;
      }, yt.prototype.selectionInEditor = function() {
        var o = this.getSelection();
        if (!o.rangeCount)
          return false;
        var c = o.getRangeAt(0).commonAncestorContainer;
        return Ie(this.div, c);
      }, yt.prototype.focus = function() {
        this.cm.options.readOnly != "nocursor" && ((!this.selectionInEditor() || le(Xe(this.div)) != this.div) && this.showSelection(this.prepareSelection(), true), this.div.focus());
      }, yt.prototype.blur = function() {
        this.div.blur();
      }, yt.prototype.getField = function() {
        return this.div;
      }, yt.prototype.supportsTouch = function() {
        return true;
      }, yt.prototype.receivedFocus = function() {
        var o = this, c = this;
        this.selectionInEditor() ? setTimeout(function() {
          return o.pollSelection();
        }, 20) : Yn(this.cm, function() {
          return c.cm.curOp.selectionChanged = true;
        });
        function p() {
          c.cm.state.focused && (c.pollSelection(), c.polling.set(c.cm.options.pollInterval, p));
        }
        this.polling.set(this.cm.options.pollInterval, p);
      }, yt.prototype.selectionChanged = function() {
        var o = this.getSelection();
        return o.anchorNode != this.lastAnchorNode || o.anchorOffset != this.lastAnchorOffset || o.focusNode != this.lastFocusNode || o.focusOffset != this.lastFocusOffset;
      }, yt.prototype.pollSelection = function() {
        if (!(this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged())) {
          var o = this.getSelection(), c = this.cm;
          if (R && v && this.cm.display.gutterSpecs.length && aR(o.anchorNode)) {
            this.cm.triggerOnKeyDown({ type: "keydown", keyCode: 8, preventDefault: Math.abs }), this.blur(), this.focus();
            return;
          }
          if (!this.composing) {
            this.rememberSelection();
            var p = Vd(c, o.anchorNode, o.anchorOffset), h = Vd(c, o.focusNode, o.focusOffset);
            p && h && Yn(c, function() {
              bn(c.doc, ss(p, h), tn), (p.bad || h.bad) && (c.curOp.selectionChanged = true);
            });
          }
        }
      }, yt.prototype.pollContent = function() {
        this.readDOMTimeout != null && (clearTimeout(this.readDOMTimeout), this.readDOMTimeout = null);
        var o = this.cm, c = o.display, p = o.doc.sel.primary(), h = p.from(), m = p.to();
        if (h.ch == 0 && h.line > o.firstLine() && (h = Q(h.line - 1, Re(o.doc, h.line - 1).length)), m.ch == Re(o.doc, m.line).text.length && m.line < o.lastLine() && (m = Q(m.line + 1, 0)), h.line < c.viewFrom || m.line > c.viewTo - 1)
          return false;
        var S, x, T;
        h.line == c.viewFrom || (S = Us(o, h.line)) == 0 ? (x = M(c.view[0].line), T = c.view[0].node) : (x = M(c.view[S].line), T = c.view[S - 1].node.nextSibling);
        var k = Us(o, m.line), D, z;
        if (k == c.view.length - 1 ? (D = c.viewTo - 1, z = c.lineDiv.lastChild) : (D = M(c.view[k + 1].line) - 1, z = c.view[k + 1].node.previousSibling), !T)
          return false;
        for (var W = o.doc.splitLines(oR(o, T, z, x, D)), q = yr(o.doc, Q(x, 0), Q(D, Re(o.doc, D).text.length)); W.length > 1 && q.length > 1; )
          if (me(W) == me(q))
            W.pop(), q.pop(), D--;
          else if (W[0] == q[0])
            W.shift(), q.shift(), x++;
          else
            break;
        for (var Y = 0, ee = 0, oe = W[0], fe = q[0], ve = Math.min(oe.length, fe.length); Y < ve && oe.charCodeAt(Y) == fe.charCodeAt(Y); )
          ++Y;
        for (var xe = me(W), ye = me(q), ke = Math.min(
          xe.length - (W.length == 1 ? Y : 0),
          ye.length - (q.length == 1 ? Y : 0)
        ); ee < ke && xe.charCodeAt(xe.length - ee - 1) == ye.charCodeAt(ye.length - ee - 1); )
          ++ee;
        if (W.length == 1 && q.length == 1 && x == h.line)
          for (; Y && Y > h.ch && xe.charCodeAt(xe.length - ee - 1) == ye.charCodeAt(ye.length - ee - 1); )
            Y--, ee++;
        W[W.length - 1] = xe.slice(0, xe.length - ee).replace(/^\u200b+/, ""), W[0] = W[0].slice(Y).replace(/\u200b+$/, "");
        var Ve = Q(x, Y), Ne = Q(D, q.length ? me(q).length - ee : 0);
        if (W.length > 1 || W[0] || Se(Ve, Ne))
          return Ha(o.doc, W, Ve, Ne, "+input"), true;
      }, yt.prototype.ensurePolled = function() {
        this.forceCompositionEnd();
      }, yt.prototype.reset = function() {
        this.forceCompositionEnd();
      }, yt.prototype.forceCompositionEnd = function() {
        this.composing && (clearTimeout(this.readDOMTimeout), this.composing = null, this.updateFromDOM(), this.div.blur(), this.div.focus());
      }, yt.prototype.readFromDOMSoon = function() {
        var o = this;
        this.readDOMTimeout == null && (this.readDOMTimeout = setTimeout(function() {
          if (o.readDOMTimeout = null, o.composing)
            if (o.composing.done)
              o.composing = null;
            else
              return;
          o.updateFromDOM();
        }, 80));
      }, yt.prototype.updateFromDOM = function() {
        var o = this;
        (this.cm.isReadOnly() || !this.pollContent()) && Yn(this.cm, function() {
          return On(o.cm);
        });
      }, yt.prototype.setUneditable = function(o) {
        o.contentEditable = "false";
      }, yt.prototype.onKeyPress = function(o) {
        o.charCode == 0 || this.composing || (o.preventDefault(), this.cm.isReadOnly() || sn(this.cm, cp)(this.cm, String.fromCharCode(o.charCode == null ? o.keyCode : o.charCode), 0));
      }, yt.prototype.readOnlyChanged = function(o) {
        this.div.contentEditable = String(o != "nocursor");
      }, yt.prototype.onContextMenu = function() {
      }, yt.prototype.resetPosition = function() {
      }, yt.prototype.needsContentAttribute = true;
      function mb(o, c) {
        var p = Af(o, c.line);
        if (!p || p.hidden)
          return null;
        var h = Re(o.doc, c.line), m = HS(p, h, c.line), S = Qe(h, o.doc.direction), x = "left";
        if (S) {
          var T = Zr(S, c.ch);
          x = T % 2 ? "right" : "left";
        }
        var k = YS(m.map, c.ch, x);
        return k.offset = k.collapse == "right" ? k.end : k.start, k;
      }
      function aR(o) {
        for (var c = o; c; c = c.parentNode)
          if (/CodeMirror-gutter-wrapper/.test(c.className))
            return true;
        return false;
      }
      function Ka(o, c) {
        return c && (o.bad = true), o;
      }
      function oR(o, c, p, h, m) {
        var S = "", x = false, T = o.doc.lineSeparator(), k = false;
        function D(Y) {
          return function(ee) {
            return ee.id == Y;
          };
        }
        function z() {
          x && (S += T, k && (S += T), x = k = false);
        }
        function W(Y) {
          Y && (z(), S += Y);
        }
        function q(Y) {
          if (Y.nodeType == 1) {
            var ee = Y.getAttribute("cm-text");
            if (ee) {
              W(ee);
              return;
            }
            var oe = Y.getAttribute("cm-marker"), fe;
            if (oe) {
              var ve = o.findMarks(Q(h, 0), Q(m + 1, 0), D(+oe));
              ve.length && (fe = ve[0].find(0)) && W(yr(o.doc, fe.from, fe.to).join(T));
              return;
            }
            if (Y.getAttribute("contenteditable") == "false")
              return;
            var xe = /^(pre|div|p|li|table|br)$/i.test(Y.nodeName);
            if (!/^br$/i.test(Y.nodeName) && Y.textContent.length == 0)
              return;
            xe && z();
            for (var ye = 0; ye < Y.childNodes.length; ye++)
              q(Y.childNodes[ye]);
            /^(pre|p)$/i.test(Y.nodeName) && (k = true), xe && (x = true);
          } else
            Y.nodeType == 3 && W(Y.nodeValue.replace(/\u200b/g, "").replace(/\u00a0/g, " "));
        }
        for (; q(c), c != p; )
          c = c.nextSibling, k = false;
        return S;
      }
      function Vd(o, c, p) {
        var h;
        if (c == o.display.lineDiv) {
          if (h = o.display.lineDiv.childNodes[p], !h)
            return Ka(o.clipPos(Q(o.display.viewTo - 1)), true);
          c = null, p = 0;
        } else
          for (h = c; ; h = h.parentNode) {
            if (!h || h == o.display.lineDiv)
              return null;
            if (h.parentNode && h.parentNode == o.display.lineDiv)
              break;
          }
        for (var m = 0; m < o.display.view.length; m++) {
          var S = o.display.view[m];
          if (S.node == h)
            return lR(S, c, p);
        }
      }
      function lR(o, c, p) {
        var h = o.text.firstChild, m = false;
        if (!c || !Ie(h, c))
          return Ka(Q(M(o.line), 0), true);
        if (c == h && (m = true, c = h.childNodes[p], p = 0, !c)) {
          var S = o.rest ? me(o.rest) : o.line;
          return Ka(Q(M(S), S.text.length), m);
        }
        var x = c.nodeType == 3 ? c : null, T = c;
        for (!x && c.childNodes.length == 1 && c.firstChild.nodeType == 3 && (x = c.firstChild, p && (p = x.nodeValue.length)); T.parentNode != h; )
          T = T.parentNode;
        var k = o.measure, D = k.maps;
        function z(fe, ve, xe) {
          for (var ye = -1; ye < (D ? D.length : 0); ye++)
            for (var ke = ye < 0 ? k.map : D[ye], Ve = 0; Ve < ke.length; Ve += 3) {
              var Ne = ke[Ve + 2];
              if (Ne == fe || Ne == ve) {
                var Ke = M(ye < 0 ? o.line : o.rest[ye]), xt = ke[Ve] + xe;
                return (xe < 0 || Ne != fe) && (xt = ke[Ve + (xe ? 1 : 0)]), Q(Ke, xt);
              }
            }
        }
        var W = z(x, T, p);
        if (W)
          return Ka(W, m);
        for (var q = T.nextSibling, Y = x ? x.nodeValue.length - p : 0; q; q = q.nextSibling) {
          if (W = z(q, q.firstChild, 0), W)
            return Ka(Q(W.line, W.ch - Y), m);
          Y += q.textContent.length;
        }
        for (var ee = T.previousSibling, oe = p; ee; ee = ee.previousSibling) {
          if (W = z(ee, ee.firstChild, -1), W)
            return Ka(Q(W.line, W.ch + oe), m);
          oe += ee.textContent.length;
        }
      }
      var $t = function(o) {
        this.cm = o, this.prevInput = "", this.pollingFast = false, this.polling = new $e(), this.hasSelection = false, this.composing = null, this.resetting = false;
      };
      $t.prototype.init = function(o) {
        var c = this, p = this, h = this.cm;
        this.createField(o);
        var m = this.textarea;
        o.wrapper.insertBefore(this.wrapper, o.wrapper.firstChild), L && (m.style.width = "0px"), Oe(m, "input", function() {
          d && u >= 9 && c.hasSelection && (c.hasSelection = null), p.poll();
        }), Oe(m, "paste", function(x) {
          _t(h, x) || ub(x, h) || (h.state.pasteIncoming = +/* @__PURE__ */ new Date(), p.fastPoll());
        });
        function S(x) {
          if (!_t(h, x)) {
            if (h.somethingSelected())
              Od({ lineWise: false, text: h.getSelections() });
            else if (h.options.lineWiseCopyCut) {
              var T = fb(h);
              Od({ lineWise: true, text: T.text }), x.type == "cut" ? h.setSelections(T.ranges, null, tn) : (p.prevInput = "", m.value = T.text.join(`
`), Ye(m));
            } else
              return;
            x.type == "cut" && (h.state.cutIncoming = +/* @__PURE__ */ new Date());
          }
        }
        Oe(m, "cut", S), Oe(m, "copy", S), Oe(o.scroller, "paste", function(x) {
          if (!(Cr(o, x) || _t(h, x))) {
            if (!m.dispatchEvent) {
              h.state.pasteIncoming = +/* @__PURE__ */ new Date(), p.focus();
              return;
            }
            var T = new Event("paste");
            T.clipboardData = x.clipboardData, m.dispatchEvent(T);
          }
        }), Oe(o.lineSpace, "selectstart", function(x) {
          Cr(o, x) || Sn(x);
        }), Oe(m, "compositionstart", function() {
          var x = h.getCursor("from");
          p.composing && p.composing.range.clear(), p.composing = {
            start: x,
            range: h.markText(x, h.getCursor("to"), { className: "CodeMirror-composing" })
          };
        }), Oe(m, "compositionend", function() {
          p.composing && (p.poll(), p.composing.range.clear(), p.composing = null);
        });
      }, $t.prototype.createField = function(o) {
        this.wrapper = pb(), this.textarea = this.wrapper.firstChild;
        var c = this.cm.options;
        dp(this.textarea, c.spellcheck, c.autocorrect, c.autocapitalize);
      }, $t.prototype.screenReaderLabelChanged = function(o) {
        o ? this.textarea.setAttribute("aria-label", o) : this.textarea.removeAttribute("aria-label");
      }, $t.prototype.prepareSelection = function() {
        var o = this.cm, c = o.display, p = o.doc, h = s0(o);
        if (o.options.moveInputWithCursor) {
          var m = Mi(o, p.sel.primary().head, "div"), S = c.wrapper.getBoundingClientRect(), x = c.lineDiv.getBoundingClientRect();
          h.teTop = Math.max(0, Math.min(
            c.wrapper.clientHeight - 10,
            m.top + x.top - S.top
          )), h.teLeft = Math.max(0, Math.min(
            c.wrapper.clientWidth - 10,
            m.left + x.left - S.left
          ));
        }
        return h;
      }, $t.prototype.showSelection = function(o) {
        var c = this.cm, p = c.display;
        G(p.cursorDiv, o.cursors), G(p.selectionDiv, o.selection), o.teTop != null && (this.wrapper.style.top = o.teTop + "px", this.wrapper.style.left = o.teLeft + "px");
      }, $t.prototype.reset = function(o) {
        if (!(this.contextMenuPending || this.composing && o)) {
          var c = this.cm;
          if (this.resetting = true, c.somethingSelected()) {
            this.prevInput = "";
            var p = c.getSelection();
            this.textarea.value = p, c.state.focused && Ye(this.textarea), d && u >= 9 && (this.hasSelection = p);
          } else
            o || (this.prevInput = this.textarea.value = "", d && u >= 9 && (this.hasSelection = null));
          this.resetting = false;
        }
      }, $t.prototype.getField = function() {
        return this.textarea;
      }, $t.prototype.supportsTouch = function() {
        return false;
      }, $t.prototype.focus = function() {
        if (this.cm.options.readOnly != "nocursor" && (!_ || le(Xe(this.textarea)) != this.textarea))
          try {
            this.textarea.focus();
          } catch {
          }
      }, $t.prototype.blur = function() {
        this.textarea.blur();
      }, $t.prototype.resetPosition = function() {
        this.wrapper.style.top = this.wrapper.style.left = 0;
      }, $t.prototype.receivedFocus = function() {
        this.slowPoll();
      }, $t.prototype.slowPoll = function() {
        var o = this;
        this.pollingFast || this.polling.set(this.cm.options.pollInterval, function() {
          o.poll(), o.cm.state.focused && o.slowPoll();
        });
      }, $t.prototype.fastPoll = function() {
        var o = false, c = this;
        c.pollingFast = true;
        function p() {
          var h = c.poll();
          !h && !o ? (o = true, c.polling.set(60, p)) : (c.pollingFast = false, c.slowPoll());
        }
        c.polling.set(20, p);
      }, $t.prototype.poll = function() {
        var o = this, c = this.cm, p = this.textarea, h = this.prevInput;
        if (this.contextMenuPending || this.resetting || !c.state.focused || es(p) && !h && !this.composing || c.isReadOnly() || c.options.disableInput || c.state.keySeq)
          return false;
        var m = p.value;
        if (m == h && !c.somethingSelected())
          return false;
        if (d && u >= 9 && this.hasSelection === m || A && /[\uf700-\uf7ff]/.test(m))
          return c.display.input.reset(), false;
        if (c.doc.sel == c.display.selForContextMenu) {
          var S = m.charCodeAt(0);
          if (S == 8203 && !h && (h = "​"), S == 8666)
            return this.reset(), this.cm.execCommand("undo");
        }
        for (var x = 0, T = Math.min(h.length, m.length); x < T && h.charCodeAt(x) == m.charCodeAt(x); )
          ++x;
        return Yn(c, function() {
          cp(
            c,
            m.slice(x),
            h.length - x,
            null,
            o.composing ? "*compose" : null
          ), m.length > 1e3 || m.indexOf(`
`) > -1 ? p.value = o.prevInput = "" : o.prevInput = m, o.composing && (o.composing.range.clear(), o.composing.range = c.markText(
            o.composing.start,
            c.getCursor("to"),
            { className: "CodeMirror-composing" }
          ));
        }), true;
      }, $t.prototype.ensurePolled = function() {
        this.pollingFast && this.poll() && (this.pollingFast = false);
      }, $t.prototype.onKeyPress = function() {
        d && u >= 9 && (this.hasSelection = null), this.fastPoll();
      }, $t.prototype.onContextMenu = function(o) {
        var c = this, p = c.cm, h = p.display, m = c.textarea;
        c.contextMenuPending && c.contextMenuPending();
        var S = Fs(p, o), x = h.scroller.scrollTop;
        if (!S || w)
          return;
        var T = p.options.resetSelectionOnContextMenu;
        T && p.doc.sel.contains(S) == -1 && sn(p, bn)(p.doc, ss(S), tn);
        var k = m.style.cssText, D = c.wrapper.style.cssText, z = c.wrapper.offsetParent.getBoundingClientRect();
        c.wrapper.style.cssText = "position: static", m.style.cssText = `position: absolute; width: 30px; height: 30px;
      top: ` + (o.clientY - z.top - 5) + "px; left: " + (o.clientX - z.left - 5) + `px;
      z-index: 1000; background: ` + (d ? "rgba(255, 255, 255, .05)" : "transparent") + `;
      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);`;
        var W;
        f && (W = m.ownerDocument.defaultView.scrollY), h.input.focus(), f && m.ownerDocument.defaultView.scrollTo(null, W), h.input.reset(), p.somethingSelected() || (m.value = c.prevInput = " "), c.contextMenuPending = Y, h.selForContextMenu = p.doc.sel, clearTimeout(h.detectingSelectAll);
        function q() {
          if (m.selectionStart != null) {
            var oe = p.somethingSelected(), fe = "​" + (oe ? m.value : "");
            m.value = "⇚", m.value = fe, c.prevInput = oe ? "" : "​", m.selectionStart = 1, m.selectionEnd = fe.length, h.selForContextMenu = p.doc.sel;
          }
        }
        function Y() {
          if (c.contextMenuPending == Y && (c.contextMenuPending = false, c.wrapper.style.cssText = D, m.style.cssText = k, d && u < 9 && h.scrollbars.setScrollTop(h.scroller.scrollTop = x), m.selectionStart != null)) {
            (!d || d && u < 9) && q();
            var oe = 0, fe = function() {
              h.selForContextMenu == p.doc.sel && m.selectionStart == 0 && m.selectionEnd > 0 && c.prevInput == "​" ? sn(p, _0)(p) : oe++ < 10 ? h.detectingSelectAll = setTimeout(fe, 500) : (h.selForContextMenu = null, h.input.reset());
            };
            h.detectingSelectAll = setTimeout(fe, 200);
          }
        }
        if (d && u >= 9 && q(), B) {
          Xr(o);
          var ee = function() {
            yn(window, "mouseup", ee), setTimeout(Y, 20);
          };
          Oe(window, "mouseup", ee);
        } else
          setTimeout(Y, 50);
      }, $t.prototype.readOnlyChanged = function(o) {
        o || this.reset(), this.textarea.disabled = o == "nocursor", this.textarea.readOnly = !!o;
      }, $t.prototype.setUneditable = function() {
      }, $t.prototype.needsContentAttribute = false;
      function cR(o, c) {
        if (c = c ? ze(c) : {}, c.value = o.value, !c.tabindex && o.tabIndex && (c.tabindex = o.tabIndex), !c.placeholder && o.placeholder && (c.placeholder = o.placeholder), c.autofocus == null) {
          var p = le(Xe(o));
          c.autofocus = p == o || o.getAttribute("autofocus") != null && p == document.body;
        }
        function h() {
          o.value = T.getValue();
        }
        var m;
        if (o.form && (Oe(o.form, "submit", h), !c.leaveSubmitMethodAlone)) {
          var S = o.form;
          m = S.submit;
          try {
            var x = S.submit = function() {
              h(), S.submit = m, S.submit(), S.submit = x;
            };
          } catch {
          }
        }
        c.finishInit = function(k) {
          k.save = h, k.getTextArea = function() {
            return o;
          }, k.toTextArea = function() {
            k.toTextArea = isNaN, h(), o.parentNode.removeChild(k.getWrapperElement()), o.style.display = "", o.form && (yn(o.form, "submit", h), !c.leaveSubmitMethodAlone && typeof o.form.submit == "function" && (o.form.submit = m));
          };
        }, o.style.display = "none";
        var T = At(
          function(k) {
            return o.parentNode.insertBefore(k, o.nextSibling);
          },
          c
        );
        return T;
      }
      function dR(o) {
        o.off = yn, o.on = Oe, o.wheelEventPixels = vA, o.Doc = Vn, o.splitLines = hi, o.countColumn = We, o.findColumn = te, o.isWordChar = zt, o.Pass = ci, o.signal = Nt, o.Line = Na, o.changeEnd = as, o.scrollbarModel = u0, o.Pos = Q, o.cmpPos = Se, o.modes = La, o.mimeModes = Pi, o.resolveMode = Da, o.getMode = Pa, o.modeExtensions = ts, o.extendMode = Aa, o.copyState = Ji, o.startState = Ra, o.innerMode = hl2, o.commands = Ol, o.keyMap = xr, o.keyName = Z0, o.isModifierKey = q0, o.lookupKey = Ja, o.normalizeKeyMap = FA, o.StringStream = Ot, o.SharedTextMarker = Ml, o.TextMarker = ls, o.LineWidget = Rl, o.e_preventDefault = Sn, o.e_stopPropagation = ka, o.e_stop = Xr, o.addClass = Te, o.contains = Ie, o.rmClass = U, o.keyNames = cs;
      }
      tR(At), sR(At);
      var uR = "iter insert remove copy getEditor constructor".split(" ");
      for (var Bd in Vn.prototype)
        Vn.prototype.hasOwnProperty(Bd) && Pe(uR, Bd) < 0 && (At.prototype[Bd] = /* @__PURE__ */ function(o) {
          return function() {
            return o.apply(this.doc, arguments);
          };
        }(Vn.prototype[Bd]));
      return Ii(Vn), At.inputStyles = { textarea: $t, contenteditable: yt }, At.defineMode = function(o) {
        !At.defaults.mode && o != "null" && (At.defaults.mode = o), Ai.apply(this, arguments);
      }, At.defineMIME = Os, At.defineMode("null", function() {
        return { token: function(o) {
          return o.skipToEnd();
        } };
      }), At.defineMIME("text/plain", "null"), At.defineExtension = function(o, c) {
        At.prototype[o] = c;
      }, At.defineDocExtension = function(o, c) {
        Vn.prototype[o] = c;
      }, At.fromTextArea = cR, dR(At), At.version = "5.65.18", At;
    });
  }(sg)), sg.exports;
}
(function(n, e) {
  (function(t) {
    t(sl());
  })(function(t) {
    t.defineMode("javascript", function(i, r) {
      var s = i.indentUnit, a = r.statementIndent, l = r.jsonld, d = r.json || l, u = r.trackScope !== false, f = r.typescript, g = r.wordCharacters || /[\w$\xa1-\uffff]/, v = function() {
        function M(nn) {
          return { type: nn, style: "keyword" };
        }
        var $ = M("keyword a"), ie = M("keyword b"), he = M("keyword c"), Q = M("keyword d"), Se = M("operator"), ct = { type: "atom", style: "atom" };
        return {
          if: M("if"),
          while: $,
          with: $,
          else: ie,
          do: ie,
          try: ie,
          finally: ie,
          return: Q,
          break: Q,
          continue: Q,
          new: M("new"),
          delete: he,
          void: he,
          throw: he,
          debugger: M("debugger"),
          var: M("var"),
          const: M("var"),
          let: M("var"),
          function: M("function"),
          catch: M("catch"),
          for: M("for"),
          switch: M("switch"),
          case: M("case"),
          default: M("default"),
          in: Se,
          typeof: Se,
          instanceof: Se,
          true: ct,
          false: ct,
          null: ct,
          undefined: ct,
          NaN: ct,
          Infinity: ct,
          this: M("this"),
          class: M("class"),
          super: M("atom"),
          yield: he,
          export: M("export"),
          import: M("import"),
          extends: he,
          await: he
        };
      }(), y = /[+\-*&%=<>!?|~^@]/, w = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/;
      function C(M) {
        for (var $ = false, ie, he = false; (ie = M.next()) != null; ) {
          if (!$) {
            if (ie == "/" && !he)
              return;
            ie == "[" ? he = true : he && ie == "]" && (he = false);
          }
          $ = !$ && ie == "\\";
        }
      }
      var b, E;
      function L(M, $, ie) {
        return b = M, E = ie, $;
      }
      function R(M, $) {
        var ie = M.next();
        if (ie == '"' || ie == "'")
          return $.tokenize = _(ie), $.tokenize(M, $);
        if (ie == "." && M.match(/^\d[\d_]*(?:[eE][+\-]?[\d_]+)?/))
          return L("number", "number");
        if (ie == "." && M.match(".."))
          return L("spread", "meta");
        if (/[\[\]{}\(\),;\:\.]/.test(ie))
          return L(ie);
        if (ie == "=" && M.eat(">"))
          return L("=>", "operator");
        if (ie == "0" && M.match(/^(?:x[\dA-Fa-f_]+|o[0-7_]+|b[01_]+)n?/))
          return L("number", "number");
        if (/\d/.test(ie))
          return M.match(/^[\d_]*(?:n|(?:\.[\d_]*)?(?:[eE][+\-]?[\d_]+)?)?/), L("number", "number");
        if (ie == "/")
          return M.eat("*") ? ($.tokenize = A, A(M, $)) : M.eat("/") ? (M.skipToEnd(), L("comment", "comment")) : ei(M, $, 1) ? (C(M), M.match(/^\b(([gimyus])(?![gimyus]*\2))+\b/), L("regexp", "string-2")) : (M.eat("="), L("operator", "operator", M.current()));
        if (ie == "`")
          return $.tokenize = I, I(M, $);
        if (ie == "#" && M.peek() == "!")
          return M.skipToEnd(), L("meta", "meta");
        if (ie == "#" && M.eatWhile(g))
          return L("variable", "property");
        if (ie == "<" && M.match("!--") || ie == "-" && M.match("->") && !/\S/.test(M.string.slice(0, M.start)))
          return M.skipToEnd(), L("comment", "comment");
        if (y.test(ie))
          return (ie != ">" || !$.lexical || $.lexical.type != ">") && (M.eat("=") ? (ie == "!" || ie == "=") && M.eat("=") : /[<>*+\-|&?]/.test(ie) && (M.eat(ie), ie == ">" && M.eat(ie))), ie == "?" && M.eat(".") ? L(".") : L("operator", "operator", M.current());
        if (g.test(ie)) {
          M.eatWhile(g);
          var he = M.current();
          if ($.lastType != ".") {
            if (v.propertyIsEnumerable(he)) {
              var Q = v[he];
              return L(Q.type, Q.style, he);
            }
            if (he == "async" && M.match(/^(\s|\/\*([^*]|\*(?!\/))*?\*\/)*[\[\(\w]/, false))
              return L("async", "keyword", he);
          }
          return L("variable", "variable", he);
        }
      }
      function _(M) {
        return function($, ie) {
          var he = false, Q;
          if (l && $.peek() == "@" && $.match(w))
            return ie.tokenize = R, L("jsonld-keyword", "meta");
          for (; (Q = $.next()) != null && !(Q == M && !he); )
            he = !he && Q == "\\";
          return he || (ie.tokenize = R), L("string", "string");
        };
      }
      function A(M, $) {
        for (var ie = false, he; he = M.next(); ) {
          if (he == "/" && ie) {
            $.tokenize = R;
            break;
          }
          ie = he == "*";
        }
        return L("comment", "comment");
      }
      function I(M, $) {
        for (var ie = false, he; (he = M.next()) != null; ) {
          if (!ie && (he == "`" || he == "$" && M.eat("{"))) {
            $.tokenize = R;
            break;
          }
          ie = !ie && he == "\\";
        }
        return L("quasi", "string-2", M.current());
      }
      var P = "([{}])";
      function N(M, $) {
        $.fatArrowAt && ($.fatArrowAt = null);
        var ie = M.string.indexOf("=>", M.start);
        if (!(ie < 0)) {
          if (f) {
            var he = /:\s*(?:\w+(?:<[^>]*>|\[\])?|\{[^}]*\})\s*$/.exec(M.string.slice(M.start, ie));
            he && (ie = he.index);
          }
          for (var Q = 0, Se = false, ct = ie - 1; ct >= 0; --ct) {
            var nn = M.string.charAt(ct), _n = P.indexOf(nn);
            if (_n >= 0 && _n < 3) {
              if (!Q) {
                ++ct;
                break;
              }
              if (--Q == 0) {
                nn == "(" && (Se = true);
                break;
              }
            } else if (_n >= 3 && _n < 6)
              ++Q;
            else if (g.test(nn))
              Se = true;
            else if (/["'\/`]/.test(nn))
              for (; ; --ct) {
                if (ct == 0)
                  return;
                var Ma = M.string.charAt(ct - 1);
                if (Ma == nn && M.string.charAt(ct - 2) != "\\") {
                  ct--;
                  break;
                }
              }
            else if (Se && !Q) {
              ++ct;
              break;
            }
          }
          Se && !Q && ($.fatArrowAt = ct);
        }
      }
      var O = {
        atom: true,
        number: true,
        variable: true,
        string: true,
        regexp: true,
        this: true,
        import: true,
        "jsonld-keyword": true
      };
      function B(M, $, ie, he, Q, Se) {
        this.indented = M, this.column = $, this.type = ie, this.prev = Q, this.info = Se, he != null && (this.align = he);
      }
      function j(M, $) {
        if (!u)
          return false;
        for (var ie = M.localVars; ie; ie = ie.next)
          if (ie.name == $)
            return true;
        for (var he = M.context; he; he = he.prev)
          for (var ie = he.vars; ie; ie = ie.next)
            if (ie.name == $)
              return true;
      }
      function U(M, $, ie, he, Q) {
        var Se = M.cc;
        for (V.state = M, V.stream = Q, V.marked = null, V.cc = Se, V.style = $, M.lexical.hasOwnProperty("align") || (M.lexical.align = true); ; ) {
          var ct = Se.length ? Se.pop() : d ? Pe : We;
          if (ct(ie, he)) {
            for (; Se.length && Se[Se.length - 1].lex; )
              Se.pop()();
            return V.marked ? V.marked : ie == "variable" && j(M, he) ? "variable-2" : $;
          }
        }
      }
      var V = { state: null, column: null, marked: null, cc: null };
      function G() {
        for (var M = arguments.length - 1; M >= 0; M--)
          V.cc.push(arguments[M]);
      }
      function F() {
        return G.apply(null, arguments), true;
      }
      function ue(M, $) {
        for (var ie = $; ie; ie = ie.next)
          if (ie.name == M)
            return true;
        return false;
      }
      function ae(M) {
        var $ = V.state;
        if (V.marked = "def", !!u) {
          if ($.context) {
            if ($.lexical.info == "var" && $.context && $.context.block) {
              var ie = Ie(M, $.context);
              if (ie != null) {
                $.context = ie;
                return;
              }
            } else if (!ue(M, $.localVars)) {
              $.localVars = new Ue(M, $.localVars);
              return;
            }
          }
          r.globalVars && !ue(M, $.globalVars) && ($.globalVars = new Ue(M, $.globalVars));
        }
      }
      function Ie(M, $) {
        if ($)
          if ($.block) {
            var ie = Ie(M, $.prev);
            return ie ? ie == $.prev ? $ : new Te(ie, $.vars, true) : null;
          } else
            return ue(M, $.vars) ? $ : new Te($.prev, new Ue(M, $.vars), false);
        else
          return null;
      }
      function le(M) {
        return M == "public" || M == "private" || M == "protected" || M == "abstract" || M == "readonly";
      }
      function Te(M, $, ie) {
        this.prev = M, this.vars = $, this.block = ie;
      }
      function Ue(M, $) {
        this.name = M, this.next = $;
      }
      var Ye = new Ue("this", new Ue("arguments", null));
      function Ze() {
        V.state.context = new Te(V.state.context, V.state.localVars, false), V.state.localVars = Ye;
      }
      function rt() {
        V.state.context = new Te(V.state.context, V.state.localVars, true), V.state.localVars = null;
      }
      Ze.lex = rt.lex = true;
      function Xe() {
        V.state.localVars = V.state.context.vars, V.state.context = V.state.context.prev;
      }
      Xe.lex = true;
      function Be(M, $) {
        var ie = function() {
          var he = V.state, Q = he.indented;
          if (he.lexical.type == "stat")
            Q = he.lexical.indented;
          else
            for (var Se = he.lexical; Se && Se.type == ")" && Se.align; Se = Se.prev)
              Q = Se.indented;
          he.lexical = new B(Q, V.stream.column(), M, null, he.lexical, $);
        };
        return ie.lex = true, ie;
      }
      function Ae() {
        var M = V.state;
        M.lexical.prev && (M.lexical.type == ")" && (M.indented = M.lexical.indented), M.lexical = M.lexical.prev);
      }
      Ae.lex = true;
      function ze(M) {
        function $(ie) {
          return ie == M ? F() : M == ";" || ie == "}" || ie == ")" || ie == "]" ? G() : F($);
        }
        return $;
      }
      function We(M, $) {
        return M == "var" ? F(Be("vardef", $), ka, ze(";"), Ae) : M == "keyword a" ? F(Be("form"), ci, We, Ae) : M == "keyword b" ? F(Be("form"), We, Ae) : M == "keyword d" ? V.stream.match(/^\s*$/, false) ? F() : F(Be("stat"), X, ze(";"), Ae) : M == "debugger" ? F(ze(";")) : M == "{" ? F(Be("}"), rt, Pt, Ae, Xe) : M == ";" ? F() : M == "if" ? (V.state.lexical.info == "else" && V.state.cc[V.state.cc.length - 1] == Ae && V.state.cc.pop()(), F(Be("form"), ci, We, Ae, Ia)) : M == "function" ? F(hi) : M == "for" ? F(Be("form"), rt, od, We, Xe, Ae) : M == "class" || f && $ == "interface" ? (V.marked = "keyword", F(Be("form", M == "class" ? M : $), La, Ae)) : M == "variable" ? f && $ == "declare" ? (V.marked = "keyword", F(We)) : f && ($ == "module" || $ == "enum" || $ == "type") && V.stream.match(/^\s*\w/, false) ? (V.marked = "keyword", $ == "enum" ? F(Re) : $ == "type" ? F(ld, ze("operator"), Qe, ze(";")) : F(Be("form"), Nn, ze("{"), Be("}"), Pt, Ae, Ae)) : f && $ == "namespace" ? (V.marked = "keyword", F(Be("form"), Pe, We, Ae)) : f && $ == "abstract" ? (V.marked = "keyword", F(We)) : F(Be("stat"), st) : M == "switch" ? F(
          Be("form"),
          ci,
          ze("{"),
          Be("}", "switch"),
          rt,
          Pt,
          Ae,
          Ae,
          Xe
        ) : M == "case" ? F(Pe, ze(":")) : M == "default" ? F(ze(":")) : M == "catch" ? F(Be("form"), Ze, $e, We, Ae, Xe) : M == "export" ? F(Be("stat"), Da, Ae) : M == "import" ? F(Be("stat"), ts, Ae) : M == "async" ? F(We) : $ == "@" ? F(Pe, We) : G(Be("stat"), Pe, ze(";"), Ae);
      }
      function $e(M) {
        if (M == "(")
          return F(Di, ze(")"));
      }
      function Pe(M, $) {
        return tn(M, $, false);
      }
      function bt(M, $) {
        return tn(M, $, true);
      }
      function ci(M) {
        return M != "(" ? G() : F(Be(")"), X, ze(")"), Ae);
      }
      function tn(M, $, ie) {
        if (V.state.fatArrowAt == V.stream.start) {
          var he = ie ? Ge : me;
          if (M == "(")
            return F(Ze, Be(")"), qe(Di, ")"), Ae, ze("=>"), he, Xe);
          if (M == "variable")
            return G(Ze, Nn, ze("=>"), he, Xe);
        }
        var Q = ie ? te : ne;
        return O.hasOwnProperty(M) ? F(Q) : M == "function" ? F(hi, Q) : M == "class" || f && $ == "interface" ? (V.marked = "keyword", F(Be("form"), bf, Ae)) : M == "keyword c" || M == "async" ? F(ie ? bt : Pe) : M == "(" ? F(Be(")"), X, ze(")"), Ae, Q) : M == "operator" || M == "spread" ? F(ie ? bt : Pe) : M == "[" ? F(Be("]"), Ot, Ae, Q) : M == "{" ? Rt(pt, "}", null, Q) : M == "quasi" ? G(ge, Q) : M == "new" ? F(tt(ie)) : F();
      }
      function X(M) {
        return M.match(/[;\}\)\],]/) ? G() : G(Pe);
      }
      function ne(M, $) {
        return M == "," ? F(X) : te(M, $, false);
      }
      function te(M, $, ie) {
        var he = ie == false ? ne : te, Q = ie == false ? Pe : bt;
        if (M == "=>")
          return F(Ze, ie ? Ge : me, Xe);
        if (M == "operator")
          return /\+\+|--/.test($) || f && $ == "!" ? F(he) : f && $ == "<" && V.stream.match(/^([^<>]|<[^<>]*>)*>\s*\(/, false) ? F(Be(">"), qe(Qe, ">"), Ae, he) : $ == "?" ? F(Pe, ze(":"), Q) : F(Q);
        if (M == "quasi")
          return G(ge, he);
        if (M != ";") {
          if (M == "(")
            return Rt(bt, ")", "call", he);
          if (M == ".")
            return F(zt, he);
          if (M == "[")
            return F(Be("]"), X, ze("]"), Ae, he);
          if (f && $ == "as")
            return V.marked = "keyword", F(Qe, he);
          if (M == "regexp")
            return V.state.lastType = V.marked = "operator", V.stream.backUp(V.stream.pos - V.stream.start - 1), F(Q);
        }
      }
      function ge(M, $) {
        return M != "quasi" ? G() : $.slice($.length - 2) != "${" ? F(ge) : F(X, we);
      }
      function we(M) {
        if (M == "}")
          return V.marked = "string-2", V.state.tokenize = I, F(ge);
      }
      function me(M) {
        return N(V.stream, V.state), G(M == "{" ? We : Pe);
      }
      function Ge(M) {
        return N(V.stream, V.state), G(M == "{" ? We : bt);
      }
      function tt(M) {
        return function($) {
          return $ == "." ? F(M ? ft : ht) : $ == "variable" && f ? F(Jn, M ? te : ne) : G(M ? bt : Pe);
        };
      }
      function ht(M, $) {
        if ($ == "target")
          return V.marked = "keyword", F(ne);
      }
      function ft(M, $) {
        if ($ == "target")
          return V.marked = "keyword", F(te);
      }
      function st(M) {
        return M == ":" ? F(Ae, We) : G(ne, ze(";"), Ae);
      }
      function zt(M) {
        if (M == "variable")
          return V.marked = "property", F();
      }
      function pt(M, $) {
        if (M == "async")
          return V.marked = "property", F(pt);
        if (M == "variable" || V.style == "keyword") {
          if (V.marked = "property", $ == "get" || $ == "set")
            return F(Dt);
          var ie;
          return f && V.state.fatArrowAt == V.stream.start && (ie = V.stream.match(/^\s*:\s*/, false)) && (V.state.fatArrowAt = V.stream.pos + ie[0].length), F(Gt);
        } else {
          if (M == "number" || M == "string")
            return V.marked = l ? "property" : V.style + " property", F(Gt);
          if (M == "jsonld-keyword")
            return F(Gt);
          if (f && le($))
            return V.marked = "keyword", F(pt);
          if (M == "[")
            return F(Pe, di, ze("]"), Gt);
          if (M == "spread")
            return F(bt, Gt);
          if ($ == "*")
            return V.marked = "keyword", F(pt);
          if (M == ":")
            return G(Gt);
        }
      }
      function Dt(M) {
        return M != "variable" ? G(Gt) : (V.marked = "property", F(hi));
      }
      function Gt(M) {
        if (M == ":")
          return F(bt);
        if (M == "(")
          return G(hi);
      }
      function qe(M, $, ie) {
        function he(Q, Se) {
          if (ie ? ie.indexOf(Q) > -1 : Q == ",") {
            var ct = V.state.lexical;
            return ct.info == "call" && (ct.pos = (ct.pos || 0) + 1), F(function(nn, _n) {
              return nn == $ || _n == $ ? G() : G(M);
            }, he);
          }
          return Q == $ || Se == $ ? F() : ie && ie.indexOf(";") > -1 ? G(M) : F(ze($));
        }
        return function(Q, Se) {
          return Q == $ || Se == $ ? F() : G(M, he);
        };
      }
      function Rt(M, $, ie) {
        for (var he = 3; he < arguments.length; he++)
          V.cc.push(arguments[he]);
        return F(Be($, ie), qe(M, $), Ae);
      }
      function Pt(M) {
        return M == "}" ? F() : G(We, Pt);
      }
      function di(M, $) {
        if (f) {
          if (M == ":")
            return F(Qe);
          if ($ == "?")
            return F(di);
        }
      }
      function ji(M, $) {
        if (f && (M == ":" || $ == "in"))
          return F(Qe);
      }
      function Zr(M) {
        if (f && M == ":")
          return V.stream.match(/^\s*\w+\s+is\b/, false) ? F(Pe, yf, Qe) : F(Qe);
      }
      function yf(M, $) {
        if ($ == "is")
          return V.marked = "keyword", F();
      }
      function Qe(M, $) {
        if ($ == "keyof" || $ == "typeof" || $ == "infer" || $ == "readonly")
          return V.marked = "keyword", F($ == "typeof" ? bt : Qe);
        if (M == "variable" || $ == "void")
          return V.marked = "type", F(ui);
        if ($ == "|" || $ == "&")
          return F(Qe);
        if (M == "string" || M == "number" || M == "atom")
          return F(ui);
        if (M == "[")
          return F(Be("]"), qe(Qe, "]", ","), Ae, ui);
        if (M == "{")
          return F(Be("}"), Oe, Ae, ui);
        if (M == "(")
          return F(qe(_t, ")"), ad, ui);
        if (M == "<")
          return F(qe(Qe, ">"), Qe);
        if (M == "quasi")
          return G(yn, ui);
      }
      function ad(M) {
        if (M == "=>")
          return F(Qe);
      }
      function Oe(M) {
        return M.match(/[\}\)\]]/) ? F() : M == "," || M == ";" ? F(Oe) : G(vr, Oe);
      }
      function vr(M, $) {
        if (M == "variable" || V.style == "keyword")
          return V.marked = "property", F(vr);
        if ($ == "?" || M == "number" || M == "string")
          return F(vr);
        if (M == ":")
          return F(Qe);
        if (M == "[")
          return F(ze("variable"), ji, ze("]"), vr);
        if (M == "(")
          return G(es, vr);
        if (!M.match(/[;\}\)\],]/))
          return F();
      }
      function yn(M, $) {
        return M != "quasi" ? G() : $.slice($.length - 2) != "${" ? F(yn) : F(Qe, Nt);
      }
      function Nt(M) {
        if (M == "}")
          return V.marked = "string-2", V.state.tokenize = I, F(yn);
      }
      function _t(M, $) {
        return M == "variable" && V.stream.match(/^\s*[?:]/, false) || $ == "?" ? F(_t) : M == ":" ? F(Qe) : M == "spread" ? F(_t) : G(Qe);
      }
      function ui(M, $) {
        if ($ == "<")
          return F(Be(">"), qe(Qe, ">"), Ae, ui);
        if ($ == "|" || M == "." || $ == "&")
          return F(Qe);
        if (M == "[")
          return F(Qe, ze("]"), ui);
        if ($ == "extends" || $ == "implements")
          return V.marked = "keyword", F(Qe);
        if ($ == "?")
          return F(Qe, ze(":"), Qe);
      }
      function Jn(M, $) {
        if ($ == "<")
          return F(Be(">"), qe(Qe, ">"), Ae, ui);
      }
      function Ii() {
        return G(Qe, Sn);
      }
      function Sn(M, $) {
        if ($ == "=")
          return F(Qe);
      }
      function ka(M, $) {
        return $ == "enum" ? (V.marked = "keyword", F(Re)) : G(Nn, di, Li, Sf);
      }
      function Nn(M, $) {
        if (f && le($))
          return V.marked = "keyword", F(Nn);
        if (M == "variable")
          return ae($), F();
        if (M == "spread")
          return F(Nn);
        if (M == "[")
          return Rt(dl, "]");
        if (M == "{")
          return Rt(Xr, "}");
      }
      function Xr(M, $) {
        return M == "variable" && !V.stream.match(/^\s*:/, false) ? (ae($), F(Li)) : (M == "variable" && (V.marked = "property"), M == "spread" ? F(Nn) : M == "}" ? G() : M == "[" ? F(Pe, ze("]"), ze(":"), Xr) : F(ze(":"), Nn, Li));
      }
      function dl() {
        return G(Nn, Li);
      }
      function Li(M, $) {
        if ($ == "=")
          return F(bt);
      }
      function Sf(M) {
        if (M == ",")
          return F(ka);
      }
      function Ia(M, $) {
        if (M == "keyword b" && $ == "else")
          return F(Be("form", "else"), We, Ae);
      }
      function od(M, $) {
        if ($ == "await")
          return F(od);
        if (M == "(")
          return F(Be(")"), ul, Ae);
      }
      function ul(M) {
        return M == "var" ? F(ka, Qr) : M == "variable" ? F(Qr) : G(Qr);
      }
      function Qr(M, $) {
        return M == ")" ? F() : M == ";" ? F(Qr) : $ == "in" || $ == "of" ? (V.marked = "keyword", F(Pe, Qr)) : G(Pe, Qr);
      }
      function hi(M, $) {
        if ($ == "*")
          return V.marked = "keyword", F(hi);
        if (M == "variable")
          return ae($), F(hi);
        if (M == "(")
          return F(Ze, Be(")"), qe(Di, ")"), Ae, Zr, We, Xe);
        if (f && $ == "<")
          return F(Be(">"), qe(Ii, ">"), Ae, hi);
      }
      function es(M, $) {
        if ($ == "*")
          return V.marked = "keyword", F(es);
        if (M == "variable")
          return ae($), F(es);
        if (M == "(")
          return F(Ze, Be(")"), qe(Di, ")"), Ae, Zr, Xe);
        if (f && $ == "<")
          return F(Be(">"), qe(Ii, ">"), Ae, es);
      }
      function ld(M, $) {
        if (M == "keyword" || M == "variable")
          return V.marked = "type", F(ld);
        if ($ == "<")
          return F(Be(">"), qe(Ii, ">"), Ae);
      }
      function Di(M, $) {
        return $ == "@" && F(Pe, Di), M == "spread" ? F(Di) : f && le($) ? (V.marked = "keyword", F(Di)) : f && M == "this" ? F(di, Li) : G(Nn, di, Li);
      }
      function bf(M, $) {
        return M == "variable" ? La(M, $) : Pi(M, $);
      }
      function La(M, $) {
        if (M == "variable")
          return ae($), F(Pi);
      }
      function Pi(M, $) {
        if ($ == "<")
          return F(Be(">"), qe(Ii, ">"), Ae, Pi);
        if ($ == "extends" || $ == "implements" || f && M == ",")
          return $ == "implements" && (V.marked = "keyword"), F(f ? Qe : Pe, Pi);
        if (M == "{")
          return F(Be("}"), Ai, Ae);
      }
      function Ai(M, $) {
        if (M == "async" || M == "variable" && ($ == "static" || $ == "get" || $ == "set" || f && le($)) && V.stream.match(/^\s+#?[\w$\xa1-\uffff]/, false))
          return V.marked = "keyword", F(Ai);
        if (M == "variable" || V.style == "keyword")
          return V.marked = "property", F(Os, Ai);
        if (M == "number" || M == "string")
          return F(Os, Ai);
        if (M == "[")
          return F(Pe, di, ze("]"), Os, Ai);
        if ($ == "*")
          return V.marked = "keyword", F(Ai);
        if (f && M == "(")
          return G(es, Ai);
        if (M == ";" || M == ",")
          return F(Ai);
        if (M == "}")
          return F();
        if ($ == "@")
          return F(Pe, Ai);
      }
      function Os(M, $) {
        if ($ == "!" || $ == "?")
          return F(Os);
        if (M == ":")
          return F(Qe, Li);
        if ($ == "=")
          return F(bt);
        var ie = V.state.lexical.prev, he = ie && ie.info == "interface";
        return G(he ? es : hi);
      }
      function Da(M, $) {
        return $ == "*" ? (V.marked = "keyword", F(Ra, ze(";"))) : $ == "default" ? (V.marked = "keyword", F(Pe, ze(";"))) : M == "{" ? F(qe(Pa, "}"), Ra, ze(";")) : G(We);
      }
      function Pa(M, $) {
        if ($ == "as")
          return V.marked = "keyword", F(ze("variable"));
        if (M == "variable")
          return G(bt, Pa);
      }
      function ts(M) {
        return M == "string" ? F() : M == "(" ? G(Pe) : M == "." ? G(ne) : G(Aa, Ji, Ra);
      }
      function Aa(M, $) {
        return M == "{" ? Rt(Aa, "}") : (M == "variable" && ae($), $ == "*" && (V.marked = "keyword"), F(hl2));
      }
      function Ji(M) {
        if (M == ",")
          return F(Aa, Ji);
      }
      function hl2(M, $) {
        if ($ == "as")
          return V.marked = "keyword", F(Aa);
      }
      function Ra(M, $) {
        if ($ == "from")
          return V.marked = "keyword", F(Pe);
      }
      function Ot(M) {
        return M == "]" ? F() : G(qe(bt, "]"));
      }
      function Re() {
        return G(Be("form"), Nn, ze("{"), Be("}"), qe(yr, "}"), Ae, Ae);
      }
      function yr() {
        return G(Nn, Li);
      }
      function fl(M, $) {
        return M.lastType == "operator" || M.lastType == "," || y.test($.charAt(0)) || /[,.]/.test($.charAt(0));
      }
      function ei(M, $, ie) {
        return $.tokenize == R && /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\[{}\(,;:]|=>)$/.test($.lastType) || $.lastType == "quasi" && /\{\s*$/.test(M.string.slice(0, M.pos - (ie || 0)));
      }
      return {
        startState: function(M) {
          var $ = {
            tokenize: R,
            lastType: "sof",
            cc: [],
            lexical: new B((M || 0) - s, 0, "block", false),
            localVars: r.localVars,
            context: r.localVars && new Te(null, null, false),
            indented: M || 0
          };
          return r.globalVars && typeof r.globalVars == "object" && ($.globalVars = r.globalVars), $;
        },
        token: function(M, $) {
          if (M.sol() && ($.lexical.hasOwnProperty("align") || ($.lexical.align = false), $.indented = M.indentation(), N(M, $)), $.tokenize != A && M.eatSpace())
            return null;
          var ie = $.tokenize(M, $);
          return b == "comment" ? ie : ($.lastType = b == "operator" && (E == "++" || E == "--") ? "incdec" : b, U($, ie, b, E, M));
        },
        indent: function(M, $) {
          if (M.tokenize == A || M.tokenize == I)
            return t.Pass;
          if (M.tokenize != R)
            return 0;
          var ie = $ && $.charAt(0), he = M.lexical, Q;
          if (!/^\s*else\b/.test($))
            for (var Se = M.cc.length - 1; Se >= 0; --Se) {
              var ct = M.cc[Se];
              if (ct == Ae)
                he = he.prev;
              else if (ct != Ia && ct != Xe)
                break;
            }
          for (; (he.type == "stat" || he.type == "form") && (ie == "}" || (Q = M.cc[M.cc.length - 1]) && (Q == ne || Q == te) && !/^[,\.=+\-*:?[\(]/.test($)); )
            he = he.prev;
          a && he.type == ")" && he.prev.type == "stat" && (he = he.prev);
          var nn = he.type, _n = ie == nn;
          return nn == "vardef" ? he.indented + (M.lastType == "operator" || M.lastType == "," ? he.info.length + 1 : 0) : nn == "form" && ie == "{" ? he.indented : nn == "form" ? he.indented + s : nn == "stat" ? he.indented + (fl(M, $) ? a || s : 0) : he.info == "switch" && !_n && r.doubleIndentSwitch != false ? he.indented + (/^(?:case|default)\b/.test($) ? s : 2 * s) : he.align ? he.column + (_n ? 0 : 1) : he.indented + (_n ? 0 : s);
        },
        electricInput: /^\s*(?:case .*?:|default:|\{|\})$/,
        blockCommentStart: d ? null : "/*",
        blockCommentEnd: d ? null : "*/",
        blockCommentContinue: d ? null : " * ",
        lineComment: d ? null : "//",
        fold: "brace",
        closeBrackets: "()[]{}''\"\"``",
        helperType: d ? "json" : "javascript",
        jsonldMode: l,
        jsonMode: d,
        expressionAllowed: ei,
        skipExpression: function(M) {
          U(M, "atom", "atom", "true", new t.StringStream("", 2, null));
        }
      };
    }), t.registerHelper("wordChars", "javascript", /[\w$]/), t.defineMIME("text/javascript", "javascript"), t.defineMIME("text/ecmascript", "javascript"), t.defineMIME("application/javascript", "javascript"), t.defineMIME("application/x-javascript", "javascript"), t.defineMIME("application/ecmascript", "javascript"), t.defineMIME("application/json", { name: "javascript", json: true }), t.defineMIME("application/x-json", { name: "javascript", json: true }), t.defineMIME("application/manifest+json", { name: "javascript", json: true }), t.defineMIME("application/ld+json", { name: "javascript", jsonld: true }), t.defineMIME("text/typescript", { name: "javascript", typescript: true }), t.defineMIME("application/typescript", { name: "javascript", typescript: true });
  });
})();
var E$ = { exports: {} };
(function(n, e) {
  (function(t) {
    t(sl());
  })(function(t) {
    function i(l, d, u, f) {
      if (u && u.call) {
        var g = u;
        u = null;
      } else
        var g = a(l, u, "rangeFinder");
      typeof d == "number" && (d = t.Pos(d, 0));
      var v = a(l, u, "minFoldSize");
      function y(E) {
        var L = g(l, d);
        if (!L || L.to.line - L.from.line < v)
          return null;
        if (f === "fold")
          return L;
        for (var R = l.findMarksAt(L.from), _ = 0; _ < R.length; ++_)
          if (R[_].__isFold) {
            if (!E)
              return null;
            L.cleared = true, R[_].clear();
          }
        return L;
      }
      var w = y(true);
      if (a(l, u, "scanUp"))
        for (; !w && d.line > l.firstLine(); )
          d = t.Pos(d.line - 1, 0), w = y(false);
      if (!(!w || w.cleared || f === "unfold")) {
        var C = r(l, u, w);
        t.on(C, "mousedown", function(E) {
          b.clear(), t.e_preventDefault(E);
        });
        var b = l.markText(w.from, w.to, {
          replacedWith: C,
          clearOnEnter: a(l, u, "clearOnEnter"),
          __isFold: true
        });
        b.on("clear", function(E, L) {
          t.signal(l, "unfold", l, E, L);
        }), t.signal(l, "fold", l, w.from, w.to);
      }
    }
    function r(l, d, u) {
      var f = a(l, d, "widget");
      if (typeof f == "function" && (f = f(u.from, u.to)), typeof f == "string") {
        var g = document.createTextNode(f);
        f = document.createElement("span"), f.appendChild(g), f.className = "CodeMirror-foldmarker";
      } else
        f && (f = f.cloneNode(true));
      return f;
    }
    t.newFoldFunction = function(l, d) {
      return function(u, f) {
        i(u, f, { rangeFinder: l, widget: d });
      };
    }, t.defineExtension("foldCode", function(l, d, u) {
      i(this, l, d, u);
    }), t.defineExtension("isFolded", function(l) {
      for (var d = this.findMarksAt(l), u = 0; u < d.length; ++u)
        if (d[u].__isFold)
          return true;
    }), t.commands.toggleFold = function(l) {
      l.foldCode(l.getCursor());
    }, t.commands.fold = function(l) {
      l.foldCode(l.getCursor(), null, "fold");
    }, t.commands.unfold = function(l) {
      l.foldCode(l.getCursor(), { scanUp: false }, "unfold");
    }, t.commands.foldAll = function(l) {
      l.operation(function() {
        for (var d = l.firstLine(), u = l.lastLine(); d <= u; d++)
          l.foldCode(t.Pos(d, 0), { scanUp: false }, "fold");
      });
    }, t.commands.unfoldAll = function(l) {
      l.operation(function() {
        for (var d = l.firstLine(), u = l.lastLine(); d <= u; d++)
          l.foldCode(t.Pos(d, 0), { scanUp: false }, "unfold");
      });
    }, t.registerHelper("fold", "combine", function() {
      var l = Array.prototype.slice.call(arguments, 0);
      return function(d, u) {
        for (var f = 0; f < l.length; ++f) {
          var g = l[f](d, u);
          if (g)
            return g;
        }
      };
    }), t.registerHelper("fold", "auto", function(l, d) {
      for (var u = l.getHelpers(d, "fold"), f = 0; f < u.length; f++) {
        var g = u[f](l, d);
        if (g)
          return g;
      }
    });
    var s = {
      rangeFinder: t.fold.auto,
      widget: "↔",
      minFoldSize: 0,
      scanUp: false,
      clearOnEnter: true
    };
    t.defineOption("foldOptions", null);
    function a(l, d, u) {
      if (d && d[u] !== void 0)
        return d[u];
      var f = l.options.foldOptions;
      return f && f[u] !== void 0 ? f[u] : s[u];
    }
    t.defineExtension("foldOption", function(l, d) {
      return a(this, l, d);
    });
  });
})();
var T$ = E$.exports;
(function(n, e) {
  (function(t) {
    t(sl(), T$);
  })(function(t) {
    t.defineOption("foldGutter", false, function(b, E, L) {
      L && L != t.Init && (b.clearGutter(b.state.foldGutter.options.gutter), b.state.foldGutter = null, b.off("gutterClick", g), b.off("changes", y), b.off("viewportChange", w), b.off("fold", C), b.off("unfold", C), b.off("swapDoc", y), b.off("optionChange", v)), E && (b.state.foldGutter = new r(s(E)), f(b), b.on("gutterClick", g), b.on("changes", y), b.on("viewportChange", w), b.on("fold", C), b.on("unfold", C), b.on("swapDoc", y), b.on("optionChange", v));
    });
    var i = t.Pos;
    function r(b) {
      this.options = b, this.from = this.to = 0;
    }
    function s(b) {
      return b === true && (b = {}), b.gutter == null && (b.gutter = "CodeMirror-foldgutter"), b.indicatorOpen == null && (b.indicatorOpen = "CodeMirror-foldgutter-open"), b.indicatorFolded == null && (b.indicatorFolded = "CodeMirror-foldgutter-folded"), b;
    }
    function a(b, E) {
      for (var L = b.findMarks(i(E, 0), i(E + 1, 0)), R = 0; R < L.length; ++R)
        if (L[R].__isFold) {
          var _ = L[R].find(-1);
          if (_ && _.line === E)
            return L[R];
        }
    }
    function l(b) {
      if (typeof b == "string") {
        var E = document.createElement("div");
        return E.className = b + " CodeMirror-guttermarker-subtle", E;
      } else
        return b.cloneNode(true);
    }
    function d(b, E, L) {
      var R = b.state.foldGutter.options, _ = E - 1, A = b.foldOption(R, "minFoldSize"), I = b.foldOption(R, "rangeFinder"), P = typeof R.indicatorFolded == "string" && u(R.indicatorFolded), N = typeof R.indicatorOpen == "string" && u(R.indicatorOpen);
      b.eachLine(E, L, function(O) {
        ++_;
        var B = null, j = O.gutterMarkers;
        if (j && (j = j[R.gutter]), a(b, _)) {
          if (P && j && P.test(j.className))
            return;
          B = l(R.indicatorFolded);
        } else {
          var U = i(_, 0), V = I && I(b, U);
          if (V && V.to.line - V.from.line >= A) {
            if (N && j && N.test(j.className))
              return;
            B = l(R.indicatorOpen);
          }
        }
        !B && !j || b.setGutterMarker(O, R.gutter, B);
      });
    }
    function u(b) {
      return new RegExp("(^|\\s)" + b + "(?:$|\\s)\\s*");
    }
    function f(b) {
      var E = b.getViewport(), L = b.state.foldGutter;
      L && (b.operation(function() {
        d(b, E.from, E.to);
      }), L.from = E.from, L.to = E.to);
    }
    function g(b, E, L) {
      var R = b.state.foldGutter;
      if (R) {
        var _ = R.options;
        if (L == _.gutter) {
          var A = a(b, E);
          A ? A.clear() : b.foldCode(i(E, 0), _);
        }
      }
    }
    function v(b, E) {
      E == "mode" && y(b);
    }
    function y(b) {
      var E = b.state.foldGutter;
      if (E) {
        var L = E.options;
        E.from = E.to = 0, clearTimeout(E.changeUpdate), E.changeUpdate = setTimeout(function() {
          f(b);
        }, L.foldOnChangeTimeSpan || 600);
      }
    }
    function w(b) {
      var E = b.state.foldGutter;
      if (E) {
        var L = E.options;
        clearTimeout(E.changeUpdate), E.changeUpdate = setTimeout(function() {
          var R = b.getViewport();
          E.from == E.to || R.from - E.to > 20 || E.from - R.to > 20 ? f(b) : b.operation(function() {
            R.from < E.from && (d(b, R.from, E.from), E.from = R.from), R.to > E.to && (d(b, E.to, R.to), E.to = R.to);
          });
        }, L.updateViewportTimeSpan || 400);
      }
    }
    function C(b, E) {
      var L = b.state.foldGutter;
      if (L) {
        var R = E.line;
        R >= L.from && R < L.to && d(b, R, R + 1);
      }
    }
  });
})();
(function(n, e) {
  (function(t) {
    t(sl());
  })(function(t) {
    function i(r) {
      return function(s, a) {
        var l = a.line, d = s.getLine(l);
        function u(C) {
          for (var b, E = a.ch, L = 0; ; ) {
            var R = E <= 0 ? -1 : d.lastIndexOf(C[0], E - 1);
            if (R == -1) {
              if (L == 1)
                break;
              L = 1, E = d.length;
              continue;
            }
            if (L == 1 && R < a.ch)
              break;
            if (b = s.getTokenTypeAt(t.Pos(l, R + 1)), !/^(comment|string)/.test(b))
              return { ch: R + 1, tokenType: b, pair: C };
            E = R - 1;
          }
        }
        function f(C) {
          var b = 1, E = s.lastLine(), L, R = C.ch, _;
          e:
            for (var A = l; A <= E; ++A)
              for (var I = s.getLine(A), P = A == l ? R : 0; ; ) {
                var N = I.indexOf(C.pair[0], P), O = I.indexOf(C.pair[1], P);
                if (N < 0 && (N = I.length), O < 0 && (O = I.length), P = Math.min(N, O), P == I.length)
                  break;
                if (s.getTokenTypeAt(t.Pos(A, P + 1)) == C.tokenType) {
                  if (P == N)
                    ++b;
                  else if (!--b) {
                    L = A, _ = P;
                    break e;
                  }
                }
                ++P;
              }
          return L == null || l == L ? null : {
            from: t.Pos(l, R),
            to: t.Pos(L, _)
          };
        }
        for (var g = [], v = 0; v < r.length; v++) {
          var y = u(r[v]);
          y && g.push(y);
        }
        g.sort(function(C, b) {
          return C.ch - b.ch;
        });
        for (var v = 0; v < g.length; v++) {
          var w = f(g[v]);
          if (w)
            return w;
        }
        return null;
      };
    }
    t.registerHelper("fold", "brace", i([["{", "}"], ["[", "]"]])), t.registerHelper("fold", "brace-paren", i([["{", "}"], ["[", "]"], ["(", ")"]])), t.registerHelper("fold", "import", function(r, s) {
      function a(v) {
        if (v < r.firstLine() || v > r.lastLine())
          return null;
        var y = r.getTokenAt(t.Pos(v, 1));
        if (/\S/.test(y.string) || (y = r.getTokenAt(t.Pos(v, y.end + 1))), y.type != "keyword" || y.string != "import")
          return null;
        for (var w = v, C = Math.min(r.lastLine(), v + 10); w <= C; ++w) {
          var b = r.getLine(w), E = b.indexOf(";");
          if (E != -1)
            return { startCh: y.end, end: t.Pos(w, E) };
        }
      }
      var l = s.line, d = a(l), u;
      if (!d || a(l - 1) || (u = a(l - 2)) && u.end.line == l - 1)
        return null;
      for (var f = d.end; ; ) {
        var g = a(f.line + 1);
        if (g == null)
          break;
        f = g.end;
      }
      return { from: r.clipPos(t.Pos(l, d.startCh + 1)), to: f };
    }), t.registerHelper("fold", "include", function(r, s) {
      function a(g) {
        if (g < r.firstLine() || g > r.lastLine())
          return null;
        var v = r.getTokenAt(t.Pos(g, 1));
        if (/\S/.test(v.string) || (v = r.getTokenAt(t.Pos(g, v.end + 1))), v.type == "meta" && v.string.slice(0, 8) == "#include")
          return v.start + 8;
      }
      var l = s.line, d = a(l);
      if (d == null || a(l - 1) != null)
        return null;
      for (var u = l; ; ) {
        var f = a(u + 1);
        if (f == null)
          break;
        ++u;
      }
      return {
        from: t.Pos(l, d + 1),
        to: r.clipPos(t.Pos(u))
      };
    });
  });
})();
var k$ = sl();
var ms = Gs(k$);
var I$ = 100;
var L$ = class extends hf {
  constructor(e) {
    super(), this.viewer = e, this.parsedValue = null, this.debouncedValueUpdater = lt(() => {
      const s = this.textEditor.getValue();
      try {
        const a = JSON.parse(s);
        this.parsedValue = a, this.applyButton.disabled = false, this.textEditor.setOption("lint", void 0);
      } catch (a) {
        this.parsedValue = null, this.applyButton.disabled = true;
        let l = 0, d = 0, u = "Unknown parse error";
        if (a instanceof Error) {
          const f = a.message.match(/^((?:.|\n)*) in JSON at position ([0-9]+)$/);
          if (f !== null) {
            u = f[1];
            const g = parseInt(f[2], 10), y = s.substring(0, g).split(`
`);
            l = y.length - 1, d = y[y.length - 1].length;
          } else
            u = a.message;
        }
        this.textEditor.setOption("lint", {
          getAnnotations: () => [{
            message: u,
            severity: "error",
            from: ms.Pos(l, d)
          }]
        });
      }
    }, I$), this.content.classList.add("neuroglancer-state-editor");
    const t = this.applyButton = document.createElement("button");
    t.textContent = "Apply changes", this.content.appendChild(t), t.addEventListener("click", () => this.applyChanges()), t.disabled = true;
    const i = this.closeButton = document.createElement("button");
    i.classList.add("close-button"), i.textContent = "Close", this.content.appendChild(i), i.addEventListener("click", () => this.dispose());
    const r = this.downloadButton = document.createElement("button");
    r.textContent = "Download", r.title = "Download state as a JSON file", this.content.appendChild(r), r.addEventListener("click", () => this.downloadState()), this.textEditor = ms((s) => {
    }, {
      value: "",
      mode: { name: "javascript", json: true },
      foldGutter: true,
      gutters: ["CodeMirror-lint-markers", "CodeMirror-foldgutter"]
    }), this.updateView(), this.textEditor.on("change", () => {
      this.debouncedValueUpdater();
    }), this.content.appendChild(this.textEditor.getWrapperElement()), this.textEditor.refresh();
  }
  downloadState() {
    const e = document.createElement("a"), t = new Blob([this.getJson()], { type: "text/json" }), i = URL.createObjectURL(t);
    e.href = i, e.download = "state.json", e.click(), document.body.removeChild(e);
  }
  applyChanges() {
    this.parsedValue !== null && (this.viewer.state.reset(), this.viewer.state.restoreState(this.parsedValue)), this.applyButton.disabled = true;
  }
  updateView() {
    this.textEditor.setValue(this.getJson()), this.textEditor.execCommand("foldAll"), this.textEditor.execCommand("unfold");
  }
  getJson() {
    return se(Wh(this.viewer.state).value, null, "  ");
  }
};
var D$ = PE;
var P$ = A$(D$);
function A$(n) {
  return n && n.__esModule ? n : { default: n };
}
var R$ = function(n) {
  return Array.isArray(n) ? n : (0, P$.default)(n);
};
var M$ = {
  side: "bottom",
  size: 100,
  minSize: 50,
  row: 0,
  col: 0,
  flex: 1,
  visible: false
};
var N$ = class {
  constructor() {
    this.location = new Ns(M$);
  }
  get changed() {
    return this.location.changed;
  }
  restoreState(e) {
    this.location.restoreState(e);
  }
  reset() {
    this.location.reset();
  }
  toJSON() {
    return ya(this.location.toJSON());
  }
};
function _$(n) {
  const e = new de();
  function t(i, r) {
    if (typeof i != "object") {
      e.set(r, "" + i);
      return;
    }
    for (const s of un(i))
      t(i[s], r + "." + s);
  }
  return t(n, ""), e;
}
function O$(n) {
  const e = new je();
  e.add(".type");
  const t = new je();
  function i(r, s) {
    for (const a of e)
      if (n[r].get(a) !== n[s].get(a))
        return true;
    return false;
  }
  for (let r = 0, s = n.length; r < s; ++r) {
    for (const l of n[r].keys())
      t.add(l);
    let a = [];
    for (let l = 0; l < r; ++l)
      i(r, l) || a.push(l);
    for (; a.length > 0; ) {
      let l = a, d;
      for (const u of t) {
        if (e.has(u))
          continue;
        const f = [];
        for (const g of a)
          n[g].get(u) === n[r].get(u) && f.push(g);
        if (f.length < l.length && (l = f, d = u), f.length === 0)
          break;
      }
      if (d === void 0)
        break;
      a = l, e.add(d);
    }
  }
  return De(e);
}
function V$(n, e) {
  const t = {};
  for (const i of e) {
    const r = n.get(i);
    if (r !== void 0) {
      if (i === "")
        return r;
      t[i] = r;
    }
  }
  return se(t);
}
function B$(n) {
  return RZr({ type: n.RPC_TYPE_ID }, n.key || {});
}
function F$(n) {
  const e = n.map(_$), t = O$(e);
  return e.map((i) => V$(i, t));
}
var U$ = 1e3;
var ag = [{
  label: "Visible chunks/T",
  key: "visibleChunksTotal",
  getter: (n) => {
    let e = 0;
    for (let t = 0; t < j1; ++t)
      e += n[Js(t, kr.VISIBLE) * ps + Ir.numChunks];
    return e;
  }
}, {
  label: "Visible chunks/D",
  key: "visibleChunksDownloading",
  getter: (n) => n[Js(Et.DOWNLOADING, kr.VISIBLE) * ps + Ir.numChunks]
}, {
  label: "Visible chunks/M",
  key: "visibleChunksSystemMemory",
  getter: (n) => n[Js(Et.SYSTEM_MEMORY, kr.VISIBLE) * ps + Ir.numChunks] + n[Js(Et.SYSTEM_MEMORY_WORKER, kr.VISIBLE) * ps + Ir.numChunks]
}, {
  label: "Visible chunks/G",
  key: "visibleChunksGpuMemory",
  getter: (n) => n[Js(Et.GPU_MEMORY, kr.VISIBLE) * ps + Ir.numChunks]
}, {
  label: "Visible chunks/F",
  key: "visibleChunksFailed",
  getter: (n) => n[Js(Et.FAILED, kr.VISIBLE) * ps + Ir.numChunks]
}, {
  label: "Visible memory",
  key: "visibleGpuMemory",
  getter: (n) => n[Js(Et.GPU_MEMORY, kr.VISIBLE) * ps + Ir.gpuMemoryBytes]
}, {
  label: "Download latency",
  key: "downloadLatency",
  getter: (n) => n[cC(Nu.totalTime)] / n[cC(Nu.totalChunks)]
}];
var z$ = class extends wa {
  constructor(e, t, i) {
    super(e, i.location), this.chunkQueueManager = t, this.displayState = i, this.data = void 0, this.requestDataTimerId = -1, this.dataRequested = false, this.body = document.createElement("div"), this.debouncedUpdateView = this.registerCancellable(lt(() => this.updateView(), 0));
    const r = this.body;
    r.classList.add("neuroglancer-statistics-panel-body"), this.addTitleBar({ title: "Chunk statistics" }), this.addBody(r), this.requestData();
  }
  disposed() {
    window.clearTimeout(this.requestDataTimerId), super.disposed();
  }
  requestData() {
    if (this.dataRequested)
      return;
    const e = this.chunkQueueManager;
    this.dataRequested = true, e.getStatistics().then((t) => {
      this.dataRequested = false, this.data = t, this.debouncedUpdateView(), this.requestDataTimerId = window.setTimeout(() => {
        this.requestDataTimerId = -1, this.requestData();
      }, U$);
    });
  }
  updateView() {
    const e = this.data;
    if (e === void 0)
      return;
    const t = document.createElement("table"), i = [];
    for (const u of e) {
      var r = ce(u, 2);
      const f = r[0], g = r[1], v = [f];
      for (const y of ag) {
        const w = y.getter;
        v.push(w(g));
      }
      i.push(v);
    }
    const s = F$(i.map((u) => B$(u[0]))), a = new de();
    s.forEach((u, f) => {
      a.set(i[f][0], u);
    });
    {
      const u = document.createElement("thead");
      let f = document.createElement("tr");
      u.appendChild(f);
      const g = (y) => {
        const w = document.createElement("td");
        w.textContent = y, f.appendChild(w);
      };
      g("Name");
      let v;
      for (const y of ag) {
        const w = y.label, C = w.indexOf("/");
        let b = w;
        if (C !== -1) {
          if (b = w.substring(0, C), b === v) {
            ++f.lastElementChild.colSpan;
            continue;
          }
          v = b;
        }
        g(b);
      }
      f = document.createElement("tr"), u.appendChild(f);
      {
        const y = document.createElement("td");
        f.appendChild(y);
      }
      for (const y of ag) {
        const w = y.label, C = w.indexOf("/");
        let b = "";
        C !== -1 && (b = w.substring(C + 1));
        const E = document.createElement("td");
        E.textContent = b, f.appendChild(E);
      }
      t.appendChild(u);
    }
    const l = document.createElement("tbody");
    for (const u of i) {
      var d = R$(u);
      const f = d[0], g = d.slice(1), v = document.createElement("tr"), y = (w) => {
        const C = document.createElement("td");
        C.textContent = w, v.appendChild(C);
      };
      y(a.get(f));
      for (const w of g)
        y("" + w);
      l.appendChild(v);
    }
    t.appendChild(l), it(this.body), this.body.appendChild(t);
  }
};
var By = class extends Z {
  constructor(e, t = () => St(1, 0, 0)) {
    super(), this.model = e, this.getDefaultColor = t, this.element = document.createElement("input");
    const i = this.element;
    i.classList.add("neuroglancer-color-widget"), i.type = "color", i.addEventListener("change", () => this.updateModel()), i.addEventListener("input", () => this.updateModel()), i.addEventListener("wheel", (r) => {
      r.stopPropagation(), r.preventDefault(), this.adjustHueViaWheel(r);
    }), this.registerDisposer(e.changed.add(() => this.updateView())), this.updateView();
  }
  getRGB() {
    var e;
    return (e = this.model.value) !== null && e !== void 0 ? e : this.getDefaultColor();
  }
  updateView() {
    this.element.value = Wn(this.getRGB());
  }
  updateModel() {
    this.model.value = va(this.element.value);
  }
  adjustHueViaWheel(e) {
    const t = this.getRGB(), i = _e();
    D3(i, t[0], t[1], t[2]);
    const r = e.deltaY;
    let s = Math.round(i[0] * 256);
    s += r > 0 ? 1 : r < 0 ? -1 : 0, s = (s + 256) % 256, i[0] = s / 256, $u(i, i[0], i[1], i[2]), this.model.value = i;
  }
};
var G$ = class extends Z {
  constructor(e, t = {}) {
    super(), this.model = e, this.element = document.createElement("label"), this.inputElement = document.createElement("input");
    let i = t.validator, r = t.label;
    const s = this.element, a = this.inputElement;
    i === void 0 && (e instanceof hn ? i = e.validator : i = (l) => l), this.validator = i, r !== void 0 && (s.textContent = r), s.appendChild(a), s.className = "neuroglancer-number-input", a.type = "text", this.registerDisposer(this.model.changed.add(() => this.updateView())), this.registerEventListener(a, "change", () => this.updateModel()), this.updateView();
  }
  updateView() {
    this.inputElement.value = "" + this.model.value;
  }
  updateModel() {
    let e = parseFloat(this.inputElement.value.trim());
    if (nr(e)) {
      this.updateView();
      return;
    }
    try {
      e = this.validator(e), this.model.value = e;
    } catch {
      this.updateView();
    }
  }
  disposed() {
    Ft(this.element), super.disposed();
  }
};
var $I = class extends Z {
  constructor(e) {
    super(), this.model = e, this.element = document.createElement("input"), this.registerDisposer(e.changed.add(() => this.updateView()));
    const t = this.element;
    t.type = "text", this.registerEventListener(t, "change", () => this.updateModel()), this.updateView();
  }
  disposed() {
    Ft(this.element);
  }
  updateView() {
    var e;
    this.element.value = ((e = this.model.value) !== null && e !== void 0 ? e : "") + "";
  }
  updateModel() {
    try {
      this.model.restoreState(this.element.value);
    } catch {
    }
    this.updateView();
  }
};
var $$ = RZr(RZr({}, Ca), { side: "left", row: 2 });
var W$ = class {
  constructor() {
    this.location = new Ns($$);
  }
  get changed() {
    return this.location.changed;
  }
  toJSON() {
    return ya(this.location.toJSON());
  }
  reset() {
    this.location.reset();
  }
  restoreState(e) {
    this.location.restoreState(e);
  }
};
var H$ = class extends wa {
  constructor(e, t, i) {
    super(e, t.location), this.addTitleBar({ title: "Settings" });
    const r = document.createElement("div");
    r.classList.add("neuroglancer-settings-body");
    let s = document.createElement("div");
    s.classList.add("neuroglancer-settings-scroll-container"), r.appendChild(s), this.addBody(r);
    {
      const u = this.registerDisposer(new $I(i.title));
      u.element.placeholder = "Title", u.element.classList.add("neuroglancer-settings-title"), s.appendChild(u.element);
    }
    const a = (u, f) => {
      const g = this.registerDisposer(new G$(f, { label: u }));
      g.element.classList.add("neuroglancer-settings-limit-widget"), s.appendChild(g.element);
    };
    a("GPU memory limit", i.chunkQueueManager.capacities.gpuMemory.sizeLimit), a("System memory limit", i.chunkQueueManager.capacities.systemMemory.sizeLimit), a("Concurrent chunk requests", i.chunkQueueManager.capacities.download.itemLimit);
    const l = (u, f) => {
      const g = document.createElement("label");
      g.textContent = u;
      const v = this.registerDisposer(new Rs(f));
      g.appendChild(v.element), s.appendChild(g);
    };
    l("Show axis lines", i.showAxisLines), l("Show scale bar", i.showScaleBar), l("Show cross sections in 3-d", i.showPerspectiveSliceViews), l("Show default annotations", i.showDefaultAnnotations), l("Show chunk statistics", i.statisticsDisplayState.location.watchableVisible), l("Wire frame rendering", i.wireFrame), l("Enable prefetching", i.chunkQueueManager.enablePrefetch);
    const d = (u, f) => {
      const g = document.createElement("label");
      g.textContent = u;
      const v = this.registerDisposer(new By(f));
      g.appendChild(v.element), s.appendChild(g);
    };
    d("Cross-section background", i.crossSectionBackgroundColor), d("Projection background", i.perspectiveViewBackgroundColor);
  }
};
var j$ = class extends Z {
  constructor(e, t) {
    super(), this.selectedLayer = e, this.toolBinder = t, this.element = document.createElement("div"), this.viewContext = void 0, this.updateView = this.registerCancellable(Ct(() => {
      let r = this.viewContext;
      r !== void 0 && (this.unregisterDisposer(r), r.dispose()), this.viewContext = r = this.registerDisposer(new Z()), it(this.element);
      const s = this.selectedTool;
      s !== void 0 && this.element.appendChild(this.makeWidget(r, s));
      const a = De(this.toolBinder.bindings);
      a.sort(([d], [u]) => jc(d, u));
      for (const d of a) {
        var l = ce(d, 2);
        const u = l[1];
        this.element.appendChild(this.makeWidget(r, u));
      }
    }));
    const i = this.element;
    i.className = "neuroglancer-annotation-tool-status", this.registerDisposer(e.changed.add(() => this.selectedLayerChanged())), this.registerDisposer(t.changed.add(this.updateView)), this.registerDisposer(this.selectedLayer.layerManager.layersChanged.add(this.updateView)), this.selectedLayerChanged();
  }
  get selectedTool() {
    const e = this.selectedLayer.layer;
    if (e === void 0)
      return;
    const t = e.layer;
    if (t !== null)
      return t.tool.value;
  }
  selectedLayerChanged() {
    let e = this.unbindPreviousLayer;
    e !== void 0 && e();
    const t = this.selectedLayer.layer;
    t !== void 0 && (this.unbindPreviousLayer = t.specificationChanged.add(() => {
      this.updateView();
    })), this.updateView();
  }
  disposed() {
    const e = this.unbindPreviousLayer;
    e !== void 0 && e(), this.unbindPreviousLayer = void 0;
  }
  makeWidget(e, t) {
    const i = document.createElement("div");
    i.title = "dblclick → unbind", t instanceof Uo && (i.title += ", click → bind key"), i.className = "neuroglancer-annotation-tool-status-widget";
    const r = document.createElement("div");
    r.className = "neuroglancer-annotation-tool-status-widget-layer-number";
    const s = t.layer.managedLayer;
    s.manager.rootLayers.updateNonArchivedLayerIndices();
    const a = s.nonArchivedLayerIndex;
    r.textContent = (a + 1).toString();
    const l = document.createElement("div");
    if (l.className = "neuroglancer-annotation-tool-status-widget-description", l.textContent = t.description, i.addEventListener("dblclick", () => {
      t instanceof cI ? t.layer.tool.value = void 0 : this.toolBinder.set(t.keyBinding, void 0);
    }), t instanceof Uo) {
      const d = document.createElement("div");
      d.className = "neuroglancer-annotation-tool-status-widget-key", d.textContent = t.keyBinding, i.appendChild(d), hI(e, i, (u) => t.layer.toolBinder.set(u, t.addRef()));
    }
    return i.appendChild(r), i.appendChild(l), i;
  }
};
function Fy(n) {
  return encodeURI(n).replace(/[!'()*;,]/g, function(e) {
    return "%" + e.charCodeAt(0).toString(16).toUpperCase();
  });
}
var J$ = class extends Z {
  constructor(e, t, i = {}) {
    super(), this.root = e, this.credentialsManager = t, this.parseError = new gt(void 0);
    var r = i.updateDelayMilliseconds;
    const s = r === void 0 ? 200 : r;
    var a = i.defaultFragment;
    const l = a === void 0 ? "{}" : a;
    this.registerEventListener(window, "hashchange", () => this.updateFromUrlHash());
    const d = lt(() => this.setUrlHash(), s);
    this.registerDisposer(e.changed.add(d)), this.registerDisposer(() => d.cancel()), this.defaultFragment = l;
  }
  /**
   * Sets the URL hash to match the current state.
   */
  setUrlHash() {
    const e = Wh(this.root);
    if (e.generation !== this.prevStateGeneration) {
      this.prevStateGeneration = e.generation;
      let i = Fy(se(e.value));
      i !== this.prevStateString && (this.prevStateString = i, decodeURIComponent(i) === "{}" ? history.replaceState(null, "", "#") : history.replaceState(null, "", "#!" + i));
    }
  }
  /**
   * Sets the current state to match the URL hash.  If it is desired to initialize the state based
   * on the URL hash, then this should be called immediately after construction.
   */
  updateFromUrlHash() {
    try {
      let t = location.href.replace(/^[^#]+/, "");
      if ((t === "" || t === "#" || t === "#!") && (t = "#!" + this.defaultFragment), t.match(/^#!([a-z][a-z\d+-.]*):\/\//)) {
        const i = t.substring(2);
        var e = rl(i, this.credentialsManager);
        const r = e.url, s = e.credentialsProvider;
        nt.forPromise(Ea(s, r, {}, Hi).then((a) => {
          pe(a), this.root.reset(), this.root.restoreState(a);
        }), { initialMessage: `Loading state from ${i}`, errorPrefix: "Error loading state:" });
      } else if (t.startsWith("#!+")) {
        t = t.slice(3), t = decodeURIComponent(t);
        let i = Iu(t);
        pe(i), this.root.restoreState(i), this.prevStateString = void 0;
      } else if (t.startsWith("#!")) {
        if (t = t.slice(2), t = decodeURIComponent(t), t === this.prevStateString)
          return;
        this.prevStateString = t, this.root.reset();
        let i = Iu(t);
        pe(i), this.root.restoreState(i);
      } else
        throw new Error('URL hash is expected to be of the form "#!{...}" or "#!+{...}".');
      this.parseError.value = void 0;
    } catch (t) {
      this.parseError.value = t;
    }
  }
};
var Y$ = Object.freeze(Object.defineProperty({
  __proto__: null,
  UrlHashBinding: J$,
  encodeFragment: Fy
}, Symbol.toStringTag, { value: "Module" }));
var q$ = class extends Z {
  constructor(e, t, i = "") {
    super(), this.gl = e, this.frameNumberCounter = t;
    const r = i + "chunk_worker.bundle.js";
    this.worker = typeof i == "string" ? new Worker(r) : i, this.chunkQueueManager = this.registerDisposer(new tm(new iV(this.worker), this.gl, this.frameNumberCounter, {
      gpuMemory: new Jd({ defaultItemLimit: 1e6, defaultSizeLimit: 1e9 }),
      systemMemory: new Jd({ defaultItemLimit: 1e7, defaultSizeLimit: 2e9 }),
      download: new Jd({ defaultItemLimit: 100, defaultSizeLimit: Number.POSITIVE_INFINITY }),
      compute: new Jd({ defaultItemLimit: 128, defaultSizeLimit: 5e8 })
    })), this.chunkQueueManager.registerDisposer(() => this.worker.terminate()), this.chunkManager = this.registerDisposer(new nm(this.chunkQueueManager));
  }
  get rpc() {
    return this.chunkQueueManager.rpc;
  }
};
var WI = ["showHelpButton", "showSettingsButton", "showEditStateButton", "showLayerListPanelButton", "showSelectionPanelButton", "showLayerSidePanelButton", "showLocation", "showAnnotationToolStatus"];
var HI = [...WI, "showLayerPanel", "showLayerHoverValues"];
var jI = [...HI, "showUIControls", "showPanelBorders"];
function K$() {
  return Object.fromEntries(jI.map((n) => [n, new en(true)]));
}
function Z$(n, e) {
  for (const t of jI) {
    const i = e[t];
    i !== void 0 && (n[t].value = i);
  }
}
var X$ = typeof NEUROGLANCER_OVERRIDE_DEFAULT_VIEWER_OPTIONS < "u" ? NEUROGLANCER_OVERRIDE_DEFAULT_VIEWER_OPTIONS : {
  showLayerDialog: true,
  resetStateWhenEmpty: true
};
var Q$ = class extends $h {
  constructor(e) {
    super(), this.viewer = e, this.add("title", e.title), this.add("dimensions", e.coordinateSpace), this.add("relativeDisplayScales", e.relativeDisplayScales), this.add("displayDimensions", e.displayDimensions), this.add("position", e.position), this.add("crossSectionOrientation", e.crossSectionOrientation), this.add("crossSectionScale", e.crossSectionScale), this.add("crossSectionDepth", e.crossSectionDepthRange), this.add("projectionOrientation", e.projectionOrientation), this.add("projectionScale", e.projectionScale), this.add("projectionDepth", e.projectionDepthRange), this.add("layers", e.layerSpecification), this.add("showAxisLines", e.showAxisLines), this.add("wireFrame", e.wireFrame), this.add("showScaleBar", e.showScaleBar), this.add("showDefaultAnnotations", e.showDefaultAnnotations), this.add("showSlices", e.showPerspectiveSliceViews), this.add("gpuMemoryLimit", e.dataContext.chunkQueueManager.capacities.gpuMemory.sizeLimit), this.add("prefetch", e.dataContext.chunkQueueManager.enablePrefetch), this.add("systemMemoryLimit", e.dataContext.chunkQueueManager.capacities.systemMemory.sizeLimit), this.add("concurrentDownloads", e.dataContext.chunkQueueManager.capacities.download.itemLimit), this.add("selectedLayer", e.selectedLayer), this.add("crossSectionBackgroundColor", e.crossSectionBackgroundColor), this.add("projectionBackgroundColor", e.perspectiveViewBackgroundColor), this.add("layout", e.layout), this.add("statistics", e.statisticsDisplayState), this.add("helpPanel", e.helpPanelState), this.add("settingsPanel", e.settingsPanelState), this.add("selection", e.selectionDetailsState), this.add("layerListPanel", e.layerListPanelState), this.add("partialViewport", e.partialViewport), this.add("selectedStateServer", e.selectedStateServer);
  }
  restoreState(e) {
    const t = this.viewer;
    super.restoreState(e), Ce(e, "navigation", (i) => {
      pe(i), Ce(i, "pose", (r) => {
        pe(r), Ce(r, "position", (s) => {
          pe(s), In(s, "voxelCoordinates", t.position), Ce(s, "voxelSize", (a) => {
            const l = at(new Float64Array(3), a, vn);
            for (let d = 0; d < 3; ++d)
              l[d] *= 1e-9;
            t.coordinateSpace.value = mt({
              valid: false,
              names: ["x", "y", "z"],
              units: ["m", "m", "m"],
              scales: l
            });
          });
        }), In(r, "orientation", t.crossSectionOrientation);
      }), In(i, "zoomFactor", t.crossSectionScale.legacyJsonView);
    }), In(e, "perspectiveOrientation", t.projectionOrientation), In(e, "perspectiveZoom", t.projectionScale.legacyJsonView), In(e, "perspectiveViewBackgroundColor", t.perspectiveViewBackgroundColor);
  }
};
var ws = {
  expectingExternalUI: false
};
var eW = class extends Z {
  constructor(e, t = {}) {
    super(), this.display = e, this.title = new hn(void 0, Le), this.coordinateSpace = new Bv(), this.position = this.registerDisposer(new ea(this.coordinateSpace)), this.relativeDisplayScales = this.registerDisposer(new xk(this.coordinateSpace)), this.displayDimensions = this.registerDisposer(new Tk(this.coordinateSpace)), this.displayDimensionRenderInfo = this.registerDisposer(new Ek(this.relativeDisplayScales.addRef(), this.displayDimensions.addRef())), this.crossSectionOrientation = this.registerDisposer(new _o()), this.crossSectionScale = this.registerDisposer(new i3(this.displayDimensionRenderInfo.addRef())), this.projectionOrientation = this.registerDisposer(new _o()), this.crossSectionDepthRange = this.registerDisposer(new cm(-10, this.displayDimensionRenderInfo)), this.projectionDepthRange = this.registerDisposer(new cm(-50, this.displayDimensionRenderInfo)), this.projectionScale = this.registerDisposer(new r3(this.displayDimensionRenderInfo.addRef())), this.navigationState = this.registerDisposer(new Vo(new Oo(this.position.addRef(), this.displayDimensionRenderInfo.addRef(), this.crossSectionOrientation.addRef()), this.crossSectionScale.addRef(), this.crossSectionDepthRange.addRef())), this.perspectiveNavigationState = this.registerDisposer(new Vo(new Oo(this.position.addRef(), this.displayDimensionRenderInfo.addRef(), this.projectionOrientation.addRef()), this.projectionScale.addRef(), this.projectionDepthRange.addRef())), this.mouseState = new rW(), this.layerManager = this.registerDisposer(new JI()), this.selectedLayer = this.registerDisposer(new uW(this.layerManager.addRef())), this.showAxisLines = new en(true, true), this.wireFrame = new en(false, false), this.showScaleBar = new en(true, true), this.showPerspectiveSliceViews = new en(true, true), this.visibleLayerRoles = cV(), this.showDefaultAnnotations = new en(true, true), this.crossSectionBackgroundColor = new uc(St(0.5, 0.5, 0.5)), this.perspectiveViewBackgroundColor = new uc(St(0, 0, 0)), this.scaleBarOptions = new $z(), this.partialViewport = new pO(), this.statisticsDisplayState = new N$(), this.helpPanelState = new NG(), this.settingsPanelState = new W$(), this.layerSelectedValues = this.registerDisposer(new sW(this.layerManager, this.mouseState)), this.selectionDetailsState = this.registerDisposer(new aW(this.coordinateSpace, this.layerSelectedValues)), this.selectedStateServer = new hn("", Le), this.layerListPanelState = new y$(), this.resetInitiated = new Ee(), this.makeUrlFromState = (R) => ws.expectingExternalUI ? "/#!" + Fy(se(R)) : window.location.toString(), this.uiControlVisibility = {}, this.visible = true, this.toolInputEventMapBinder = (R, _) => {
      _.registerDisposer(this.inputEventBindings.sliceView.addParent(R, Number.POSITIVE_INFINITY)), _.registerDisposer(this.inputEventBindings.perspectiveView.addParent(R, Number.POSITIVE_INFINITY));
    }, this.toolBinder = this.registerDisposer(new dz(this.toolInputEventMapBinder));
    var i = t.dataContext;
    const r = i === void 0 ? new q$(e.gl, e, t.bundleRoot) : i;
    var s = t.visibility;
    const a = s === void 0 ? new Kt(Kt.VISIBLE) : s;
    var l = t.inputEventBindings;
    const d = l === void 0 ? {
      global: new vt(),
      sliceView: new vt(),
      perspectiveView: new vt()
    } : l;
    var u = t.element;
    const f = u === void 0 ? e.makeCanvasOverlayElement() : u;
    var g = t.dataSourceProvider;
    const v = g === void 0 ? SG({ credentialsManager: il }) : g;
    var y = t.uiConfiguration;
    const w = y === void 0 ? K$() : y;
    this.visibility = a, this.inputEventBindings = d, this.element = f, this.dataSourceProvider = v, this.uiConfiguration = w, this.registerDisposer(Vr((R) => {
      this.display.applyWindowedViewportToElement(f, R);
    }, this.partialViewport)), this.registerDisposer(() => Ft(this.element)), this.dataContext = this.registerDisposer(r), Z$(w, t);
    const C = RZr(RZr({}, X$), t), b = C.resetStateWhenEmpty, E = C.showLayerDialog;
    for (const R of HI)
      this.uiControlVisibility[R] = this.makeUiControlVisibilityState(R);
    this.registerDisposer(this.uiConfiguration.showPanelBorders.changed.add(() => {
      this.updateShowBorders();
    })), this.showLayerDialog = E, this.resetStateWhenEmpty = b, this.layerSpecification = new pW(this.display, this.dataSourceProvider, this.layerManager, this.chunkManager, this.selectionDetailsState, this.selectedLayer, this.navigationState.coordinateSpace, this.navigationState.pose.position, this.toolBinder), this.registerDisposer(e.updateStarted.add(() => {
      this.onUpdateDisplay();
    })), this.showDefaultAnnotations.changed.add(() => {
      this.showDefaultAnnotations.value ? this.visibleLayerRoles.add(Ti.DEFAULT_ANNOTATION) : this.visibleLayerRoles.delete(Ti.DEFAULT_ANNOTATION);
    }), this.registerDisposer(this.navigationState.changed.add(() => {
      this.handleNavigationStateChanged();
    }));
    const L = this.registerCancellable(lt(() => {
      !this.wasDisposed && this.layerManager.managedLayers.length === 0 && this.resetStateWhenEmpty && (this.navigationState.reset(), this.perspectiveNavigationState.pose.orientation.reset(), this.perspectiveNavigationState.zoomFactor.reset(), this.resetInitiated.dispatch(), !Dm && this.showLayerDialog && this.visibility.visible && sL(this.layerSpecification, this.selectedLayer));
    }));
    this.layerManager.layersChanged.add(L), L(), this.registerDisposer(this.dataContext.chunkQueueManager.visibleChunksChanged.add(() => {
      this.layerSelectedValues.handleLayerChange();
    })), this.registerDisposer(this.dataContext.chunkQueueManager.visibleChunksChanged.add(() => {
      this.visible && e.scheduleRedraw();
    })), this.makeUI(), this.updateShowBorders(), this.registerActionListeners(), this.registerEventActionBindings(), this.registerDisposer(BI(f, this.navigationState.position)), this.state = new Q$(this);
  }
  get chunkManager() {
    return this.dataContext.chunkManager;
  }
  get chunkQueueManager() {
    return this.dataContext.chunkQueueManager;
  }
  get expectingExternalUI() {
    return ws.expectingExternalUI;
  }
  set expectingExternalUI(e) {
    ws.expectingExternalUI = e;
  }
  makeUiControlVisibilityState(e) {
    const t = this.uiConfiguration.showUIControls, i = this.uiConfiguration[e];
    return this.registerDisposer(Fb((r, s) => r && s, t, i));
  }
  get inputEventMap() {
    return this.inputEventBindings.global;
  }
  updateShowBorders() {
    const e = this.element, t = "neuroglancer-show-panel-borders";
    this.uiConfiguration.showPanelBorders.value ? e.classList.add(t) : e.classList.remove(t);
  }
  makeUI() {
    const e = this.element;
    e.classList.add("neuroglancer-viewer"), e.classList.add("neuroglancer-noselect"), e.style.display = "flex", e.style.flexDirection = "column";
    const t = document.createElement("div");
    t.classList.add("neuroglancer-viewer-top-row"), t.style.display = "flex", t.style.flexDirection = "row", t.style.alignItems = "stretch";
    const i = this.registerDisposer(new uf(this.navigationState.position, this.layerSpecification.coordinateSpaceCombiner));
    this.registerDisposer(new pi(this.uiControlVisibility.showLocation, i.element)), t.appendChild(i.element);
    const r = this.registerDisposer(new t$(document.createElement("div"), this.mouseState, this.navigationState.coordinateSpace));
    if (r.element.style.flex = "1", r.element.style.alignSelf = "center", this.registerDisposer(new pi(this.uiControlVisibility.showLocation, r.element)), t.appendChild(r.element), typeof NEUROGLANCER_CREDIT_LINK < "u") {
      let l = NEUROGLANCER_CREDIT_LINK;
      Array.isArray(l) || (l = [l]);
      for (const d of l) {
        const u = d.url, f = d.text, g = document.createElement("a");
        g.style.marginRight = "5px", g.href = u, g.textContent = f, g.style.fontFamily = "sans-serif", g.style.color = "yellow", g.target = "_blank", t.appendChild(g);
      }
    }
    const s = this.registerDisposer(new j$(this.selectedLayer, this.toolBinder));
    if (t.appendChild(s.element), this.registerDisposer(new pi(this.uiControlVisibility.showAnnotationToolStatus, s.element)), DG) {
      const l = this.registerDisposer(new PG(this));
      t.appendChild(l.element);
    }
    {
      const l = this.layerListPanelState, d = this.registerDisposer(new tr(l.location.watchableVisible, {
        svg: gz,
        backgroundScheme: "dark",
        enableTitle: "Show layer list panel",
        disableTitle: "Hide layer list panel"
      }));
      d.element.insertAdjacentElement("afterbegin", this.registerDisposer(new x$(this.layerManager)).element), this.registerDisposer(new pi(this.uiControlVisibility.showLayerListPanelButton, d.element)), t.appendChild(d.element);
    }
    {
      const l = this.selectionDetailsState, d = this.registerDisposer(new tr(l.location.watchableVisible, {
        svg: mz,
        backgroundScheme: "dark",
        enableTitle: "Show selection details panel",
        disableTitle: "Hide selection details panel"
      }));
      this.registerDisposer(new pi(this.uiControlVisibility.showSelectionPanelButton, d.element)), t.appendChild(d.element);
    }
    {
      const l = this.selectedLayer, d = this.registerDisposer(new tr({
        get value() {
          return l.visible;
        },
        set value(u) {
          l.visible = u;
        },
        changed: l.location.locationChanged
      }, {
        svg: fI,
        backgroundScheme: "dark",
        enableTitle: "Show layer side panel",
        disableTitle: "Hide layer side panel"
      }));
      this.registerDisposer(new pi(this.uiControlVisibility.showLayerSidePanelButton, d.element)), t.appendChild(d.element);
    }
    {
      const l = Tt({ text: "{}", title: "Edit JSON state" });
      this.registerEventListener(l, "click", () => {
        this.editJsonState();
      }), this.registerDisposer(new pi(this.uiControlVisibility.showEditStateButton, l)), t.appendChild(l);
    }
    {
      const l = dr({
        title: "Copy view URL to clipboard",
        onClick: () => {
          const d = oi(this.makeUrlFromState(this.state.toJSON()));
          nt.showTemporaryMessage(d ? "URL copied to clipboard" : "Failed to copy URL to clipboard");
        }
      });
      t.appendChild(l);
    }
    {
      const l = this.helpPanelState, d = this.registerDisposer(new tr(l.location.watchableVisible, {
        text: "?",
        backgroundScheme: "dark",
        enableTitle: "Show help panel",
        disableTitle: "Hide help panel"
      }));
      this.registerDisposer(new pi(this.uiControlVisibility.showHelpButton, d.element)), t.appendChild(d.element);
    }
    {
      const l = this.settingsPanelState, d = this.registerDisposer(new tr(l.location.watchableVisible, {
        svg: vz,
        backgroundScheme: "dark",
        enableTitle: "Show settings panel",
        disableTitle: "Hide settings panel"
      }));
      this.registerDisposer(new pi(this.uiControlVisibility.showSettingsButton, d.element)), t.appendChild(d.element);
    }
    this.registerDisposer(new pi(Fb((...l) => l.reduce((d, u) => d || u, false), ...WI.map((l) => this.uiControlVisibility[l])), t)), e.appendChild(t), this.layout = this.registerDisposer(new c$(this, "4panel")), this.sidePanelManager = this.registerDisposer(new Z3(this.display, this.layout.element, this.visibility)), this.registerDisposer(this.sidePanelManager.registerPanel({
      location: this.layerListPanelState.location,
      makePanel: () => new w$(this.sidePanelManager, this.layerSpecification, this.layerListPanelState)
    })), this.registerDisposer(new m$(this.sidePanelManager, this.selectedLayer.addRef())), this.registerDisposer(this.sidePanelManager.registerPanel({
      location: this.selectionDetailsState.location,
      makePanel: () => new yw(this.sidePanelManager, this.selectionDetailsState, this.layerSpecification, this.selectedLayer)
    })), e.appendChild(this.sidePanelManager.element), this.closeSelectionTab = () => {
      for (const l of this.sidePanelManager.registeredPanels)
        l.panel instanceof yw && l.panel.close();
    }, this.registerDisposer(this.sidePanelManager.registerPanel({
      location: this.statisticsDisplayState.location,
      makePanel: () => new z$(this.sidePanelManager, this.chunkQueueManager, this.statisticsDisplayState)
    })), this.registerDisposer(this.sidePanelManager.registerPanel({
      location: this.helpPanelState.location,
      makePanel: () => {
        const l = this.inputEventBindings;
        return new _G(this.sidePanelManager, this.helpPanelState, [["Global", l.global], ["Cross section view", l.sliceView], ["3-D projection view", l.perspectiveView]], this.layerManager, this.toolBinder);
      }
    })), this.registerDisposer(this.sidePanelManager.registerPanel({
      location: this.settingsPanelState.location,
      makePanel: () => new H$(this.sidePanelManager, this.settingsPanelState, this)
    }));
    const a = () => {
      const l = this.visibility.visible;
      l !== this.visible && (e.style.visibility = l ? "inherit" : "hidden", this.visible = l);
    };
    a(), this.registerDisposer(this.visibility.changed.add(a));
  }
  /**
   * Called once by the constructor to set up event handlers.
   */
  registerEventActionBindings() {
    const e = this.element;
    this.registerDisposer(new Wi(e, this.inputEventMap)), this.registerDisposer(new sf(e));
  }
  bindAction(e, t) {
    this.registerDisposer(be(this.element, e, t));
  }
  bindCallback(e, t) {
    const i = () => {
      t(this);
    };
    this.registerDisposer(be(this.element, e, i));
  }
  /**
   * Called once by the constructor to register the action listeners.
   */
  registerActionListeners() {
    for (const e of ["recolor", "clear-segments"])
      this.bindAction(e, () => {
        this.layerManager.invokeAction(e), this.closeSelectionTab && this.closeSelectionTab();
      });
    for (const e of ["select"])
      this.bindAction(e, () => {
        this.mouseState.updateUnconditionally(), this.layerManager.invokeAction(e);
      });
    for (const e of ["copy-segment-id", "add-copy-segment-id"])
      this.bindAction(e, () => {
        this.mouseState.updateUnconditionally(), this.layerManager.invokeAction(e, this.selectedLayer.layer);
      });
    this.bindAction("help", () => this.toggleHelpPanel());
    for (let e = 1; e <= 9; ++e)
      this.bindAction(`toggle-layer-${e}`, () => {
        const t = this.layerManager.getLayerByNonArchivedIndex(e - 1);
        t !== void 0 && t.setVisible(!t.visible);
      }), this.bindAction(`toggle-pick-layer-${e}`, () => {
        const t = this.layerManager.getLayerByNonArchivedIndex(e - 1);
        t !== void 0 && (t.pickEnabled = !t.pickEnabled);
      }), this.bindAction(`select-layer-${e}`, () => {
        const t = this.layerManager.getLayerByNonArchivedIndex(e - 1);
        t !== void 0 && (this.selectedLayer.layer = t, this.selectedLayer.visible = true);
      });
    for (let e = 0; e < 26; ++e) {
      const t = String.fromCharCode(65 + e);
      this.bindAction(`tool-${t}`, () => {
        this.activateTool(t);
      });
    }
    this.bindAction("annotate", () => {
      const e = this.selectedLayer.layer;
      if (e === void 0) {
        nt.showTemporaryMessage("The annotate command requires a layer to be selected.");
        return;
      }
      const t = e.layer;
      if (t === null || t.tool.value === void 0) {
        nt.showTemporaryMessage(`The selected layer (${se(e.name)}) does not have an active annotation tool.`);
        return;
      }
      t.tool.value.trigger(this.mouseState);
    }), this.bindAction("toggle-axis-lines", () => this.showAxisLines.toggle()), this.bindAction("toggle-scale-bar", () => this.showScaleBar.toggle()), this.bindAction("toggle-default-annotations", () => this.showDefaultAnnotations.toggle()), this.bindAction("toggle-show-slices", () => this.showPerspectiveSliceViews.toggle()), this.bindAction("toggle-show-statistics", () => this.showStatistics());
  }
  toggleHelpPanel() {
    this.helpPanelState.location.visible = !this.helpPanelState.location.visible;
  }
  activateTool(e) {
    this.toolBinder.activate(e);
  }
  editJsonState() {
    new L$(this);
  }
  copyJsonStateToUrl() {
    oi(this.makeUrlFromState(this.state.toJSON()));
  }
  showStatistics(e = void 0) {
    e === void 0 && (e = !this.statisticsDisplayState.location.visible), this.statisticsDisplayState.location.visible = e;
  }
  get gl() {
    return this.display.gl;
  }
  onUpdateDisplay() {
    this.visible && (this.dataContext.chunkQueueManager.chunkUpdateDeadline = null);
  }
  handleNavigationStateChanged() {
    if (this.visible) {
      let e = this.dataContext.chunkQueueManager;
      e.chunkUpdateDeadline === null && (e.chunkUpdateDeadline = Date.now() + 10);
    }
  }
};
var sx = "tool";
var ax = "toolBindings";
var og = "localPosition";
var ox = "localDimensions";
var lx = "source";
var tW = "transform";
var cx = "pick";
var nW = class {
  constructor() {
    this.callbacks = [];
  }
  defer(e) {
    this.callbacks.push(e);
  }
};
var al = class extends Z {
  constructor(e) {
    super(), this.managedLayer = e, this.pick = new en(true, true), this.layersChanged = new Ee(), this.readyStateChanged = new Ee(), this.specificationChanged = new Ee(), this.renderLayers = new Array(), this.loadingCounter = 1, this.tabs = this.registerDisposer(new KU()), this.panels = new sz(this), this.tool = this.registerDisposer(new cz(this)), this.toolBinder = new uz(this), this.dataSourcesChanged = new Ee(), this.dataSources = [], this.allowingRefresh = false, this.localCoordinateSpaceCombiner.includeDimensionPredicate = O1, this.tabs.changed.add(this.specificationChanged.dispatch), this.panels.specificationChanged.add(this.specificationChanged.dispatch), this.tool.changed.add(this.specificationChanged.dispatch), this.toolBinder.changed.add(this.specificationChanged.dispatch), this.localPosition.changed.add(this.specificationChanged.dispatch), this.pick.changed.add(this.specificationChanged.dispatch), this.pick.changed.add(this.layersChanged.dispatch), this.dataSourcesChanged.add(this.specificationChanged.dispatch), this.dataSourcesChanged.add(() => this.updateDataSubsourceActivations()), this.tabs.add("source", {
      label: "Source",
      order: -100,
      getter: () => new iz(this)
    });
  }
  get localPosition() {
    return this.managedLayer.localPosition;
  }
  get localCoordinateSpaceCombiner() {
    return this.managedLayer.localCoordinateSpaceCombiner;
  }
  get localCoordinateSpace() {
    return this.managedLayer.localCoordinateSpace;
  }
  get type() {
    return this.constructor.type;
  }
  initializeSelectionState(e) {
    e.generation = -1, e.localPositionValid = false, e.localPosition = Eo, e.localCoordinateSpace = void 0, e.annotationId = void 0, e.annotationType = void 0, e.annotationBuffer = void 0, e.annotationIndex = void 0, e.annotationCount = void 0, e.annotationSourceIndex = void 0, e.annotationSubsource = void 0, e.annotationPartIndex = void 0, e.value = void 0;
  }
  resetSelectionState(e) {
    e.localPositionValid = false, e.annotationId = void 0, e.value = void 0;
  }
  selectionStateFromJson(e, t) {
    const r = (e.localCoordinateSpace = this.localCoordinateSpace.value).rank;
    if (r !== 0) {
      const a = Ce(t, og, (l) => at(new Float32Array(r), l, Lt));
      a === void 0 ? e.localPositionValid = false : (e.localPositionValid = true, e.localPosition = a);
    }
    (e.annotationId = Ce(t, "annotationId", Le)) !== void 0 && (e.annotationSourceIndex = Ce(t, "annotationSource", pn, 0), e.annotationPartIndex = Ce(t, "annotationPart", pn), e.annotationSubsource = Ce(t, "annotationSubsource", Le)), e.value = t.value;
  }
  // Derived classes should override.
  displaySelectionState(e, t, i) {
    return false;
  }
  selectionStateToJson(e, t) {
    const i = {};
    if (e.localPositionValid) {
      const r = e.localPosition;
      r.length > 0 && (i.localPosition = De(r));
    }
    return e.annotationId !== void 0 && (i.annotationId = e.annotationId, i.annotationPart = e.annotationPartIndex, i.annotationSource = e.annotationSourceIndex, i.annotationSubsource = e.annotationSubsource), e.value != null && (i.value = e.value), i;
  }
  captureSelectionState(e, t) {
    e.localCoordinateSpace = this.localCoordinateSpace.value;
    const i = this.localPosition.value;
    let r = e.localPosition;
    r.length !== i.length ? e.localPosition = i.slice() : r.set(i), e.localPositionValid = true, e.value = this.getValueAt(t.position, t);
  }
  copySelectionState(e, t) {
    e.generation = t.generation, e.localPositionValid = t.localPositionValid, e.localCoordinateSpace = t.localCoordinateSpace;
    const i = t.localPosition;
    e.localPosition.length !== i.length ? e.localPosition = i.slice() : e.localPosition.set(i), e.annotationId = t.annotationId, e.annotationType = t.annotationType, e.annotationBuffer = t.annotationBuffer, e.annotationIndex = t.annotationIndex, e.annotationCount = t.annotationCount, e.annotationSourceIndex = t.annotationSourceIndex, e.annotationSubsource = t.annotationSubsource, e.annotationPartIndex = t.annotationPartIndex, e.value = t.value;
  }
  get isReady() {
    return this.loadingCounter === 0;
  }
  get manager() {
    return this.managedLayer.manager;
  }
  canAddDataSource() {
    return true;
  }
  addDataSource(e) {
    const t = new MF(this, e);
    return this.dataSources.push(t), this.dataSourcesChanged.dispatch(), t;
  }
  // Should be overridden by derived classes.
  activateDataSubsources(e) {
  }
  updateDataSubsourceActivations() {
    function* e() {
      for (const t of this.dataSources) {
        const i = t.loadState;
        if (!(i === void 0 || i.error !== void 0))
          for (const r of i.subsources)
            if (r.enabled)
              yield r;
            else {
              const s = r.activated;
              r.messages.clearMessages(), s !== void 0 && (s.dispose(), r.activated = void 0, i.activatedSubsourcesChanged.dispatch());
            }
      }
    }
    this.activateDataSubsources(e.call(this));
  }
  decrementLoadingCounter() {
    --this.loadingCounter === 0 && this.readyStateChanged.dispatch();
  }
  markLoading() {
    const e = this.localCoordinateSpaceCombiner.retain(), t = this.manager.root.coordinateSpaceCombiner.retain();
    return ++this.loadingCounter === 1 && this.readyStateChanged.dispatch(), () => {
      e(), t(), this.decrementLoadingCounter();
    };
  }
  addCoordinateSpace(e) {
    const t = this.manager.root.coordinateSpaceCombiner.bind(e), i = this.localCoordinateSpaceCombiner.bind(e);
    return () => {
      t(), i();
    };
  }
  initializationDone() {
    const e = this.selectionState = {};
    this.initializeSelectionState(e), this.decrementLoadingCounter();
  }
  getLegacyDataSourceSpecifications(e, t, i, r) {
    return e === void 0 ? [] : [ac(e, i)];
  }
  getDataSourceSpecifications(e) {
    let t, i = K(e, lx, (s) => Array.isArray(s) ? s.map((a) => ac(a)) : typeof s == "object" ? [ac(s)] : (t = s, []));
    const r = K(e, tW, J2);
    return i.push(...this.getLegacyDataSourceSpecifications(t, e, r, i)), i = i.filter((s) => s.url), i.length === 0 && i.push(ok()), i;
  }
  restoreState(e) {
    this.tool.restoreState(e[sx]), this.toolBinder.restoreState(e[ax]), this.panels.restoreState(e), this.localCoordinateSpace.restoreState(e[ox]), this.localPosition.restoreState(e[og]), this.constructor.supportsPickOption && this.pick.restoreState(e[cx]);
    for (const t of this.getDataSourceSpecifications(e))
      this.addDataSource(t);
  }
  addRenderLayer(e) {
    this.renderLayers.push(e);
    const t = this.layersChanged;
    return e.layerChanged.add(t.dispatch), e.userLayer = this, t.dispatch(), () => this.removeRenderLayer(e);
  }
  removeRenderLayer(e) {
    const t = this.renderLayers, i = this.layersChanged, r = t.indexOf(e);
    if (r === -1)
      throw new Error("Attempted to remove invalid RenderLayer");
    t.splice(r, 1), e.layerChanged.remove(i.dispatch), e.userLayer = void 0, e.dispose(), i.dispatch();
  }
  disposed() {
    const e = this.layersChanged;
    Co(this.dataSources);
    for (const t of this.renderLayers)
      t.layerChanged.remove(e.dispatch), t.dispose();
    this.renderLayers.length = 0, super.disposed();
  }
  getValueAt(e, t) {
    let i, r = this.renderLayers, s = t.pickedRenderLayer;
    if (s !== null && r.indexOf(s) !== -1 && (i = s.transformPickedValue(t), i = this.transformPickedValue(i), i != null))
      return i;
    for (let a of r)
      if (i = a.getValueAt(e), i != null)
        break;
    return this.transformPickedValue(i);
  }
  transformPickedValue(e) {
    return e;
  }
  toJSON() {
    return RZr({ type: this.type, [lx]: iW(this.dataSources), [sx]: this.tool.toJSON(), [ax]: this.toolBinder.toJSON(), [ox]: this.localCoordinateSpace.toJSON(), [og]: this.localPosition.toJSON(), [cx]: this.pick.toJSON() }, this.panels.toJSON());
  }
  // Derived classes should override.
  handleAction(e, t) {
  }
  selectedValueToJson(e) {
    return e;
  }
  selectedValueFromJson(e) {
    return e;
  }
  setLayerPosition(e, t) {
    const i = this.manager.root.globalPosition, r = this.localPosition;
    e ? (_b(i.value, t, e.globalToRenderLayerDimensions), _b(r.value, t, e.localToRenderLayerDimensions)) : i.value.set(t), r.changed.dispatch(), i.changed.dispatch();
  }
};
al.supportsPickOption = false;
function iW(n) {
  if (n.length !== 0)
    return n.length === 1 ? n[0].toJSON() : n.map((e) => e.toJSON());
}
var Uy = class extends Z {
  /**
   * If layer is not null, tranfers ownership of a reference.
   */
  constructor(e, t) {
    super(), this.manager = t, this.localCoordinateSpace = new Bv(), this.localCoordinateSpaceCombiner = new Gv2(this.localCoordinateSpace, ic), this.localPosition = this.registerDisposer(new ea(this.localCoordinateSpace)), this.nonArchivedLayerIndex = -1, this.readyStateChanged = new Ee(), this.layerChanged = new Ee(), this.specificationChanged = new Ee(), this.containers = new je(), this.layer_ = null, this.visible = true, this.archived = false, this.name_ = e;
  }
  get layer() {
    return this.layer_;
  }
  /**
   * If layer is not null, tranfers ownership of a reference.
   */
  set layer(e) {
    let t = this.layer_;
    if (t != null && (this.unregisterUserLayer(), t.dispose()), this.layer_ = e, e != null) {
      const i = [e.layersChanged.add(this.layerChanged.dispatch), e.readyStateChanged.add(this.readyStateChanged.dispatch), e.specificationChanged.add(this.specificationChanged.dispatch)];
      this.unregisterUserLayer = () => {
        i.forEach((r) => r());
      }, this.readyStateChanged.dispatch(), this.layerChanged.dispatch();
    }
  }
  isReady() {
    const e = this.layer;
    return e !== null && e.isReady;
  }
  get name() {
    return this.name_;
  }
  set name(e) {
    e !== this.name_ && (this.name_ = e, this.layerChanged.dispatch());
  }
  get supportsPickOption() {
    const e = this.layer;
    return e !== null && e.constructor.supportsPickOption;
  }
  get pickEnabled() {
    const e = this.layer;
    return e !== null && e.constructor.supportsPickOption && e.pick.value;
  }
  set pickEnabled(e) {
    const t = this.layer;
    t !== null && t.constructor.supportsPickOption && (t.pick.value = e);
  }
  toJSON() {
    let e = this.layer;
    if (e === null)
      return;
    let t = e.toJSON();
    return t.name = this.name, this.visible || (this.archived ? t.archived = true : t.visible = false), t;
  }
  setVisible(e) {
    if (e !== this.visible) {
      if (e && this.archived) {
        this.visible = true, this.setArchived(false);
        return;
      }
      this.visible = e, this.layerChanged.dispatch();
    }
  }
  setArchived(e) {
    if (this.archived !== e) {
      if (e === true) {
        this.visible = false, this.archived = true;
        for (const t of this.manager.root.subsets) {
          const i = t.layerManager;
          i.has(this) && i.removeManagedLayer(this);
        }
      } else {
        for (const t of this.manager.root.subsets) {
          const i = t.layerManager;
          i.has(this) || i.addManagedLayer(this.addRef());
        }
        this.archived = false;
      }
      this.layerChanged.dispatch();
    }
  }
  disposed() {
    this.layer = null, super.disposed();
  }
};
var JI = class extends Z {
  constructor() {
    super(), this.managedLayers = new Array(), this.layerSet = new je(), this.layersChanged = new Ee(), this.readyStateChanged = new Ee(), this.specificationChanged = new Ee(), this.boundPositions = new EF(), this.numDirectUsers = 0, this.nonArchivedLayerIndexGeneration = -1, this.renderLayerToManagedLayerMapGeneration = -1, this.renderLayerToManagedLayerMap_ = new de(), this.scheduleRemoveLayersWithSingleRef = this.registerCancellable(lt(() => this.removeLayersWithSingleRef(), 0)), this.layersChanged.add(this.scheduleRemoveLayersWithSingleRef);
  }
  updateNonArchivedLayerIndices() {
    const e = this.layersChanged.count;
    if (e === this.nonArchivedLayerIndexGeneration)
      return;
    this.nonArchivedLayerIndexGeneration = e;
    let t = 0;
    for (const i of this.managedLayers)
      i.archived || (i.nonArchivedLayerIndex = t++);
    for (const i of this.managedLayers)
      i.archived && (i.nonArchivedLayerIndex = t++);
  }
  getLayerByNonArchivedIndex(e) {
    let t = 0;
    for (const i of this.managedLayers)
      if (!i.archived) {
        if (t === e)
          return i;
        ++t;
      }
  }
  get renderLayerToManagedLayerMap() {
    const e = this.layersChanged.count, t = this.renderLayerToManagedLayerMap_;
    if (this.renderLayerToManagedLayerMapGeneration !== e) {
      this.renderLayerToManagedLayerMapGeneration = e, t.clear();
      for (const i of this.managedLayers) {
        const r = i.layer;
        if (r !== null)
          for (const s of r.renderLayers)
            t.set(s, i);
      }
    }
    return t;
  }
  filter(e) {
    let t = false;
    this.managedLayers = this.managedLayers.filter((i) => e(i) ? true : (this.unbindManagedLayer(i), this.layerSet.delete(i), t = true, false)), t && this.layersChanged.dispatch();
  }
  removeLayersWithSingleRef() {
    this.numDirectUsers > 0 || this.filter((e) => e.refCount !== 1 || e.archived);
  }
  updateSignalBindings(e, t) {
    t(e.layerChanged, this.layersChanged.dispatch), t(e.readyStateChanged, this.readyStateChanged.dispatch), t(e.specificationChanged, this.specificationChanged.dispatch);
  }
  useDirectly() {
    return ++this.numDirectUsers === 1 && this.layersChanged.remove(this.scheduleRemoveLayersWithSingleRef), () => {
      --this.numDirectUsers === 0 && (this.layersChanged.add(this.scheduleRemoveLayersWithSingleRef), this.scheduleRemoveLayersWithSingleRef());
    };
  }
  /**
   * Assumes ownership of an existing reference to managedLayer.
   */
  addManagedLayer(e, t) {
    return this.updateSignalBindings(e, pz), this.layerSet.add(e), e.containers.add(this), t === void 0 && (t = this.managedLayers.length), this.managedLayers.splice(t, 0, e), this.layersChanged.dispatch(), this.readyStateChanged.dispatch(), e;
  }
  *readyRenderLayers() {
    for (let e of this.managedLayers)
      !e.visible || !e.layer || (yield* e.layer.renderLayers);
  }
  unbindManagedLayer(e) {
    this.updateSignalBindings(e, fz), e.containers.delete(this), e.manager.rootLayers.layersChanged.dispatch(), e.dispose();
  }
  clear() {
    for (let e of this.managedLayers)
      this.unbindManagedLayer(e);
    this.managedLayers.length = 0, this.layerSet.clear(), this.layersChanged.dispatch();
  }
  remove(e) {
    const t = this.managedLayers[e];
    this.unbindManagedLayer(t), this.managedLayers.splice(e, 1), this.layerSet.delete(t), this.layersChanged.dispatch();
  }
  removeManagedLayer(e) {
    let t = this.managedLayers.indexOf(e);
    if (t === -1)
      throw new Error("Internal error: invalid managed layer.");
    this.remove(t);
  }
  reorderManagedLayer(e, t) {
    const i = this.managedLayers.length;
    if (e === t || e < 0 || e >= i || t < 0 || t >= i)
      return;
    var r = this.managedLayers.splice(e, 1), s = ce(r, 1);
    let a = s[0];
    this.managedLayers.splice(t, 0, a), this.layersChanged.dispatch();
  }
  disposed() {
    this.clear(), super.disposed();
  }
  getLayerByName(e) {
    return this.managedLayers.find((t) => t.name === e);
  }
  getUniqueLayerName(e) {
    let t = e, i = 0;
    for (; this.getLayerByName(t) !== void 0; )
      t = e + ++i;
    return t;
  }
  has(e) {
    return this.layerSet.has(e);
  }
  get renderLayers() {
    let e = this;
    return {
      *[wZr]() {
        for (let t of e.managedLayers)
          if (t.layer !== null)
            for (let i of t.layer.renderLayers)
              yield i;
      }
    };
  }
  get visibleRenderLayers() {
    let e = this;
    return {
      *[wZr]() {
        for (let t of e.managedLayers)
          if (!(t.layer === null || !t.visible))
            for (let i of t.layer.renderLayers)
              yield i;
      }
    };
  }
  invokeAction(e, t) {
    const i = new nW();
    for (let r of this.managedLayers) {
      if (r.layer === null || !r.visible || t !== void 0 && r !== t)
        continue;
      let s = r.layer;
      s.handleAction(e, i);
      for (let a of s.renderLayers)
        a.handleAction(e);
    }
    for (const r of i.callbacks)
      r();
  }
};
var rW = class {
  constructor() {
    this.changed = new Ee(), this.coordinateSpace = zr, this.position = Eo, this.unsnappedPosition = Eo, this.active = false, this.displayDimensions = void 0, this.pickedRenderLayer = null, this.pickedValue = new re(0, 0), this.pickedOffset = 0, this.pickedAnnotationLayer = void 0, this.pickedAnnotationId = void 0, this.pickedAnnotationBuffer = void 0, this.pickedAnnotationBufferBaseOffset = void 0, this.pickedAnnotationIndex = void 0, this.pickedAnnotationCount = void 0, this.pickedAnnotationType = void 0, this.forcerFunction = void 0;
  }
  removeForcer(e) {
    e === this.forcerFunction && (this.forcerFunction = void 0, this.setActive(false));
  }
  setForcer(e) {
    this.forcerFunction = e, e === void 0 && this.setActive(false);
  }
  updateUnconditionally() {
    const e = this.forcerFunction;
    return e === void 0 ? false : (e(), this.active);
  }
  setActive(e) {
    (this.active !== e || e === true) && (this.active = e, this.changed.dispatch());
  }
};
var sW = class extends Z {
  constructor(e, t) {
    super(), this.layerManager = e, this.mouseState = t, this.changed = new Ee(), this.needsUpdate = true, this.registerDisposer(t.changed.add(() => {
      this.handleChange();
    })), this.registerDisposer(e.layersChanged.add(() => {
      this.handleLayerChange();
    }));
  }
  /**
   * This should be called when the layer data may have changed, due to the set of managed layers
   * changing or new data having been received.
   */
  handleLayerChange() {
    this.mouseState.active && this.handleChange();
  }
  handleChange() {
    this.needsUpdate = true, this.changed.dispatch();
  }
  update() {
    if (!this.needsUpdate)
      return;
    this.needsUpdate = false;
    let e = this.mouseState;
    const t = this.changed.count;
    if (e.active)
      for (const i of this.layerManager.managedLayers) {
        const r = i.layer;
        if (i.visible && r !== null) {
          const s = r.selectionState;
          s && (r.resetSelectionState(s), s.generation = t, r.captureSelectionState(s, e));
        }
      }
  }
  get(e) {
    this.update();
    const t = e.selectionState;
    if (!(t && t.generation !== this.changed.count))
      return t;
  }
  toJSON() {
    this.update();
    const e = {};
    for (const t of this.layerManager.managedLayers) {
      const i = t.layer;
      if (i) {
        const r = this.get(i);
        r !== void 0 && (e[t.name] = i.selectionStateToJson(r, true));
      }
    }
    return e;
  }
};
var dx = 10;
var Pm = RZr(RZr({}, Ca), { minSize: 150, row: 1 });
var ux = RZr(RZr({}, Pm), { visible: true });
var aW = class extends Z {
  constructor(e, t) {
    super(), this.coordinateSpace = e, this.layerSelectedValues = t, this.changed = new Ee(), this.history = [], this.historyIndex = 0, this.location = new Ns(Pm), this.pin = new gt(true), this.registerDisposer(Ur((i, r) => {
      r || (this.capture(true), i.registerDisposer(t.changed.add(i.registerCancellable(zh(() => this.capture(true), 100, { leading: true, trailing: true })))));
    }, this.pin)), this.pin.changed.add(this.changed.dispatch), this.location.changed.add(this.changed.dispatch);
  }
  get value() {
    return this.value_;
  }
  goBack() {
    const e = this.pin.value ? this.historyIndex : this.history.length;
    e > 0 && (this.historyIndex = e - 1, this.value_ = this.history[e - 1], this.pin.value = true, this.changed.dispatch());
  }
  canGoBack() {
    return (this.pin.value ? this.historyIndex : this.history.length) > 0;
  }
  canGoForward() {
    return this.pin.value ? this.historyIndex + 1 < this.history.length : false;
  }
  goForward() {
    if (!this.pin.value)
      return;
    const e = this.historyIndex;
    e + 1 < this.history.length && (this.historyIndex = e + 1, this.value_ = this.history[e + 1], this.changed.dispatch());
  }
  set value(e) {
    if (e !== this.value_) {
      if (this.value_ = e, e !== void 0 && this.pin.value) {
        const t = this.history;
        t.length = Math.min(t.length, this.historyIndex + 1), t.push(e), t.length > dx && t.splice(0, t.length - dx), this.historyIndex = t.length - 1;
      }
      this.changed.dispatch();
    }
  }
  captureSingleLayerState(e, t, i = true, r = true) {
    if (i === false && (!this.location.visible || this.pin.value))
      return;
    const s = {};
    e.initializeSelectionState(s), t(s) && (r && (this.location.visible = true), i === true ? this.pin.value = true : i === "toggle" && (this.pin.value = !this.pin.value), this.value = {
      layers: [{ layer: e, state: s }],
      coordinateSpace: this.coordinateSpace.value,
      position: void 0
    });
  }
  reset() {
    this.location.reset(), this.pin.value = false, this.value = void 0;
  }
  toJSON() {
    const e = this.value;
    let t;
    if (this.location.visible) {
      if (t = this.location.toJSON(RZr(RZr({}, ux), { visible: !ws.expectingExternalUI })), this.pin.value && e !== void 0) {
        const i = {};
        for (const r of e.layers) {
          let a = r.layer.selectionStateToJson(r.state, false);
          un(a).length === 0 && (a = void 0), i[r.layer.managedLayer.name] = a;
        }
        e.position !== void 0 && (t.position = De(e.position)), t.layers = i;
      }
    } else
      t = this.location.toJSON(Pm), t = ya(t), t !== void 0 && (t.visible = false);
    return t;
  }
  select(e = true) {
    const t = this.pin;
    e && (this.location.visible = true), t.value = !t.value, t.value && this.capture();
  }
  capture(e = false) {
    const t = oW(this.layerSelectedValues);
    e && t === void 0 || (this.value = t);
  }
  restoreState(e) {
    if (e === void 0) {
      this.pin.value = true, this.value = void 0;
      return;
    }
    if (e === null) {
      this.pin.value = false, this.location.visible = true, this.value = void 0;
      return;
    }
    pe(e), this.location.restoreState(e, RZr(RZr({}, ux), { visible: !ws.expectingExternalUI }));
    const t = this.coordinateSpace.value, i = t.rank > 0 ? Ce(e, "position", (s) => at(new Float32Array(t.rank), s, Lt)) : void 0, r = [];
    Ce(e, "layers", (s) => {
      pe(s);
      const a = this.layerSelectedValues.layerManager;
      for (const d of Jc(s)) {
        var l = ce(d, 2);
        const u = l[0], f = l[1], g = a.getLayerByName(u);
        if (g === void 0)
          return;
        const v = g.layer;
        if (v === null)
          return;
        pe(f);
        const y = {};
        v.initializeSelectionState(y), v.selectionStateFromJson(y, f), r.push({ layer: v, state: y });
      }
    }), this.pin.value = r.length > 0 || i !== void 0, this.value = { position: i, coordinateSpace: t, layers: r };
  }
};
function oW(n) {
  const e = n.mouseState;
  if (!e.active)
    return;
  const t = [];
  for (const i of n.layerManager.managedLayers) {
    const r = i.layer;
    if (r === null)
      continue;
    const s = n.get(r);
    if (s === void 0)
      continue;
    const a = {};
    r.initializeSelectionState(a), r.copySelectionState(a, s), t.push({
      layer: r,
      state: a
    });
  }
  return {
    position: e.position.slice(),
    coordinateSpace: e.coordinateSpace,
    layers: t
  };
}
var lW = class extends Z {
  constructor(e) {
    super(), this.view = e, this.messages = new qo(), this.seenGeneration = -1, this.state = void 0;
  }
};
var cW = 0;
var dW = class extends Z {
  constructor(e, t, i, r, s, a) {
    super(), this.layerManager = e, this.renderLayerType = t, this.view = i, this.roles = r, this.layerAdded = s, this.visibility = a, this.visibleLayers_ = new de(), this.debouncedUpdateVisibleLayers = this.registerCancellable(lt(() => this.updateVisibleLayers(), 0)), this.registerDisposer(e.layersChanged.add(this.debouncedUpdateVisibleLayers)), this.registerDisposer(r.changed.add(this.debouncedUpdateVisibleLayers)), this.updateVisibleLayers();
  }
  disposed() {
    this.visibleLayers.forEach((e) => e.dispose()), this.visibleLayers.clear(), super.disposed();
  }
  updateVisibleLayers() {
    const e = ++cW, t = this.visibleLayers_, i = this.renderLayerType, r = this.layerAdded, s = this.roles;
    for (let l of this.layerManager.readyRenderLayers())
      if (l instanceof i && s.has(l.role)) {
        let d = l, u = t.get(d);
        u === void 0 && (u = new lW(this.view), u.registerDisposer(d.messages.addChild(u.messages)), u.registerDisposer(d.addRef()), u.registerDisposer(d.visibility.add(this.visibility)), t.set(d, u), r(d, u), d.attach(u)), u.seenGeneration = e;
      }
    for (const l of t) {
      var a = ce(l, 2);
      const d = a[0], u = a[1];
      u.seenGeneration !== e && (t.delete(d), u.dispose());
    }
  }
  get visibleLayers() {
    return this.debouncedUpdateVisibleLayers.flush(), this.visibleLayers_;
  }
};
function YI(n, e, t, i, r) {
  return i.registerDisposer(new dW(n, e, i, t, (s, a) => {
    a.registerDisposer(s.redrawNeeded.add(() => i.scheduleRedraw()));
    const l = s.backend;
    l && (l.rpc.invoke(vO, { layer: l.rpcId, view: i.rpcId }), a.registerDisposer(() => l.rpc.invoke(yO, { layer: l.rpcId, view: i.rpcId }))), r !== void 0 && r(s, a), i.scheduleRedraw(), a.registerDisposer(() => i.scheduleRedraw());
  }, i.visibility));
}
var uW = class extends Z {
  constructor(e) {
    super(), this.layerManager = e, this.changed = new Ee(), this.location = new Ns(rz), this.registerDisposer(e), this.location.changed.add(() => {
      var t, i;
      this.changed.dispatch();
      const r = (i = (t = this.layer) === null || t === void 0 ? void 0 : t.layer) !== null && i !== void 0 ? i : void 0;
      if (r !== void 0) {
        const s = this.location.value;
        if (s.visible) {
          const a = r.panels.panels[0];
          a.location.value !== s && (a.location.value = s, a.location.locationChanged.dispatch());
        }
      }
    });
  }
  get layer() {
    return this.layer_;
  }
  get visible() {
    return this.location.visible;
  }
  toggle(e) {
    this.layer === e && this.visible ? this.visible = false : (this.layer = e, this.visible = true);
  }
  set visible(e) {
    let t = this.layer_;
    if (e === true && t === void 0) {
      const i = this.layerManager.managedLayers;
      i.length > 0 ? t = this.layer = i[0] : e = false;
    }
    if (e === true && t !== void 0) {
      const i = t.layer;
      (i === null || i.panels.panels[0].tabs.length === 0) && (e = false);
    }
    this.visible !== e && (this.location.visible = e, !e && t !== void 0 && this.maybeDeleteNewLayer(t), this.changed.dispatch());
  }
  maybeDeleteNewLayer(e) {
    if (e.wasDisposed)
      return;
    const t = e.layer;
    t !== null && t instanceof Hr && (t.dataSources.some((i) => i.spec.url.length !== 0) || ll(e));
  }
  set layer(e) {
    if (e === this.layer_)
      return;
    const t = this.layer_;
    if (t !== void 0 && (this.existingLayerDisposer(), this.existingLayerDisposer = void 0, this.maybeDeleteNewLayer(t)), this.layer_ = e, e !== void 0) {
      const i = () => {
        this.layer_ = void 0, this.visible = false, this.existingLayerDisposer = void 0, this.changed.dispatch();
      };
      e.registerDisposer(i);
      const r = e.specificationChanged.add(() => {
        this.changed.dispatch();
      });
      this.existingLayerDisposer = () => {
        const s = e.layer;
        if (s !== null) {
          const a = s.tool.value;
          a !== void 0 && a.deactivate();
        }
        e.unregisterDisposer(i), r();
      };
    } else
      this.location.visible = false;
    this.changed.dispatch();
  }
  toJSON() {
    const e = this.location.toJSON();
    return this.layer !== void 0 && (e.layer = this.layer.name), ya(e);
  }
  restoreState(e) {
    if (e === void 0) {
      this.reset();
      return;
    }
    pe(e), this.location.restoreState(e);
    const t = K(e, "layer", xi), i = t !== void 0 ? this.layerManager.getLayerByName(t) : void 0;
    i === void 0 && (this.visible = false), this.layer = i;
  }
  reset() {
    this.location.reset(), this.layer = void 0;
  }
};
var hW = class extends Z {
  constructor(e, t) {
    super(), this.layerManager = e, this.filter = t, this.changed = new Ee(), this.validate = lt(() => {
      const i = this.layerName_;
      if (i !== void 0) {
        const r = this.layerManager.getLayerByName(i);
        r !== void 0 && this.filter(r) ? (this.layer_ = r, this.changed.dispatch()) : (this.layer_ = void 0, this.layerName_ = void 0, this.changed.dispatch());
      }
    }, 0), this.registerDisposer(e), this.registerDisposer(e.specificationChanged.add(() => {
      const i = this.layer_;
      if (i !== void 0)
        if (!this.layerManager.layerSet.has(i) || !this.filter(i))
          this.layer_ = void 0, this.layerName_ = void 0, this.changed.dispatch();
        else {
          const r = i.name;
          r !== this.layerName_ && (this.layerName_ = r, this.changed.dispatch());
        }
    }));
  }
  get layer() {
    return this.layer_;
  }
  get layerName() {
    return this.layerName_;
  }
  set layer(e) {
    this.layer_ !== e && (e !== void 0 && this.layerManager.layerSet.has(e) && this.filter(e) ? (this.layer_ = e, this.layerName_ = e.name) : (this.layer_ = void 0, this.layerName_ = void 0), this.changed.dispatch());
  }
  set layerName(e) {
    e !== this.layerName_ && (this.layer_ = void 0, this.layerName_ = e, this.changed.dispatch(), this.validate());
  }
  restoreState(e) {
    const t = xi(e);
    this.layerName = t;
  }
  toJSON() {
    const e = this.layer_;
    return e !== void 0 ? e.name : this.layerName_;
  }
  reset() {
    this.layerName_ = void 0, this.layer_ = void 0, this.changed.dispatch();
  }
};
var hx = class extends Z {
  constructor(e, t, i, r) {
    super(), this.layerManager = e, this.layer = t, this.predicate = i, this.getGroup = r, this.linkedLayers_ = new je(), this.changed = new Ee(), this.linkedLayersChanged = new Ee(), this.root_ = t;
    const s = this;
    this.root = {
      get value() {
        return s.root_;
      },
      changed: s.changed
    };
  }
  get linkedLayers() {
    return this.linkedLayers_;
  }
  get rootGroup() {
    return this.getGroup(this.root.value);
  }
  reset() {
    this.isolate();
  }
  restoreState(e) {
    if (e === void 0)
      return;
    const t = Le(e);
    this.linkByName(t);
  }
  toJSON() {
    const e = this.root.value;
    if (e !== this.layer)
      return e.managedLayer.name;
  }
  isolate(e = true) {
    const t = this.getGroup, i = this.layer, r = this.root_;
    if (r === i) {
      const a = this.linkedLayers_;
      if (a.size !== 0) {
        for (const l of a) {
          const d = t(l);
          d.root_ = l, d.changed.dispatch();
        }
        a.clear(), this.linkedLayersChanged.dispatch();
      }
      return;
    }
    const s = t(r);
    s.linkedLayers_.delete(i), s.linkedLayersChanged.dispatch(), this.root_ = i, e && this.changed.dispatch();
  }
  linkByName(e) {
    const i = this.layer.managedLayer, s = this.layerManager.getLayerByName(e);
    if (s === void 0 || s === i)
      return;
    const a = s.layer;
    a !== null && this.predicate(a) && this.linkToLayer(a);
  }
  linkToLayer(e) {
    if (e === this.layer || this.root_ === e)
      return;
    this.root_ !== this.layer && this.isolate(
      /*notifyChanged=*/
      false
    );
    const t = this.getGroup, i = t(e).root_;
    if (i === this.layer)
      return;
    const r = t(i);
    r.linkedLayers_.add(this.layer), r.linkedLayersChanged.dispatch(), this.root_ = i, this.changed.dispatch();
  }
  disposed() {
    this.isolate(
      /*notifyChanged=*/
      false
    );
  }
};
function qI(n, e) {
  const t = Ce(e, "type", Le, "auto");
  n.archived = Ce(e, "archived", la, false), n.archived ? n.visible = false : n.visible = Ce(e, "visible", la, true);
  const i = Qu.get(t) || Hr;
  return n.layer = new i(n), e;
}
function KI(n, e) {
  try {
    const t = n.layer;
    if (t === null)
      return;
    t.restoreState(e), t.initializationDone();
  } catch (t) {
    throw ll(n), t;
  }
}
function ZI(n, e) {
  try {
    pe(e), qI(n, e), KI(n, e);
  } catch (t) {
    throw ll(n), t;
  }
}
function fW(n, e) {
  try {
    ZI(n, e);
  } catch (t) {
    new nt().setErrorMessage(t instanceof Error ? t.message : "" + t);
  }
}
function XI(n, e, t) {
  const i = new Uy(e, n);
  return ZI(i, t), i;
}
var QI = class extends Z {
  constructor() {
    super(...arguments), this.changed = new Ee();
  }
};
var pW = class extends QI {
  constructor(e, t, i, r, s, a, l, d, u) {
    super(), this.display = e, this.dataSourceProviderRegistry = t, this.layerManager = i, this.chunkManager = r, this.selectionState = s, this.selectedLayer = a, this.coordinateSpace = l, this.globalPosition = d, this.toolBinder = u, this.coordinateSpaceCombiner = new Gv2(this.coordinateSpace, G2), this.subsets = new je(), this.layerSelectedValues = this.selectionState.layerSelectedValues, this.registerDisposer(i.layersChanged.add(this.changed.dispatch)), this.registerDisposer(i.specificationChanged.add(this.changed.dispatch));
  }
  get rpc() {
    return this.chunkManager.rpc;
  }
  get root() {
    return this;
  }
  reset() {
    this.layerManager.clear();
  }
  restoreState(e) {
    this.layerManager.clear();
    let t;
    Array.isArray(e) ? t = e : (pe(e), t = Jc(e).map(([r, s]) => typeof s == "string" ? { name: r, source: s } : (pe(s), RZr(RZr({}, s), { name: r }))));
    const i = [];
    for (const r of t) {
      pe(r);
      const s = this.layerManager.getUniqueLayerName(K(r, "name", Le)), a = new Uy(s, this);
      try {
        qI(a, r), this.layerManager.addManagedLayer(a), i.push({ managedLayer: a, spec: r });
      } catch (l) {
        a.dispose(), new nt().setErrorMessage(`Error creating layer ${se(s)}: ` + (l instanceof Error) ? l.message : "" + l);
      }
    }
    for (const r of i) {
      const s = r.managedLayer, a = r.spec;
      try {
        KI(s, a);
      } catch (l) {
        new nt().setErrorMessage(`Error creating layer ${se(name)}: ` + (l instanceof Error) ? l.message : "" + l);
      }
    }
  }
  add(e, t) {
    this.layerManager.managedLayers.indexOf(e) === -1 && (e.name = this.layerManager.getUniqueLayerName(e.name)), this.layerManager.addManagedLayer(e, t);
  }
  toJSON() {
    const e = [];
    let t = 0;
    for (let i of this.layerManager.managedLayers) {
      const r = i.toJSON();
      r != null && (e.push(r), ++t);
    }
    if (t !== 0)
      return e;
  }
  get rootLayers() {
    return this.layerManager;
  }
};
var eL = class extends QI {
  constructor(e) {
    super(), this.master = e, this.changed = new Ee(), this.layerManager = this.registerDisposer(new JI()), this.registerDisposer(e);
    const t = this.layerManager;
    this.registerDisposer(t.layersChanged.add(this.changed.dispatch)), this.registerDisposer(t.specificationChanged.add(this.changed.dispatch)), e.subsets.add(this);
  }
  get rpc() {
    return this.master.rpc;
  }
  get dataSourceProviderRegistry() {
    return this.master.dataSourceProviderRegistry;
  }
  get chunkManager() {
    return this.master.chunkManager;
  }
  get layerSelectedValues() {
    return this.master.layerSelectedValues;
  }
  get root() {
    return this.master;
  }
  disposed() {
    super.disposed(), this.master.subsets.delete(this);
  }
  reset() {
    this.layerManager.clear();
  }
  restoreState(e) {
    const t = this.master.layerManager, i = [];
    for (const r of new je(Je(e, Le))) {
      const s = t.getLayerByName(r);
      if (s === void 0)
        throw new Error(`Undefined layer referenced in subset specification: ${se(r)}`);
      s.archived || i.push(s);
    }
    this.layerManager.clear();
    for (const r of i)
      this.layerManager.addManagedLayer(r.addRef());
  }
  toJSON() {
    return this.layerManager.managedLayers.map((e) => e.name);
  }
  add(e, t) {
    this.master.layerManager.managedLayers.indexOf(e) === -1 && (e.name = this.master.layerManager.getUniqueLayerName(e.name), this.master.layerManager.addManagedLayer(e.addRef())), this.layerManager.addManagedLayer(e, t);
  }
  get rootLayers() {
    return this.master.rootLayers;
  }
};
var Qu = new de();
var zy = new de();
var tL = [(n) => {
  const e = n.volume;
  if (e === void 0)
    return;
  const t = zy.get(e.volumeType);
  if (t !== void 0)
    return { layerConstructor: t, priority: 0 };
}];
function ol(n, e = n.type) {
  Qu.set(e, n);
}
function Gy(n) {
  tL.push(n);
}
function nL(n, e) {
  zy.set(n, e);
}
function $y(n, e) {
  const t = n.layer;
  if (t === null)
    return;
  const i = t.toJSON(), r = new e(n);
  r.restoreState(i), r.initializationDone(), n.layer = r;
}
function iL(n, e) {
  return e !== n.name ? (e = n.manager.root.layerManager.getUniqueLayerName(e), n.name = e, n.layerChanged.dispatch(), true) : false;
}
function ll(n) {
  if (!n.wasDisposed)
    for (const e of n.containers)
      e.removeManagedLayer(n);
}
function Am(n, e) {
  return n === void 0 ? e : e === void 0 ? n : n.priority < e.priority ? e : n;
}
function gW(n) {
  let e;
  for (const i of tL)
    e = Am(e, i(n));
  const t = n.volume;
  if (t !== void 0) {
    const i = zy.get(t.volumeType);
    i !== void 0 && (e = Am(e, { layerConstructor: i, priority: 0 }));
  }
  return e;
}
function rL(n) {
  let e;
  for (const t of n) {
    const r = t.subsourceEntry.subsource;
    e = Am(e, gW(r));
  }
  return e;
}
var Hr = class extends al {
  activateDataSubsources(e) {
    var t;
    this.detectedLayerConstructor = (t = rL(e)) === null || t === void 0 ? void 0 : t.layerConstructor;
  }
};
Hr.type = "new";
Hr.typeAbbreviation = "new";
var Wy = class extends al {
  activateDataSubsources(e) {
    var t;
    const i = (t = rL(e)) === null || t === void 0 ? void 0 : t.layerConstructor;
    i !== void 0 && $y(this.managedLayer, i);
  }
};
Wy.type = "auto";
Wy.typeAbbreviation = "auto";
function sL(n, e) {
  const t = XI(n, "new layer", { type: "new" });
  n.add(t), e.layer = t, e.visible = true;
}
ol(Hr);
ol(Wy);
function fx(n, e) {
  return e = ir(e, 3432918353) >>> 0, e = (e << 15 | e >>> 17) >>> 0, e = ir(e, 461845907) >>> 0, n ^= e, n = (n << 13 | n >>> 19) >>> 0, n = ir(n, 5) + 3864292196 >>> 0, n;
}
function mW(n, e) {
  return n ^= e, n ^= n >>> 16, n = ir(n, 2246822507) >>> 0, n ^= n >>> 13, n *= 3266489909, n ^= n >>> 16, n >>> 0;
}
function aL(n, e, t) {
  let i = n;
  return i = fx(i, e), i = fx(i, t), mW(i, 8);
}
var vW = class extends Yr {
  constructor(e, t) {
    super(e, t), this.properties = t.properties;
  }
  static encodeOptions(e) {
    return { properties: e.properties };
  }
};
function yW(n, e, t) {
  const i = n.length - 1;
  for (; ; ) {
    if (e = e & i, n[e] === 0) {
      n[e] = t;
      return;
    }
    ++e;
  }
}
function eh(n, e) {
  return e <= 255 ? new Uint8Array(n) : e <= 65535 ? new Uint16Array(n) : new Uint32Array(n);
}
function SW(n) {
  const e = n.length / 2, i = 2 ** (Math.ceil(Zn(e)) + 1), r = eh(i, e + 1);
  for (let s = 0; s < e; ++s) {
    const a = n[2 * s], l = n[2 * s + 1];
    yW(r, aL(
      /*seed=*/
      0,
      a,
      l
    ), s + 1);
  }
  return r;
}
function bW(n, e, t, i) {
  let r = aL(
    /*seed=*/
    0,
    t,
    i
  );
  const s = n.length - 1;
  for (; ; ) {
    r = r & s;
    let a = n[r];
    if (a === 0)
      return -1;
    if (--a, e[2 * a] === t && e[2 * a + 1] === i)
      return a;
    ++r;
  }
}
var oL = class {
  constructor(e) {
    this.inlineProperties = e.inlineProperties;
  }
};
var CW = class {
  constructor(e) {
    var t;
    this.segmentPropertyMap = e;
    const i = e.inlineProperties;
    i !== void 0 && (this.inlineIdToIndex = SW(i.ids)), this.tags = i == null ? void 0 : i.properties.find((r) => r.type === "tags"), this.labels = i == null ? void 0 : i.properties.find((r) => r.type === "label"), this.numericalProperties = (t = i == null ? void 0 : i.properties.filter((r) => r.type === "number")) !== null && t !== void 0 ? t : [];
  }
  getSegmentInlineIndex(e) {
    const t = this.inlineIdToIndex;
    return t === void 0 ? -1 : bW(t, this.segmentPropertyMap.inlineProperties.ids, e.low, e.high);
  }
  getSegmentLabel(e) {
    const t = this.getSegmentInlineIndex(e);
    if (t === -1)
      return;
    const i = this.labels, r = this.tags;
    let s = "";
    if (i !== void 0 && (s = i.values[t]), r !== void 0) {
      const a = r.tags;
      let d = r.values[t];
      for (let u = 0, f = d.length; u < f; ++u) {
        const g = a[d.charCodeAt(u)];
        s.length > 0 && (s += " "), s += "#", s += g;
      }
    }
    if (s.length !== 0)
      return s;
  }
};
function lL(n, e, t) {
  for (let i = 0, r = t.length; i < r; ++i)
    e[t[i]] = n[i];
}
function wW(n) {
  const e = n.length;
  if (e === 0)
    return true;
  let t = n[0], i = n[1];
  for (let r = 0; r < e; r += 2) {
    const s = n[r], a = n[r + 1];
    if ((a - i || s - t) <= 0)
      return false;
    t = s, i = a;
  }
  return true;
}
function xW(n) {
  const e = n.ids;
  if (wW(e))
    return n;
  const t = e.length / 2, i = eh(t, t - 1);
  for (let a = 0; a < t; ++a)
    i[a] = a;
  i.sort((a, l) => {
    const d = e[a * 2], u = e[a * 2 + 1], f = e[l * 2], g = e[l * 2 + 1];
    return u - g || d - f;
  });
  const r = new Uint32Array(t * 2);
  for (let a = 0; a < t; ++a) {
    const l = i[a];
    r[a * 2] = e[l * 2], r[a * 2 + 1] = e[l * 2 + 1];
  }
  const s = n.properties.map((a) => {
    const l = a.values, d = new l.constructor(t);
    for (let u = 0; u < t; ++u)
      d[u] = l[i[u]];
    return RZr(RZr({}, a), { values: d });
  });
  return { ids: r, properties: s };
}
function EW(n, e, t) {
  const i = new Array(e);
  return i.fill(""), lL(n.values, i, t), RZr(RZr({}, n), { values: i });
}
function TW(n, e, t) {
  const i = new Float32Array(e);
  return i.fill(Number.NaN), lL(n.values, i, t), RZr(RZr({}, n), { values: i });
}
function px(n, e, t) {
  const i = n.type;
  return i === "label" || i === "description" || i === "string" || i === "tags" ? EW(n, e, t) : TW(n, e, t);
}
function kW(n, e) {
  if (n === void 0)
    return e;
  if (e === void 0)
    return n;
  let t = 0;
  const i = n.ids.length / 2, r = e.ids.length / 2, s = new Uint32Array(i), a = new Uint32Array(r), l = n.ids, d = e.ids;
  bN(i, r, (g, v) => {
    const y = l[2 * g + 1], w = l[2 * g], C = d[2 * v + 1], b = d[2 * v];
    return y - C || w - b;
  }, (g) => {
    s[g] = t, ++t;
  }, (g) => {
    a[g] = t, ++t;
  }, (g, v) => {
    s[g] = t, a[v] = t, ++t;
  });
  let u;
  if (t === i)
    u = l;
  else if (t === r)
    u = d;
  else {
    u = new Uint32Array(t * 2);
    for (let g = 0; g < i; ++g) {
      const v = s[g];
      u[2 * v] = l[2 * g], u[2 * v + 1] = l[2 * g + 1];
    }
    for (let g = 0; g < r; ++g) {
      const v = a[g];
      u[2 * v] = d[2 * g], u[2 * v + 1] = d[2 * g + 1];
    }
  }
  const f = [];
  if (t === i)
    f.push(...n.properties);
  else
    for (const g of n.properties)
      f.push(px(g, t, s));
  if (t === r)
    f.push(...e.properties);
  else
    for (const g of e.properties)
      f.push(px(g, t, a));
  return { ids: u, properties: f };
}
function IW(n, e) {
  return new oL({
    inlineProperties: kW(n.inlineProperties, e.inlineProperties)
  });
}
function LW(n) {
  for (; ; ) {
    if (n.length === 0)
      return;
    if (n.length === 1)
      return n[0];
    const e = [];
    for (let t = 0, i = n.length; t < i; t += 2)
      t + 1 === i ? e.push(n[t]) : e.push(IW(n[t], n[t + 1]));
    n = e;
  }
}
function DW(n, e) {
  return n.memoize.getUncounted({ id: "getPreprocessedSegmentPropertyMap", maps: e.map((t) => xn(t)) }, () => {
    const t = LW(e);
    if (t !== void 0)
      return new CW(t);
  });
}
var PW = /^[,\s]*[0-9]+(?:[,\s]+[0-9]+)*[,\s]*$/;
function AW(n, e) {
  var t;
  if (e.match(PW) !== null) {
    const g = e.split(/[\s,]+/), v = [], y = new je();
    for (let w = 0, C = g.length; w < C; ++w) {
      const b = g[w];
      if (b === "")
        continue;
      const E = new re();
      if (!E.tryParseString(b))
        continue;
      const L = E.toString();
      y.has(L) || (y.add(L), v.push(E));
    }
    return v.sort(re.compare), { ids: v };
  }
  const i = {
    regexp: void 0,
    prefix: void 0,
    includeTags: [],
    excludeTags: [],
    numericalConstraints: [],
    sortBy: [],
    includeColumns: []
  }, r = (t = n == null ? void 0 : n.segmentPropertyMap.inlineProperties) === null || t === void 0 ? void 0 : t.properties, s = n == null ? void 0 : n.tags, a = (s == null ? void 0 : s.tags) || [], l = a.map((g) => g.toLowerCase()), d = n == null ? void 0 : n.labels, u = [];
  let f;
  for (let g = 0; g < e.length; g = f) {
    let v = e.indexOf(" ", g), y;
    if (v === -1 ? f = v = e.length : f = v + 1, y = e.substring(g, v), y.length === 0)
      continue;
    const w = (b, E) => {
      const L = b.toLowerCase(), R = l.indexOf(L);
      if (R === -1) {
        u.push({ begin: E, end: v, message: `Invalid tag: ${b}` });
        return;
      }
      if (b = a[R], i.includeTags.includes(b) || i.excludeTags.includes(b)) {
        u.push({ begin: E, end: v, message: `Duplicate tag: ${b}` });
        return;
      }
      return b;
    };
    if (y.startsWith("#")) {
      const b = w(y.substring(1), g + 1);
      b !== void 0 && i.includeTags.push(b);
      continue;
    }
    if (y.startsWith("-#")) {
      const b = w(y.substring(2), g + 2);
      b !== void 0 && i.excludeTags.push(b);
      continue;
    }
    if (y.startsWith("<") || y.startsWith(">")) {
      let b = y.substring(1).toLowerCase();
      if (b !== "id" && b !== "label") {
        const E = r == null ? void 0 : r.find((L) => L.id.toLowerCase() === b && (L.type === "number" || L.type === "label" || L.type === "string"));
        if (E === void 0) {
          u.push({ begin: g + 1, end: v, message: `Invalid field: ${b}` });
          continue;
        }
        b = E.id;
      }
      if (i.sortBy.find((E) => E.fieldId === b) !== void 0) {
        u.push({ begin: g + 1, end: v, message: `Duplicate sort field: ${b}` });
        continue;
      }
      i.sortBy.push({ order: y[0], fieldId: b });
      continue;
    }
    if (y.startsWith("|")) {
      let b = y.substring(1).toLowerCase();
      if (b === "id" || b === "label")
        continue;
      const E = r == null ? void 0 : r.find((L) => L.id.toLowerCase() === b && (L.type === "number" || L.type === "string"));
      if (E === void 0) {
        u.push({ begin: g + 1, end: v, message: `Invalid field: ${b}` });
        continue;
      }
      if (b = E.id, i.sortBy.find((L) => L.fieldId === b) || i.includeColumns.find((L) => L === b))
        continue;
      i.includeColumns.push(b);
      continue;
    }
    if (y.startsWith("/")) {
      if (i.regexp !== void 0) {
        u.push({ begin: g, end: v, message: "Only one regular expression allowed" });
        continue;
      }
      if (i.prefix !== void 0) {
        u.push({
          begin: g,
          end: v,
          message: "Prefix cannot be combined with regular expression"
        });
        continue;
      }
      if (d === void 0) {
        u.push({ begin: g, end: v, message: "No label property" });
        continue;
      }
      try {
        i.regexp = new RegExp(y.substring(1));
      } catch {
        u.push({ begin: g, end: v, message: "Invalid regular expression syntax" });
      }
      continue;
    }
    const C = y.match(/^([a-zA-Z][a-zA-Z0-9_]*)(<|<=|=|>=|>)([0-9.].*)$/);
    if (C !== null) {
      let b = C[1].toLowerCase();
      const E = C[2], L = n == null ? void 0 : n.numericalProperties.find((O) => O.id.toLowerCase() === b);
      if (L === void 0) {
        u.push({
          begin: g,
          end: g + b.length,
          message: `Invalid numerical field: ${b}`
        });
        continue;
      }
      b = L.id;
      let R;
      try {
        R = Vc(L.dataType, C[3]);
      } catch (O) {
        u.push({
          begin: g + C[1].length + C[2].length,
          end: v,
          message: O.message
        });
        continue;
      }
      let _ = i.numericalConstraints.find((O) => O.fieldId === b);
      _ === void 0 && (_ = { fieldId: b, bounds: L.bounds }, i.numericalConstraints.push(_));
      const A = fc(L.bounds, _.bounds[0]), I = fc(L.bounds, _.bounds[1]);
      let P = I, N = A;
      switch (E) {
        case "<":
          P = Du(L.dataType, R, -1);
          break;
        case "<=":
          P = R;
          break;
        case "=":
          P = N = R;
          break;
        case ">=":
          N = R;
          break;
        case ">":
          N = Du(L.dataType, R, 1);
          break;
      }
      if (N = Ei(A, N) > 0 ? A : N, P = Ei(I, P) < 0 ? I : P, Ei(N, P) > 0) {
        u.push({ begin: g, end: v, message: "Constraint would not match any values" });
        continue;
      }
      _.bounds = [N, P];
      continue;
    }
    if (i.regexp !== void 0) {
      u.push({
        begin: g,
        end: v,
        message: "Prefix cannot be combined with regular expression"
      });
      continue;
    }
    if (d === void 0) {
      u.push({ begin: g, end: v, message: "No label property" });
      continue;
    }
    i.prefix !== void 0 ? i.prefix += ` ${y}` : i.prefix = y;
  }
  return u.length > 0 ? { errors: u } : (i.sortBy.length === 0 && i.sortBy.push({ fieldId: cL(n), order: "<" }), i);
}
function lg(n) {
  return "\\u" + n.toString(16).padStart(4, "0");
}
function RW(n, e) {
  var t;
  if (e.errors !== void 0)
    return { query: e, total: -1, count: 0, errors: e.errors };
  if (e.ids !== void 0) {
    const A = e.ids;
    return { query: e, total: -1, explicitIds: A, count: A.length };
  }
  const i = (t = n == null ? void 0 : n.segmentPropertyMap) === null || t === void 0 ? void 0 : t.inlineProperties;
  if (i === void 0)
    return {
      query: e,
      count: 0,
      total: -1
    };
  const r = i == null ? void 0 : i.properties, s = i.ids.length / 2;
  let a = eh(s, s);
  for (let A = 0; A < s; ++A)
    a[A] = A;
  const l = (A) => {
    let I = a.length, P = 0;
    for (let N = 0; N < I; ++N) {
      const O = a[N];
      A(O) && (a[P] = O, ++P);
    }
    a = a.subarray(0, P);
  };
  if (e.regexp !== void 0 || e.prefix !== void 0) {
    const A = n.labels.values, I = e.regexp, P = e.prefix;
    I !== void 0 && l((N) => A[N].match(I) !== null), P !== void 0 && l((N) => A[N].startsWith(P));
  }
  const d = e.includeTags, u = e.excludeTags, f = n.tags;
  if (d.length > 0 || u.length > 0) {
    const A = f.values, I = f.tags, P = [];
    for (const U of d)
      P.push([I.indexOf(U), 1]);
    for (const U of u)
      P.push([I.indexOf(U), 0]);
    P.sort((U, V) => U[0] - V[0]);
    let N = "^", O = 0;
    const B = (U) => {
      U < O || (N += `[${lg(O)}-${lg(U)}]*`);
    };
    for (const U of P) {
      var g = ce(U, 2);
      const V = g[0], G = g[1];
      B(V - 1), G && (N += lg(V)), O = V + 1;
    }
    B(65535), N += "$";
    const j = new RegExp(N);
    l((U) => A[U].match(j) !== null);
  }
  let v, y;
  const w = e.numericalConstraints;
  if (w.length > 0) {
    const A = n.numericalProperties, I = w.length, P = 2 ** I - 1;
    v = eh(a.length, P);
    for (let B = 0; B < I; ++B) {
      const j = w[B], V = A.find((ae) => ae.id === j.fieldId).values, G = 2 ** B;
      var C = ce(j.bounds, 2);
      const F = C[0], ue = C[1];
      for (let ae = 0, Ie = a.length; ae < Ie; ++ae) {
        const le = V[a[ae]];
        v[ae] |= G * (le >= F && le <= ue);
      }
    }
    y = a, a = y.slice();
    let N = a.length, O = 0;
    for (let B = 0; B < N; ++B)
      v[B] === P && (a[O] = a[B], ++O);
    a = a.subarray(0, O);
  }
  let b = [];
  if (f !== void 0) {
    const A = [], I = f.tags, P = f.values, N = new Uint32Array(I.length);
    for (let O = 0, B = a.length; O < B; ++O) {
      const j = P[a[O]];
      for (let U = 0, V = j.length; U < V; ++U)
        ++N[j.charCodeAt(U)];
    }
    for (let O = 0, B = I.length; O < B; ++O) {
      const j = N[O], U = I[O], V = { tag: U, tagIndex: O, count: N[O] };
      e.includeTags.includes(U) || e.excludeTags.includes(U) ? A.push(V) : j > 0 && b.push(V);
    }
    A.push(...b), b = A;
  }
  const E = (A, I) => {
    if (A.type !== "number") {
      const P = A.values;
      a.sort((N, O) => jc(P[N], P[O]) * I);
    } else {
      const P = A.values;
      a.sort((N, O) => (P[N] - P[O]) * I);
    }
  }, L = (A) => {
    f !== void 0 && E(f, A);
    const I = n == null ? void 0 : n.labels;
    I !== void 0 && E(I, A);
  }, R = e.sortBy;
  for (let A = R.length - 1; A >= 0; --A) {
    var _ = R[A];
    const I = _.fieldId, P = _.order, N = P === "<" ? 1 : -1;
    if (I === "id") {
      if (A + 1 === R.length) {
        if (P === "<")
          continue;
        a.reverse();
        continue;
      }
      a.sort((O, B) => N * (O - B));
      continue;
    } else
      I === "label" ? L(N) : E(r.find((O) => O.id === I), N);
  }
  return {
    query: e,
    intermediateIndices: y,
    intermediateIndicesMask: v,
    indices: a,
    tags: b,
    count: a.length,
    total: s
  };
}
function MW(n, e, t) {
  const r = e.values;
  var s = ce(t, 2);
  const a = s[0], l = s[1], d = l <= a ? 0 : 256 / (l - a), u = new Uint32Array(256 + 2), f = n.query.numericalConstraints, g = f.findIndex((v) => v.fieldId === e.id);
  if (g === -1) {
    const v = n.indices;
    for (let y = 0, w = v.length; y < w; ++y) {
      const C = r[v[y]];
      isNaN(C) || ++u[Math.min(256 - 1, Math.max(-1, (C - a) * d)) + 1 >>> 0];
    }
  } else {
    const v = n.intermediateIndices, y = n.intermediateIndicesMask, w = 2 ** f.length - 1 - 2 ** g;
    for (let C = 0, b = v.length; C < b; ++C)
      if ((y[C] & w) == w) {
        const L = r[v[C]];
        isNaN(L) || ++u[Math.min(256 - 1, Math.max(-1, (L - a) * d)) + 1 >>> 0];
      }
  }
  return { queryResult: n, histogram: u, window: t };
}
function NW(n, e, t, i) {
  if (n === void 0) {
    t.length = 0, i.length = 0;
    return;
  }
  const r = n.numericalProperties, s = r.length;
  if ((e == null ? void 0 : e.indices) === void 0) {
    t.length = 0;
    return;
  }
  for (let l = 0; l < s; ++l) {
    const d = t[l], u = i[l], f = r[l];
    d !== void 0 && d.queryResult === e && Mr(f.dataType, d.window, u) || (t[l] = MW(e, f, u));
  }
}
function cL(n) {
  return (n == null ? void 0 : n.tags) || (n == null ? void 0 : n.labels) ? "label" : "id";
}
function _W(n, e) {
  var t = e;
  const i = t.ids;
  if (i !== void 0)
    return i.map((g) => g.toString()).join(", ");
  let r = "";
  e = e;
  var s = e;
  const a = s.prefix, l = s.regexp;
  a !== void 0 ? r = a : l !== void 0 && (r = `/${l}`);
  for (const g of e.includeTags)
    r.length > 0 && (r += " "), r += `#${g}`;
  for (const g of e.excludeTags)
    r.length > 0 && (r += " "), r += `-#${g}`;
  for (const g of e.numericalConstraints) {
    const v = g.fieldId, y = g.bounds;
    var d = ce(y, 2);
    const w = d[0], C = d[1], b = n.numericalProperties.find((E) => E.id === v);
    if (!Mr(b.dataType, b.bounds, y)) {
      if (Ei(w, C) === 0) {
        r.length > 0 && (r += " "), r += `${v}=${w}`;
        continue;
      }
      if (Ei(w, b.bounds[0]) > 0) {
        r.length > 0 && (r += " ");
        const E = Du(b.dataType, w, -1), L = w.toString(), R = E.toString();
        b.dataType !== J.FLOAT32 || L.length <= R.length ? r += `${v}>=${L}` : r += `${v}>${R}`;
      }
      if (Ei(C, b.bounds[1]) < 0) {
        r.length > 0 && (r += " ");
        const E = Du(b.dataType, C, 1), L = C.toString(), R = E.toString();
        b.dataType !== J.FLOAT32 || L.length <= R.length ? r += `${v}<=${L}` : r += `${v}<${R}`;
      }
    }
  }
  var u = e;
  let f = u.sortBy;
  if (f.length === 1) {
    const g = f[0];
    g.order === "<" && g.fieldId === cL(n) && (f = []);
  }
  for (const g of f)
    r.length > 0 && (r += " "), r += `${g.order}${g.fieldId}`;
  for (const g of e.includeColumns)
    r.length > 0 && (r += " "), r += `|${g}`;
  return r;
}
var cg = new re();
function yu(n, e, t) {
  if (e === void 0)
    return;
  const i = e.explicitIds;
  if (i !== void 0) {
    i.forEach(t);
    return;
  }
  const r = e.indices;
  if (r !== void 0) {
    var s = n == null ? void 0 : n.segmentPropertyMap.inlineProperties;
    const a = s.ids;
    for (let l = 0, d = r.length; l < d; ++l) {
      const u = r[l];
      cg.low = a[u * 2], cg.high = a[u * 2 + 1], t(cg, l);
    }
  }
}
function OW(n, e, t) {
  if (t.size === 0)
    return 0;
  let i = 0;
  return yu(n, e, (r) => {
    t.has(r) && ++i;
  }), i;
}
function gx(n, e, t, i) {
  const r = n.includeTags.filter((a) => a !== e), s = n.excludeTags.filter((a) => a !== e);
  return i === true && (t ? r : s).push(e), RZr(RZr({}, n), { includeTags: r, excludeTags: s });
}
function VW(n) {
  return n.ids !== void 0 ? false : n.errors !== void 0 ? true : !(n.numericalConstraints.length > 0 || n.includeTags.length > 0 || n.excludeTags.length > 0 || n.prefix || n.regexp);
}
function Hy(n, e) {
  if (n === void 0 || n.ids !== void 0 || n.errors !== void 0)
    return false;
  const t = n.sortBy, i = n.includeColumns;
  return t.find((r) => r.fieldId === e) !== void 0 || i.includes(e);
}
var Su = NZr("disjoint_sets:rank");
var Nr = NZr("disjoint_sets:parent");
var th = NZr("disjoint_sets:next");
var ec = NZr("disjoint_sets:prev");
function dg(n) {
  let e = n, t = n[Nr];
  for (; t !== n; )
    n = t, t = n[Nr];
  for (n = e[Nr]; t !== n; )
    e[Nr] = t, e = n, n = e[Nr];
  return t;
}
function BW(n, e) {
  let t = n[Su], i = e[Su];
  return t > i ? (e[Nr] = n, n) : (n[Nr] = e, t === i && (e[Su] = i + 1), e);
}
function FW(n, e) {
  let t = n[ec], i = e[ec];
  e[ec] = t, t[th] = e, n[ec] = i, i[th] = n;
}
function* mx(n) {
  let e = n;
  do
    yield e, e = e[th];
  while (e !== n);
}
function UW(n) {
  n[Nr] = n, n[Su] = 0, n[th] = n[ec] = n;
}
var ro = NZr("disjoint_sets:min");
function vx(n) {
  return n[Nr] === n;
}
var dL = class {
  constructor() {
    this.map = new de(), this.visibleSegmentEquivalencePolicy = new gt(Fi.MIN_REPRESENTATIVE), this.generation = 0;
  }
  has(e) {
    let t = e.toString();
    return this.map.get(t) !== void 0;
  }
  get(e) {
    let t = e.toString(), i = this.map.get(t);
    return i === void 0 ? e : dg(i)[ro];
  }
  isMinElement(e) {
    let t = this.get(e);
    return t === e || re.equal(t, e);
  }
  makeSet(e) {
    let t = e.toString(), i = this.map, r = i.get(t);
    return r === void 0 ? (r = e.clone(), UW(r), r[ro] = r, i.set(t, r), r) : dg(r);
  }
  /**
   * Union the sets containing `a` and `b`.
   * @returns `false` if `a` and `b` are already in the same set, otherwise `true`.
   */
  link(e, t) {
    if (e = this.makeSet(e), t = this.makeSet(t), e === t)
      return false;
    this.generation++;
    let i = BW(e, t);
    FW(e, t);
    let r = e[ro], s = t[ro];
    const a = (this.visibleSegmentEquivalencePolicy.value & Fi.MAX_REPRESENTATIVE) !== 0;
    return i[ro] = re.less(r, s) === a ? s : r, true;
  }
  linkAll(e) {
    for (let t = 1, i = e.length; t < i; ++t)
      this.link(e[0], e[t]);
  }
  /**
   * Unlinks all members of the specified set.
   */
  deleteSet(e) {
    const t = this.map;
    let i = false;
    for (const r of this.setElements(e))
      t.delete(r.toString()), i = true;
    return i;
  }
  *setElements(e) {
    let t = e.toString(), i = this.map.get(t);
    i === void 0 ? yield e : yield* mx(i);
  }
  clear() {
    let e = this.map;
    return e.size === 0 ? false : (++this.generation, e.clear(), true);
  }
  get size() {
    return this.map.size;
  }
  *mappings(e = new Array(2)) {
    for (let t of this.map.values())
      e[0] = t, e[1] = dg(t)[ro], yield e;
  }
  *roots() {
    for (let e of this.map.values())
      vx(e) && (yield e);
  }
  [wZr]() {
    return this.mappings();
  }
  /**
   * Returns an array of arrays of strings, where the arrays contained in the outer array correspond
   * to the disjoint sets, and the strings are the base-10 string representations of the members of
   * each set.  The members are sorted in numerical order, and the sets are sorted in numerical
   * order of their smallest elements.
   */
  toJSON() {
    let e = new Array();
    for (let t of this.map.values())
      if (vx(t)) {
        let i = new Array();
        for (let r of mx(t))
          i.push(r);
        i.sort(re.compare), e.push(i);
      }
    return e.sort((t, i) => re.compare(t[0], i[0])), e.map((t) => t.map((i) => i.toString()));
  }
};
var zW = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, s = r < 3 ? e : i === null ? i = $i(e, t) : i, a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(n, e, t, i);
  else
    for (var l = n.length - 1; l >= 0; l--)
      (a = n[l]) && (s = (r < 3 ? a(s) : r > 3 ? a(e, t, s) : a(e, t)) || s);
  return r > 3 && s && UZr(e, t, s), s;
};
var Rm;
var GW = "DisjointUint64Sets";
var uL = "DisjointUint64Sets.add";
var hL = "DisjointUint64Sets.clear";
var fL = "DisjointUint64Sets.highBitRepresentativeChanged";
var pL = "DisjointUint64Sets.deleteSet";
var Pc = Rm = class extends Nh {
  constructor() {
    super(...arguments), this.disjointSets = new dL(), this.changed = new Ee();
  }
  /**
   * For compatibility with `WatchableValueInterface`.
   */
  get value() {
    return this;
  }
  static makeWithCounterpart(e, t) {
    let i = new this();
    return i.disjointSets.visibleSegmentEquivalencePolicy = t, i.registerDisposer(t.changed.add(() => {
      yx(i);
    })), i.initializeCounterpart(e), t.value && yx(i), i;
  }
  disposed() {
    this.disjointSets = void 0, this.changed = void 0, super.disposed();
  }
  link(e, t) {
    if (this.disjointSets.link(e, t)) {
      let i = this.rpc;
      return i && i.invoke(uL, { id: this.rpcId, al: e.low, ah: e.high, bl: t.low, bh: t.high }), this.changed.dispatch(), true;
    }
    return false;
  }
  linkAll(e) {
    for (let t = 1, i = e.length; t < i; ++t)
      this.link(e[0], e[t]);
  }
  has(e) {
    return this.disjointSets.has(e);
  }
  get(e) {
    return this.disjointSets.get(e);
  }
  clear() {
    if (this.disjointSets.clear()) {
      let e = this.rpc;
      e && e.invoke(hL, { id: this.rpcId }), this.changed.dispatch();
    }
  }
  setElements(e) {
    return this.disjointSets.setElements(e);
  }
  deleteSet(e) {
    if (this.disjointSets.deleteSet(e)) {
      let t = this.rpc;
      t && t.invoke(pL, { id: this.rpcId, l: e.low, h: e.high }), this.changed.dispatch();
    }
  }
  get size() {
    return this.disjointSets.size;
  }
  toJSON() {
    return this.disjointSets.toJSON();
  }
  /**
   * Restores the state from a JSON representation.
   */
  restoreState(e) {
    if (e !== void 0) {
      let t = [new re(), new re()];
      Je(e, (i) => {
        Je(i, (r, s) => {
          t[s % 2].parseString(String(r), 10), s !== 0 && this.link(t[0], t[1]);
        });
      });
    }
  }
  assignFrom(e) {
    this.clear(), e instanceof Rm && (e = e.disjointSets);
    for (const i of e) {
      var t = ce(i, 2);
      const r = t[0], s = t[1];
      this.link(r, s);
    }
  }
};
Pc = Rm = zW([_h(GW)], Pc);
var bo = new re();
var ug = new re();
Ut(uL, function(n) {
  let e = this.get(n.id);
  bo.low = n.al, bo.high = n.ah, ug.low = n.bl, ug.high = n.bh, e.disjointSets.link(bo, ug) && e.changed.dispatch();
});
Ut(hL, function(n) {
  let e = this.get(n.id);
  e.disjointSets.clear() && e.changed.dispatch();
});
function yx(n) {
  n.rpc.invoke(fL, { id: n.rpcId, value: n.disjointSets.visibleSegmentEquivalencePolicy.value });
}
Ut(fL, function(n) {
  let e = this.get(n.id);
  e.disjointSets.visibleSegmentEquivalencePolicy.value = n.value;
});
Ut(pL, function(n) {
  let e = this.get(n.id);
  bo.low = n.l, bo.high = n.h, e.disjointSets.deleteSet(bo) && e.changed.dispatch();
});
var $W = class extends FB {
  constructor() {
    super(...arguments), this.spanningTreeEdges = new de(), this.equivalences = new Pc(), this.connections = new je(), this.changed = new ot();
  }
  link(e, t) {
    this.equivalences.link(e, t);
    for (const i of this.connections)
      i.segmentsState.segmentEquivalences.link(e, t);
  }
  linkAll(e) {
    this.equivalences.linkAll(e);
    for (const t of this.connections)
      t.segmentsState.segmentEquivalences.linkAll(e);
  }
  deleteSet(e) {
    this.equivalences.deleteSet(e);
    for (const t of this.connections)
      t.segmentsState.segmentEquivalences.deleteSet(e);
  }
  normalizeAll() {
    for (const e of this.connections)
      hg(e.segmentsState.visibleSegments, e.segmentsState.segmentEquivalences.disjointSets);
  }
  addSpanningTreeEdge(e, t) {
    const i = e.toString(), r = t.toString(), s = this.spanningTreeEdges;
    let a = s.get(i);
    a === void 0 && (a = new je(), s.set(i, a));
    let l = s.get(r);
    l === void 0 && (l = new je(), s.set(r, l)), a.add(r), l.add(i);
  }
  removeSpanningTreeEdge(e, t) {
    const i = e.toString(), r = t.toString(), s = this.spanningTreeEdges, a = s.get(i), l = s.get(r);
    a.delete(r), a.size === 0 && s.delete(i), l.delete(i), l.size === 0 && s.delete(r);
  }
  *getSpanningTreeNeighbors(e) {
    const t = new re(), i = this.spanningTreeEdges.get(e.toString());
    if (i !== void 0)
      for (const r of i)
        t.parseString(r), yield t;
  }
  restoreState(e) {
    const t = this.equivalences, i = this.spanningTreeEdges;
    if (t.clear(), i.clear(), e === void 0)
      return;
    const r = [new re(), new re()];
    Je(e, (s) => {
      Je(s, (a, l) => {
        r[l % 2].parseString(String(a), 10), l !== 0 && t.link(r[0], r[1]) && this.addSpanningTreeEdge(r[0], r[1]);
      });
    });
  }
  toJSON() {
    const e = this.spanningTreeEdges;
    if (e.size === 0)
      return;
    const t = new Array();
    for (let r of e) {
      var i = ce(r, 2);
      let s = i[0], a = i[1];
      const l = re.parseString(s);
      for (const d of a) {
        const u = re.parseString(d);
        re.compare(l, u) > 0 || t.push([l, u]);
      }
    }
    return t.sort((r, s) => re.compare(r[0], s[0]) || re.compare(r[1], s[1])), t.map((r) => r.map((s) => s.toString()));
  }
  get visibleSegmentEquivalencePolicy() {
    return Fi.MIN_REPRESENTATIVE;
  }
  async merge(e, t) {
    const i = this.equivalences;
    return re.equal(i.get(e), i.get(t)) ? e : (this.addSpanningTreeEdge(e, t), this.link(e, t), this.normalizeAll(), this.changed.dispatch(), i.get(e));
  }
  async split(e, t) {
    const i = this.computeSplit(e, t);
    if (i === void 0)
      throw new Error("Segments are already split");
    const r = i.includeBaseSegments, s = i.includeRepresentative, a = i.excludeBaseSegments, l = i.excludeRepresentative, d = this.equivalences;
    this.deleteSet(e), this.linkAll(r), this.linkAll(a);
    const u = (v, y) => {
      for (const w of v)
        for (const C of this.getSpanningTreeNeighbors(w))
          re.equal(d.get(C), y) || this.removeSpanningTreeEdge(w, C);
    }, f = d.get(e), g = d.get(t);
    u(r, f), u(a, g);
    for (const v of this.connections) {
      const y = v.segmentsState.visibleSegments;
      y.has(l) && (y.delete(l), y.add(s));
    }
    return this.normalizeAll(), this.changed.dispatch(), { include: f, exclude: g };
  }
  trackSegment(e, t) {
    return () => {
    };
  }
  computeSplit(e, t) {
    const i = this.equivalences, r = i.get(e);
    if (!re.equal(r, i.get(t)))
      return;
    const s = new dL();
    for (const g of i.setElements(r))
      if (!re.equal(g, t))
        for (const v of this.getSpanningTreeNeighbors(g))
          re.equal(v, t) || s.link(g, v);
    const a = [], l = [], d = s.get(e);
    let u = e, f = t;
    for (const g of i.setElements(r))
      re.equal(s.get(g), d) ? (a.push(g), re.compare(g, u) < 0 && (u = g)) : (l.push(g), re.compare(g, f) < 0 && (f = g));
    return a.sort(re.compare), l.sort(re.compare), {
      includeBaseSegments: a,
      includeRepresentative: u,
      excludeBaseSegments: l,
      excludeRepresentative: f
    };
  }
  connect(e) {
    const t = new WW(this, e);
    return e.segmentEquivalences.assignFrom(this.equivalences), hg(e.visibleSegments, e.segmentEquivalences.disjointSets), t.registerDisposer(e.visibleSegments.changed.add(t.registerCancellable(lt(() => hg(e.visibleSegments, e.segmentEquivalences.disjointSets), 0)))), this.connections.add(t), t.registerDisposer(() => {
      this.connections.delete(t);
    }), t;
  }
};
function hg(n, e) {
  const t = [];
  for (const i of n.unsafeKeys()) {
    const r = e.get(i);
    re.equal(i, r) || (t.push(r), n.delete(i));
  }
  for (const i of t)
    n.add(i);
}
var WW = class extends UB {
  computeSplit(e, t) {
    return this.graph.computeSplit(e, t);
  }
};
var Dn;
(function(n) {
  n[n.UNKNOWN = 0] = "UNKNOWN", n[n.IMAGE = 1] = "IMAGE", n[n.SEGMENTATION = 2] = "SEGMENTATION";
})(Dn || (Dn = {}));
function Sx(n) {
  const e = n.rank, t = n.dataType, i = n.compressedSegmentationBlockSize;
  var r = n.baseVoxelOffset;
  const s = r === void 0 ? new Float32Array(e) : r;
  return RZr(RZr({}, Gc(n)), {
    compressedSegmentationBlockSize: i,
    baseVoxelOffset: s,
    dataType: t
  });
}
function HW(n) {
  if (n.compressedSegmentationBlockSize !== void 0 || n.volumeType !== Dn.SEGMENTATION && !n.volumeSourceOptions.discreteValues)
    return false;
  switch (n.dataType) {
    case J.UINT32:
    case J.UINT64:
      break;
    default:
      return false;
  }
  switch (n.rank) {
    case 3:
      return true;
    case 4:
      return n.chunkDataSize[3] === 1;
    default:
      return false;
  }
}
function jW(n) {
  let e = n.rank, t = n.lowerVoxelBound, i = n.upperVoxelBound;
  if (!HW(n))
    return Sx(n);
  var r = n.volumeSourceOptions;
  let s = r.displayRank, a = r.multiscaleToViewTransform, l = n.chunkToMultiscaleTransform, d = n.chunkToViewTransform;
  d === void 0 && (d = Ph(
    new Float32Array(e * s),
    s,
    //
    a,
    s,
    //
    l,
    e + 1,
    //
    s,
    e,
    e
  ));
  const u = n.maxCompressedSegmentationBlockSize, f = n.chunkDataSize;
  return Sx(RZr(RZr({}, n), { compressedSegmentationBlockSize: Float32Array.from(Bu({
    rank: e,
    chunkToViewTransform: d,
    displayRank: s,
    lowerVoxelBound: t,
    upperVoxelBound: i,
    maxVoxelsPerChunkLog2: 9,
    maxBlockSize: u === void 0 ? f : D2(new Uint32Array(e), f, u)
  })) }));
}
function rd(n) {
  const e = n.rank;
  var t = n.volumeSourceOptions;
  const i = t.displayRank, r = t.multiscaleToViewTransform, s = t.modelChannelDimensionIndices, a = n.chunkToMultiscaleTransform, l = Ph(
    new Float32Array(i * e),
    i,
    //
    r,
    i,
    //
    a,
    e + 1,
    //
    i,
    e,
    e
  );
  let d = n.minBlockSize;
  d === void 0 ? (d = new Uint32Array(e), d.fill(1)) : d = new Uint32Array(d);
  const u = n.lowerVoxelBound, f = n.upperVoxelBound;
  if (s.length !== 0)
    for (const y of Ih(a, e, s)) {
      let w = f[y];
      u !== void 0 && (w -= u[y]), d[y] = w;
    }
  var g = n.chunkDataSizes;
  return (g === void 0 ? yB(RZr(RZr({}, n), {
    minBlockSize: d,
    chunkToViewTransform: l,
    displayRank: i
  })) : g).map((y) => jW(RZr(RZr({}, n), { chunkDataSize: y, chunkToViewTransform: l })));
}
var JW = _e();
var YW = _e();
var bx = 1e-3;
var qW = 1e-3;
function KW(n) {
  let e = 0;
  for (var t = 0; t < 3; ++t)
    n[t] < 0 && (e += 1 << t);
  return e;
}
var gL = new Float32Array([0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1]);
var ZW = (() => {
  const n = [0, 1, 2, 4, 5, 3, 6, 7], e = [0, 1, 2, 5, 3, 4, 6, 7], t = [0, 1, 1, 4, 4, 7, 4, 7, 1, 5, 0, 1, 1, 4, 4, 7, 0, 2, 2, 5, 5, 7, 5, 7, 2, 6, 0, 2, 2, 5, 5, 7, 0, 3, 3, 6, 6, 7, 6, 7, 3, 4, 0, 3, 3, 6, 6, 7], i = [0, 1, 2, 3, 4, 5, 6, 7, 1, 4, 5, 0, 3, 7, 2, 6, 2, 6, 0, 5, 7, 3, 1, 4, 3, 0, 6, 4, 1, 2, 7, 5, 4, 3, 7, 1, 0, 6, 5, 2, 5, 2, 1, 7, 6, 0, 4, 3, 6, 7, 3, 2, 5, 4, 0, 1, 7, 5, 4, 6, 2, 1, 3, 0], r = new Int32Array(8 * 8 * 6);
  for (let s = 0; s < 8; ++s)
    for (let a = 0; a < t.length; ++a) {
      const l = e[s] * 8 + t[a];
      r[s * 8 * 6 + a] = n[i[l]];
    }
  return r;
})();
function nh(n) {
  n.addUniform("highp vec3", "uPlaneNormal"), n.addUniform("highp float", "uPlaneDistance"), n.addUniform("highp ivec2", "uVertexIndex", 24), n.addUniform("highp vec3", "uVertexBasePosition", 8), n.addInitializer((e) => {
    e.gl.uniform3fv(e.uniform("uVertexBasePosition"), gL);
  }), n.addVertexCode(`
vec3 getBoundingBoxPlaneIntersectionVertexPosition(vec3 chunkSize, vec3 boxLower, vec3 lowerClipBound, vec3 upperClipBound, int vertexIndex, float planeDistance) {
  for (int e = 0; e < 4; ++e) {
    highp ivec2 vidx = uVertexIndex[vertexIndex*4 + e];
    highp vec3 v1 = max(lowerClipBound, min(upperClipBound, chunkSize * uVertexBasePosition[vidx.x] + boxLower));
    highp vec3 v2 = max(lowerClipBound, min(upperClipBound, chunkSize * uVertexBasePosition[vidx.y] + boxLower));
    highp vec3 vDir = v2 - v1;
    highp float denom = dot(vDir, uPlaneNormal);
    if (abs(denom) > ${qW}) {
      highp float lambda = (planeDistance - dot(v1, uPlaneNormal)) / denom;
      if ((lambda >= -${bx}) && (lambda <= (1.0 + ${bx}))) {
        lambda = clamp(lambda, 0.0, 1.0);
        highp vec3 position = v1 + lambda * vDir;
        return position;
      }
    }
  }
  return vec3(0, 0, 0);
}
vec3 getBoundingBoxPlaneIntersectionVertexPosition(vec3 chunkSize, vec3 boxLower, vec3 lowerClipBound, vec3 upperClipBound, int vertexIndex) {
  return getBoundingBoxPlaneIntersectionVertexPosition(chunkSize, boxLower, lowerClipBound, upperClipBound, vertexIndex, uPlaneDistance);
}
`);
}
function XW(n, e, t) {
  const i = n.gl;
  i.uniform3fv(n.uniform("uPlaneNormal"), e), i.uniform1f(n.uniform("uPlaneDistance"), t);
  const r = KW(e);
  i.uniform2iv(n.uniform("uVertexIndex"), ZW.subarray(r * 48, (r + 1) * 48));
}
function jy(n, e, t, i, r) {
  const s = KE(JW, e, i);
  wu(s, s);
  const a = Tv(Si(YW, t, r), s);
  XW(n, s, a);
}
var QW = 1e-3;
var e4 = et();
function t4(n, e) {
  if (Wr(n), nh(n), n.addUniform("highp vec3", "uTranslation"), n.addUniform("highp mat4", "uProjectionMatrix"), n.addUniform("highp vec3", "uChunkDataSize"), n.addUniform("highp vec3", "uLowerClipBound"), n.addUniform("highp vec3", "uUpperClipBound"), e) {
    fr(n), n.setVertexMain(`
int vertexIndex1 = gl_VertexID / ${bs};
int vertexIndex2 = vertexIndex1 == 5 ? 0 : vertexIndex1 + 1;
vec3 vertexPosition1 = getBoundingBoxPlaneIntersectionVertexPosition(uChunkDataSize, uTranslation, uLowerClipBound, uUpperClipBound, vertexIndex1);
vec3 vertexPosition2 = getBoundingBoxPlaneIntersectionVertexPosition(uChunkDataSize, uTranslation, uLowerClipBound, uUpperClipBound, vertexIndex2);
emitLine(uProjectionMatrix * vec4(vertexPosition1, 1.0),
         uProjectionMatrix * vec4(vertexPosition2, 1.0),
         2.0);
`), n.setFragmentMain(`
emit(vec4(1.0, 1.0, 1.0, getLineAlpha()));
`);
    return;
  }
  n.addVarying("highp vec3", "vChunkPosition"), n.setVertexMain(`
vec3 position = getBoundingBoxPlaneIntersectionVertexPosition(uChunkDataSize, uTranslation, uLowerClipBound, uUpperClipBound, gl_VertexID);
gl_Position = uProjectionMatrix * vec4(position, 1.0);
gl_Position.z = 0.0;
vChunkPosition = (position - uTranslation) +
    ${QW} * abs(uPlaneNormal);
`);
}
function n4(n, e, t) {
  t && gr(
    n,
    e,
    /*featherWidthInPixels=*/
    1
  );
}
function i4(n, e, t, i, r, s) {
  const a = t.projectionParameters.value, l = a.centerDataPosition;
  jy(e, a.viewportNormalInGlobalCoordinates, l, s.transform, s.invTransform), n.uniformMatrix4fv(e.uniform("uProjectionMatrix"), false, mn(e4, i, s.transform)), n.uniform3fv(e.uniform("uLowerClipBound"), r.lowerClipDisplayBound), n.uniform3fv(e.uniform("uUpperClipBound"), r.upperClipDisplayBound);
}
function r4(n, e, t) {
  n.uniform3fv(e.uniform("uChunkDataSize"), t);
}
function s4(n, e, t, i) {
  n.uniform3fv(e.uniform("uTranslation"), t), i ? pr(e.gl, 6, 1) : n.drawArrays(n.TRIANGLE_FAN, 0, 6);
}
function a4(n, e, t) {
  return n > e ? t > n ? n : e > t ? e : t : t > e ? e : n > t ? n : t;
}
var mL = class extends cy {
  constructor(e, t) {
    var i = t.shaderError;
    const r = i === void 0 ? Vh() : i, s = t.shaderParameters;
    super(e.chunkManager, e, t);
    const a = this.gl;
    this.vertexIdHelper = this.registerDisposer(mr.get(a)), this.shaderParameters = s;
    const l = t.channelCoordinateSpace;
    this.channelCoordinateSpace = l === void 0 ? oa(zr) : l, this.registerDisposer(s.changed.add(this.redrawNeeded.dispatch));
    const d = this.registerDisposer(wi((u, f) => ({ numChannelDimensions: u.rank, dataHistogramChannelSpecifications: f }), [this.channelCoordinateSpace, this.dataHistogramSpecifications.channels]));
    this.shaderGetter = qv(this, a, {
      memoizeKey: `volume/RenderLayer:${xn(this.constructor)}`,
      fallbackParameters: t.fallbackShaderParameters,
      parameters: s,
      encodeParameters: t.encodeShaderParameters,
      shaderError: r,
      extraParameters: d,
      defineShader: (u, f, g, v) => {
        const y = f.chunkFormat, w = f.dataHistogramsEnabled, C = v.dataHistogramChannelSpecifications, b = v.numChannelDimensions;
        if (t4(u, y === null), u.addOutputBuffer("vec4", "v4f_fragData0", 0), u.addFragmentCode(`
void emit(vec4 color) {
  v4f_fragData0 = color;
}
`), y === null)
          return;
        nI(u, y, b, "vChunkPosition");
        const E = C.length;
        if (w && E > 0) {
          let L = "";
          const R = y.dataType;
          for (let _ = 0; _ < E; ++_) {
            const A = C[_].channel, I = `out_histogram${_}`;
            u.addOutputBuffer("vec4", I, 1 + _);
            const P = `getDataValue(${A.join(",")})`, N = `invlerpForHistogram${_}`;
            u.addFragmentCode(NT(
              u,
              N,
              R,
              /*clamp=*/
              false
            )), u.addFragmentCode(`
float getHistogramValue${_}() {
  return invlerpForHistogram${_}(${P});
}
`), L += `{
float x = getHistogramValue${_}();
if (x < 0.0) x = 0.0;
else if (x > 1.0) x = 1.0;
else x = (1.0 + x * 253.0) / 255.0;
${I} = vec4(x, x, x, 1.0);
}`;
          }
          u.addFragmentCode(`void userMain();
void main() {
  ${L}
  userMain();
}
#define main userMain
`);
        }
        this.defineShader(u, g);
      },
      getContextKey: (u) => {
        var f;
        return `${(f = u.chunkFormat) === null || f === void 0 ? void 0 : f.shaderKey}/${u.dataHistogramsEnabled}`;
      }
    }), this.tempChunkPosition = new Float32Array(e.rank), this.initializeCounterpart();
  }
  get dataType() {
    return this.multiscaleSource.dataType;
  }
  getValueAt(e) {
    let t = this.tempChunkPosition;
    for (const i of this.visibleSourcesList) {
      const r = i.source, s = i.chunkTransform;
      if (!gc(t, e, this.localPosition.value, s.layerRank, s.combinedGlobalLocalToChunkTransform))
        continue;
      const a = r.getValueAt(t, s);
      if (a != null)
        return a;
    }
    return null;
  }
  beginChunkFormat(e, t, i) {
    const r = this.gl, s = this.dataHistogramSpecifications.visibility.visible, a = this.shaderGetter({ chunkFormat: t, dataHistogramsEnabled: s }), l = a.shader, d = a.parameters, u = a.fallback;
    if (l !== null && (l.bind(), n4(l, i, t === null), t !== null)) {
      if (s) {
        const g = a.extraParameters.dataHistogramChannelSpecifications.length, v = this.dataHistogramSpecifications.bounds.value;
        for (let y = 0; y < g; ++y)
          ty(l, `invlerpForHistogram${y}`, t.dataType, v[y]);
      }
      this.initializeShader(e, l, d, u), t.beginDrawing(r, l);
    }
    return a;
  }
  endSlice(e, t, i) {
  }
  draw(e) {
    const t = e.sliceView, r = t.visibleLayers.get(this).visibleSources;
    if (r.length === 0)
      return;
    const s = e.projectionParameters, a = e.wireFrame, l = this.gl;
    this.vertexIdHelper.enable();
    const d = _e(), u = this.renderScaleHistogram;
    u !== void 0 && u.begin(this.chunkManager.chunkQueueManager.frameNumberCounter.frameNumber);
    let f, g = null, v;
    const y = _e(), w = () => {
      g !== null && (v !== null && v.endDrawing(l, g), this.endSlice(t, g, f.parameters));
    };
    let C = true;
    for (const b of r) {
      const E = ay(s, b.chunkLayout), L = b.chunkTransform.channelToChunkDimensionIndices, R = b.source, _ = b.fixedPositionWithinChunk, A = b.chunkDisplayDimensionIndices;
      for (const V of A)
        _[V] = 0;
      const I = a ? null : R.chunkFormat;
      if (I !== v && (v = I, w(), f = this.beginChunkFormat(t, I, s), g = f.shader), g === null)
        continue;
      const P = R.chunks;
      y.fill(1);
      let N = E.size, O;
      const B = R.spec.rank;
      i4(l, g, t, s.viewProjectionMat, b, E), I !== null && I.beginSource(l, g), C = true;
      let j = 0, U = 0;
      if (t.forEachVisibleChunk(b, E, (V) => {
        let G = P.get(V);
        if (G && G.state === Et.GPU_MEMORY) {
          let F = G.chunkDataSize;
          if (F !== O) {
            O = F;
            for (let ae = 0; ae < 3; ++ae) {
              const Ie = A[ae];
              y[ae] = Ie === -1 || Ie >= B ? 1 : O[Ie];
            }
            r4(l, g, y);
          }
          const ue = G.chunkGridPosition;
          for (let ae = 0; ae < 3; ++ae) {
            const Ie = A[ae];
            d[ae] = Ie === -1 || Ie >= B ? 0 : N[ae] * ue[Ie];
          }
          I !== null && I.bindChunk(l, g, G, _, A, L, C), C = false, s4(l, g, d, a), ++j;
        } else
          ++U;
      }), (j !== 0 || U !== 0) && u !== void 0) {
        const V = b.effectiveVoxelSize, G = a4(V[0], V[1], V[2]);
        u.add(G, G / s.pixelSize, j, U);
      }
    }
    if (w(), this.vertexIdHelper.disable(), !e.wireFrame) {
      const b = this.getDataHistogramCount();
      b > 0 && t.computeHistograms(b, this.dataHistogramSpecifications);
    }
  }
};
var Cx = class {
  constructor(e) {
    this.disjointSets = e, this.generation = Number.NaN, this.hashMap = new py();
  }
  update() {
    let e = this.disjointSets;
    const t = e.generation;
    if (this.generation !== t) {
      this.generation = t;
      let r = this.hashMap;
      r.clear();
      for (let s of e.mappings()) {
        var i = ce(s, 2);
        let a = i[0], l = i[1];
        r.set(a, l);
      }
    }
  }
};
var fg = class extends mL {
  constructor(e, t) {
    super(e, {
      shaderParameters: new FE((i) => ({
        hasEquivalences: i.registerDisposer(wi((r) => r.size !== 0, [t.segmentationGroupState.value.segmentEquivalences])),
        hasSegmentStatedColors: i.registerDisposer(wi((r) => r.size !== 0, [t.segmentStatedColors])),
        hasSegmentDefaultColor: i.registerDisposer(wi((r) => r !== void 0, [t.segmentDefaultColor])),
        hideSegmentZero: t.hideSegmentZero,
        baseSegmentColoring: t.baseSegmentColoring
      })),
      transform: t.transform,
      renderScaleHistogram: t.renderScaleHistogram,
      renderScaleTarget: t.renderScaleTarget,
      localPosition: t.localPosition
    }), this.displayState = t, this.segmentationGroupState = this.displayState.segmentationGroupState.value, this.segmentColorShaderManager = new P3("segmentColorHash"), this.segmentStatedColorShaderManager = new A3("segmentStatedColor"), this.hashTableManager = new Ak("visibleSegments"), this.gpuHashTable = this.registerDisposer(Jl.get(this.gl, this.segmentationGroupState.visibleSegments.hashTable)), this.gpuTemporaryHashTable = Jl.get(this.gl, this.segmentationGroupState.temporaryVisibleSegments.hashTable), this.equivalencesShaderManager = new Rk("equivalences"), this.equivalencesHashMap = new Cx(this.segmentationGroupState.segmentEquivalences.disjointSets), this.temporaryEquivalencesHashMap = new Cx(this.segmentationGroupState.temporarySegmentEquivalences.disjointSets), this.gpuEquivalencesHashTable = this.registerDisposer(Jl.get(this.gl, this.equivalencesHashMap.hashMap)), this.gpuTemporaryEquivalencesHashTable = this.registerDisposer(Jl.get(this.gl, this.temporaryEquivalencesHashMap.hashMap)), this.registerDisposer(this.shaderParameters), Ey(t, this), this.registerDisposer(t.selectedAlpha.changed.add(this.redrawNeeded.dispatch)), this.registerDisposer(t.notSelectedAlpha.changed.add(this.redrawNeeded.dispatch)), this.registerDisposer(t.ignoreNullVisibleSet.changed.add(this.redrawNeeded.dispatch));
  }
  disposed() {
    var e;
    (e = this.gpuSegmentStatedColorHashTable) === null || e === void 0 || e.dispose();
  }
  getSources(e) {
    return this.multiscaleSource.getSources(RZr(RZr({}, e), { discreteValues: true }));
  }
  defineShader(e, t) {
    this.hashTableManager.defineShader(e);
    let i = `
uint64_t getUint64DataValue() {
  uint64_t x = toUint64(getDataValue());
`;
    i += `return x;
}
`, e.addFragmentCode(i), t.hasEquivalences ? (this.equivalencesShaderManager.defineShader(e), e.addFragmentCode(`
uint64_t getMappedObjectId(uint64_t value) {
  uint64_t mappedValue;
  if (${this.equivalencesShaderManager.getFunctionName}(value, mappedValue)) {
    return mappedValue;
  }
  return value;
}
`)) : e.addFragmentCode(`
uint64_t getMappedObjectId(uint64_t value) {
  return value;
}
`), e.addUniform("highp uvec2", "uSelectedSegment"), e.addUniform("highp uint", "uShowAllSegments"), e.addUniform("highp float", "uSelectedAlpha"), e.addUniform("highp float", "uNotSelectedAlpha"), e.addUniform("highp float", "uSaturation");
    let r = `
  uint64_t baseValue = getUint64DataValue();
  uint64_t value = getMappedObjectId(baseValue);
  uint64_t valueForColor = ${t.baseSegmentColoring ? "baseValue" : "value"};

  float alpha = uSelectedAlpha;
  float saturation = uSaturation;
`;
    t.hideSegmentZero && (r += `
  if (value.value[0] == 0u && value.value[1] == 0u) {
    emit(vec4(vec4(0, 0, 0, 0)));
    return;
  }
`), r += `
  bool has = uShowAllSegments != 0u ? true : ${this.hashTableManager.hasFunctionName}(value);
  if (uSelectedSegment == value.value) {
    float adjustment = has ? 0.5 : 0.75;
    if (saturation > adjustment) {
      saturation -= adjustment;
    } else {
      saturation += adjustment;
    }
  } else if (!has) {
    alpha = uNotSelectedAlpha;
  }
`;
    let s = `vec3 getMappedIdColor(uint64_t value) {
`;
    t.hasSegmentStatedColors && (this.segmentStatedColorShaderManager.defineShader(e), s += `
  vec3 rgb;
  if (${this.segmentStatedColorShaderManager.getFunctionName}(value, rgb)) {
    return rgb;
  }
`), t.hasSegmentDefaultColor ? (e.addUniform("highp vec3", "uSegmentDefaultColor"), s += `  return uSegmentDefaultColor;
`) : (this.segmentColorShaderManager.defineShader(e), s += `  return segmentColorHash(value);
`), s += `
}
`, e.addFragmentCode(s), r += `
  vec3 rgb = getMappedIdColor(valueForColor);
  emit(vec4(mix(vec3(1.0,1.0,1.0), rgb, saturation), alpha));
`, e.setFragmentMain(r);
  }
  initializeShader(e, t, i) {
    const r = this.gl, s = this.displayState, a = this.segmentationGroupState, l = this.displayState.segmentSelectionState;
    var d = this.displayState;
    const u = d.segmentDefaultColor.value, f = d.segmentColorHash.value, g = jT(a), v = this.displayState.ignoreNullVisibleSet.value;
    let y = 0, w = 0;
    if (l.hasSelectedSegment) {
      let C = l.selectedSegment;
      y = C.low, w = C.high;
    }
    if (r.uniform1f(t.uniform("uSelectedAlpha"), s.selectedAlpha.value), r.uniform1f(t.uniform("uSaturation"), s.saturation.value), r.uniform1f(t.uniform("uNotSelectedAlpha"), s.notSelectedAlpha.value), r.uniform2ui(t.uniform("uSelectedSegment"), y, w), r.uniform1ui(t.uniform("uShowAllSegments"), g.hashTable.size || !v ? 0 : 1), this.hashTableManager.enable(r, t, a.useTemporaryVisibleSegments.value ? this.gpuTemporaryHashTable : this.gpuHashTable), i.hasEquivalences) {
      const C = a.useTemporarySegmentEquivalences.value;
      (C ? this.temporaryEquivalencesHashMap : this.equivalencesHashMap).update(), this.equivalencesShaderManager.enable(r, t, C ? this.gpuTemporaryEquivalencesHashTable : this.gpuEquivalencesHashTable);
    }
    if (u === void 0 ? this.segmentColorShaderManager.enable(r, t, f) : r.uniform3fv(t.uniform("uSegmentDefaultColor"), u), i.hasSegmentStatedColors) {
      const C = this.displayState.segmentStatedColors.value;
      let b = this.gpuSegmentStatedColorHashTable;
      (b === void 0 || b.hashTable !== C.hashTable) && (b == null ? void 0 : b.dispose(), this.gpuSegmentStatedColorHashTable = b = Jl.get(r, C.hashTable)), this.segmentStatedColorShaderManager.enable(r, t, b);
    }
  }
  endSlice(e, t, i) {
    const r = this.gl;
    this.hashTableManager.disable(r, t), i.hasEquivalences && this.equivalencesShaderManager.disable(r, t), i.hasSegmentStatedColors && this.segmentStatedColorShaderManager.disable(r, t), super.endSlice(e, t, i);
  }
};
function tc(n = 0.5) {
  return new hn(n, Dv);
}
var Jy = 12;
var vL = 8;
var o4 = 6;
var l4 = `
vec3 getBoxFaceVertexPosition(int vertexIndex) {
  const vec3 vertexPositions[] = vec3[](
  // Front face
  vec3(0.0, 0.0,  1.0), // 0
  vec3(1.0, 0.0,  1.0), // 1
  vec3(1.0,  1.0,  1.0), // 2
  vec3(0.0,  1.0,  1.0), // 3

  // Back face
  vec3(0.0, 0.0, 0.0), // 4
  vec3(0.0,  1.0, 0.0), // 5
  vec3(1.0,  1.0, 0.0), // 6
  vec3(1.0, 0.0, 0.0), // 7

  // Top face
  vec3(0.0,  1.0, 0.0), // 8
  vec3(0.0,  1.0,  1.0), // 9
  vec3(1.0,  1.0,  1.0), // 10
  vec3(1.0,  1.0, 0.0), // 11

  // Bottom face
  vec3(0.0, 0.0, 0.0), // 12
  vec3( 1.0, 0.0, 0.0), // 13
  vec3( 1.0, 0.0,  1.0), // 14
  vec3(0.0, 0.0,  1.0), // 15

  // Right face
  vec3( 1.0, 0.0, 0.0), // 16
  vec3( 1.0,  1.0, 0.0), // 17
  vec3( 1.0,  1.0,  1.0), // 18
  vec3( 1.0, 0.0,  1.0), // 19

  // Left face
  vec3(0.0, 0.0, 0.0), // 20
  vec3(0.0, 0.0,  1.0), // 21
  vec3(0.0,  1.0,  1.0), // 22
  vec3(0.0,  1.0, 0.0) // 23
  );
  const int indices[] = int[](
    0,  1,  2,      0,  2,  3,    // front
    4,  5,  6,      4,  6,  7,    // back
    8,  9,  10,     8,  10, 11,   // top
    12, 13, 14,     12, 14, 15,   // bottom
    16, 17, 18,     16, 18, 19,   // right
    20, 21, 22,     20, 22, 23   // left
  );
  return vertexPositions[indices[vertexIndex]];
}
`;
function c4(n, e, t) {
  n.drawArraysInstanced(WebGL2RenderingContext.TRIANGLES, 0, 6 * o4 * e, t);
}
var yL = 0;
var ih = yL + 1;
var kn = ih + vL;
var SL = kn + Jy;
var d4 = SL + 6;
var u4 = Float32Array.from([
  // a1
  0,
  0,
  0,
  // b1
  0,
  0,
  1,
  // c1
  kn + 0,
  // a2
  1,
  0,
  0,
  // b2
  1,
  0,
  1,
  // c2
  kn + 1,
  // a3
  0,
  1,
  0,
  // b3
  0,
  1,
  1,
  // c3
  kn + 2,
  // a4
  1,
  1,
  0,
  // b4
  1,
  1,
  1,
  // c4
  kn + 3,
  // a5
  0,
  0,
  0,
  // b5
  0,
  1,
  0,
  // c5
  kn + 4,
  // a6
  0,
  0,
  1,
  // b6
  0,
  1,
  1,
  // c6
  kn + 5,
  // a7
  1,
  0,
  0,
  // b7
  1,
  1,
  0,
  // c7
  kn + 6,
  // a8
  1,
  0,
  1,
  // b8
  1,
  1,
  1,
  // c8
  kn + 7,
  // a9
  0,
  0,
  0,
  // b9
  1,
  0,
  0,
  // c9
  kn + 8,
  // a10
  0,
  0,
  1,
  // b10
  1,
  0,
  1,
  // c10
  kn + 9,
  // a11
  0,
  1,
  0,
  // b11
  1,
  1,
  0,
  // c11
  kn + 10,
  // a12
  0,
  1,
  1,
  // b12
  1,
  1,
  1,
  // c12
  kn + 11
]);
var wx = et();
var fs = new Float32Array(6);
var bL = class extends $c {
  constructor() {
    super(...arguments), this.vertexIdHelper = this.registerDisposer(mr.get(this.gl));
  }
  defineShader(e) {
    Wr(e);
    const t = this.rank;
    Uc(
      e,
      "float",
      WebGL2RenderingContext.FLOAT,
      /*normalized=*/
      false,
      "Bounds",
      t,
      2
    ), e.addUniform("vec3", "uModelSpaceBoundOffsets", 2);
  }
  enable(e, t, i) {
    xs(wx, t.modelViewProjectionMatrix), x_(wx, fs);
    const r = t.chunkDisplayTransform.numChunkDisplayDims;
    for (let s = 0; s < r; ++s)
      fs[s] = 0, fs[s + 3] = 0;
    for (let s = r; s < 3; ++s) {
      const a = Math.abs(fs[s + 3] - fs[s]);
      fs[s] -= a, fs[s + 3] += a;
    }
    super.enable(e, t, (s) => {
      const a = s.vertexShaderInputBinders.Bounds;
      a.enable(1);
      const l = this.gl;
      l.uniform3fv(s.uniform("uModelSpaceBoundOffsets"), fs), l.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, t.buffer.buffer), a.bind(this.geometryDataStride, t.bufferOffset);
      const d = this.vertexIdHelper;
      d.enable(), i(s), d.disable(), a.disable();
    });
  }
};
function CL(n) {
  n.addVertexCode(`
void setBoundingBoxBorderWidth(float width) {}
void setBoundingBoxBorderColor(vec4 color) {}
`);
}
function wL(n) {
  n.addVertexCode(`
void setBoundingBoxFillColor(vec4 color) {}
`);
}
function Mm(n) {
  wL(n), n.addVertexCode(`
float ng_lineWidth;
void setBoundingBoxBorderWidth(float size) {
  ng_lineWidth = size;
}
void setBoundingBoxBorderColor(vec4 color) {
  vColor = color;
}
`);
}
function h4(n) {
  CL(n), n.addVertexCode(`
void setBoundingBoxFillColor(vec4 color) {
  vColor = color;
}
`);
}
var f4 = class extends bL {
  constructor() {
    super(...arguments), this.edgeBoxCornerOffsetsBuffer = this.registerDisposer(Xn.fromData(this.gl, Tg(
      u4,
      /*majorDimension=*/
      7,
      /*minorTiles=*/
      1,
      /*majorTiles=*/
      bs
    ))), this.edgeShaderGetter = this.getDependentShader("annotation/boundingBox/projection/border", (e) => {
      const t = this.rank;
      this.defineShader(e), fr(e), e.addAttribute("highp vec3", "aBoxCornerOffset1"), e.addAttribute("highp vec4", "aBoxCornerOffset2"), e.addVarying("highp float", "vClipCoefficient"), Mm(e), e.setVertexMain(`
float modelPositionA[${t}] = getBounds0();
float modelPositionB[${t}] = getBounds1();
vec3 subspacePositionA = projectModelVectorToSubspace(modelPositionA) + uModelSpaceBoundOffsets[0];
vec3 subspacePositionB = projectModelVectorToSubspace(modelPositionB) + uModelSpaceBoundOffsets[1];
vec3 endpointA = mix(subspacePositionA, subspacePositionB, aBoxCornerOffset1);
vec3 endpointB = mix(subspacePositionA, subspacePositionB, aBoxCornerOffset2.xyz);
vClipCoefficient = getMaxSubspaceClipCoefficient(modelPositionA, modelPositionB);
if (vClipCoefficient == 0.0) {
  gl_Position = vec4(2.0, 0.0, 0.0, 1.0);
  return;
}
ng_lineWidth = 1.0;
${this.invokeUserMain}
emitLine(uModelViewProjection * vec4(endpointA, 1.0),
         uModelViewProjection * vec4(endpointB, 1.0),
         ng_lineWidth);
${this.setPartIndex(e, "uint(aBoxCornerOffset2.w)")};
`), e.setFragmentMain(`
emitAnnotation(vec4(vColor.rgb, getLineAlpha() * vClipCoefficient));
`);
    }), this.boxCornerOffsetsBuffer = this.registerDisposer(Xn.fromData(this.gl, Tg(
      gL,
      /*majorDimension=*/
      3,
      /*minorTiles=*/
      1,
      /*majorTiles=*/
      Dy
    ))), this.cornerShaderGetter = this.getDependentShader("annotation/boundingBox/projection/corner", (e) => {
      const t = this.rank;
      this.defineShader(e), Xc(e, this.targetIsSliceView), e.addAttribute("highp vec3", "aBoxCornerOffset"), e.addVarying("highp float", "vClipCoefficient"), Mm(e), e.setVertexMain(`
float modelPositionA[${t}] = getBounds0();
float modelPositionB[${t}] = getBounds1();
vClipCoefficient = getMaxEndpointSubspaceClipCoefficient(modelPositionA, modelPositionB);
if (vClipCoefficient == 0.0) {
  gl_Position = vec4(2.0, 0.0, 0.0, 1.0);
  return;
}
vec3 subspacePositionA = projectModelVectorToSubspace(modelPositionA) + uModelSpaceBoundOffsets[0];
vec3 subspacePositionB = projectModelVectorToSubspace(modelPositionB) + uModelSpaceBoundOffsets[1];
vec3 vertexPosition = mix(subspacePositionA, subspacePositionB, aBoxCornerOffset);
emitCircle(uModelViewProjection * vec4(vertexPosition, 1.0), ng_lineWidth, 0.0);
uint cornerIndex = uint(aBoxCornerOffset.x + aBoxCornerOffset.y * 2.0 + aBoxCornerOffset.z * 4.0);
uint cornerPickOffset = ${ih}u + cornerIndex;
${this.setPartIndex(e, "cornerPickOffset")};
`), e.setFragmentMain(`
vec4 borderColor = vec4(0.0, 0.0, 0.0, 1.0);
vec4 color = getCircleColor(vColor, borderColor);
color.a *= vClipCoefficient;
emitAnnotation(color);
`);
    });
  }
  drawEdges(e) {
    const t = this.gl;
    this.enable(this.edgeShaderGetter, e, (i) => {
      const r = i.attribute("aBoxCornerOffset1"), s = i.attribute("aBoxCornerOffset2");
      this.edgeBoxCornerOffsetsBuffer.bindToVertexAttrib(
        r,
        /*components=*/
        3,
        /*attributeType=*/
        WebGL2RenderingContext.FLOAT,
        /*normalized=*/
        false,
        /*stride=*/
        4 * 7,
        /*offset=*/
        0
      ), this.edgeBoxCornerOffsetsBuffer.bindToVertexAttrib(
        s,
        /*components=*/
        4,
        /*attributeType=*/
        WebGL2RenderingContext.FLOAT,
        /*normalized=*/
        false,
        /*stride=*/
        4 * 7,
        /*offset=*/
        4 * 3
      ), gr(
        i,
        e.renderContext.projectionParameters,
        /*featherWidthInPixels=*/
        1
      ), pr(t, Jy, e.count), t.disableVertexAttribArray(r), t.disableVertexAttribArray(s);
    });
  }
  drawCorners(e) {
    const t = this.gl;
    this.enable(this.cornerShaderGetter, e, (i) => {
      const r = i.attribute("aBoxCornerOffset");
      this.boxCornerOffsetsBuffer.bindToVertexAttrib(
        r,
        /*components=*/
        3,
        /*attributeType=*/
        WebGL2RenderingContext.FLOAT,
        /*normalized=*/
        false
      ), Qc(i, e.renderContext.projectionParameters, { featherWidthInPixels: 0 }), ed(i.gl, vL, e.count), t.disableVertexAttribArray(r);
    });
  }
  draw(e) {
    this.drawEdges(e), this.drawCorners(e);
  }
};
var p4 = class extends bL {
  constructor() {
    super(...arguments), this.faceShaderGetter = this.getDependentShader("annotation/boundingBox/crossSection/face", (e) => {
      const t = this.rank;
      super.defineShader(e), nh(e), fr(e), e.addVarying("highp float", "vClipCoefficient"), Mm(e), e.setVertexMain(`
float modelPositionA[${t}] = getBounds0();
float modelPositionB[${t}] = getBounds1();
for (int i = 0; i < ${t}; ++i) {
  float a = modelPositionA[i];
  float b = modelPositionB[i];
  modelPositionA[i] = min(a, b);
  modelPositionB[i] = max(a, b);
}
vClipCoefficient = getMaxSubspaceClipCoefficient(modelPositionA, modelPositionB);
if (vClipCoefficient == 0.0) {
  gl_Position = vec4(2.0, 0.0, 0.0, 1.0);
  return;
}
vec3 subspacePositionA = projectModelVectorToSubspace(modelPositionA) + uModelSpaceBoundOffsets[0];
vec3 subspacePositionB = projectModelVectorToSubspace(modelPositionB) + uModelSpaceBoundOffsets[1];
int vertexIndex1 = gl_VertexID / ${bs};
int vertexIndex2 = vertexIndex1 == 5 ? 0 : vertexIndex1 + 1;
vec3 vertexPosition1 = getBoundingBoxPlaneIntersectionVertexPosition(subspacePositionB - subspacePositionA, subspacePositionA, subspacePositionA, subspacePositionB, vertexIndex1);
vec3 vertexPosition2 = getBoundingBoxPlaneIntersectionVertexPosition(subspacePositionB - subspacePositionA, subspacePositionA, subspacePositionA, subspacePositionB, vertexIndex2);
ng_lineWidth = 1.0;
${this.invokeUserMain}
emitLine(uModelViewProjection * vec4(vertexPosition1, 1.0),
         uModelViewProjection * vec4(vertexPosition2, 1.0),
         ng_lineWidth);
${this.setPartIndex(e)};
`), e.setFragmentMain(`
emitAnnotation(vec4(vColor.rgb, vColor.a * getLineAlpha() * vClipCoefficient));
`);
    }), this.fillShaderGetter = this.getDependentShader("annotation/boundingBox/crossSection/fill", (e) => {
      const t = this.rank;
      super.defineShader(e), nh(e), e.addVarying("highp float", "vClipCoefficient"), h4(e), e.setVertexMain(`
float modelPositionA[${t}] = getBounds0();
float modelPositionB[${t}] = getBounds1();
for (int i = 0; i < ${t}; ++i) {
  float a = modelPositionA[i];
  float b = modelPositionB[i];
  modelPositionA[i] = min(a, b);
  modelPositionB[i] = max(a, b);
}
vClipCoefficient = getMaxSubspaceClipCoefficient(modelPositionA, modelPositionB);
if (vClipCoefficient == 0.0) {
  gl_Position = vec4(2.0, 0.0, 0.0, 1.0);
  return;
}
vec3 subspacePositionA = projectModelVectorToSubspace(modelPositionA) + uModelSpaceBoundOffsets[0];
vec3 subspacePositionB = projectModelVectorToSubspace(modelPositionB) + uModelSpaceBoundOffsets[1];
int vertexIndex = gl_VertexID;
vec3 vertexPosition = getBoundingBoxPlaneIntersectionVertexPosition(subspacePositionB - subspacePositionA, subspacePositionA, subspacePositionA, subspacePositionB, vertexIndex);
gl_Position = uModelViewProjection * vec4(vertexPosition, 1);
${this.invokeUserMain}
${this.setPartIndex(e)};
`), e.setFragmentMain(`
emitAnnotation(vec4(vColor.rgb, vColor.a * vClipCoefficient));
`);
    });
  }
  enableForBoundingBox(e, t, i) {
    super.enable(e, t, (r) => {
      const s = t.renderContext.sliceView.projectionParameters.value;
      jy(r, s.viewportNormalInGlobalCoordinates, s.centerDataPosition, t.renderSubspaceModelMatrix, t.renderSubspaceInvModelMatrix), i(r);
    });
  }
  draw(e) {
    this.shaderControlState.parseResult.value.code.match(/\bsetBoundingBoxFillColor\b/) && this.enableForBoundingBox(this.fillShaderGetter, e, () => {
      mV(this.gl, WebGL2RenderingContext.TRIANGLE_FAN, 0, 6, e.count);
    }), this.enableForBoundingBox(this.faceShaderGetter, e, (t) => {
      gr(
        t,
        e.renderContext.projectionParameters,
        /*featherWidthInPixels=*/
        1
      ), pr(t.gl, 6, e.count);
    });
  }
};
function g4(n, e) {
  const t = n.length;
  for (let i = 0; i < t; ++i) {
    const r = e[i], s = e[i + t], a = n[i];
    n[i] = Math.abs(r - a) < Math.abs(s - a) ? r : s;
  }
}
Wc(Me.AXIS_ALIGNED_BOUNDING_BOX, {
  sliceViewRenderHelper: p4,
  perspectiveViewRenderHelper: f4,
  defineShaderNoOpSetters(n) {
    wL(n), CL(n);
  },
  pickIdsPerInstance: d4,
  snapPosition(n, e, t, i) {
    const r = n.length, s = new Float32Array(e, t, r * 2);
    i >= ih && i < kn && g4(n, s);
  },
  getRepresentativePoint(n, e, t) {
    t === yL || t >= ih && t < kn || t >= kn && t < SL, n.set(e.pointA);
  },
  updateViaRepresentativePoint(n, e, t) {
    const i = e.length, r = n.pointA, s = n.pointB, a = new Float32Array(i), l = new Float32Array(i);
    for (let d = 0; d < i; ++d) {
      const u = a[d] = e[d];
      l[d] = s[d] + (u - r[d]);
    }
    return RZr(RZr({}, n), { pointA: a, pointB: l });
  }
});
var ao2 = 0;
var Nm = ao2 + 1;
var m4 = Nm + 2;
function xL(n) {
  n.addVertexCode(`
void setEndpointMarkerSize(float startSize, float endSize) {}
void setEndpointMarkerBorderWidth(float startSize, float endSize) {}
void setEndpointMarkerColor(vec4 startColor, vec4 endColor) {}
void setEndpointMarkerBorderColor(vec4 startColor, vec4 endColor) {}
`);
}
function EL(n) {
  n.addVertexCode(`
void setLineWidth(float width) {}
void setLineColor(vec4 startColor, vec4 endColor) {}
`);
}
var xx = class extends $c {
  constructor() {
    super(...arguments), this.vertexIdHelper = this.registerDisposer(mr.get(this.gl)), this.edgeShaderGetter = this.getDependentShader("annotation/line/edge", (e) => {
      const t = this.rank;
      this.defineShader(e), fr(e), e.addVarying(`highp float[${t}]`, "vModelPosition"), e.addVertexCode(`
float ng_LineWidth;
`), xL(e), e.addVertexCode(`
void setLineWidth(float width) {
  ng_LineWidth = width;
}
void setLineColor(vec4 startColor, vec4 endColor) {
  vColor = mix(startColor, endColor, getLineEndpointCoefficient());
}
`), e.setVertexMain(`
float modelPositionA[${t}] = getVertexPosition0();
float modelPositionB[${t}] = getVertexPosition1();
for (int i = 0; i < ${t}; ++i) {
  vModelPosition[i] = mix(modelPositionA[i], modelPositionB[i], getLineEndpointCoefficient());
}
ng_LineWidth = 1.0;
vColor = vec4(0.0, 0.0, 0.0, 0.0);
${this.invokeUserMain}
emitLine(uModelViewProjection * vec4(projectModelVectorToSubspace(modelPositionA), 1.0),
         uModelViewProjection * vec4(projectModelVectorToSubspace(modelPositionB), 1.0),
         ng_LineWidth);
${this.setPartIndex(e)};
`), e.setFragmentMain(`
float clipCoefficient = getSubspaceClipCoefficient(vModelPosition);
emitAnnotation(vec4(vColor.rgb, vColor.a * getLineAlpha() *
                                ${this.getCrossSectionFadeFactor()} *
                                clipCoefficient));
`);
    }), this.endpointShaderGetter = this.getDependentShader("annotation/line/endpoint", (e) => {
      const t = this.rank;
      this.defineShader(e), Xc(e, this.targetIsSliceView), e.addVarying("highp float", "vClipCoefficient"), e.addVarying("highp vec4", "vBorderColor"), EL(e), e.addVertexCode(`
float ng_markerDiameter;
float ng_markerBorderWidth;
int getEndpointIndex() {
  return gl_VertexID / ${Dy};
}
void setEndpointMarkerSize(float startSize, float endSize) {
  ng_markerDiameter = mix(startSize, endSize, float(getEndpointIndex()));
}
void setEndpointMarkerBorderWidth(float startSize, float endSize) {
  ng_markerBorderWidth = mix(startSize, endSize, float(getEndpointIndex()));
}
void setEndpointMarkerColor(vec4 startColor, vec4 endColor) {
  vColor = mix(startColor, endColor, float(getEndpointIndex()));
}
void setEndpointMarkerBorderColor(vec4 startColor, vec4 endColor) {
  vBorderColor = mix(startColor, endColor, float(getEndpointIndex()));
}
`), e.setVertexMain(`
float modelPosition[${t}] = getVertexPosition0();
float modelPositionB[${t}] = getVertexPosition1();
for (int i = 0; i < ${t}; ++i) {
  modelPosition[i] = mix(modelPosition[i], modelPositionB[i], float(getEndpointIndex()));
}
vClipCoefficient = getSubspaceClipCoefficient(modelPosition);
vColor = vec4(0.0, 0.0, 0.0, 0.0);
vBorderColor = vec4(0.0, 0.0, 0.0, 1.0);
ng_markerDiameter = 5.0;
ng_markerBorderWidth = 1.0;
${this.invokeUserMain}
emitCircle(uModelViewProjection * vec4(projectModelVectorToSubspace(modelPosition), 1.0), ng_markerDiameter, ng_markerBorderWidth);
${this.setPartIndex(e, "uint(getEndpointIndex()) + 1u")};
`), e.setFragmentMain(`
vec4 color = getCircleColor(vColor, vBorderColor);
color.a *= vClipCoefficient;
emitAnnotation(color);
`);
    });
  }
  defineShader(e) {
    Wr(e);
    const t = this.rank;
    Uc(
      e,
      "float",
      WebGL2RenderingContext.FLOAT,
      /*normalized=*/
      false,
      "VertexPosition",
      t,
      2
    );
  }
  enable(e, t, i) {
    super.enable(e, t, (r) => {
      const s = r.vertexShaderInputBinders.VertexPosition;
      s.enable(1), this.gl.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, t.buffer.buffer), s.bind(this.geometryDataStride, t.bufferOffset);
      const a = this.vertexIdHelper;
      a.enable(), i(r), a.disable(), s.disable();
    });
  }
  drawEdges(e) {
    this.enable(this.edgeShaderGetter, e, (t) => {
      gr(
        t,
        e.renderContext.projectionParameters,
        /*featherWidthInPixels=*/
        1
      ), pr(t.gl, 1, e.count);
    });
  }
  drawEndpoints(e) {
    this.enable(this.endpointShaderGetter, e, (t) => {
      Qc(t, e.renderContext.projectionParameters, { featherWidthInPixels: 0.5 }), ed(t.gl, 2, e.count);
    });
  }
  draw(e) {
    this.drawEdges(e), this.drawEndpoints(e);
  }
};
function v4(n, e) {
  const t = n.length;
  ZE(n, e.subarray(0, t), e.subarray(t), n);
}
function y4(n, e, t) {
  const i = n.length, r = i * t;
  for (let s = 0; s < i; ++s)
    n[s] = e[r + s];
}
Wc(Me.LINE, {
  sliceViewRenderHelper: xx,
  perspectiveViewRenderHelper: xx,
  defineShaderNoOpSetters(n) {
    xL(n), EL(n);
  },
  pickIdsPerInstance: m4,
  snapPosition(n, e, t, i) {
    const r = n.length, s = new Float32Array(e, t, r * 2);
    i === ao2 ? v4(n, s) : y4(n, s, i - Nm);
  },
  getRepresentativePoint(n, e, t) {
    n.set(t === ao2 || t === Nm ? e.pointA : e.pointB);
  },
  updateViaRepresentativePoint(n, e, t) {
    let i = RZr({}, n);
    const r = e.length;
    switch (t) {
      case ao2: {
        const s = n.pointA, a = n.pointB, l = new Float32Array(r), d = new Float32Array(r);
        for (let u = 0; u < r; ++u) {
          const f = l[u] = e[u];
          d[u] = a[u] + (f - s[u]);
        }
        return RZr(RZr({}, n), { pointA: l, pointB: d });
      }
      case ao2 + 1:
        return RZr(RZr({}, n), { pointA: new Float32Array(e) });
      case ao2 + 2:
        return RZr(RZr({}, n), { pointB: new Float32Array(e) });
    }
    return i;
  }
});
var Ex = class extends $c {
  constructor() {
    super(...arguments), this.shaderGetter3d = this.getDependentShader("annotation/point:3d", (e) => {
      Wr(e), Xc(
        e,
        /*crossSectionFade=*/
        this.targetIsSliceView
      ), this.defineShaderCommon(e), e.addVertexMain(`
emitCircle(uModelViewProjection *
           vec4(projectModelVectorToSubspace(modelPosition), 1.0), ng_markerDiameter, ng_markerBorderWidth);
`), e.setFragmentMain(`
vec4 color = getCircleColor(vColor, vBorderColor);
emitAnnotation(color);
`);
    }), this.makeShaderGetter2d = (e) => this.getDependentShader(`annotation/point:2d:${e}`, (t) => {
      Wr(t), fr(
        t,
        /*rounded=*/
        true
      ), this.defineShaderCommon(t), t.addVertexMain(`
vec3 subspacePositionA = projectModelVectorToSubspace(modelPosition);
vec3 subspacePositionB = subspacePositionA;
vec4 baseProjection = uModelViewProjection * vec4(subspacePositionA, 1.0);
vec4 zCoeffs = uModelViewProjection[${e}];
float minZ = 1e30;
float maxZ = -1e30;
for (int i = 0; i < 3; ++i) {
  // Want: baseProjection[i] + z * zCoeffs[i] = -2.0 * (baseProjection.w - z * zCoeffs.w)
  //  i.e. baseProjection[i] + 2.0 * baseProjection.w < -z * (2.0 * zCoeffs.w + zCoeffs[i])
  //  i.e. baseProjection[i] + 2.0 * baseProjection.w < -z * k1
  float k1 = 2.0 * zCoeffs.w + zCoeffs[i];
  float q1 = -(baseProjection[i] + 2.0 * baseProjection.w) / k1;
  if (k1 != 0.0) {
    minZ = min(minZ, q1);
    maxZ = max(maxZ, q1);
  }
  // Want: baseProjection[i] + z * zCoeffs[i] = 2.0 * (baseProjection.w + z * zCoeffs.w)
  //  i.e. baseProjection[i] - 2.0 * baseProjection.w > z * (2.0 * zCoeffs.w - zCoeffs[i])
  //  i.e. baseProjection[i] - 2.0 * baseProjection.w > z * k2
  float k2 = 2.0 * zCoeffs.w - zCoeffs[i];
  float q2 = (baseProjection[i] - 2.0 * baseProjection.w) / k2;
  if (k2 != 0.0) {
    minZ = min(minZ, q2);
    maxZ = max(maxZ, q2);
  }
}
if (minZ > maxZ) minZ = maxZ = 0.0;
subspacePositionA[${e}] = minZ;
subspacePositionB[${e}] = maxZ;
emitLine(uModelViewProjection, subspacePositionA, subspacePositionB, ng_markerDiameter, ng_markerBorderWidth);
`), t.setFragmentMain(`
vec4 color = getRoundedLineColor(vColor, vBorderColor);
emitAnnotation(vec4(color.rgb, color.a * ${this.getCrossSectionFadeFactor()}));
`);
    }), this.shaderGetter2d = this.makeShaderGetter2d(2), this.shaderGetter1d = this.makeShaderGetter2d(1), this.vertexIdHelper = this.registerDisposer(mr.get(this.gl));
  }
  defineShaderCommon(e) {
    const t = this.rank;
    Uc(
      e,
      "float",
      WebGL2RenderingContext.FLOAT,
      /*normalized=*/
      false,
      "VertexPosition",
      t
    ), e.addVarying("highp vec4", "vBorderColor"), e.addVertexCode(`
float ng_markerDiameter;
float ng_markerBorderWidth;
void setPointMarkerSize(float size) {
  ng_markerDiameter = size;
}
void setPointMarkerBorderWidth(float size) {
  ng_markerBorderWidth = size;
}
void setPointMarkerColor(vec4 color) {
  vColor = color;
}
void setPointMarkerBorderColor(vec4 color) {
  vBorderColor = color;
}
`), e.addVertexMain(`
ng_markerDiameter = 5.0;
ng_markerBorderWidth = 1.0;
vBorderColor = vec4(0.0, 0.0, 0.0, 1.0);
float modelPosition[${t}] = getVertexPosition0();
float clipCoefficient = getSubspaceClipCoefficient(modelPosition);
if (clipCoefficient == 0.0) {
  gl_Position = vec4(2.0, 0.0, 0.0, 1.0);
  return;
}
${this.invokeUserMain}
vColor.a *= clipCoefficient;
vBorderColor.a *= clipCoefficient;
${this.setPartIndex(e)};
`);
  }
  enable(e, t, i) {
    super.enable(e, t, (r) => {
      const s = r.vertexShaderInputBinders.VertexPosition;
      s.enable(1), this.gl.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, t.buffer.buffer), s.bind(this.geometryDataStride, t.bufferOffset);
      const a = this.vertexIdHelper;
      a.enable(), i(r), a.disable(), s.disable();
    });
  }
  draw(e) {
    const t = e.chunkDisplayTransform.numChunkDisplayDims;
    switch (t) {
      case 3:
        this.enable(this.shaderGetter3d, e, (i) => {
          Qc(i, e.renderContext.projectionParameters, { featherWidthInPixels: 1 }), ed(i.gl, 1, e.count);
        });
        break;
      case 2:
      case 1:
        this.enable(t === 2 ? this.shaderGetter2d : this.shaderGetter1d, e, (i) => {
          gr(
            i,
            e.renderContext.projectionParameters,
            /*featherWidthInPixels=*/
            1
          ), pr(i.gl, 1, e.count);
        });
        break;
    }
  }
};
Wc(Me.POINT, {
  sliceViewRenderHelper: Ex,
  perspectiveViewRenderHelper: Ex,
  defineShaderNoOpSetters(n) {
    n.addVertexCode(`
void setPointMarkerSize(float size) {}
void setPointMarkerBorderWidth(float size) {}
void setPointMarkerColor(vec4 color) {}
void setPointMarkerBorderColor(vec4 color) {}
`);
  },
  pickIdsPerInstance: 1,
  snapPosition(n, e, t) {
    n.set(new Float32Array(e, t, n.length));
  },
  getRepresentativePoint(n, e) {
    n.set(e.point);
  },
  updateViaRepresentativePoint(n, e) {
    return RZr(RZr({}, n), { point: new Float32Array(e) });
  }
});
var TL = `
struct EllipseQuadraticForm {
  highp float A;  // x*x coefficient
  highp float B;  // x*y coefficient
  highp float C;  // y*y coefficient
  highp float D;  // x coefficient
  highp float E;  // y coefficient
  highp float F;  // 1 coefficient
};
`;
var S4 = [TL, `
EllipseQuadraticForm computeCrossSectionEllipse(mat3 A, vec3 c) {
  EllipseQuadraticForm p;
  p.A = A[0][0];
  p.B = A[0][1] + A[1][0];
  p.C = A[1][1];
  p.D = -2.0 * c[0] * A[0][0] - c[1] * (A[0][1] + A[1][0]) +
        c[2] * (A[0][2] + A[2][0]);
  p.E = -c[0] * (A[0][1] + A[1][0]) - 2.0 * c[1] * A[1][1] +
        c[2] * (A[1][2] + A[2][1]);
  p.F = c[0] * c[0] * A[0][0] + c[0] * c[1] * (A[0][1] + A[1][0]) -
        c[0] * c[2] * (A[0][2] + A[2][0]) + c[1] * c[1] * A[1][1] -
        c[1] * c[2] * (A[1][2] + A[2][1]) + c[2] * c[2] * A[2][2] - 1.0;
  return p;
}
`];
var b4 = `
struct CenterOrientEllipse {
  vec2 k;   // center
  vec2 u1;  // minor axis direction
  vec2 u2;  // major axis direction
  float a;  // semimajor axis
  float b;  // semiminor axis
  bool valid; // indicates if the ellipse is valid
};
`;
var C4 = [TL, b4, `
CenterOrientEllipse computeCenterOrientEllipse(EllipseQuadraticForm p) {
  CenterOrientEllipse r;
  float a11 = p.A;
  float a12 = p.B / 2.0;
  float a22 = p.C;
  float b1 = p.D;
  float b2 = p.E;
  float c = p.F;
  float kdenom = 2.0 * (a12 * a12 - a11 * a22);
  float k1 = r.k.x = (a22 * b1 - a12 * b2) / kdenom;
  float k2 = r.k.y = (a11 * b2 - a12 * b1) / kdenom;
  float mu = 1.0 / (a11 * k1 * k1 + 2.0 * a12 * k1 * k2 + a22 * k2 * k2 - c);
  float m11 = mu * a11;
  float m12 = mu * a12;
  float m22 = mu * a22;
  float lambdaTerm1 = m11 + m22;
  float lambdaTerm2 = sqrt((m11 - m22) * (m11 - m22) + 4.0 * m12 * m12);
  float lambda1 = ((lambdaTerm1 + lambdaTerm2) / 2.0);
  float lambda2 = ((lambdaTerm1 - lambdaTerm2) / 2.0);
  r.a = 1.0 / sqrt(lambda1);
  r.b = 1.0 / sqrt(lambda2);
  r.valid = lambda1 > 0.0 && lambda2 > 0.0;
  if (abs(m11 - m22) < 1e-6 && abs(m12) < 1e-6) {
    r.u1 = vec2(1.0, 0.0);
  } else if (m11 >= m22) {
    r.u1 = normalize(vec2(lambda1 - m22, m12));
  } else {
    r.u1 = normalize(vec2(m12, lambda1 - m11));
  }
  r.u2 = vec2(-r.u1.y, r.u1.x);
  return r;
}
`];
var Tx = et();
var kL = class extends $c {
  defineShader(e) {
    const t = this.rank;
    Uc(
      e,
      "float",
      WebGL2RenderingContext.FLOAT,
      /*normalized=*/
      false,
      "CenterAndRadii",
      t,
      2
    ), e.addVertexCode(`
struct SubspaceParams {
  highp vec3 subspaceCenter;
  highp vec3 subspaceRadii;
  highp float clipCoefficient;
  bool cull;
};
SubspaceParams getSubspaceParams() {
  SubspaceParams params;
  highp float modelCenter[${t}] = getCenterAndRadii0();
  highp float modelRadii[${t}] = getCenterAndRadii1();
  float radiusAdjustment = 1.0;
  float clipCoefficient = 1.0;
  for (int i = 0; i < ${t}; ++i) {
    float r = modelRadii[i];
    float c = modelCenter[i];
    float x = uModelClipBounds[i];
    float clipRadius = uModelClipBounds[i + ${t}];
    if (r != 0.0 && clipRadius != 0.0) {
      float d = c - x;
      d = d * d;
      radiusAdjustment -= d / (r * r);
    }
    float e = abs(x - clamp(x, c - r, c + r)) * clipRadius;
    clipCoefficient *= max(0.0, 1.0 - e);
  }
  radiusAdjustment = sqrt(max(0.0, radiusAdjustment));
  params.subspaceCenter = projectModelVectorToSubspace(modelCenter);
  params.subspaceRadii = projectModelVectorToSubspace(modelRadii) * radiusAdjustment;
  params.clipCoefficient = clipCoefficient;
  params.cull = clipCoefficient == 0.0 || radiusAdjustment == 0.0;
  return params;
}
void setEllipsoidFillColor(vec4 color) {
  vColor = color;
}
`);
  }
  enable(e, t, i) {
    super.enable(e, t, (r) => {
      const s = r.vertexShaderInputBinders.CenterAndRadii;
      s.enable(1), this.gl.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, t.buffer.buffer), s.bind(this.geometryDataStride, t.bufferOffset), i(r), s.disable();
    });
  }
};
var w4 = class extends kL {
  constructor() {
    super(...arguments), this.sphereRenderHelper = this.registerDisposer(new Qk(this.gl, 10, 10)), this.shaderGetter = this.getDependentShader("annotation/ellipsoid/projection", (e) => {
      this.defineShader(e), this.sphereRenderHelper.defineShader(e), e.addUniform("highp vec4", "uLightDirection"), e.addUniform("highp mat4", "uNormalTransform"), e.addVarying("highp float", "vClipCoefficient"), e.setVertexMain(`
SubspaceParams params = getSubspaceParams();
if (params.cull) {
  gl_Position = vec4(2.0, 0.0, 0.0, 1.0);
  return;
}
vClipCoefficient = params.clipCoefficient;
${this.invokeUserMain}
emitSphere(uModelViewProjection, uNormalTransform, params.subspaceCenter, params.subspaceRadii, uLightDirection);
${this.setPartIndex(e)};
`), e.setFragmentMain(`
emitAnnotation(vec4(vColor.rgb * vLightingFactor, vColor.a * vClipCoefficient));
`);
    }), this.tempLightVec = new Float32Array(4);
  }
  draw(e) {
    this.enable(this.shaderGetter, e, (t) => {
      const i = t.gl;
      let r = this.tempLightVec;
      var s = e.renderContext;
      let a = s.lightDirection, l = s.ambientLighting, d = s.directionalLighting;
      Ev(r, a, d), r[3] = l, i.uniform4fv(t.uniform("uLightDirection"), r), i.uniformMatrix4fv(
        t.uniform("uNormalTransform"),
        /*transpose=*/
        false,
        xv2(et(), e.renderSubspaceInvModelMatrix)
      ), this.sphereRenderHelper.draw(t, e.count);
    });
  }
};
var x4 = class extends kL {
  constructor() {
    super(...arguments), this.shaderGetter = this.getDependentShader("annotation/ellipsoid/crossSection", (e) => {
      Wr(e), this.defineShader(e), e.addUniform("highp mat4", "uViewportToObject"), e.addUniform("highp mat4", "uObjectToViewport"), e.addUniform("highp mat4", "uViewportToDevice"), e.addAttribute("highp vec2", "aCornerOffset"), e.addVarying("highp vec2", "vCircleCoord"), e.addVarying("highp float", "vClipCoefficient"), e.addVertexCode(S4), e.addVertexCode(C4), e.addVertexCode(Iy), e.setVertexMain(`
SubspaceParams params = getSubspaceParams();
if (params.cull) {
  gl_Position = vec4(2.0, 0.0, 0.0, 1.0);
  return;
}
vClipCoefficient = params.clipCoefficient;
mat3 Aobject = mat3(0.0);
for (int i = 0; i < 3; ++i) {
  float r = max(params.subspaceRadii[i], 1e-3);
  Aobject[i][i] = 1.0 / (r * r);
}
mat3 RviewportToObject = mat3(uViewportToObject);
mat3 Aviewport = transpose(RviewportToObject) * Aobject * RviewportToObject;
vec3 cViewport = (uObjectToViewport * vec4(params.subspaceCenter, 1.0)).xyz;
EllipseQuadraticForm quadraticForm = computeCrossSectionEllipse(Aviewport, cViewport);
vec2 u1, u2;
float a, b;
CenterOrientEllipse centerOrient = computeCenterOrientEllipse(quadraticForm);
vec2 cornerOffset = getQuadVertexPosition(vec2(-1.0, -1.0), vec2(1.0, 1.0));
vec2 viewportCorner = centerOrient.k +
  centerOrient.u1 * cornerOffset.x * centerOrient.a +
  centerOrient.u2 * cornerOffset.y * centerOrient.b;
if (centerOrient.valid) {
  gl_Position = uViewportToDevice * vec4(viewportCorner, 0.0, 1.0);
} else {
  gl_Position = vec4(2.0, 0.0, 0.0, 1.0);
}
vCircleCoord = cornerOffset;
${this.invokeUserMain}
${this.setPartIndex(e)};
`), e.setFragmentMain(`
if (dot(vCircleCoord, vCircleCoord) > 1.0) {
  discard;
}
emitAnnotation(vec4(vColor.rgb, vColor.a * vClipCoefficient));
`);
    }), this.vertexIdHelper = this.registerDisposer(mr.get(this.gl));
  }
  draw(e) {
    this.enable(this.shaderGetter, e, (t) => {
      const i = t.gl, r = e.renderContext.sliceView.projectionParameters.value, s = mn(Tx, e.renderSubspaceInvModelMatrix, r.invViewMatrix);
      i.uniformMatrix4fv(
        t.uniform("uViewportToObject"),
        /*transpose=*/
        false,
        s
      ), i.uniformMatrix4fv(
        t.uniform("uViewportToDevice"),
        /*transpose=*/
        false,
        r.projectionMat
      );
      const a = Tx;
      xs(a, s), i.uniformMatrix4fv(
        t.uniform("uObjectToViewport"),
        /*transpose=*/
        false,
        a
      );
      const l = this.vertexIdHelper;
      l.enable(), Ly(i, 1, e.count), l.disable();
    });
  }
};
Wc(Me.ELLIPSOID, {
  sliceViewRenderHelper: x4,
  perspectiveViewRenderHelper: w4,
  defineShaderNoOpSetters(n) {
    n.addVertexCode(`
void setEllipsoidFillColor(vec4 color) {}
`);
  },
  pickIdsPerInstance: 1,
  snapPosition: () => {
  },
  getRepresentativePoint(n, e) {
    n.set(e.center);
  },
  updateViaRepresentativePoint(n, e) {
    return RZr(RZr({}, n), { center: new Float32Array(e) });
  }
});
var oo = 0;
var _m = oo + 1;
var E4 = _m + 2;
function Om(n) {
  n.addVertexCode(`
 void setAxisEndpointMarkerSize(float startSize, float endSize) {}
 void setAxisEndpointMarkerBorderWidth(float startSize, float endSize) {}
 void setAxisEndpointMarkerColor(vec4 startColor, vec4 endColor) {}
 void setAxisEndpointMarkerBorderColor(vec4 startColor, vec4 endColor) {}
 `);
}
function Vm(n) {
  n.addVertexCode(`
 void setAxisWidth(float width) {}
 void setAxisColor(vec4 startColor, vec4 endColor) {}
 `);
}
function Bm(n) {
  n.addVertexCode(`
 void setSphereColor(vec4 color) {}
 `);
}
var kx = class extends $c {
  constructor() {
    super(...arguments), this.sphereShader = this.registerDisposer(new SU(this.gl)), this.vertexIdHelper = this.registerDisposer(mr.get(this.gl)), this.edgeShaderGetter = this.getDependentShader("annotation/sphere/axis", (e) => {
      const t = this.rank;
      this.defineShader(e), fr(e), e.addVarying(`highp float[${t}]`, "vModelPosition"), e.addVertexCode(`
float ng_LineWidth;
`), Om(e), Bm(e), e.addVertexCode(`
void setAxisWidth(float width) {
  ng_LineWidth = width;
}
void setAxisColor(vec4 startColor, vec4 endColor) {
  vColor = mix(startColor, endColor, getLineEndpointCoefficient());
}
`), e.setVertexMain(`
float modelPositionA[${t}] = getVertexPosition0();
float modelPositionB[${t}] = getVertexPosition1();
for (int i = 0; i < ${t}; ++i) {
  vModelPosition[i] = mix(modelPositionA[i], modelPositionB[i], getLineEndpointCoefficient());
}
ng_LineWidth = 1.0;
vColor = vec4(0.0, 0.0, 0.0, 0.0);
${this.invokeUserMain}
emitLine(uModelViewProjection * vec4(projectModelVectorToSubspace(modelPositionA), 1.0),
         uModelViewProjection * vec4(projectModelVectorToSubspace(modelPositionB), 1.0),
         ng_LineWidth);
${this.setPartIndex(e)};
`), e.setFragmentMain(`
float clipCoefficient = getSubspaceClipCoefficient(vModelPosition);
emitAnnotation(vec4(vColor.rgb, vColor.a * getLineAlpha() *
                                ${this.getCrossSectionFadeFactor()} *
                                clipCoefficient));
`);
    }), this.endpointShaderGetter = this.getDependentShader("annotation/sphere/endpoint", (e) => {
      const t = this.rank;
      this.defineShader(e), Xc(e, this.targetIsSliceView), e.addVarying("highp float", "vClipCoefficient"), e.addVarying("highp vec4", "vBorderColor"), Vm(e), Bm(e), e.addVertexCode(`
float ng_markerDiameter;
float ng_markerBorderWidth;
int getEndpointIndex() {
  return gl_VertexID / ${Dy};
}
void setAxisEndpointMarkerSize(float startSize, float endSize) {
  ng_markerDiameter = mix(startSize, endSize, float(getEndpointIndex()));
}
void setAxisEndpointMarkerBorderWidth(float startSize, float endSize) {
  ng_markerBorderWidth = mix(startSize, endSize, float(getEndpointIndex()));
}
void setAxisEndpointMarkerColor(vec4 startColor, vec4 endColor) {
  vColor = mix(startColor, endColor, float(getEndpointIndex()));
}
void setAxisEndpointMarkerBorderColor(vec4 startColor, vec4 endColor) {
  vBorderColor = mix(startColor, endColor, float(getEndpointIndex()));
}
`), e.setVertexMain(`
float modelPosition[${t}] = getVertexPosition0();
float modelPositionB[${t}] = getVertexPosition1();
for (int i = 0; i < ${t}; ++i) {
  modelPosition[i] = mix(modelPosition[i], modelPositionB[i], float(getEndpointIndex()));
}
vClipCoefficient = getSubspaceClipCoefficient(modelPosition);
vColor = vec4(0.0, 0.0, 0.0, 0.0);
vBorderColor = vec4(0.0, 0.0, 0.0, 1.0);
ng_markerDiameter = 5.0;
ng_markerBorderWidth = 1.0;
${this.invokeUserMain}
emitCircle(uModelViewProjection * vec4(projectModelVectorToSubspace(modelPosition), 1.0), ng_markerDiameter, ng_markerBorderWidth);
${this.setPartIndex(e, "uint(getEndpointIndex()) + 1u")};
`), e.setFragmentMain(`
vec4 color = getCircleColor(vColor, vBorderColor);
color.a *= vClipCoefficient;
emitAnnotation(color);
`);
    }), this.sphereShadeGetter = this.getDependentShader("annotation/sphere/sphere", (e) => {
      const t = this.rank;
      this.defineShader(e), this.sphereShader.defineShader(e), e.addVarying("highp float", "vClipCoefficient"), Vm(e), Om(e), e.addVertexCode(`
 void setSphereColor(vec4 color) {
   vColor = color;
 }
 `), e.setVertexMain(`
 float modelPosition[${t}] = getVertexPosition0();
 float modelPositionB[${t}] = getVertexPosition1();
 float diameter = 0.0;
 for (int i = 0; i < ${t}; ++i) {
   float dx = modelPosition[i] - modelPositionB[i];
   diameter += dx * dx;
   modelPosition[i] = (modelPosition[i] + modelPositionB[i]) * 0.5;
 }
 float radius = sqrt(diameter) * 0.5;
 if (radius > 0.0) {
   vClipCoefficient = getRadiusAdjustment(vec3(modelPosition[0], modelPosition[1], modelPosition[2]), radius);
 } else {
   vClipCoefficient = 1.0;
 }

 // vClipCoefficient = getSubspaceClipCoefficient(modelPosition);
 vColor = vec4(1.0, 0.0, 0.0, 0.5);
 // vColor = vec4(defaultColor(), 0.5);
 ${this.invokeUserMain}
 // float radius = diameter * 0.5;
 emitSphere(uModelViewProjection, uNormalTransform, projectModelVectorToSubspace(modelPosition), vec3(radius, radius, radius), uLightDirection);
 ${this.setPartIndex(e)};
 `), e.setFragmentMain(`
     vec4 color = vColor;
     color.a *= vClipCoefficient;
     emitAnnotation(color);
 `);
    });
  }
  defineShader(e) {
    Wr(e);
    const t = this.rank;
    Uc(
      e,
      "float",
      WebGL2RenderingContext.FLOAT,
      /*normalized=*/
      false,
      "VertexPosition",
      t,
      2
    );
  }
  enable(e, t, i, r = true) {
    super.enable(e, t, (s) => {
      const a = s.vertexShaderInputBinders.VertexPosition;
      a.enable(1), this.gl.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER, t.buffer.buffer), a.bind(this.serializedBytesPerAnnotation, t.bufferOffset);
      const l = this.vertexIdHelper;
      r && l.enable(), i(s), r && l.disable(), a.disable();
    });
  }
  drawEdges(e) {
    this.enable(this.edgeShaderGetter, e, (t) => {
      gr(
        t,
        e.renderContext.projectionParameters,
        /*featherWidthInPixels=*/
        1
      ), pr(t.gl, 1, e.count);
    });
  }
  drawEndpoints(e) {
    this.enable(this.endpointShaderGetter, e, (t) => {
      Qc(t, e.renderContext.projectionParameters, { featherWidthInPixels: 0.5 }), ed(t.gl, 2, e.count);
    });
  }
  drawSphere(e) {
    this.enable(this.sphereShadeGetter, e, (t) => {
      this.sphereShader.draw(t, e, e.count);
    }, false);
  }
  draw(e) {
    this.drawEdges(e), this.drawEndpoints(e), this.drawSphere(e);
  }
};
function T4(n, e) {
  const t = n.length;
  ZE(n, e.subarray(0, t), e.subarray(t), n);
}
function k4(n, e, t) {
  const i = n.length, r = i * t;
  for (let s = 0; s < i; ++s)
    n[s] = e[r + s];
}
Wc(Me.SPHERE, {
  sliceViewRenderHelper: kx,
  perspectiveViewRenderHelper: kx,
  defineShaderNoOpSetters(n) {
    Om(n), Vm(n), Bm(n);
  },
  pickIdsPerInstance: E4,
  snapPosition(n, e, t, i) {
    const r = n.length, s = new Float32Array(e, t, r * 2);
    i === oo ? T4(n, s) : k4(n, s, i - _m);
  },
  getRepresentativePoint(n, e, t) {
    n.set(t === oo || t === _m ? e.pointA : e.pointB);
  },
  updateViaRepresentativePoint(n, e, t) {
    let i = RZr({}, n);
    const r = e.length;
    switch (t) {
      case oo: {
        const s = n.pointA, a = n.pointB, l = new Float32Array(r), d = new Float32Array(r);
        for (let u = 0; u < r; ++u) {
          const f = l[u] = e[u];
          d[u] = a[u] + (f - s[u]);
        }
        return RZr(RZr({}, n), { pointA: l, pointB: d });
      }
      case oo + 1:
        return RZr(RZr({}, n), { pointA: new Float32Array(e) });
      case oo + 2:
        return RZr(RZr({}, n), { pointB: new Float32Array(e) });
    }
    return i;
  }
});
var IL = et();
var LL = _e();
function DL(n) {
  n.addUniform("highp vec3", "uTranslation"), n.addUniform("highp mat4", "uProjectionMatrix"), n.addUniform("highp vec3", "uChunkDataSize"), n.addUniform("highp vec3", "uLowerClipBound"), n.addUniform("highp vec3", "uUpperClipBound"), n.setFragmentMain(`
emit(vec4(1.0, 1.0, 1.0, getLineAlpha()), 0u);
`);
}
var I4 = {
  defineShader(n) {
    DL(n), fr(n), n.addVertexCode(`
const vec3[24] boxCornerOffsets = vec3[](
  vec3(0, 0, 0), vec3(0, 0, 1),  // e1
  vec3(1, 0, 0), vec3(1, 0, 1),  // e2
  vec3(0, 1, 0), vec3(0, 1, 1),  // e3
  vec3(1, 1, 0), vec3(1, 1, 1),  // e4
  vec3(0, 0, 0), vec3(0, 1, 0),  // e5
  vec3(0, 0, 1), vec3(0, 1, 1),  // e6
  vec3(1, 0, 0), vec3(1, 1, 0),  // e7
  vec3(1, 0, 1), vec3(1, 1, 1),  // e8
  vec3(0, 0, 0), vec3(1, 0, 0),  // e9
  vec3(0, 0, 1), vec3(1, 0, 1),  // e10
  vec3(0, 1, 0), vec3(1, 1, 0),  // e11
  vec3(0, 1, 1), vec3(1, 1, 1)  // e12
);
`), n.setVertexMain(`
int edgeIndex = gl_VertexID / ${bs};
vec3 cornerA = max(uLowerClipBound, min(uUpperClipBound, uTranslation));
vec3 cornerB = max(uLowerClipBound, min(uUpperClipBound, uTranslation + uChunkDataSize));
vec3 vertexPosition1 = mix(cornerA, cornerB, boxCornerOffsets[edgeIndex * 2]);
vec3 vertexPosition2 = mix(cornerA, cornerB, boxCornerOffsets[edgeIndex * 2 + 1]);
emitLine(uProjectionMatrix * vec4(vertexPosition1, 1.0),
         uProjectionMatrix * vec4(vertexPosition2, 1.0),
         2.0);
`);
  },
  initialize(n, e) {
    gr(
      n,
      e,
      /*featherWidthInPixels=*/
      1
    );
  },
  draw(n, e, t) {
    const i = n.gl, r = IL, s = e.chunkLayout;
    mn(r, t.viewProjectionMat, s.transform), i.uniformMatrix4fv(
      n.uniform("uProjectionMatrix"),
      /*transpose=*/
      false,
      r
    ), i.uniform3fv(n.uniform("uChunkDataSize"), s.size), i.uniform3fv(n.uniform("uLowerClipBound"), e.lowerClipDisplayBound), i.uniform3fv(n.uniform("uUpperClipBound"), e.upperClipDisplayBound);
    const a = s.size, l = e.curPositionInChunks, d = e.chunkDisplayDimensionIndices, u = LL;
    for (let f = 0; f < 3; ++f) {
      const g = d[f];
      u[f] = (g === -1 ? 0 : l[g]) * a[f];
    }
    i.uniform3fv(n.uniform("uTranslation"), u), pr(i, Jy, 1);
  }
};
var L4 = {
  defineShader(n) {
    nh(n), DL(n), fr(n), n.setVertexMain(`
int vertexIndex1 = gl_VertexID / ${bs};
int vertexIndex2 = vertexIndex1 == 5 ? 0 : vertexIndex1 + 1;
vec3 vertexPosition1 = getBoundingBoxPlaneIntersectionVertexPosition(uChunkDataSize, uTranslation, uLowerClipBound, uUpperClipBound, vertexIndex1);
vec3 vertexPosition2 = getBoundingBoxPlaneIntersectionVertexPosition(uChunkDataSize, uTranslation, uLowerClipBound, uUpperClipBound, vertexIndex2);
emitLine(uProjectionMatrix * vec4(vertexPosition1, 1.0),
         uProjectionMatrix * vec4(vertexPosition2, 1.0),
         2.0);
`);
  },
  initialize(n, e) {
    gr(
      n,
      e,
      /*featherWidthInPixels=*/
      1
    );
  },
  draw(n, e, t) {
    const i = n.gl, r = IL, s = e.chunkLayout;
    mn(r, t.viewProjectionMat, s.transform), i.uniformMatrix4fv(
      n.uniform("uProjectionMatrix"),
      /*transpose=*/
      false,
      r
    ), i.uniform3fv(n.uniform("uChunkDataSize"), s.size), i.uniform3fv(n.uniform("uLowerClipBound"), e.lowerClipDisplayBound), i.uniform3fv(n.uniform("uUpperClipBound"), e.upperClipDisplayBound);
    const a = s.size, l = e.curPositionInChunks, d = e.chunkDisplayDimensionIndices, u = LL;
    for (let f = 0; f < 3; ++f) {
      const g = d[f];
      u[f] = (g === -1 ? 0 : l[g]) * a[f];
    }
    i.uniform3fv(n.uniform("uTranslation"), u), jy(n, t.viewportNormalInGlobalCoordinates, t.centerDataPosition, s.transform, s.invTransform), pr(i, 6, 1);
  }
};
var D4 = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, s = r < 3 ? e : i === null ? i = $i(e, t) : i, a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(n, e, t, i);
  else
    for (var l = n.length - 1; l >= 0; l--)
      (a = n[l]) && (s = (r < 3 ? a(s) : r > 3 ? a(e, t, s) : a(e, t)) || s);
  return r > 3 && s && UZr(e, t, s), s;
};
var P4 = et();
function A4(n) {
  if (n !== void 0)
    return (e) => {
      const t = e.relatedSegments;
      if (t === void 0)
        return false;
      for (let r = 0, s = t.length; r < s; ++r) {
        const a = n[r];
        if (a == null)
          continue;
        var i = a.segmentationGroupState.value;
        const l = i.visibleSegments, d = i.segmentEquivalences;
        for (const u of t[r])
          if (l.has(d.get(u)))
            return true;
      }
      return false;
    };
}
function R4(n, e) {
  const t = new y2(n.annotationPropertySerializers);
  for (const i of n)
    (e === void 0 || e(i)) && t.add(i);
  return t.serialize();
}
var Fm = class extends Oh(Hc) {
  constructor(e, t, i, r) {
    super(r), this.chunkManager = e, this.source = t, this.segmentationStates = i, this.initializeCounterpart(this.chunkManager.rpc, {
      chunkManager: this.chunkManager.rpcId,
      source: t.rpcId,
      segmentationStates: this.serializeDisplayState()
    });
    const s = () => {
      const a = { id: this.rpcId, segmentationStates: this.serializeDisplayState() };
      this.rpc.invoke(_B, a);
    };
    this.registerDisposer(i.changed.add(s));
  }
  serializeDisplayState() {
    const e = this.segmentationStates.value;
    if (e !== void 0)
      return e.map((t) => t == null ? t : Ty(t.segmentationGroupState.value));
  }
};
Fm = D4([ki(NB)], Fm);
var M4 = class extends Z {
  constructor(e, t) {
    super(), this.chunkManager = e, this.state = t, this.layerChunkProgressInfo = new $v(), this.numPickIds = 0, this.generation = -1, this.redrawNeeded = new Ee(), this.serializedAnnotations = void 0, this.handleChangeAffectingBuffer = () => {
      this.generation = -1, this.redrawNeeded.dispatch();
    }, this.segmentationStates = this.registerDisposer(wi((r) => {
      var s = this.state;
      const a = s.displayState, l = s.source, d = a.relationshipStates;
      return a.displayUnfiltered.value ? void 0 : l.relationships.map((u) => {
        const f = d.get(u);
        return f.showMatches.value ? f.segmentationState.value : void 0;
      });
    }, [this.state.displayState.relationshipStates], (r, s) => r === void 0 || s === void 0 ? r === s : Fe(r, s))), this.registerDisposer(t), this.registerDisposer(this.source.changed.add(this.handleChangeAffectingBuffer)), this.registerDisposer(Ur((r, s) => {
      if (this.handleChangeAffectingBuffer(), s !== void 0)
        for (const a of s)
          a != null && r.registerDisposer(wo((l, d) => {
            l.registerDisposer(d.visibleSegments.changed.add(() => this.handleChangeAffectingBuffer())), l.registerDisposer(d.segmentEquivalences.changed.add(() => this.handleChangeAffectingBuffer()));
          }, a.segmentationGroupState));
    }, this.segmentationStates)), this.source instanceof xo || (this.sharedObject = this.registerDisposer(new Fm(e, this.source, this.segmentationStates, this.layerChunkProgressInfo)));
    const i = this.state.displayState;
    this.registerDisposer(i.color.changed.add(this.redrawNeeded.dispatch)), this.registerDisposer(i.shader.changed.add(this.redrawNeeded.dispatch)), this.registerDisposer(i.shaderControls.changed.add(this.redrawNeeded.dispatch)), this.registerDisposer(this.hoverState.changed.add(this.redrawNeeded.dispatch)), this.registerDisposer(this.transform.changed.add(this.redrawNeeded.dispatch));
  }
  get source() {
    return this.state.source;
  }
  get transform() {
    return this.state.transform;
  }
  get hoverState() {
    return this.state.displayState.hoverState;
  }
  get visibility() {
    const e = this.sharedObject;
    if (e !== void 0)
      return e.visibility;
  }
  get gl() {
    return this.chunkManager.gl;
  }
  updateBuffer() {
    const e = this.source;
    if (e instanceof xo) {
      const t = e.changed.count;
      if (this.generation !== t) {
        let i = this.buffer;
        i === void 0 && (i = this.buffer = this.registerDisposer(new Xn(this.chunkManager.gl))), this.generation = t;
        const r = this.serializedAnnotations = R4(e, A4(this.segmentationStates.value));
        i.setData(this.serializedAnnotations.data), this.numPickIds = QT(r);
      }
    }
  }
};
function PL(n) {
  const t = n.chunkTransform.modelTransform.unpaddedRank, i = new Float32Array(t * 2), r = new Float32Array(t * 3);
  r.fill(0), i.fill(1, t);
  const s = n.numChunkDisplayDims, a = n.chunkDisplayDimensionIndices;
  for (let l = 0; l < s; ++l) {
    const d = a[l];
    i[t + d] = 0, r[d * 3 + l] = 1;
  }
  return { modelClipBounds: i, renderSubspaceTransform: r };
}
function Ix(n, e, t) {
  t.clearMessages();
  const i = (u) => {
    t.addMessage({ severity: cr.error, message: u });
  };
  if (n.error !== void 0)
    return i(n.error);
  const r = W1(n.modelTransform, e.displayDimensionIndices);
  let s;
  try {
    s = H1(n, r);
  } catch (u) {
    return i(u.message);
  }
  var a = PL(s);
  const l = a.modelClipBounds, d = a.renderSubspaceTransform;
  return { chunkTransform: n, chunkDisplayTransform: s, modelClipBounds: l, renderSubspaceTransform: d };
}
function Yy(n, e) {
  class t extends n {
    constructor(r, s) {
      super(), this.base = r, this.renderScaleHistogram = s, this.curRank = -1, this.renderHelpers = [], this.isAnnotation = true;
      const a = r.visibility;
      a !== void 0 && this.registerDisposer(a.add(this.visibility)), this.registerDisposer(this.renderScaleHistogram.visibility.add(this.visibility)), this.registerDisposer(() => {
        for (const l of this.renderHelpers)
          l.dispose();
      }), this.role = r.state.role, this.registerDisposer(r.redrawNeeded.add(this.redrawNeeded.dispatch)), this.handleRankChanged();
    }
    handleRankChanged() {
      const r = this.base.source.rank;
      if (r === this.curRank)
        return;
      this.curRank = r, this.tempChunkPosition = new Float32Array(r);
      const s = this.renderHelpers, a = this.gl;
      for (const u of s)
        u.dispose();
      const l = this.base.source.properties, d = this.base.state.displayState;
      for (const u of Br) {
        const f = sc(u), g = f[e], v = s[u] = new g(a, u, r, l, d.shaderControls, d.fallbackShaderControls, d.shaderError);
        v.pickIdsPerInstance = f.pickIdsPerInstance, v.targetIsSliceView = e === "sliceViewRenderHelper";
      }
    }
    attach(r) {
      super.attach(r), this.handleRankChanged();
      const s = this.chunkTransform, a = r.view.displayDimensionRenderInfo.value;
      r.state = {
        chunkTransform: s,
        displayDimensionRenderInfo: a,
        chunkRenderParameters: Ix(s, a, r.messages)
      };
    }
    updateAttachmentState(r) {
      const s = r.state;
      this.handleRankChanged();
      const a = this.chunkTransform, l = r.view.displayDimensionRenderInfo.value;
      return s !== void 0 && s.chunkTransform === a && s.displayDimensionRenderInfo === l ? s.chunkRenderParameters : (s.chunkTransform = a, s.displayDimensionRenderInfo = l, s.chunkRenderParameters = Ix(a, l, r.messages));
    }
    get chunkTransform() {
      return this.base.state.chunkTransform.value;
    }
    updateModelClipBounds(r, s) {
      const a = s.modelClipBounds, l = this.curRank, d = s.chunkTransform;
      gc(a.subarray(0, l), r.projectionParameters.globalPosition, this.base.state.localPosition.value, d.layerRank, d.combinedGlobalLocalToChunkTransform);
    }
    get gl() {
      return this.base.chunkManager.gl;
    }
    drawGeometryChunkData(r, s, a, l = 1) {
      if (!r.bufferValid) {
        let d = r.buffer;
        d === void 0 && (d = r.buffer = new Xn(this.gl));
        const u = r.serializedAnnotations;
        d.setData(u.data), r.numPickIds = QT(u), r.bufferValid = true;
      }
      this.drawGeometry(r, s, a, l);
    }
    drawGeometry(r, s, a, l = 1) {
      const d = this.base, u = a.chunkDisplayTransform, f = r.serializedAnnotations, g = f.typeToIdMaps, v = f.typeToOffset;
      let y = 0;
      s.emitPickID && (y = s.pickIDs.register(this, r.numPickIds, 0, 0, r));
      const w = d.hoverState.value, C = mn(P4, s.projectionParameters.viewProjectionMat, u.displaySubspaceModelMatrix), b = {
        annotationLayer: d,
        renderContext: s,
        selectedIndex: 0,
        basePickId: y,
        buffer: r.buffer,
        bufferOffset: 0,
        count: 0,
        modelViewProjectionMatrix: C,
        modelClipBounds: a.modelClipBounds,
        subspaceMatrix: a.renderSubspaceTransform,
        renderSubspaceModelMatrix: u.displaySubspaceModelMatrix,
        renderSubspaceInvModelMatrix: u.displaySubspaceInvModelMatrix,
        chunkDisplayTransform: u
      };
      for (const E of Br) {
        const L = g[E];
        let R = L.size;
        if (R > 0) {
          const _ = sc(E);
          let A = 4294967295;
          if (w !== void 0) {
            const I = L.get(w.id);
            I !== void 0 && (A = I * _.pickIdsPerInstance);
          }
          R = Math.round(R * l), b.count = R, b.bufferOffset = v[E], b.selectedIndex = A, this.renderHelpers[E].draw(b), b.basePickId += R * _.pickIdsPerInstance;
        }
      }
    }
    updateMouseState(r, s, a, l) {
      const u = l.serializedAnnotations, f = u.typeToIds, g = u.typeToOffset, v = this.curRank, y = this.chunkTransform;
      if (y.error === void 0)
        for (const w of Br) {
          const C = f[w], b = sc(w), E = b.pickIdsPerInstance;
          if (a < C.length * E) {
            const L = Math.floor(a / E), R = C[L], _ = a % E;
            r.pickedAnnotationId = R, r.pickedAnnotationLayer = this.base.state, r.pickedOffset = _, r.pickedAnnotationBuffer = u.data.buffer, r.pickedAnnotationType = w, r.pickedAnnotationBufferBaseOffset = u.data.byteOffset + g[w], r.pickedAnnotationIndex = L, r.pickedAnnotationCount = C.length;
            const A = this.tempChunkPosition, I = y.chunkToLayerTransform, P = y.combinedGlobalLocalToChunkTransform, N = y.layerRank, O = y.modelTransform.globalToRenderLayerDimensions, B = r.position;
            if (!gc(A, B, this.base.state.localPosition.value, N, P))
              return;
            const j = this.base.source.annotationPropertySerializers[w];
            b.snapPosition(A, r.pickedAnnotationBuffer, r.pickedAnnotationBufferBaseOffset + r.pickedAnnotationIndex * j.propertyGroupBytes[0], _);
            const U = O.length;
            for (let V = 0; V < U; ++V) {
              const G = O[V];
              if (G === -1)
                continue;
              let F = I[(v + 1) * v + G];
              for (let ue = 0; ue < v; ++ue)
                F += A[ue] * I[ue * (N + 1) + G];
              kt(F) && (B[V] = F);
            }
            return;
          }
          a -= C.length * E;
        }
    }
    transformPickedValue(r) {
      const s = r.pickedAnnotationBuffer;
      if (s === void 0)
        return;
      const a = this.base.source.properties;
      if (a.length === 0)
        return;
      const l = r.pickedAnnotationBufferBaseOffset, d = r.pickedAnnotationType, u = r.pickedAnnotationIndex, f = r.pickedAnnotationCount, g = this.base.source.annotationPropertySerializers, v = new Array(a.length);
      return g[d].deserialize(
        new DataView(s),
        l,
        u,
        f,
        /*isLittleEndian=*/
        ai.LITTLE === _c,
        v
      ), a2(a[0], v[0]);
    }
    isReady() {
      const s = this.base.source;
      if (!(s instanceof Ui))
        return true;
      const a = this.base.segmentationStates.value;
      if (a === void 0)
        return true;
      for (let l = 0, d = a.length; l < d; ++l) {
        const u = a[l];
        if (u === null)
          return false;
        if (u === void 0)
          continue;
        const f = s.segmentFilteredSources[l].chunks;
        let g = false;
        if (Zo(u.segmentationGroupState.value, (v) => {
          const y = sr(v);
          f.has(y) || (g = true);
        }), g)
          return false;
      }
      return true;
    }
  }
  return t;
}
var AL = (n) => class extends n {
  constructor() {
    super(...arguments), this.layerChunkProgressInfo = this.base.layerChunkProgressInfo;
  }
  draw(t, i) {
    const r = this.updateAttachmentState(i);
    if (this.curRank === 0 || r === void 0)
      return;
    this.updateModelClipBounds(t, r);
    const s = this.base.source;
    if (s instanceof xo) {
      const a = this.base;
      a.updateBuffer(), this.drawGeometry(a, t, r);
    } else {
      const a = this.renderScaleHistogram;
      a.begin(this.base.chunkManager.chunkQueueManager.frameNumberCounter.frameNumber), this.drawGeometryChunkData(s.temporary.data, t, r);
      const l = this.base.segmentationStates.value;
      let d = 0, u = 0;
      if (l !== void 0)
        for (let f = 0, g = l.length; f < g; ++f) {
          const v = l[f];
          if (v == null)
            continue;
          const y = s.segmentFilteredSources[f].chunks;
          Zo(v.segmentationGroupState.value, (w) => {
            const C = sr(w), b = y.get(C);
            if (b !== void 0 && b.state === Et.GPU_MEMORY) {
              const E = b.data;
              if (E === void 0)
                return;
              this.drawGeometryChunkData(E, t, r), ++d;
            } else
              ++u;
          });
        }
      a.add(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, d, u);
    }
  }
};
var RL = Yy(el, "perspectiveViewRenderHelper");
var N4 = class extends AL(RL) {
};
var ML = (n) => {
  class e extends n {
    constructor(i) {
      super(i.annotationLayer, i.renderScaleHistogram), this.wireFrameRenderHelper = this instanceof Mo ? L4 : I4, this.wireFrameShaderGetter = Io(this, this.gl, {
        memoizeKey: `annotation/wireFrameShader:${this instanceof Mo}`,
        parameters: oa(void 0),
        defineShader: (a) => {
          this.wireFrameRenderHelper.defineShader(a);
        }
      }), this.renderScaleTarget = i.renderScaleTarget, this.registerDisposer(this.renderScaleTarget.changed.add(this.redrawNeeded.dispatch));
      const r = this.registerDisposer(new Hc(this.layerChunkProgressInfo)), s = this.base.chunkManager.rpc;
      r.RPC_TYPE_ID = RB, r.initializeCounterpart(s, {
        chunkManager: this.base.chunkManager.rpcId,
        localPosition: this.registerDisposer(An.makeFromExisting(s, this.base.state.localPosition)).rpcId,
        renderScaleTarget: this.registerDisposer(An.makeFromExisting(s, this.renderScaleTarget)).rpcId
      }), this.backend = r;
    }
    attach(i) {
      super.attach(i), i.state.sources = i.registerDisposer(Ur((r, s, a) => {
        const l = uy(a, s, (d) => this.base.state.source.getSources(d), i.messages, this);
        for (const d of l)
          for (const u of d)
            r.registerDisposer(u.source), RZr(u, PL(u.chunkDisplayTransform));
        return i.view.flushBackendProjectionParameters(), this.backend.rpc.invoke(MB, {
          layer: this.backend.rpcId,
          view: i.view.rpcId,
          displayDimensionRenderInfo: a,
          sources: dy(l)
        }), this.redrawNeeded.dispatch(), l;
      }, this.base.state.transform, i.view.displayDimensionRenderInfo));
    }
    draw(i, r) {
      const s = this.updateAttachmentState(r);
      if (this.curRank === 0 || s === void 0)
        return;
      const a = r.state.sources.value;
      if (a.length === 0)
        return;
      this.updateModelClipBounds(i, s);
      const l = this.renderScaleHistogram;
      l.begin(this.base.chunkManager.chunkQueueManager.frameNumberCounter.frameNumber);
      const d = i.projectionParameters;
      let u;
      if (i.wireFrame) {
        var f = this.wireFrameShaderGetter(i.emitter);
        const g = f.shader;
        if (g === null)
          return;
        g.bind(), this.wireFrameRenderHelper.initialize(g, d), u = g;
      }
      VB(d, this.base.state.localPosition.value, this.renderScaleTarget.value, a[0], () => {
      }, (g, v, y, w, C) => {
        const b = g.source.chunks.get(g.curPositionInChunks.join());
        let E;
        if (b === void 0 || b.state !== Et.GPU_MEMORY)
          E = 0;
        else {
          const L = b.data;
          if (L === void 0)
            return;
          u !== void 0 ? this.wireFrameRenderHelper.draw(u, g, d) : this.drawGeometryChunkData(L, i, s, y), E = 1;
        }
        l.add(w, C, E, 1 - E);
      });
    }
  }
  return e;
};
var _4 = ML(RL);
var O4 = ML(Yy(Mo, "sliceViewRenderHelper"));
var V4 = AL(Yy(Mo, "sliceViewRenderHelper"));
var B4 = class extends Z {
  constructor() {
    super(...arguments), this.changed = new Ee(), this.isLoadingChanged = new Ee(), this.states = [], this.relationships = [], this.loadingCount = 0;
  }
  get value() {
    return this.states;
  }
  get isLoading() {
    return this.loadingCount !== 0;
  }
  markLoading() {
    return this.loadingCount++, () => {
      --this.loadingCount === 0 && this.isLoadingChanged.dispatch();
    };
  }
  sort() {
    this.states.sort((e, t) => {
      let i = e.sourceIndex - t.sourceIndex;
      return i !== 0 ? i : e.subsourceIndex - t.subsourceIndex;
    });
  }
  updateRelationships() {
    const e = new je();
    for (const t of this.states)
      for (const i of t.source.relationships)
        e.add(i);
    this.relationships = De(e);
  }
  add(e) {
    return this.states.push(e), this.sort(), this.updateRelationships(), this.changed.dispatch(), () => {
      const t = this.states.indexOf(e);
      this.states.splice(t, 1), this.updateRelationships(), this.changed.dispatch();
    };
  }
};
function F4(n, e) {
  switch (e.type) {
    case Me.AXIS_ALIGNED_BOUNDING_BOX:
    case Me.LINE:
    case Me.SPHERE:
      L1(n, e.pointA, e.pointB), L2(n, n, 0.5);
      break;
    case Me.POINT:
      n.set(e.point);
      break;
    case Me.ELLIPSOID:
      n.set(e.center);
      break;
  }
}
function NL(n, e, t) {
  e.error === void 0 && n.setLayerPosition(e.modelTransform, t);
}
function _L(n, e, t) {
  const i = e.layerRank, r = new Float32Array(i);
  Gn[n.type].visitGeometry(n, (s, a) => {
    r.set(s);
    const l = new Float32Array(i);
    (a ? E1 : _r)(l, e.chunkToLayerTransform, i + 1, r, i), t(l, a);
  });
}
var U4 = class extends Kr {
  constructor(e, t) {
    super(), this.layer = e, this.displayState = t, this.previousSelectedState = void 0, this.previousHoverId = void 0, this.previousHoverAnnotationLayerState = void 0, this.virtualListSource = {
      length: 0,
      render: (y) => this.render(y),
      changed: new ot()
    }, this.virtualList = new Py({ source: this.virtualListSource }), this.listElements = [], this.updated = false, this.mutableControls = document.createElement("div"), this.headerRow = document.createElement("div"), this.attachedAnnotationStates = new de(), this.forceUpdateView = () => {
      this.updated = false, this.updateView();
    }, this.globalDimensionIndices = [], this.localDimensionIndices = [], this.curCoordinateSpaceGeneration = -1, this.prevCoordinateSpaceGeneration = -1, this.columnWidths = [], this.gridTemplate = "", this.selectedAnnotationState = rr((y, w) => {
      var C;
      if (y === void 0)
        return;
      const b = this.layer, E = (C = y.layers.find((_) => _.layer === b)) === null || C === void 0 ? void 0 : C.state;
      if (E === void 0)
        return;
      const L = E.annotationId;
      if (L === void 0)
        return;
      const R = this.annotationStates.states.find((_) => _.sourceIndex === E.annotationSourceIndex && (E.annotationSubsource === void 0 || _.subsourceId === E.annotationSubsource));
      if (R !== void 0)
        return { annotationId: L, annotationLayerState: R, pin: w };
    }, this.layer.manager.root.selectionState, this.layer.manager.root.selectionState.pin), this.element.classList.add("neuroglancer-annotation-layer-view"), this.registerDisposer(this.visibility.changed.add(() => this.updateView())), this.registerDisposer(e.annotationStates.changed.add(() => this.updateAttachedAnnotationLayerStates())), this.headerRow.classList.add("neuroglancer-annotation-list-header");
    const i = document.createElement("div");
    i.className = "neuroglancer-annotation-toolbox", e.initializeAnnotationLayerViewTab(this);
    const r = this.registerDisposer(new By(this.displayState.color));
    r.element.title = "Change annotation display color", this.registerDisposer(new pi(rr((y) => y.match(/\bdefaultColor\b/) !== null, t.shaderControls.processedFragmentMain), r.element)), i.appendChild(r.element);
    const s = this.mutableControls, a = Tt({
      text: Gn[Me.POINT].icon,
      title: "Annotate point",
      onClick: () => {
        this.layer.tool.value = new GL(this.layer, {});
      }
    });
    s.appendChild(a);
    const l = Tt({
      text: Gn[Me.AXIS_ALIGNED_BOUNDING_BOX].icon,
      title: "Annotate bounding box",
      onClick: () => {
        this.layer.tool.value = new Ky(this.layer, {});
      }
    });
    s.appendChild(l);
    const d = Tt({
      text: Gn[Me.LINE].icon,
      title: "Annotate line",
      onClick: () => {
        this.layer.tool.value = new Zy(this.layer, {});
      }
    });
    s.appendChild(d);
    const u = Tt({
      text: Gn[Me.SPHERE].icon,
      title: "Annotate Sphere",
      onClick: () => {
        this.layer.tool.value = new Xy(this.layer, {});
      }
    });
    s.appendChild(u);
    const f = Tt({
      text: Gn[Me.ELLIPSOID].icon,
      title: "Annotate ellipsoid",
      onClick: () => {
        this.layer.tool.value = new WL(this.layer, {});
      }
    });
    s.appendChild(f), i.appendChild(s), this.element.appendChild(i), this.element.appendChild(this.headerRow);
    const g = this.virtualList;
    g.element.classList.add("neuroglancer-annotation-list"), this.element.appendChild(g.element), this.virtualList.element.addEventListener("mouseleave", () => {
      this.displayState.hoverState.value = void 0;
    });
    const v = V3();
    this.registerDisposer(new qr(this.virtualList.element, v)), this.virtualList.element.title = v.describe(), this.registerDisposer(this.displayState.hoverState.changed.add(() => this.updateHoverView())), this.registerDisposer(this.selectedAnnotationState.changed.add(() => this.updateSelectionView())), this.registerDisposer(this.layer.localCoordinateSpace.changed.add(() => {
      this.updateCoordinateSpace(), this.updateView();
    })), this.registerDisposer(this.layer.manager.root.coordinateSpace.changed.add(() => {
      this.updateCoordinateSpace(), this.updateView();
    })), this.updateCoordinateSpace(), this.updateAttachedAnnotationLayerStates(), this.updateSelectionView();
  }
  get annotationStates() {
    return this.layer.annotationStates;
  }
  updateAttachedAnnotationLayerStates() {
    const e = this.annotationStates.states, t = this.attachedAnnotationStates, i = new de();
    for (const s of t) {
      var r = ce(s, 2);
      const a = r[0], l = r[1];
      e.includes(a) || (t.delete(a), l.refCounted.dispose());
    }
    for (const s of e) {
      const a = t.get(s);
      if (a !== void 0) {
        i.set(s, a);
        continue;
      }
      const l = s.source, d = new Z();
      (l instanceof xo || l instanceof Ui) && (d.registerDisposer(l.childAdded.add((u) => this.addAnnotationElement(u, s))), d.registerDisposer(l.childUpdated.add((u) => this.updateAnnotationElement(u, s))), d.registerDisposer(l.childDeleted.add((u) => this.deleteAnnotationElement(u, s))), d.registerDisposer(l.childRefreshed.add(() => this.clearAnnotationElement(s)))), d.registerDisposer(s.transform.changed.add(this.forceUpdateView)), i.set(s, { refCounted: d, annotations: [], idToIndex: new de(), listOffset: 0 });
    }
    this.attachedAnnotationStates = i, t.clear(), this.updateCoordinateSpace(), this.forceUpdateView();
  }
  updateCoordinateSpace() {
    const e = this.layer.localCoordinateSpace.value, t = this.layer.manager.root.coordinateSpace.value, i = [], r = [];
    for (let s = 0, a = t.rank; s < a; ++s)
      this.annotationStates.states.some((l) => {
        const d = l.transform.value;
        return d.error !== void 0 ? false : d.globalToRenderLayerDimensions[s] !== -1;
      }) && i.push(s);
    for (let s = 0, a = e.rank; s < a; ++s)
      this.annotationStates.states.some((l) => {
        const d = l.transform.value;
        return d.error !== void 0 ? false : d.localToRenderLayerDimensions[s] !== -1;
      }) && r.push(s);
    (!Fe(i, this.globalDimensionIndices) || !Fe(r, this.localDimensionIndices)) && (this.localDimensionIndices = r, this.globalDimensionIndices = i, ++this.curCoordinateSpaceGeneration);
  }
  getRenderedAnnotationListElement(e, t, i = false) {
    const r = this.attachedAnnotationStates.get(e);
    if (r == null)
      return;
    const s = r.idToIndex.get(t);
    if (s === void 0)
      return;
    const a = r.listOffset + s;
    return i && this.virtualList.scrollItemIntoView(s), this.virtualList.getItemElement(a);
  }
  clearSelectionClass() {
    const e = this.previousSelectedState;
    if (e === void 0)
      return;
    this.previousSelectedState = void 0;
    const t = this.getRenderedAnnotationListElement(e.annotationLayerState, e.annotationId);
    t !== void 0 && t.classList.remove("neuroglancer-annotation-selected");
  }
  clearHoverClass() {
    const e = this.previousHoverId, t = this.previousHoverAnnotationLayerState;
    if (t !== void 0) {
      this.previousHoverAnnotationLayerState = void 0, this.previousHoverId = void 0;
      const i = this.getRenderedAnnotationListElement(t, e);
      i !== void 0 && i.classList.remove("neuroglancer-annotation-hover");
    }
  }
  updateSelectionView() {
    const e = this.selectedAnnotationState.value, t = this.previousSelectedState;
    if (t === e || t !== void 0 && e !== void 0 && t.annotationId === e.annotationId && t.annotationLayerState === e.annotationLayerState && t.pin === e.pin || (this.clearSelectionClass(), this.previousSelectedState = e, e === void 0))
      return;
    const i = this.getRenderedAnnotationListElement(
      e.annotationLayerState,
      e.annotationId,
      /*scrollIntoView=*/
      e.pin
    );
    i !== void 0 && i.classList.add("neuroglancer-annotation-selected");
  }
  updateHoverView() {
    const e = this.displayState.hoverState.value;
    let t, i;
    e !== void 0 && (t = e.id, i = e.annotationLayerState);
    const r = this.previousHoverId, s = this.previousHoverAnnotationLayerState;
    if (t === r && i === s || (this.clearHoverClass(), this.previousHoverId = t, this.previousHoverAnnotationLayerState = i, t === void 0))
      return;
    const a = this.getRenderedAnnotationListElement(i, t);
    a !== void 0 && a.classList.add("neuroglancer-annotation-hover");
  }
  render(e) {
    var t = this.listElements[e];
    const i = t.annotation, r = t.state;
    return this.makeAnnotationListElement(i, r);
  }
  setColumnWidth(e, t) {
    t += 2;
    const i = this.columnWidths;
    i[e] > t || (i[e] = t, this.element.style.setProperty(`--neuroglancer-column-${e}-width`, `${t}ch`));
  }
  updateView() {
    if (!this.visible)
      return;
    if (this.curCoordinateSpaceGeneration !== this.prevCoordinateSpaceGeneration) {
      this.updated = false;
      const s = this.columnWidths;
      s.length = 0;
      const a = this.headerRow, l = document.createElement("div");
      l.style.gridColumn = "symbol";
      const d = document.createElement("div");
      d.style.gridColumn = "delete", it(a), a.appendChild(l);
      let u = 0, f = "[symbol] 2ch";
      const g = (w, C) => {
        const b = document.createElement("div");
        b.classList.add("neuroglancer-annotations-view-dimension");
        const E = document.createElement("span");
        E.classList.add("neuroglancer-annotations-view-dimension-name"), E.textContent = w.names[C];
        const L = document.createElement("scale");
        L.classList.add("neuroglancer-annotations-view-dimension-scale"), L.textContent = ca(w.scales[C], w.units[C], { precision: 2 }), b.appendChild(E), b.appendChild(L), b.style.gridColumn = `dim ${u + 1}`, this.setColumnWidth(u, L.textContent.length + E.textContent.length + 3), f += ` [dim] var(--neuroglancer-column-${u}-width)`, ++u, a.appendChild(b);
      }, v = this.layer.manager.root.coordinateSpace.value;
      for (const w of this.globalDimensionIndices)
        g(v, w);
      const y = this.layer.localCoordinateSpace.value;
      for (const w of this.localDimensionIndices)
        g(y, w);
      a.appendChild(d), f += " [delete] 2ch", this.gridTemplate = f, a.style.gridTemplateColumns = f, this.prevCoordinateSpaceGeneration = this.curCoordinateSpaceGeneration;
    }
    if (this.updated)
      return;
    let e = false;
    const t = this.listElements;
    t.length = 0;
    for (const s of this.attachedAnnotationStates) {
      var i = ce(s, 2);
      const a = i[0], l = i[1];
      if (a.source.readonly || (e = true), a.chunkTransform.value.error !== void 0)
        continue;
      const d = a.source, u = De(d);
      l.annotations = u;
      const f = l.idToIndex;
      f.clear();
      for (let g = 0, v = u.length; g < v; ++g)
        f.set(u[g].id, g);
      for (const g of u)
        t.push({ state: a, annotation: g });
    }
    const r = this.virtualListSource.length;
    this.updateListLength(), this.virtualListSource.changed.dispatch([{ retainCount: 0, deleteCount: r, insertCount: t.length }]), this.mutableControls.style.display = e ? "contents" : "none", this.resetOnUpdate();
  }
  updateListLength() {
    let e = 0;
    for (const t of this.attachedAnnotationStates.values())
      t.listOffset = e, e += t.annotations.length;
    this.virtualListSource.length = e;
  }
  clearAnnotationElement(e) {
    if (!this.visible) {
      this.updated = false;
      return;
    }
    if (!this.updated) {
      this.updateView();
      return;
    }
    const t = this.attachedAnnotationStates.get(e);
    if (t !== void 0) {
      const i = t.annotations.length;
      t.annotations = [], t.idToIndex.clear(), this.listElements = [], this.updateListLength(), this.virtualListSource.changed.dispatch([{ retainCount: 0, deleteCount: i, insertCount: 0 }]);
    }
    this.resetOnUpdate();
  }
  addAnnotationElement(e, t) {
    if (!this.visible) {
      this.updated = false;
      return;
    }
    if (!this.updated) {
      this.updateView();
      return;
    }
    const i = this.attachedAnnotationStates.get(t);
    if (i !== void 0) {
      const r = i.annotations.length;
      i.annotations.push(e), i.idToIndex.set(e.id, r);
      const s = i.listOffset + r;
      this.listElements.splice(s, 0, { state: t, annotation: e }), this.updateListLength(), this.virtualListSource.changed.dispatch([{ retainCount: s, deleteCount: 0, insertCount: 1 }]);
    }
    this.resetOnUpdate();
  }
  updateAnnotationElement(e, t) {
    if (!this.visible) {
      this.updated = false;
      return;
    }
    if (!this.updated) {
      this.updateView();
      return;
    }
    const i = this.attachedAnnotationStates.get(t);
    if (i !== void 0) {
      const r = i.idToIndex.get(e.id);
      if (r !== void 0) {
        const s = i.listOffset + r;
        i.annotations[r] = e, this.listElements[s].annotation = e, this.virtualListSource.changed.dispatch([{ retainCount: s, deleteCount: 1, insertCount: 1 }]);
      }
    }
    this.resetOnUpdate();
  }
  deleteAnnotationElement(e, t) {
    if (!this.visible) {
      this.updated = false;
      return;
    }
    if (!this.updated) {
      this.updateView();
      return;
    }
    const i = this.attachedAnnotationStates.get(t);
    if (i !== void 0) {
      const r = i.idToIndex, s = r.get(e);
      if (s !== void 0) {
        const a = i.listOffset + s, l = i.annotations;
        l.splice(s, 1), r.delete(e);
        for (let d = s, u = l.length; d < u; ++d)
          r.set(l[d].id, d);
        this.listElements.splice(a, 1), this.updateListLength(), this.virtualListSource.changed.dispatch([{ retainCount: a, deleteCount: 1, insertCount: 0 }]);
      }
    }
    this.resetOnUpdate();
  }
  resetOnUpdate() {
    this.clearHoverClass(), this.clearSelectionClass(), this.updated = true, this.updateHoverView(), this.updateSelectionView();
  }
  makeAnnotationListElement(e, t) {
    const i = t.chunkTransform.value, r = document.createElement("div");
    r.classList.add("neuroglancer-annotation-list-entry"), r.style.gridTemplateColumns = this.gridTemplate;
    const s = document.createElement("div");
    s.className = "neuroglancer-annotation-icon", s.textContent = Gn[e.type].icon, r.appendChild(s);
    let a;
    const l = () => {
      t.source.readonly || a === void 0 && (a = Cs({
        title: "Delete annotation",
        onClick: (f) => {
          f.stopPropagation(), f.preventDefault();
          const g = t.source.getReference(e.id);
          try {
            t.source.delete(g);
          } finally {
            g.dispose();
          }
        }
      }), a.classList.add("neuroglancer-annotation-list-entry-delete"), r.appendChild(a));
    };
    let d = 0;
    if (_L(e, i, (f, g) => {
      ++d;
      const v = document.createElement("div");
      v.className = "neuroglancer-annotation-position", r.appendChild(v);
      let y = 0;
      const w = (C, b) => {
        for (const E of C) {
          const L = b[E];
          if (L !== -1) {
            const R = Math.floor(f[L]), _ = document.createElement("div"), A = R.toString();
            _.textContent = A, _.classList.add("neuroglancer-annotation-coordinate"), _.style.gridColumn = `dim ${y + 1}`, this.setColumnWidth(y, A.length), v.appendChild(_);
          }
          ++y;
        }
      };
      w(this.globalDimensionIndices, i.modelTransform.globalToRenderLayerDimensions), w(this.localDimensionIndices, i.modelTransform.localToRenderLayerDimensions), l();
    }), e.description) {
      ++d;
      const f = document.createElement("div");
      f.classList.add("neuroglancer-annotation-description"), f.textContent = e.description, r.appendChild(f);
    }
    s.style.gridRow = `span ${d}`, a !== void 0 && (a.style.gridRow = `span ${d}`), r.addEventListener("mouseenter", () => {
      this.displayState.hoverState.value = {
        id: e.id,
        partIndex: 0,
        annotationLayerState: t
      }, this.layer.selectAnnotation(t, e.id, false);
    }), r.addEventListener("action:select-position", (f) => {
      f.stopPropagation(), this.layer.selectAnnotation(t, e.id, "toggle");
    }), r.addEventListener("action:pin-annotation", (f) => {
      f.stopPropagation(), this.layer.selectAnnotation(t, e.id, true);
    }), r.addEventListener("action:move-to-annotation", (f) => {
      f.stopPropagation(), f.preventDefault();
      const g = i.layerRank, v = new Float32Array(g), y = new Float32Array(g);
      F4(v, e), _r(y, i.chunkToLayerTransform, g + 1, v, g), NL(this.layer, i, y);
    });
    const u = this.selectedAnnotationState.value;
    return u !== void 0 && u.annotationLayerState === t && u.annotationId === e.id && r.classList.add("neuroglancer-annotation-selected"), r;
  }
};
var z4 = class extends Kr {
  constructor(e) {
    super(), this.layer = e, this.layerView = this.registerDisposer(new U4(this.layer, this.layer.annotationDisplayState));
    const t = this.element;
    t.classList.add("neuroglancer-annotations-tab"), t.appendChild(this.layerView.element);
  }
};
function Wo(n) {
  let e = [];
  const t = n.source.relationships, i = n.displayState.relationshipStates;
  for (let r = 0, s = t.length; r < s; ++r) {
    const a = i.get(t[r]).segmentationState.value;
    if (a != null && a.segmentSelectionState.hasSelectedSegment) {
      e[r] = [a.segmentSelectionState.selectedSegment.clone()];
      continue;
    }
    e[r] = [];
  }
  return e;
}
var OL = class extends cI {
  constructor(e, t) {
    super(e);
  }
  get annotationLayer() {
    for (const e of this.layer.annotationStates.states)
      if (!e.source.readonly)
        return e;
  }
};
var VL = "annotatePoint";
var BL = "annotateLine";
var FL = "annotateBoundingBox";
var UL = "annotateEllipsoid";
var zL = "annotateSphere";
var GL = class extends OL {
  constructor() {
    super(...arguments), this.sourceSignalUpdated = false;
  }
  trigger(e) {
    const t = this.annotationLayer;
    if (t !== void 0 && e.updateUnconditionally()) {
      const i = Ac(e, t);
      if (i === void 0)
        return;
      const r = {
        id: "",
        description: "",
        relatedSegments: Wo(t),
        point: i,
        type: Me.POINT,
        properties: t.source.properties.map((a) => a.default)
      }, s = t.source.add(
        r,
        /*commit=*/
        true
      );
      t.source instanceof Ui ? this.sourceSignalUpdated || (t.source.childAdded.add((a) => {
        a.source === void 0 && this.layer.selectAnnotation(t, a.id, true, !ws.expectingExternalUI);
      }), this.sourceSignalUpdated = true) : this.layer.selectAnnotation(t, s.id, true), s.dispose();
    }
  }
  get description() {
    return "annotate point";
  }
  toJSON() {
    return VL;
  }
};
function Ac(n, e) {
  const t = e.chunkTransform.value;
  if (t.error !== void 0)
    return;
  const i = new Float32Array(t.modelTransform.unpaddedRank);
  if (gc(i, n.unsnappedPosition, e.localPosition.value, t.layerRank, t.combinedGlobalLocalToChunkTransform))
    return i;
}
var $L = class extends OL {
  trigger(e) {
    const t = this.annotationLayer;
    if (t !== void 0 && e.updateUnconditionally()) {
      const i = () => {
        const r = this.inProgressAnnotation, s = r.reference, a = this.getUpdatedAnnotation(s.value, e, t);
        se(Ug(a, t.source)) !== se(Ug(s.value, t.source)) && (r.annotationLayer.source.update(s, a), this.layer.selectAnnotation(t, s.id, true, !ws.expectingExternalUI));
      };
      if (this.inProgressAnnotation === void 0) {
        const r = t.source.add(
          this.getInitialAnnotation(e, t),
          /*commit=*/
          false
        );
        this.layer.selectAnnotation(t, r.id, true, !ws.expectingExternalUI);
        const s = e.changed.add(i), a = () => {
          s(), r.dispose();
        };
        this.inProgressAnnotation = {
          annotationLayer: t,
          reference: r,
          disposer: a
        };
      } else
        i(), this.inProgressAnnotation.annotationLayer.source.commit(this.inProgressAnnotation.reference), this.inProgressAnnotation.disposer(), this.inProgressAnnotation = void 0;
    }
  }
  disposed() {
    this.deactivate(), super.disposed();
  }
  deactivate() {
    this.inProgressAnnotation !== void 0 && (this.inProgressAnnotation.annotationLayer.source.delete(this.inProgressAnnotation.reference), this.inProgressAnnotation.disposer(), this.inProgressAnnotation = void 0);
  }
};
var qy = class extends $L {
  getInitialAnnotation(e, t) {
    const i = Ac(e, t);
    return {
      id: "",
      type: this.annotationType,
      description: "",
      pointA: i,
      pointB: i,
      properties: t.source.properties.map((r) => r.default)
    };
  }
  getUpdatedAnnotation(e, t, i) {
    const r = Ac(t, i);
    return r === void 0 ? e : RZr(RZr({}, e), { pointB: r });
  }
};
var Ky = class extends qy {
  get description() {
    return "annotate bounding box";
  }
  getUpdatedAnnotation(e, t, i) {
    const r = super.getUpdatedAnnotation(e, t, i), s = r.pointA, a = r.pointB, l = s.length;
    for (let d = 0; d < l; ++d)
      s[d] === a[d] && (a[d] += 1);
    return r;
  }
  toJSON() {
    return FL;
  }
};
Ky.prototype.annotationType = Me.AXIS_ALIGNED_BOUNDING_BOX;
var Zy = class extends qy {
  get description() {
    return "annotate line";
  }
  getInitialAnnotation(e, t) {
    const i = super.getInitialAnnotation(e, t);
    return this.initialRelationships = i.relatedSegments = Wo(t), i;
  }
  getUpdatedAnnotation(e, t, i) {
    const r = super.getUpdatedAnnotation(e, t, i), s = this.initialRelationships, a = Wo(i);
    return s === void 0 ? r.relatedSegments = a : r.relatedSegments = De(a, (l, d) => {
      const u = s[d];
      return l = l.filter((f) => u.findIndex((g) => re.equal(f, g)) === -1), [...u, ...l];
    }), r;
  }
  toJSON() {
    return BL;
  }
};
Zy.prototype.annotationType = Me.LINE;
var Xy = class extends qy {
  get description() {
    return "annotate sphere";
  }
  getInitialAnnotation(e, t) {
    const i = super.getInitialAnnotation(e, t);
    return this.initialRelationships = i.relatedSegments = Wo(t), i;
  }
  getUpdatedAnnotation(e, t, i) {
    const r = super.getUpdatedAnnotation(e, t, i), s = this.initialRelationships, a = Wo(i);
    return s === void 0 ? r.relatedSegments = a : r.relatedSegments = De(a, (l, d) => {
      const u = s[d];
      return l = l.filter((f) => u.findIndex((g) => re.equal(f, g)) === -1), [...u, ...l];
    }), r;
  }
  toJSON() {
    return zL;
  }
};
Xy.prototype.annotationType = Me.SPHERE;
var WL = class extends $L {
  getInitialAnnotation(e, t) {
    const i = Ac(e, t);
    return {
      type: Me.ELLIPSOID,
      id: "",
      description: "",
      segments: Wo(t),
      center: i,
      radii: St(0, 0, 0),
      properties: t.source.properties.map((r) => r.default)
    };
  }
  getUpdatedAnnotation(e, t, i) {
    const r = Ac(t, i);
    if (r === void 0)
      return e;
    const s = e.center, a = s.length;
    for (let l = 0; l < a; ++l)
      r[l] = Math.abs(s[l] - r[l]);
    return RZr(RZr({}, e), { radii: r });
  }
  get description() {
    return "annotate ellipsoid";
  }
  toJSON() {
    return UL;
  }
};
nd(VL, (n, e) => new GL(n, e));
nd(FL, (n, e) => new Ky(n, e));
nd(BL, (n, e) => new Zy(n, e));
nd(UL, (n, e) => new WL(n, e));
nd(zL, (n, e) => new Xy(n, e));
var G4 = vt.fromObject({
  enter: { action: "commit" },
  escape: { action: "cancel" }
});
function $4(n, e, t, i) {
  return new ur(t, (r, s, a) => {
    const l = document.createElement("div");
    l.classList.add("neuroglancer-related-segment-list"), r != null && a.registerDisposer(Bo(r, l));
    const d = document.createElement("div");
    d.classList.add("neuroglancer-related-segment-list-header");
    const u = dr({
      title: "Copy segment IDs",
      onClick: () => {
        oi(e.map((w) => w.toString()).join(", "));
      }
    });
    d.appendChild(u);
    let f;
    if (r != null && (f = document.createElement("input"), f.type = "checkbox", f.addEventListener("change", () => {
      const w = r.segmentationGroupState.value.visibleSegments, C = e.some((b) => !w.has(b));
      for (const b of e)
        w.set(b, C);
    }), d.appendChild(f)), i !== void 0) {
      const w = Cs({
        title: "Remove all IDs",
        onClick: () => {
          i([]);
        }
      });
      d.appendChild(w);
    }
    const g = document.createElement("span");
    if (g.classList.add("neuroglancer-related-segment-list-title"), g.textContent = n, d.appendChild(g), i !== void 0) {
      const w = sI({
        title: "Add related segment ID",
        onClick: () => {
          const C = new Z(), b = a.registerDisposer(_E(C)), E = document.createElement("div");
          E.classList.add("neuroglancer-segment-list-entry"), E.classList.add("neuroglancer-segment-list-entry-new");
          const L = dr({});
          if (L.classList.add("neuroglancer-segment-list-entry-copy"), E.appendChild(L), r != null) {
            const P = document.createElement("input");
            P.classList.add("neuroglancer-segment-list-entry-visible-checkbox"), P.type = "checkbox", E.appendChild(P);
          }
          const R = Cs({
            title: "Cancel adding new segment ID",
            onClick: () => {
              b();
            }
          });
          R.classList.add("neuroglancer-segment-list-entry-delete"), E.appendChild(R);
          const _ = document.createElement("input");
          _.autocomplete = "off", _.spellcheck = false, _.classList.add("neuroglancer-segment-list-entry-id");
          const A = C.registerDisposer(new Wi(_, G4));
          A.allShortcutsAreGlobal = true;
          const I = () => {
            const P = new re();
            if (P.tryParseString(_.value))
              return _.dataset.valid = "true", P;
            _.dataset.valid = "false";
          };
          I(), _.addEventListener("input", () => {
            I();
          }), _.addEventListener("blur", () => {
            const P = I();
            P !== void 0 && i([...e, P]), b();
          }), be(_, "cancel", b), be(_, "commit", () => {
            const P = I();
            P !== void 0 && i([...e, P]), b();
          }), E.appendChild(_), l.appendChild(E), _.focus(), C.registerDisposer(() => {
            _.value = "", E.remove();
          });
        }
      });
      d.appendChild(w);
    }
    l.appendChild(d);
    const v = [], y = tl.make(
      r ?? void 0,
      /*includeMapped=*/
      false
    );
    for (const w of e) {
      const C = y.get(w);
      if (v.push(C), i !== void 0) {
        const b = Cs({
          title: "Remove ID",
          onClick: (E) => {
            i(e.filter((L) => !re.equal(L, w))), E.stopPropagation();
          }
        });
        b.classList.add("neuroglancer-segment-list-entry-delete"), C.children[0].appendChild(b);
      }
      l.appendChild(C);
    }
    if (r != null) {
      const w = a.registerCancellable(Ct(() => {
        const C = r.segmentationGroupState.value.visibleSegments;
        let b = 0;
        for (const E of e)
          C.has(E) && ++b;
        for (const E of v)
          y.update(E);
        f.checked = b === e.length && b > 0, f.indeterminate = b > 0 && b < e.length;
      }));
      w(), w.flush(), nl(r, a, w), a.registerDisposer(r.segmentationGroupState.changed.add(w));
    }
    s.appendChild(l);
  });
}
var Lx = "annotationColor";
function Qy(n) {
  class e extends n {
    constructor(...i) {
      super(...i), this.annotationStates = this.registerDisposer(new B4()), this.annotationDisplayState = new cB(), this.annotationCrossSectionRenderScaleHistogram = new Ro(), this.annotationCrossSectionRenderScaleTarget = ua(8), this.annotationProjectionRenderScaleHistogram = new Ro(), this.annotationProjectionRenderScaleTarget = ua(8), this.annotationDisplayState.color.changed.add(this.specificationChanged.dispatch), this.annotationDisplayState.shader.changed.add(this.specificationChanged.dispatch), this.annotationDisplayState.shaderControls.changed.add(this.specificationChanged.dispatch), this.tabs.add("annotations", { label: "Annotations", order: 10, getter: () => new z4(this) });
      let r;
      const s = () => {
        const l = this.isReady;
        l && r !== void 0 ? (r(), r = void 0) : !l && r === void 0 && (r = this.annotationStates.markLoading());
      };
      this.readyStateChanged.add(s), s();
      const a = this.manager.layerSelectedValues.mouseState;
      this.registerDisposer(a.changed.add(() => {
        if (a.active) {
          const l = a.pickedAnnotationLayer;
          if (l !== void 0 && this.annotationStates.states.includes(l)) {
            const d = this.annotationDisplayState.hoverState.value;
            (d === void 0 || d.id !== a.pickedAnnotationId || d.partIndex !== a.pickedOffset || d.annotationLayerState !== l) && (this.annotationDisplayState.hoverState.value = {
              id: a.pickedAnnotationId,
              partIndex: a.pickedOffset,
              annotationLayerState: l
            });
            return;
          }
        }
        this.annotationDisplayState.hoverState.value = void 0;
      }));
    }
    initializeAnnotationLayerViewTab(i) {
    }
    restoreState(i) {
      super.restoreState(i), this.annotationDisplayState.color.restoreState(i[Lx]);
    }
    captureSelectionState(i, r) {
      super.captureSelectionState(i, r);
      const s = r.pickedAnnotationLayer;
      s === void 0 || !this.annotationStates.states.includes(s) || (i.annotationId = r.pickedAnnotationId, i.annotationType = r.pickedAnnotationType, i.annotationBuffer = new Uint8Array(r.pickedAnnotationBuffer, r.pickedAnnotationBufferBaseOffset), i.annotationIndex = r.pickedAnnotationIndex, i.annotationCount = r.pickedAnnotationCount, i.annotationPartIndex = r.pickedOffset, i.annotationSourceIndex = s.sourceIndex, i.annotationSubsource = s.subsourceId);
    }
    displayAnnotationState(i, r, s) {
      if (i.annotationId === void 0)
        return false;
      const a = this.annotationStates.states.find((d) => d.sourceIndex === i.annotationSourceIndex && (i.annotationSubsource === void 0 || d.subsourceId === i.annotationSubsource));
      if (a === void 0)
        return false;
      a.source instanceof Ui;
      const l = s.registerDisposer(a.source.getReference(i.annotationId));
      return r.appendChild(s.registerDisposer(new ur(s.registerDisposer(new FE(() => ({
        annotation: l,
        chunkTransform: a.chunkTransform
      }))), ({ annotation: d, chunkTransform: u }, f, g) => {
        let v;
        if (d == null)
          if (i.annotationType !== void 0 && i.annotationBuffer !== void 0) {
            const C = Gn[i.annotationType], b = a.source.rank, E = C.serializedBytes(b), L = i.annotationBuffer.byteOffset, R = new DataView(i.annotationBuffer.buffer), _ = ai.LITTLE === _c, A = a.source.properties, I = new C1(b, E, A), P = i.annotationIndex, N = i.annotationCount;
            d = C.deserialize(R, L + I.propertyGroupBytes[0] * P, _, b, i.annotationId), I.deserialize(R, L, P, N, _, d.properties = new Array(A.length)), a.source.hasNonSerializedProperties() && (v = "Loading...");
          } else
            v = d === null ? "Annotation not found" : "Loading...";
        if (d != null) {
          const C = u.error === void 0 ? u.layerRank : 0, b = document.createElement("div");
          b.classList.add("neuroglancer-selected-annotation-details-position-grid"), b.style.gridTemplateColumns = `[icon] 0fr [copy] 0fr repeat(${C}, [dim] 0fr [coord] 0fr) [move] 0fr [delete] 0fr`, f.appendChild(b);
          const E = Gn[d.type], L = document.createElement("div");
          if (L.className = "neuroglancer-selected-annotation-details-icon", L.textContent = E.icon, b.appendChild(L), C !== 0) {
            const O = u.modelTransform.layerDimensionNames;
            for (let B = 0; B < C; ++B) {
              const j = document.createElement("div");
              j.classList.add("neuroglancer-selected-annotation-details-position-dim"), j.textContent = O[B], j.style.gridColumn = `dim ${B + 1}`, b.appendChild(j);
            }
            _L(d, u, (B, j) => {
              const U = dr({
                title: "Copy position",
                onClick: () => {
                  oi(B.map((V) => Math.floor(V)).join(", "));
                }
              });
              U.style.gridColumn = "copy", b.appendChild(U);
              for (let V = 0; V < C; ++V) {
                const G = document.createElement("div");
                G.classList.add("neuroglancer-selected-annotation-details-position-coord"), G.style.gridColumn = `coord ${V + 1}`, G.textContent = Math.floor(B[V]).toString(), b.appendChild(G);
              }
              if (!j) {
                const V = Gk({
                  title: "Move to position",
                  onClick: () => {
                    NL(this, u, B);
                  }
                });
                V.style.gridColumn = "move", b.appendChild(V);
              }
            });
          }
          if (!a.source.readonly) {
            const O = Cs({
              title: "Delete annotation",
              onClick: () => {
                a.source.delete(l);
              }
            });
            O.classList.add("neuroglancer-selected-annotation-details-delete"), b.appendChild(O);
          }
          var y = a.source;
          const R = y.relationships, _ = y.properties, A = a.source.readonly;
          for (let O = 0, B = _.length; O < B; ++O) {
            const j = _[O], U = document.createElement("label");
            U.classList.add("neuroglancer-annotation-property");
            const V = document.createElement("span");
            V.classList.add("neuroglancer-annotation-property-label"), V.textContent = j.identifier, U.appendChild(V);
            const G = j.description;
            G !== void 0 && (U.title = G);
            const F = d.properties[O], ue = document.createElement("span");
            switch (ue.classList.add("neuroglancer-annotation-property-value"), j.type) {
              case "rgb": {
                const ae = ia(F), Ie = Wn(ae);
                ue.textContent = Ie, ue.style.backgroundColor = Ie, ue.style.color = ku(ae) ? "white" : "black";
                break;
              }
              case "rgba": {
                const ae = ia(F);
                ue.textContent = Wn(Lh(F)), ue.style.backgroundColor = Wn(ia(F)), ue.style.color = ku(ae) ? "white" : "black";
                break;
              }
              default:
                ue.textContent = w1(j, F);
                break;
            }
            U.appendChild(ue), f.appendChild(U);
          }
          var w = d;
          const I = w.relatedSegments;
          for (let O = 0, B = R.length; O < B; ++O) {
            const j = I === void 0 ? [] : I[O];
            if (j.length === 0 && A)
              continue;
            const U = O, V = R[O];
            f.appendChild(g.registerDisposer($4(V, j, a.displayState.relationshipStates.get(V).segmentationState, A ? void 0 : (G) => {
              const F = l.value;
              if (F == null)
                return;
              let ue = F.relatedSegments;
              ue === void 0 ? ue = a.source.relationships.map(() => []) : ue = ue.slice(), ue[U] = G;
              const ae = RZr(RZr({}, F), { relatedSegments: ue });
              a.source.update(l, ae), a.source.commit(l);
            })).element);
          }
          let P = null, N = a.source;
          if (N instanceof Ui && N.makeEditWidget && (P = N.makeEditWidget(l), P && (P.className = "neuroglancer-annotation-details-description", f.appendChild(P))), (!a.source.readonly || d.description) && P === null)
            if (a.source.readonly) {
              const O = document.createElement("div");
              O.className = "neuroglancer-annotation-details-description", O.textContent = d.description || "", f.appendChild(O);
            } else {
              const O = document.createElement("textarea");
              O.value = d.description || "", O.rows = 3, O.className = "neuroglancer-annotation-details-description", O.placeholder = "Description", O.addEventListener("change", () => {
                const B = O.value;
                a.source.update(l, RZr(RZr({}, d), { description: B || void 0 })), a.source.commit(l);
              }), f.appendChild(O);
            }
        }
        if (v !== void 0) {
          const C = document.createElement("div");
          C.classList.add("neuroglancer-selection-annotation-status"), C.textContent = v, f.appendChild(C);
        }
      })).element), true;
    }
    displaySelectionState(i, r, s) {
      let a = this.displayAnnotationState(i, r, s);
      return super.displaySelectionState(i, r, s) && (a = true), a;
    }
    addLocalAnnotations(i, r, s) {
      const a = i.subsourceEntry, l = new em({
        localPosition: this.localPosition,
        transform: i.getRenderLayerTransform(),
        source: r,
        displayState: this.annotationDisplayState,
        dataSource: i.loadedDataSource.layerDataSource,
        subsourceIndex: i.subsourceIndex,
        subsourceId: a.id,
        role: s
      });
      this.addAnnotationLayerState(l, i);
    }
    addStaticAnnotations(i) {
      const s = i.subsourceEntry.subsource.staticAnnotations;
      return s === void 0 ? false : (i.activate(() => {
        this.addLocalAnnotations(i, s, Ti.DEFAULT_ANNOTATION);
      }), true);
    }
    addAnnotationLayerState(i, r) {
      const s = r.activated;
      s.registerDisposer(this.annotationStates.add(i));
      const a = new M4(this.manager.chunkManager, i.addRef());
      if (a.source instanceof Ui) {
        const l = new O4({
          annotationLayer: a.addRef(),
          renderScaleTarget: this.annotationCrossSectionRenderScaleTarget,
          renderScaleHistogram: this.annotationCrossSectionRenderScaleHistogram
        });
        s.registerDisposer(r.messages.addChild(l.messages));
        const d = new _4({
          annotationLayer: a.addRef(),
          renderScaleTarget: this.annotationProjectionRenderScaleTarget,
          renderScaleHistogram: this.annotationProjectionRenderScaleHistogram
        });
        s.registerDisposer(r.messages.addChild(d.messages)), s.registerDisposer(Ur((u, f) => {
          f && (u.registerDisposer(this.addRenderLayer(l.addRef())), u.registerDisposer(this.addRenderLayer(d.addRef())));
        }, this.annotationDisplayState.displayUnfiltered));
      }
      {
        const l = new V4(a, this.annotationCrossSectionRenderScaleHistogram);
        s.registerDisposer(this.addRenderLayer(l)), s.registerDisposer(r.messages.addChild(l.messages));
      }
      {
        const l = new N4(a.addRef(), this.annotationProjectionRenderScaleHistogram);
        s.registerDisposer(this.addRenderLayer(l)), s.registerDisposer(r.messages.addChild(l.messages));
      }
    }
    selectAnnotation(i, r, s, a = true) {
      this.manager.root.selectionState.captureSingleLayerState(this, (l) => (l.annotationId = r, l.annotationSourceIndex = i.sourceIndex, l.annotationSubsource = i.subsourceId, true), s, a);
    }
    toJSON() {
      const i = super.toJSON();
      return i[Lx] = this.annotationDisplayState.color.toJSON(), i;
    }
  }
  return e;
}
var Dx = vt.fromObject({
  "shift?+mousedown0": { action: "set" },
  "shift?+alt+mousedown0": { action: "adjust-window-via-drag" },
  "shift?+wheel": { action: "zoom-via-wheel" }
});
var HL = class extends Z {
  constructor(e, t, i, r) {
    super(), this.element = e, this.dataType = t, this.getModel = i, this.setModel = r, e.title = Dx.describe(), this.registerDisposer(new qr(e, Dx)), be(e, "set", (s) => {
      const a = s.detail, l = this.getModel(), d = this.getTargetValue(a);
      if (d === void 0)
        return;
      const u = nc(l.window, l.range), f = n2(u, d), g = (v) => {
        const y = this.getModel();
        this.setModel(rh(y, "range", f, v));
      };
      g(d), zi(a, (v) => {
        const y = this.getTargetValue(v);
        y !== void 0 && g(y);
      });
    }), be(e, "adjust-window-via-drag", (s) => {
      const a = s.detail, l = this.getTargetFraction(a), d = this.getWindowLerp(l), u = l < 0.5 ? 0 : 1, f = (g) => {
        const v = this.getModel();
        this.setModel(rh(v, "window", u, g));
      };
      zi(a, (g) => {
        const v = this.getModel().window, y = this.getTargetFraction(g);
        f(u === 0 ? Rr([d, v[1]], this.dataType, -y / (1 - y)) : Rr([v[0], d], this.dataType, 1 / y));
      });
    }), be(e, "zoom-via-wheel", (s) => {
      const a = s.detail, l = Ju(a), d = this.getTargetFraction(a), u = this.dataType, f = this.getModel(), g = Rr(f.window, u, d * (1 - l)), v = Rr(f.window, u, (1 - d) * l + d);
      this.setModel(RZr(RZr({}, f), { window: [g, v], range: f.range }));
    });
  }
  getTargetFraction(e) {
    const t = this.element.getBoundingClientRect();
    return (e.clientX - t.left) / t.width;
  }
  getWindowLerp(e) {
    return Rr(this.getModel().window, this.dataType, e);
  }
  getTargetValue(e) {
    const t = this.getTargetFraction(e);
    if (kt(t))
      return this.getWindowLerp(t);
  }
};
var Px = NZr("histogramSamplerTexture");
function rh(n, e, t, i, r = false) {
  const s = RZr({}, n), a = n[e];
  if (s[e] = [a[0], a[1]], s[e][t] = i, e === "window" && Ei(i, a[1 - t]) * (2 * t - 1) < 0 && (s[e][1 - t] = i), e === "range" && r) {
    const l = [n.window[0], n.window[1]];
    for (let d = 0; d < 2; ++d)
      Ei(i, l[d]) * (2 * d - 1) > 0 && (l[d] = i);
    s.window = l;
  }
  return s;
}
var W4 = 254;
var Kl = W4 + 1;
var H4 = class extends Q1 {
  constructor(e) {
    super(e.display, document.createElement("div"), e.visibility), this.parent = e, this.controller = this.registerDisposer(new HL(this.element, this.parent.dataType, () => this.parent.trackable.value, (i) => {
      this.parent.trackable.value = i;
    })), this.dataValuesBuffer = this.registerDisposer(bc(this.gl, WebGL2RenderingContext.ARRAY_BUFFER, () => {
      const i = new Uint8Array(Kl * bs);
      for (let r = 0; r < Kl; ++r)
        for (let s = 0; s < bs; ++s)
          i[r * bs + s] = r;
      return i;
    })).value, this.lineShader = this.registerDisposer((() => {
      const i = new da(this.gl);
      return fr(i), i.addTextureSampler("sampler2D", "uHistogramSampler", Px), i.addOutputBuffer("vec4", "out_color", 0), i.addAttribute("uint", "aDataValue"), i.addUniform("float", "uBoundsFraction"), i.addVertexCode(`
float getCount(int i) {
  return texelFetch(uHistogramSampler, ivec2(i, 0), 0).x;
}
vec4 getVertex(float cdf, int i) {
  float x;
  if (i == 0) {
    x = -1.0;
  } else if (i == 255) {
    x = 1.0;
  } else {
    x = float(i) / 254.0 * uBoundsFraction * 2.0 - 1.0;
  }
  return vec4(x, cdf * (2.0 - uLineParams.y) - 1.0 + uLineParams.y * 0.5, 0.0, 1.0);
}
`), i.setVertexMain(`
int lineNumber = int(aDataValue);
int dataValue = lineNumber;
float cumSum = 0.0;
for (int i = 0; i <= dataValue; ++i) {
  cumSum += getCount(i);
}
float total = cumSum + getCount(dataValue + 1);
float cumSumEnd = dataValue == ${Kl - 1} ? cumSum : total;
if (dataValue == ${Kl - 1}) {
  cumSum + getCount(dataValue + 1);
}
for (int i = dataValue + 2; i < 256; ++i) {
  total += getCount(i);
}
total = max(total, 1.0);
float cdf1 = cumSum / total;
float cdf2 = cumSumEnd / total;
emitLine(getVertex(cdf1, lineNumber), getVertex(cdf2, lineNumber + 1), 1.0);
`), i.setFragmentMain(`
out_color = vec4(0.0, 1.0, 1.0, getLineAlpha());
`), i.build();
    })()), this.regionCornersBuffer = Cc(this.gl, 0, -1, 1, 1), this.regionShader = this.registerDisposer((() => {
      const i = new da(this.gl);
      return i.addAttribute("vec2", "aVertexPosition"), i.addUniform("vec2", "uBounds"), i.addUniform("vec4", "uColor"), i.addOutputBuffer("vec4", "out_color", 0), i.setVertexMain(`
gl_Position = vec4(mix(uBounds[0], uBounds[1], aVertexPosition.x) * 2.0 - 1.0, aVertexPosition.y, 0.0, 1.0);
`), i.setFragmentMain(`
out_color = uColor;
`), i.build();
    })()), this.element.classList.add("neuroglancer-invlerp-cdfpanel");
  }
  get drawOrder() {
    return 100;
  }
  drawIndirect() {
    const e = this.lineShader, t = this.gl, i = this.regionShader;
    var r = this.parent;
    const s = r.dataType, a = r.trackable.value;
    this.setGLLogicalViewport(), t.clearColor(0, 0, 0, 0), t.clear(WebGL2RenderingContext.COLOR_BUFFER_BIT), t.enable(WebGL2RenderingContext.BLEND), t.blendFunc(WebGL2RenderingContext.SRC_ALPHA, WebGL2RenderingContext.ONE_MINUS_SRC_ALPHA), t.disable(WebGL2RenderingContext.DEPTH_TEST), t.disable(WebGL2RenderingContext.STENCIL_TEST);
    {
      i.bind(), t.uniform4f(i.uniform("uColor"), 0.2, 0.2, 0.2, 1);
      const l = gi(a.window, a.range[0]), d = gi(a.window, a.range[1]), u = Pu(s, a.window);
      t.uniform2f(i.uniform("uBounds"), Math.min(l, d) * u, Math.max(l, d) * u + (1 - u));
      const f = i.attribute("aVertexPosition");
      this.regionCornersBuffer.bindToVertexAttrib(
        f,
        /*componentsPerVertexAttribute=*/
        2,
        /*attributeType=*/
        WebGL2RenderingContext.FLOAT
      ), t.drawArrays(WebGL2RenderingContext.TRIANGLE_FAN, 0, 4), t.disableVertexAttribArray(f);
    }
    if (this.parent.histogramSpecifications.producerVisibility.visible) {
      const l = this.renderViewport;
      e.bind(), gr(
        e,
        { width: l.logicalWidth, height: l.logicalHeight },
        /*featherWidthInPixels=*/
        1
      );
      const d = e.textureUnit(Px);
      t.uniform1f(e.uniform("uBoundsFraction"), Pu(s, a.window)), t.activeTexture(WebGL2RenderingContext.TEXTURE0 + d), t.bindTexture(WebGL2RenderingContext.TEXTURE_2D, this.parent.texture), Lo(t);
      const u = e.attribute("aDataValue");
      this.dataValuesBuffer.bindToVertexAttribI(
        u,
        /*componentsPerVertexAttribute=*/
        1,
        /*attributeType=*/
        WebGL2RenderingContext.UNSIGNED_BYTE
      ), pr(
        t,
        /*linesPerInstance=*/
        Kl,
        /*numInstances=*/
        1
      ), t.disableVertexAttribArray(u), t.bindTexture(WebGL2RenderingContext.TEXTURE_2D, null);
    }
    t.disable(WebGL2RenderingContext.BLEND);
  }
  isReady() {
    return true;
  }
};
function j4() {
}
var J4 = class extends Q1 {
  constructor(e) {
    super(e.display, document.createElement("div"), e.visibility), this.parent = e, this.cornersBuffer = Cc(this.gl, -1, -1, 1, 1), this.element.classList.add("neuroglancer-invlerp-legend-panel");
    const i = this.shaderOptions = e.legendShaderOptions;
    this.shaderGetter = Io(this, this.gl, RZr(RZr({}, i), { memoizeKey: { id: "colorLegendShader", base: i.memoizeKey }, defineShader: (r, s, a) => {
      r.addOutputBuffer("vec4", "v4f_fragData0", 0), r.addAttribute("vec2", "aVertexPosition"), r.addUniform("float", "uLegendOffset"), r.addVarying("float", "vLinearPosition"), r.setVertexMain(`
gl_Position = vec4(aVertexPosition, 0.0, 1.0);
vLinearPosition = -uLegendOffset + ((aVertexPosition.x + 1.0) * 0.5) * (1.0 + 2.0 * uLegendOffset);
`);
      const l = this.parent.dataType, d = wn(l);
      r.addFragmentCode(YV(r, "ng_colorLegendLerp", l)), r.addFragmentCode(`
void emit(vec4 v) {
  v4f_fragData0 = v;
}
${d} getDataValue() {
  return ng_colorLegendLerp(vLinearPosition);
}
${d} getDataValue(int dummyChannel) {
  return getDataValue();
}
${d} getInterpolatedDataValue() {
  return getDataValue();
}
${d} getInterpolatedDataValue(int dummyChannel) {
  return getDataValue();
}
`), i.defineShader(r, s, a);
    } }));
  }
  drawIndirect() {
    const e = this.shaderGetter(j4), t = e.shader;
    if (t === null)
      return;
    this.setGLLogicalViewport();
    const i = this.gl;
    i.clearColor(0, 0, 0, 0), i.clear(WebGL2RenderingContext.COLOR_BUFFER_BIT), t.bind(), this.shaderOptions.initializeShader(e), i.enable(WebGL2RenderingContext.BLEND);
    var r = this.parent;
    const s = r.trackable.value.window, a = r.dataType;
    ty(t, "ng_colorLegendLerp", this.parent.dataType, s);
    const l = i2(a, s);
    i.uniform1f(t.uniform("uLegendOffset"), kt(l) ? l : 0), i.blendFunc(WebGL2RenderingContext.SRC_ALPHA, WebGL2RenderingContext.ONE_MINUS_SRC_ALPHA), i.disable(WebGL2RenderingContext.DEPTH_TEST), i.disable(WebGL2RenderingContext.STENCIL_TEST);
    const d = t.attribute("aVertexPosition");
    this.cornersBuffer.bindToVertexAttrib(
      d,
      /*componentsPerVertexAttribute=*/
      2,
      /*attributeType=*/
      WebGL2RenderingContext.FLOAT
    ), i.drawArrays(WebGL2RenderingContext.TRIANGLE_FAN, 0, 4), i.disableVertexAttribArray(d);
  }
  isReady() {
    return true;
  }
};
function Ax(n, e) {
  const t = document.createElement("input");
  return t.addEventListener("focus", () => {
    t.select();
  }), t.classList.add("neuroglancer-invlerp-widget-bound"), t.classList.add(`neuroglancer-invlerp-widget-${n}-bound`), t.type = "text", t.spellcheck = false, t.autocomplete = "off", t.title = n === "range" ? `Data value that maps to ${e}` : `${e === 0 ? "Lower" : "Upper"} bound for distribution`, t;
}
function Rx(n, e, t) {
  const i = document.createElement("div");
  i.classList.add("neuroglancer-invlerp-widget-bounds"), i.classList.add(`neuroglancer-invlerp-widget-${n}-bounds`);
  const r = [Ax(n, 0), Ax(n, 1)];
  for (let a = 0; a < 2; ++a) {
    const l = r[a];
    l.addEventListener("input", () => {
      jL(l);
    }), l.addEventListener("change", () => {
      const d = t.value, u = d[n];
      try {
        const f = Vc(e, l.value);
        t.value = rh(
          d,
          n,
          a,
          f,
          /*fitRangeInWindow=*/
          true
        );
      } catch {
        Um(l, u[a]);
      }
    });
  }
  let s;
  return i.appendChild(r[0]), i.appendChild(r[1]), n === "range" && (s = [document.createElement("div"), document.createElement("div"), document.createElement("div")], s[1].classList.add("neuroglancer-invlerp-widget-range-spacer"), i.insertBefore(s[0], r[0]), i.insertBefore(s[1], r[1]), i.appendChild(s[2])), { container: i, inputs: r, spacers: s };
}
function jL(n) {
  Kn(n, Math.max(1, n.value.length + 0.1));
}
function Um(n, e) {
  let t;
  e instanceof re || jn(e) ? t = e.toString() : t = e.toPrecision(6), n.value = t, jL(n);
}
function JL(n) {
  const e = n.value, t = e.range;
  n.value = RZr(RZr({}, e), { range: [t[1], t[0]] });
}
function Y4(n, e, t) {
  const i = e.value, r = Rr(i.range, n, 0.5 - t / 2), s = Rr(i.range, n, 0.5 + t / 2);
  e.value = RZr(RZr({}, i), { range: [r, s] });
}
function q4(n, e, t, i, r) {
  const s = Math.exp(r), a = e.value, l = Rr(t, n, 0.5 - s / 2 + i), d = Rr(t, n, 0.5 + s / 2 + i);
  e.value = RZr(RZr({}, a), { range: [l, d] });
}
var K4 = class extends Kr {
  constructor(e, t, i, r, s, a, l) {
    super(e), this.display = t, this.dataType = i, this.trackable = r, this.histogramSpecifications = s, this.histogramIndex = a, this.legendShaderOptions = l, this.cdfPanel = this.registerDisposer(new H4(this)), this.boundElements = {
      range: Rx("range", this.dataType, this.trackable),
      window: Rx("window", this.dataType, this.trackable)
    }, this.registerDisposer(s.visibility.add(this.visibility));
    const d = this.element, u = this.boundElements;
    if (l !== void 0) {
      const g = this.registerDisposer(new J4(this));
      d.appendChild(g.element);
    }
    const f = (g) => {
      const v = Tt({
        svg: g,
        title: "Invert range",
        onClick: () => {
          this.invertRange();
        }
      });
      return u.range.spacers[1].appendChild(v), v;
    };
    this.invertArrows = [f(_k), f(Nk)], d.appendChild(u.range.container), d.appendChild(this.cdfPanel.element), d.classList.add("neuroglancer-invlerp-widget"), d.appendChild(u.window.container), this.updateView(), this.registerDisposer(r.changed.add(this.registerCancellable(Ct(() => this.updateView()))));
  }
  get texture() {
    return this.histogramSpecifications.getFramebuffers(this.display.gl)[this.histogramIndex].colorBuffers[0].texture;
  }
  invertRange() {
    JL(this.trackable);
  }
  updateView() {
    const e = this.boundElements, t = this.trackable.value, i = this.dataType;
    for (let g = 0; g < 2; ++g)
      Um(e.range.inputs[g], t.range[g]), Um(e.window.inputs[g], t.window[g]);
    const r = Ei(t.range[0], t.range[1]) > 0;
    e.range.container.style.flexDirection = r ? "row-reverse" : "row";
    const s = nc(t.window, t.range), a = e.range.spacers, l = Pu(i, t.window), d = gi(t.window, s[r ? 1 : 0]) * l, u = gi(t.window, s[r ? 0 : 1]) * l + (1 - l);
    a[r ? 2 : 0].style.width = `${d * 100}%`, a[r ? 0 : 2].style.width = `${(1 - u) * 100}%`;
    const f = this.invertArrows;
    f[r ? 1 : 0].style.display = "", f[r ? 0 : 1].style.display = "none";
  }
};
var eS = "mergeSegments";
var tS = "splitSegments";
var Z4 = vt.fromObject({
  "at:shift?+mousedown0": { action: "merge-segments" },
  "at:shift?+mousedown2": { action: "set-anchor" }
});
var X4 = vt.fromObject({
  "at:shift?+mousedown0": { action: "split-segments" },
  "at:shift?+alt+mousedown0": { action: "split-and-select-segments" },
  "at:shift?+mousedown2": { action: "set-anchor" }
});
var Q4 = class extends Uo {
  constructor(e) {
    super(e), this.lastAnchorBaseSegment = new gt(void 0);
    const t = () => {
      const i = e.anchorSegment.value;
      if (i === void 0)
        return;
      const r = e.displayState.segmentSelectionState;
      if (!r.hasSelectedSegment)
        return;
      const s = e.displayState.segmentationGroupState.value.segmentEquivalences, a = s.get(i);
      if (!re.equal(r.selectedSegment, a))
        return;
      const l = r.baseSelectedSegment, d = zB(l), u = s.disjointSets.visibleSegmentEquivalencePolicy.value;
      u & Fi.NONREPRESENTATIVE_EXCLUDED && d || u & Fi.REPRESENTATIVE_EXCLUDED && !d || (this.lastAnchorBaseSegment.value = l.clone());
    };
    this.registerDisposer(e.displayState.segmentSelectionState.changed.add(t)), this.registerDisposer(e.anchorSegment.changed.add(t));
  }
  toJSON() {
    return eS;
  }
  activate(e) {
    const t = this.layer.displayState.segmentationGroupState.value, i = () => {
      let f = this.layer.anchorSegment.value, g = this.lastAnchorBaseSegment.value;
      if (f === void 0)
        return { anchorSegment: void 0, error: "Select anchor segment for merge" };
      const v = t.segmentEquivalences.get(f);
      return t.visibleSegments.has(v) ? g === void 0 || !re.equal(t.segmentEquivalences.get(g), v) ? {
        anchorSegment: f,
        error: "Hover over base segment within anchor segment that is closest to merge location"
      } : { anchorSegment: g, error: void 0 } : { anchorSegment: f, error: "Anchor segment must be in visible set" };
    }, r = () => {
      var f = i();
      let g = f.anchorSegment, v = f.error;
      if (g === void 0 || v !== void 0)
        return { anchorSegment: g, error: v, otherSegment: void 0, anchorSegmentValid: false };
      const y = this.layer.displayState, w = y.segmentSelectionState.baseValue;
      return w === void 0 || re.equal(y.segmentSelectionState.selectedSegment, t.segmentEquivalences.get(g)) ? {
        anchorSegment: g,
        otherSegment: void 0,
        error: "Hover over segment to merge",
        anchorSegmentValid: true
      } : { anchorSegment: g, otherSegment: w, error: void 0, anchorSegmentValid: true };
    };
    var s = tf(e);
    const a = s.body, l = s.header;
    l.textContent = "Merge segments", a.classList.add("neuroglancer-merge-segments-status"), e.bindInputEventMap(Z4), e.registerDisposer(() => {
      Ic(t);
    });
    const d = () => {
      it(a);
      const f = this.layer.displayState;
      var g = r();
      let v = g.anchorSegment, y = g.otherSegment, w = g.anchorSegmentValid, C = g.error;
      const b = (L) => {
        const R = qh(this.layer.displayState, L);
        return R.classList.add("neuroglancer-segment-list-entry-double-line"), R;
      };
      if (v !== void 0 && a.appendChild(b(ha(f, v))), C !== void 0) {
        const L = document.createElement("span");
        L.textContent = C, a.appendChild(L);
      }
      if (y !== void 0) {
        const L = document.createElement("span");
        L.textContent = " merge ", a.appendChild(L), a.appendChild(b(ha(f, y)));
      }
      const E = t.segmentEquivalences;
      if (w) {
        t.useTemporaryVisibleSegments.value = true;
        const L = t.temporaryVisibleSegments;
        L.clear(), L.add(E.get(v)), y !== void 0 && L.add(E.get(y));
      } else {
        Ic(t);
        return;
      }
    };
    d(), e.registerDisposer(Bo(this.layer.displayState, a));
    const u = e.registerCancellable(Ct(d));
    nl(this.layer.displayState, e, u), e.registerDisposer(this.layer.anchorSegment.changed.add(u)), e.registerDisposer(this.lastAnchorBaseSegment.changed.add(u)), e.bindAction("merge-segments", (f) => {
      f.stopPropagation(), (async () => {
        const g = t.graph.value;
        if (g === void 0)
          return;
        var v = r();
        const y = v.anchorSegment, w = v.otherSegment, C = v.error;
        if (!(y === void 0 || w === void 0 || C !== void 0))
          try {
            await g.merge(y, w), nt.showTemporaryMessage("Merge performed");
          } catch (b) {
            nt.showTemporaryMessage(`Merge failed: ${b}`);
          }
      })();
    }), e.bindAction("set-anchor", (f) => {
      f.stopPropagation();
      const v = this.layer.displayState.segmentSelectionState.baseValue;
      if (v === void 0)
        return;
      const y = this.layer.anchorSegment.value;
      if (t.visibleSegments.add(v), y === void 0 || !re.equal(y, v)) {
        this.layer.anchorSegment.value = v.clone();
        return;
      }
    });
  }
  get description() {
    return "merge";
  }
};
var eH = class extends Uo {
  toJSON() {
    return tS;
  }
  activate(e) {
    const t = this.layer.displayState.segmentationGroupState.value, i = () => {
      let g = this.layer.anchorSegment.value;
      if (g === void 0)
        return { anchorSegment: void 0, error: "Select anchor segment for split" };
      const v = t.segmentEquivalences.get(g);
      return t.visibleSegments.has(v) ? { anchorSegment: g, error: void 0 } : { anchorSegment: g, error: "Anchor segment must be in visible set" };
    };
    var r = tf(e);
    const s = r.body, a = r.header;
    a.textContent = "Split segments", s.classList.add("neuroglancer-merge-segments-status"), e.bindInputEventMap(X4);
    const l = () => {
      var g = i();
      let v = g.anchorSegment, y = g.error;
      if (v === void 0 || y !== void 0)
        return { anchorSegment: v, error: y, otherSegment: void 0, anchorSegmentValid: false };
      const w = this.layer.displayState, C = w.segmentSelectionState.baseValue;
      return C === void 0 || !re.equal(w.segmentSelectionState.selectedSegment, t.segmentEquivalences.get(v)) || re.equal(C, v) ? {
        anchorSegment: v,
        otherSegment: void 0,
        anchorSegmentValid: true,
        error: "Hover over base segment to seed split"
      } : { anchorSegment: v, otherSegment: C, anchorSegmentValid: true, error: void 0 };
    };
    e.registerDisposer(() => {
      Ic(t);
    });
    const d = () => {
      it(s);
      const g = this.layer.displayState;
      var v = l();
      let y = v.anchorSegment, w = v.otherSegment, C = v.anchorSegmentValid, b = v.error, E, L;
      (() => {
        const A = t.segmentEquivalences, I = this.layer.graphConnection;
        if (!C || I === void 0) {
          Ic(t);
          return;
        } else {
          if (t.useTemporaryVisibleSegments.value = true, w !== void 0) {
            const N = I.computeSplit(y, w);
            if (N !== void 0) {
              E = new $r(y, N.includeRepresentative), L = new $r(w, N.excludeRepresentative), t.useTemporarySegmentEquivalences.value = true;
              const O = N.includeRepresentative, B = N.excludeRepresentative, j = t.temporarySegmentEquivalences;
              j.clear();
              for (const V of N.includeBaseSegments)
                j.link(V, O);
              for (const V of N.excludeBaseSegments)
                j.link(V, B);
              const U = t.temporaryVisibleSegments;
              U.clear(), U.add(O), U.add(B);
              return;
            }
          }
          t.useTemporarySegmentEquivalences.value = false;
          const P = t.temporaryVisibleSegments;
          P.clear(), P.add(A.get(y));
        }
      })();
      const _ = (A) => {
        const I = qh(this.layer.displayState, A);
        return I.classList.add("neuroglancer-segment-list-entry-double-line"), I;
      };
      if (y !== void 0 && s.appendChild(_(E ?? ha(g, y))), b !== void 0) {
        const A = document.createElement("span");
        A.textContent = b, s.appendChild(A);
      }
      if (L !== void 0) {
        const A = document.createElement("span");
        A.textContent = " split ", s.appendChild(A), s.appendChild(_(L));
      }
    };
    e.registerDisposer(Bo(this.layer.displayState, s)), d();
    const u = e.registerCancellable(Ct(d));
    nl(this.layer.displayState, e, u), e.registerDisposer(this.layer.anchorSegment.changed.add(u));
    const f = async (g) => {
      const v = t.graph.value;
      if (v === void 0)
        return;
      var y = l();
      const w = y.anchorSegment, C = y.otherSegment, b = y.error;
      if (!(w === void 0 || C === void 0 || b !== void 0))
        try {
          await v.split(w, C), g && t.visibleSegments.add(t.segmentEquivalences.get(C)), nt.showTemporaryMessage("Split performed");
        } catch (E) {
          nt.showTemporaryMessage(`Split failed: ${E}`);
        }
    };
    e.bindAction("split-segments", (g) => {
      g.stopPropagation(), f(
        /*select=*/
        false
      );
    }), e.bindAction("split-and-select-segments", (g) => {
      g.stopPropagation(), f(
        /*select=*/
        true
      );
    }), e.bindAction("set-anchor", (g) => {
      g.stopPropagation();
      const y = this.layer.displayState.segmentSelectionState.baseValue;
      if (y === void 0)
        return;
      t.visibleSegments.add(y);
      const w = this.layer.anchorSegment.value;
      if (w === void 0 || !re.equal(w, y)) {
        this.layer.anchorSegment.value = y.clone();
        return;
      }
    });
  }
  get description() {
    return "split";
  }
};
function tH() {
  Dc(Mn, eS, (n) => new Q4(n)), Dc(Mn, tS, (n) => new eH(n));
}
var nS = "selectSegments";
var zm = "mousedown0";
var nH = vt.fromObject({
  [`at:alt?+shift?+${zm}`]: "drag-select-segments"
});
var zn;
(function(n) {
  n[n.IDLE = 0] = "IDLE", n[n.SELECT = 1] = "SELECT", n[n.DESELECT = 2] = "DESELECT";
})(zn || (zn = {}));
var iH = class extends Uo {
  constructor(e) {
    super(e);
  }
  toJSON() {
    return nS;
  }
  activate(e) {
    const t = this.layer;
    var i = tf(e);
    const r = i.body, s = i.header;
    let a = zn.IDLE, l = false;
    e.bindInputEventMap(nH);
    const d = () => ju.value & 2 ? zn.DESELECT : zn.SELECT, u = (y) => {
      a !== y && (a = y, l = false, f());
    }, f = () => {
      it(r);
      const y = document.createElement("span");
      switch (a) {
        case zn.IDLE:
          s.textContent = "Select/Deselect segments", y.textContent = `${zm} to select segments; alt+${zm} to deselect segments.`;
          break;
        case zn.SELECT:
        case zn.DESELECT:
          s.textContent = `${a == zn.SELECT ? "Select" : "Deselect"} segments`, y.textContent = `Drag to ${a == zn.SELECT ? "select" : "deselect"} segments (${t.displayState.segmentationGroupState.value.visibleSegments.size} selected).`;
      }
      r.appendChild(y);
    };
    f();
    const g = () => {
      if (a == zn.IDLE)
        return;
      const y = t.displayState.segmentSelectionState;
      if (y.hasSelectedSegment) {
        const w = y.selectedSegment, C = t.displayState.segmentationGroupState.value.visibleSegments;
        switch (a) {
          case zn.SELECT:
            C.add(w);
            break;
          case zn.DESELECT:
            C.delete(w);
            break;
        }
      }
    };
    e.registerDisposer(t.displayState.segmentSelectionState.changed.add(() => {
      l && g();
    })), e.registerDisposer(t.displayState.segmentationGroupState.value.visibleSegments.changed.add(f)), e.registerDisposer(ju.changed.add(() => {
      a != zn.IDLE && u(d());
    }));
    const v = (y, w) => {
      y.stopPropagation(), u(w), g();
      const C = y.detail.screenX, b = y.detail.screenY;
      zi(y.detail, (E, L, R) => {
        if (!l) {
          const _ = E.screenX - C, A = E.screenY - b;
          _ * _ + A * A > 25 && (g(), l = true);
        }
      }, (E) => {
        l = false, u(zn.IDLE);
      });
    };
    e.bindAction("drag-select-segments", (y) => v(y, d()));
  }
  get description() {
    return "select";
  }
};
function rH() {
  Dc(Mn, nS, (n) => new iH(n));
}
var sH = new re();
var aH = class extends Z {
  constructor(e, t, i, r) {
    super(), this.query = e, this.segmentPropertyMap = t, this.segmentationDisplayState = i, this.parentElement = r, this.changed = new ot(), this.explicitSegmentsVisible = false, this.visibleSegmentsGeneration = -1, this.queryResult = new gt(void 0), this.statusText = new gt(""), this.selectedMatches = 0, this.matchStatusTextPrefix = "", this.debouncedUpdate = lt(() => this.update(), 0), this.render = (s) => {
      const a = this.explicitSegments;
      let l, d = false;
      if (a !== void 0 && s < a.length)
        l = a[s], d = this.explicitSegmentsVisible;
      else {
        a !== void 0 && (s -= a.length), l = sH;
        const f = this.queryResult.value.indices[s], g = this.segmentPropertyMap.segmentPropertyMap.inlineProperties.ids;
        l.low = g[f * 2], l.high = g[f * 2 + 1];
      }
      const u = this.segmentWidgetFactory.get(l);
      return d && (u.dataset.visibleList = "true"), u;
    }, this.update(), this.registerDisposer(i.segmentationGroupState.value.visibleSegments.changed.add(this.debouncedUpdate)), this.registerDisposer(e.changed.add(this.debouncedUpdate));
  }
  get numMatches() {
    var e, t;
    return (t = (e = this.queryResult.value) === null || e === void 0 ? void 0 : e.count) !== null && t !== void 0 ? t : 0;
  }
  update() {
    var e;
    const t = this.query.value, i = this.segmentPropertyMap, r = this.queryResult.value;
    let s;
    if (this.prevQuery === t)
      s = r;
    else {
      const b = AW(i, t);
      s = RW(i, b);
    }
    const a = [];
    let l = false, d = "";
    const u = this.segmentationDisplayState.segmentationGroupState.value.visibleSegments, f = u.changed.count, g = this.visibleSegmentsGeneration, v = VW(s.query);
    if (v) {
      if (g !== f || this.explicitSegments === void 0 || !this.explicitSegmentsVisible) {
        this.visibleSegmentsGeneration = f;
        const b = De(u, (L) => L.clone());
        b.sort(re.compare);
        const E = this.explicitSegments;
        E === void 0 ? (this.explicitSegments = b, a.push({ retainCount: 0, insertCount: b.length, deleteCount: 0 })) : a.push(...SN(E, b, re.compare)), this.explicitSegments = b, l = true;
      } else
        a.push({ retainCount: this.explicitSegments.length, deleteCount: 0, insertCount: 0 });
      this.explicitSegmentsVisible = true;
    } else
      this.visibleSegmentsGeneration = f, this.explicitSegments !== void 0 && this.explicitSegmentsVisible && (a.push({ deleteCount: this.explicitSegments.length, retainCount: 0, insertCount: 0 }), this.explicitSegments = void 0, l = true), this.explicitSegmentsVisible = false;
    var y = s;
    const w = y.explicitIds;
    if (w !== void 0 ? this.explicitSegments = w : this.explicitSegmentsVisible || (this.explicitSegments = void 0), r !== s && (a.push({
      retainCount: 0,
      deleteCount: (e = r == null ? void 0 : r.count) !== null && e !== void 0 ? e : 0,
      insertCount: s.count
    }), l = true, this.queryResult.value = s), s.explicitIds !== void 0 ? d = `${s.count} ids` : v ? d = `${s.count} listed ids` : s.total > 0 && (d = `${s.count}/${s.total} matches`), r !== s || f !== g) {
      let b = d, E = 0;
      i !== void 0 && s.count > 0 && (E = OW(i, s, u), b += ` (${E} visible)`), this.selectedMatches = E, this.statusText.value = b;
    }
    this.prevQuery = t, this.matchStatusTextPrefix = d;
    const C = this.explicitSegments;
    this.length = (this.explicitSegmentsVisible ? C.length : 0) + s.count, l && this.changed.dispatch(a);
  }
  updateRendering(e) {
    this.segmentWidgetFactory.update(e);
  }
  updateRenderedItems(e) {
    e.forEachRenderedItem((t) => {
      this.updateRendering(t);
    });
  }
};
var Mx = vt.fromObject({
  enter: { action: "toggle-listed" },
  "shift+enter": { action: "hide-listed" },
  "control+enter": { action: "hide-all" },
  escape: { action: "cancel" }
});
var oH = 100;
function YL(n) {
  Kn(n, Math.max(1, n.value.length + 0.1));
}
function pg(n, e) {
  let t;
  if (jn(e))
    t = e.toString();
  else {
    const i = e.toString(), r = e.toPrecision(6);
    t = i.length < r.length ? i : r;
  }
  n.value = t, YL(n);
}
function lH(n, e) {
  const t = document.createElement("input");
  return t.addEventListener("focus", () => {
    t.select();
  }), t.classList.add(`neuroglancer-segment-query-result-numerical-plot-${n}-bound`), t.classList.add("neuroglancer-segment-query-result-numerical-plot-bound"), t.type = "text", t.spellcheck = false, t.autocomplete = "off", t.title = (e === 0 ? "Lower" : "Upper") + " bound " + (n === "range" ? "range" : "for distribution"), t.addEventListener("input", () => {
    YL(t);
  }), t;
}
function cH(n, e, t) {
  if (n === void 0 || n.indices === void 0)
    return;
  const i = n.query;
  let r = i.sortBy, s = i.includeColumns;
  Hy(i, t) ? (r = r.filter((l) => l.fieldId !== t), s = s.filter((l) => l !== t)) : s.push(t), e(RZr(RZr({}, i), { sortBy: r, includeColumns: s }));
}
function qL(n, e, t) {
  var i;
  const r = n == null ? void 0 : n.query, s = r == null ? void 0 : r.sortBy;
  if (s === void 0)
    return;
  const a = r.includeColumns, d = ((i = s.find((f) => f.fieldId === t)) === null || i === void 0 ? void 0 : i.order) === "<" ? ">" : "<", u = a.filter((f) => f !== t);
  for (const f of s)
    f.fieldId !== "id" && f.fieldId !== "label" && f.fieldId !== t && u.push(f.fieldId);
  e(RZr(RZr({}, r), { sortBy: [{ fieldId: t, order: d }], includeColumns: u }));
}
function KL(n, e, t) {
  var i, r;
  const s = (i = n == null ? void 0 : n.query) === null || i === void 0 ? void 0 : i.sortBy, a = (r = s == null ? void 0 : s.find((l) => l.fieldId === t)) === null || r === void 0 ? void 0 : r.order;
  e.textContent = a === ">" ? "▼" : "▲", e.style.visibility = a === void 0 ? "" : "visible", e.title = `Sort by ${t} in ${a === "<" ? "descending" : "ascending"} order`;
}
var dH = class extends Z {
  constructor(e, t, i) {
    super(), this.segmentPropertyMap = e, this.queryResult = t, this.setQuery = i, this.propertyHistograms = [], this.bounds = {
      window: new gt([]),
      range: new gt([])
    }, this.throttledUpdate = this.registerCancellable(zh(() => this.updateHistograms(), 100)), this.debouncedRender = this.registerCancellable(Ct(() => this.updateHistogramRenderings())), this.debouncedSetQuery = this.registerCancellable(lt(() => this.setQueryFromBounds(), 200));
    const r = e == null ? void 0 : e.numericalProperties, s = [];
    let a;
    if (r !== void 0 && r.length > 0) {
      a = document.createElement("details");
      const l = document.createElement("summary");
      l.textContent = `${r.length} numerical propert${r.length > 1 ? "ies" : "y"}`, a.appendChild(l), a.classList.add("neuroglancer-segment-query-result-numerical-list");
      const d = this.bounds.window.value;
      for (let u = 0, f = r.length; u < f; ++u) {
        const g = r[u], v = this.makeNumericalPropertySummary(u, g);
        s.push(v), a.appendChild(v.element), d[u] = g.bounds;
      }
    }
    this.listElement = a, this.properties = s, this.registerDisposer(this.queryResult.changed.add(() => {
      this.handleNewQueryResult();
    })), this.registerDisposer(this.bounds.window.changed.add(this.throttledUpdate)), this.registerDisposer(this.bounds.window.changed.add(this.debouncedRender)), this.registerDisposer(this.bounds.range.changed.add(this.debouncedRender)), this.registerDisposer(this.bounds.range.changed.add(this.debouncedSetQuery)), this.handleNewQueryResult();
  }
  setQueryFromBounds() {
    const e = this.queryResult.value;
    if (e === void 0 || e.indices === void 0)
      return;
    const t = e.query, i = [], r = this.bounds.range.value, s = this.properties;
    for (let a = 0, l = s.length; a < l; ++a) {
      const d = s[a].property;
      i.push({ fieldId: d.id, bounds: r[a] });
    }
    this.setQuery(RZr(RZr({}, t), { numericalConstraints: i }));
  }
  getBounds(e) {
    const t = this.bounds;
    return { range: t.range.value[e], window: t.window.value[e] };
  }
  setBounds(e, t) {
    const i = this.properties[e].property;
    let r = nc(i.bounds, t.range);
    Ei(r[0], r[1]) > 0 && (r = [r[1], r[0]]);
    const s = nc(i.bounds, t.window), a = this.getBounds(e), l = this.properties[e].property.dataType;
    Mr(l, s, a.window) || (this.bounds.window.value[e] = s, this.bounds.window.changed.dispatch()), Mr(l, r, a.range) || (this.bounds.range.value[e] = r, this.bounds.range.changed.dispatch());
  }
  setBound(e, t, i, r) {
    const a = this.segmentPropertyMap.numericalProperties[i].bounds;
    r = fc(a, r);
    const l = this.getBounds(i), d = rh(
      l,
      e,
      t,
      r,
      /*fitRangeInWindow=*/
      true
    );
    this.setBounds(i, d);
  }
  handleNewQueryResult() {
    const e = this.queryResult.value;
    if (this.listElement !== void 0) {
      if ((e == null ? void 0 : e.indices) !== void 0) {
        const i = e.query.numericalConstraints, r = this.segmentPropertyMap.numericalProperties, s = this.bounds.range.value, a = i.length, l = r.length;
        s.length = l;
        for (let d = 0; d < l; ++d)
          s[d] = r[d].bounds;
        for (let d = 0; d < a; ++d) {
          const u = i[d], f = r.findIndex((g) => g.id === u.fieldId);
          s[f] = u.bounds;
        }
      }
      this.updateHistograms(), this.throttledUpdate.cancel();
    }
  }
  updateHistograms() {
    const e = this.queryResult.value;
    this.listElement !== void 0 && (NW(this.segmentPropertyMap, e, this.propertyHistograms, this.bounds.window.value), this.updateHistogramRenderings());
  }
  updateHistogramRenderings() {
    this.debouncedRender.cancel();
    const e = this.listElement;
    if (e === void 0)
      return;
    const t = this.propertyHistograms;
    if (t.length === 0) {
      e.style.display = "none";
      return;
    }
    e.style.display = "";
    const i = this.properties;
    for (let r = 0, s = i.length; r < s; ++r)
      this.updateNumericalPropertySummary(r, i[r], t[r]);
  }
  makeNumericalPropertySummary(e, t) {
    const i = document.createElement("div");
    i.classList.add("neuroglancer-segment-query-result-numerical-plot-container");
    const r = document.createElement("img");
    r.classList.add("neuroglancer-segment-query-result-numerical-plot");
    const s = new HL(r, t.dataType, () => this.getBounds(e), (f) => this.setBounds(e, f)), a = document.createElement("span");
    a.classList.add("neuroglancer-segment-query-result-numerical-plot-sort");
    const l = document.createElement("input");
    l.type = "checkbox", l.addEventListener("click", () => {
      cH(this.queryResult.value, this.setQuery, t.id);
    });
    const d = (f) => {
      const g = document.createElement("div");
      g.classList.add("neuroglancer-segment-query-result-numerical-plot-bounds"), g.classList.add(`neuroglancer-segment-query-result-numerical-plot-bounds-${f}`);
      const v = (C) => {
        const b = lH(f, C);
        return b.addEventListener("change", () => {
          if (this.bounds[f].value[e] !== void 0) {
            try {
              const L = Vc(t.dataType, b.value);
              this.setBound(f, C, e, L), this.bounds[f].changed.dispatch();
            } catch {
            }
            pg(b, this.bounds[f].value[e][C]);
          }
        }), b;
      }, y = [v(0), v(1)];
      let w;
      if (f === "range") {
        w = [document.createElement("div"), document.createElement("div"), document.createElement("div")], w[1].classList.add("neuroglancer-segment-query-result-numerical-plot-bound-constraint-spacer"), w[1].appendChild(l);
        const C = document.createElement("span");
        C.classList.add("neuroglancer-segment-query-result-numerical-plot-label"), C.appendChild(document.createTextNode(t.id)), C.appendChild(a), C.addEventListener("click", () => {
          qL(this.queryResult.value, this.setQuery, t.id);
        }), w[1].appendChild(C);
        const b = t.description;
        b && (w[1].title = b), g.appendChild(w[0]), g.appendChild(y[0]);
        const E = document.createElement("div");
        E.textContent = "≤", E.classList.add("neuroglancer-segment-query-result-numerical-plot-bound-constraint-symbol"), g.appendChild(E), g.appendChild(w[1]);
        const L = document.createElement("div");
        L.textContent = "≤", L.classList.add("neuroglancer-segment-query-result-numerical-plot-bound-constraint-symbol"), g.appendChild(L), g.appendChild(y[1]), g.appendChild(w[2]);
      } else
        g.appendChild(y[0]), g.appendChild(y[1]);
      return { container: g, spacers: w, inputs: y };
    }, u = {
      range: d("range"),
      window: d("window")
    };
    return i.appendChild(u.range.container), i.appendChild(r), i.appendChild(u.window.container), {
      property: t,
      controller: s,
      element: i,
      plotImg: r,
      boundElements: u,
      bounds: {
        window: [NaN, NaN],
        range: [NaN, NaN]
      },
      propertyHistogram: void 0,
      columnCheckbox: l,
      sortIcon: a
    };
  }
  updateNumericalPropertySummary(e, t, i) {
    const r = t.bounds.window, s = this.bounds.window.value[e], a = t.bounds.range, l = this.bounds.range.value[e], d = t.property, u = this.queryResult.value, f = Hy(u == null ? void 0 : u.query, d.id);
    if (t.columnCheckbox.checked = f, t.columnCheckbox.title = f ? "Remove column from result table" : "Add column to result table", KL(u, t.sortIcon, d.id), t.propertyHistogram === i && Mr(d.dataType, r, s) && Mr(d.dataType, a, l))
      return;
    const g = i.histogram, v = "http://www.w3.org/2000/svg", y = document.createElementNS(v, "svg");
    y.setAttribute("width", "1"), y.setAttribute("height", "1"), y.setAttribute("preserveAspectRatio", "none");
    const w = document.createElementNS(v, "rect"), C = gi(s, l[0]), b = gi(s, l[1]);
    w.setAttribute("x", `${C}`), w.setAttribute("y", "0"), w.setAttribute("width", `${b - C}`), w.setAttribute("height", "1"), w.setAttribute("fill", "#4f4f4f"), y.appendChild(w);
    const E = g.length, L = (O, B, j) => {
      const U = document.createElementNS(v, "polyline");
      let V = "", G = 0;
      for (let le = O; le < j; ++le)
        G += g[le];
      if (G === 0)
        return;
      const F = gi(s, i.window[0]), ue = gi(s, i.window[1]), ae = (le, Te) => {
        const Ue = le / (E - 2), Ye = F * (1 - Ue) + ue * Ue;
        V += ` ${Ye},${1 - Te}`;
      };
      O !== 0 && ae(O, 0);
      let Ie = 0;
      for (let le = O; le < B; ++le) {
        const Te = g[le];
        Ie += Te, ae(le, Ie / G);
      }
      return U.setAttribute("fill", "none"), U.setAttribute("stroke-width", "1px"), U.setAttribute("points", V), U.setAttribute("vector-effect", "non-scaling-stroke"), U;
    };
    {
      const O = L(0, E - 1, E);
      O !== void 0 && (O.setAttribute("stroke", "cyan"), y.appendChild(O));
    }
    if (!Mr(d.dataType, d.bounds, l)) {
      const O = Math.floor(Math.max(0, Math.min(1, gi(i.window, l[0]))) * (E - 2)), B = Math.ceil(Math.max(0, Math.min(1, gi(i.window, l[1]))) * (E - 2)), j = L(O, B, B);
      j !== void 0 && (j.setAttribute("stroke", "white"), y.appendChild(j));
    }
    const R = new XMLSerializer().serializeToString(y);
    t.plotImg.src = `data:image/svg+xml;base64,${btoa(R)}`, t.propertyHistogram = i;
    for (let O = 0; O < 2; ++O)
      r[O] = s[O], pg(t.boundElements.window.inputs[O], s[O]), a[O] = l[O], pg(t.boundElements.range.inputs[O], l[O]);
    const _ = t.boundElements.range.spacers, A = nc(s, l), I = Pu(d.dataType, s), P = gi(s, A[0]) * I, N = gi(s, A[1]) * I + (1 - I);
    _[0].style.width = `${P * 100}%`, _[2].style.width = `${(1 - N) * 100}%`;
  }
};
function uH(n, e) {
  const t = n.tags;
  if (t === void 0 || t.length === 0)
    return;
  const i = n.query, r = document.createElement("div");
  r.classList.add("neuroglancer-segment-query-result-tag-list");
  for (const s of t) {
    const a = s.tag, l = s.count, d = document.createElement("div");
    d.classList.add("neuroglancer-segment-query-result-tag");
    const u = document.createElement("span");
    u.classList.add("neuroglancer-segment-query-result-tag-name"), u.textContent = a, r.appendChild(d);
    const f = i.includeTags.includes(a), g = i.excludeTags.includes(a);
    let v;
    f ? v = "Remove tag from required set" : g ? v = "Remove tag from excluded set" : v = "Add tag to required set", u.addEventListener("click", () => {
      e(gx(i, a, true, !f && !g));
    }), u.title = v;
    const y = f || g, w = (b) => {
      const E = b ? l : n.count - l, L = document.createElement("div");
      if (L.classList.add("neuroglancer-segment-query-result-tag-toggle"), L.classList.add(`neuroglancer-segment-query-result-tag-${b ? "include" : "exclude"}`), d.appendChild(L), !y && E === 0)
        return;
      const R = b ? f : g;
      L.appendChild(new tr({
        get value() {
          return R;
        },
        set value(_) {
          e(gx(i, a, b, _));
        },
        changed: OE
      }, {
        text: b ? "+" : "-",
        enableTitle: `Add tag to ${b ? "required" : "exclusion"} set`,
        disableTitle: `Remove tag from ${b ? "required" : "exclusion"} set`,
        backgroundScheme: "dark"
      }).element);
    };
    w(true), w(false), d.appendChild(u);
    const C = document.createElement("span");
    C.classList.add("neuroglancer-segment-query-result-tag-count"), y || (C.textContent = l.toString()), d.appendChild(C);
  }
  return r;
}
var hH = class extends Kr {
  constructor(e) {
    super(), this.layer = e;
    const t = this.element;
    t.classList.add("neuroglancer-segment-display-tab"), t.appendChild(this.registerDisposer(new ur(e.displayState.segmentationGroupState.value.graph, (d, u, f) => {
      if (d === void 0)
        return;
      const g = document.createElement("div");
      g.className = "neuroglancer-segmentation-toolbox", g.appendChild(tg(f, e, {
        toolJson: eS,
        label: "Merge",
        title: "Merge segments"
      })), g.appendChild(tg(f, e, {
        toolJson: tS,
        label: "Split",
        title: "Split segments"
      })), u.appendChild(g);
    })).element);
    const i = document.createElement("div");
    i.className = "neuroglancer-segmentation-toolbox", i.appendChild(tg(this, e, {
      toolJson: nS,
      label: "Select",
      title: "Select/Deselect segments"
    })), t.appendChild(i);
    const r = document.createElement("input");
    r.classList.add("neuroglancer-segment-list-query"), r.addEventListener("focus", () => {
      r.select();
    });
    const s = this.registerDisposer(new Wi(r, Mx));
    s.allShortcutsAreGlobal = true;
    const a = this.layer.displayState.segmentQuery, l = this.registerCancellable(lt(() => {
      a.value = r.value;
    }, 200));
    r.autocomplete = "off", r.title = Mx.describe(), r.spellcheck = false, r.placeholder = "Enter ID, name prefix or /regexp", this.registerDisposer(Vr((d) => {
      r.value = d;
    }, a)), this.registerDisposer(Vr((d) => {
      Date.now() - d < 100 && (setTimeout(() => {
        r.focus();
      }, 0), this.layer.segmentQueryFocusTime.value = Number.NEGATIVE_INFINITY);
    }, this.layer.segmentQueryFocusTime)), t.appendChild(r), t.appendChild(this.registerDisposer(new ur(
      // segmentLabelMap is guaranteed to change if segmentationGroupState changes.
      e.displayState.segmentPropertyMap,
      (d, u, f) => {
        const g = (le) => {
          r.focus(), r.select();
          const Te = _W(d, le);
          document.execCommand("insertText", false, Te), a.value = Te, r.select();
        }, v = f.registerDisposer(new aH(a, d, e.displayState, u)), y = e.displayState.segmentationGroupState.value, w = document.createElement("ul");
        w.classList.add("neuroglancer-segment-query-errors"), u.appendChild(w);
        const C = document.createElement("div");
        C.classList.add("neuroglancer-segment-query-result-statistics");
        const b = document.createElement("span"), E = document.createElement("input");
        E.type = "checkbox", E.checked = true, E.title = "Deselect all segment IDs", E.addEventListener("change", () => {
          y.visibleSegments.clear();
        });
        const L = dr({
          title: "Copy visible segment IDs",
          onClick: () => {
            const le = De(y.visibleSegments, (Te) => Te.clone());
            le.sort(re.compare), oi(le.join(", "));
          }
        }), R = document.createElement("span");
        b.appendChild(L), b.appendChild(E), b.appendChild(R);
        const _ = document.createElement("span"), A = document.createElement("input"), I = dr({
          onClick: () => {
            l(), l.flush(), v.debouncedUpdate.flush();
            const le = v.queryResult.value;
            if (le === void 0)
              return;
            const Te = new Array(le.count);
            yu(d, le, (Ue, Ye) => {
              Te[Ye] = Ue.toString();
            }), oi(Te.join(", "));
          }
        });
        A.type = "checkbox";
        const P = () => {
          l(), l.flush(), v.debouncedUpdate.flush();
          const le = v.queryResult.value;
          if (le === void 0)
            return;
          const Te = y.visibleSegments, Ue = v.selectedMatches, Ye = Ue !== le.count;
          if (Ye && le.count - Ue > oH) {
            if (!U)
              return U = true, N.textContent = `Confirm: show ${le.count - Ue} segments?`, false;
            U = false, j();
          }
          return yu(d, le, (Ze) => {
            Te.set(Ze, Ye);
          }), true;
        };
        A.addEventListener("click", (le) => {
          P() || le.preventDefault();
        });
        const N = document.createElement("span");
        _.appendChild(I), _.appendChild(A), _.appendChild(N), b.classList.add("neuroglancer-segment-list-status"), _.classList.add("neuroglancer-segment-list-status"), u.appendChild(C);
        const O = document.createElement("div");
        O.classList.add("neuroglancer-segment-query-result-statistics-separator"), u.appendChild(O), u.appendChild(_), u.appendChild(b);
        let B = -1;
        const j = () => {
          const le = y.visibleSegments.size;
          B !== le && (B = le, R.textContent = `${le} visible in total`, E.checked = le > 0, E.style.visibility = le ? "visible" : "hidden", L.style.visibility = le ? "visible" : "hidden"), N.textContent = v.statusText.value;
          const Te = v.numMatches, Ue = v.selectedMatches;
          I.style.visibility = Te ? "visible" : "hidden", I.title = `Copy ${Te} segment ID(s)`, A.style.visibility = Te ? "visible" : "hidden", Ue === 0 ? (A.checked = false, A.indeterminate = false, A.title = `Show ${Te} segment ID(s)`) : Ue === Te ? (A.checked = true, A.indeterminate = false, A.title = `Hide ${Ue} segment ID(s)`) : (A.checked = true, A.indeterminate = true, A.title = `Show ${Te - Ue} segment ID(s)`);
        };
        j(), v.statusText.changed.add(j), f.registerDisposer(y.visibleSegments.changed.add(j));
        let U = false;
        f.registerEventListener(r, "input", () => {
          l(), U && (U = false, j());
        }), f.registerDisposer(be(r, "cancel", () => {
          r.focus(), r.select(), document.execCommand("delete"), r.blur(), r.value = "", a.value = "", U = false, j();
        })), f.registerDisposer(be(r, "toggle-listed", P)), f.registerDisposer(be(r, "hide-all", () => {
          y.visibleSegments.clear();
        })), f.registerDisposer(be(r, "hide-listed", () => {
          l(), l.flush(), v.debouncedUpdate.flush();
          const le = y.visibleSegments;
          if (a.value === "")
            le.clear();
          else {
            const Te = v.queryResult.value;
            if (Te === void 0)
              return;
            yu(d, Te, (Ue) => {
              le.delete(Ue);
            });
          }
        }));
        const V = f.registerDisposer(new Py({ source: v, horizontalScroll: true })), G = f.registerCancellable(Ct(() => {
          v.updateRenderedItems(V);
        })), F = this.layer.displayState;
        f.registerDisposer(F.segmentSelectionState.changed.add(G)), f.registerDisposer(y.visibleSegments.changed.add(G)), f.registerDisposer(F.segmentColorHash.changed.add(G)), f.registerDisposer(F.segmentStatedColors.changed.add(G)), f.registerDisposer(F.segmentDefaultColor.changed.add(G)), V.element.classList.add("neuroglancer-segment-list"), f.registerDisposer(e.bindSegmentListWidth(V.element)), f.registerDisposer(new qr(V.element, Yh()));
        const ue = f.registerDisposer(new dH(d, v.queryResult, g));
        {
          const le = ue.listElement;
          le !== void 0 && C.appendChild(le);
        }
        let ae;
        const Ie = (le) => {
          const Te = le == null ? void 0 : le.errors;
          if (it(w), Te !== void 0)
            for (const Ue of Te) {
              const Ye = document.createElement("li");
              Ye.textContent = Ue.message, w.appendChild(Ye);
            }
        };
        Vr((le) => {
          if (v.segmentWidgetFactory = new Hk(v.segmentationDisplayState, v.parentElement, (Ue) => Hy(le == null ? void 0 : le.query, Ue.id)), V.scrollToTop(), it(V.header), d !== void 0) {
            const Ue = v.segmentWidgetFactory.getHeader();
            Ue.container.classList.add("neuroglancer-segment-list-header");
            for (const Ye of Ue.propertyLabels) {
              const Ze = Ye.label, rt = Ye.sortIcon, Xe = Ye.id;
              Ze.addEventListener("click", () => {
                qL(v.queryResult.value, g, Xe);
              }), KL(le, rt, Xe);
            }
            V.header.appendChild(Ue.container);
          }
          if (Ie(le), O.style.display = "none", ae == null ? void 0 : ae.remove(), le === void 0)
            return;
          let Te = le.query;
          Te.errors !== void 0 || Te.ids !== void 0 || (ae = uH(le, g), ae !== void 0 && C.appendChild(ae), (ue.properties.length > 0 || ae !== void 0) && (O.style.display = ""));
        }, v.queryResult), u.appendChild(V.element);
      }
    )).element);
  }
};
function iS(n = {}) {
  return Tt(RZr({ text: "?" }, n));
}
function ZL(n, e, t, i) {
  const r = document.createElement("label");
  r.classList.add("neuroglancer-layer-control-container");
  const s = document.createElement("div");
  s.classList.add("neuroglancer-layer-control-label-container");
  const a = document.createElement("div");
  a.classList.add("neuroglancer-layer-control-label"), s.appendChild(a);
  const l = document.createElement("div");
  l.classList.add("neuroglancer-layer-control-label-text-container"), l.appendChild(document.createTextNode(t.label)), a.appendChild(l), t.title && (a.title = t.title), r.appendChild(s);
  var d = t.makeControl(e, n, { labelContainer: s, labelTextContainer: l, display: e.manager.root.display, visibility: i });
  const u = d.control, f = d.controlElement;
  return f.classList.add("neuroglancer-layer-control-control"), r.appendChild(f), { controlContainer: r, label: a, labelContainer: s, labelTextContainer: l, control: u };
}
var XL = class extends Uo {
  constructor(e, t) {
    super(e), this.options = t;
  }
  activate(e) {
    const t = this.options, i = this.layer, r = t.isValid;
    if (r !== void 0 && !r(i).value)
      return;
    var s = tf(e);
    const a = s.header, l = s.body;
    var d = ZL(e, i, t, new Kt(Kt.VISIBLE));
    const u = d.controlContainer, f = d.control, g = d.labelContainer;
    a.appendChild(g), l.appendChild(u), t.activateTool(e, f);
  }
  get description() {
    var e;
    const t = this.options;
    return (e = t.toolDescription) !== null && e !== void 0 ? e : t.label;
  }
  toJSON() {
    return this.options.toolJson;
  }
};
function Nx(n, e, t, i) {
  var r = ZL(n, e, t, i);
  const s = r.controlContainer, a = r.label;
  return s.classList.add("neuroglancer-layer-options-control-container"), a.prepend(n.registerDisposer(new uI(e, t.toolJson)).element), s;
}
function rS(n, e, t, i) {
  const r = i.isValid;
  return r === void 0 ? Nx(n, e, i, t) : n.registerDisposer(new ur(r(e), (s, a, l) => {
    s && a.appendChild(Nx(l, e, i, t));
  }, t)).element;
}
function QL(n, e) {
  const t = e.toolJson, i = typeof t == "string" ? t : t.type;
  Dc(n, i, (r) => new XL(r, e));
}
var _x = class extends Z {
  constructor(e) {
    super(), this.group = e, this.element = document.createElement("div"), this.topRow = document.createElement("div"), this.label = document.createElement("label"), this.selectElement = document.createElement("select"), this.linkedLayers = document.createElement("div"), this.unlinkButton = document.createElement("button");
    const t = this.element, i = this.label, r = this.topRow, s = this.selectElement, a = this.linkedLayers, l = this.unlinkButton;
    r.appendChild(i), r.appendChild(s), r.appendChild(l), l.textContent = "Unlink", l.addEventListener("click", () => {
      this.group.isolate();
    }), t.appendChild(r), t.appendChild(a), this.updateView();
    const d = lt(() => this.updateView(), 0);
    this.registerEventListener(s, "change", () => {
      this.updateModel(), d();
    }), this.registerDisposer(this.group.changed.add(d)), this.registerDisposer(this.group.linkedLayersChanged.add(d)), this.registerDisposer(this.group.layerManager.layersChanged.add(d));
  }
  updateModel() {
    const e = this.selectElement.value;
    e === "" && this.group.root.value !== this.group.layer ? this.group.isolate() : this.group.linkByName(e);
  }
  updateView() {
    var e;
    const t = this.selectElement, i = this.group, r = i.predicate;
    it(t);
    const s = this.group.rootGroup.linkedLayers.size !== 0;
    this.unlinkButton.style.display = s ? "" : "none";
    const a = this.linkedLayers, l = i.linkedLayers.size !== 0;
    if (a.style.display = l ? "" : "none", this.unlinkButton.textContent = l ? "Unlink all" : "Unlink", l) {
      this.element.style.display = "", t.style.display = "none", it(a);
      for (const d of i.linkedLayers) {
        const u = document.createElement("div");
        u.classList.add("neuroglancer-linked-layer-widget-layer");
        const f = Cy({
          title: "Unlink layer",
          onClick: () => {
            this.group.getGroup(d).isolate();
          }
        });
        u.appendChild(f), u.appendChild(document.createTextNode(d.managedLayer.name)), a.appendChild(u);
      }
    } else {
      t.style.display = "";
      const d = document.createElement("option");
      t.appendChild(d);
      let u = 0;
      for (const f of this.group.layerManager.managedLayers) {
        const g = f.layer;
        if (g !== null && g !== i.layer && r(g)) {
          ++u;
          const v = document.createElement("option"), y = f.name;
          v.textContent = y, v.value = y, t.appendChild(v);
        }
      }
      t.value = (e = i.toJSON()) !== null && e !== void 0 ? e : "", this.element.style.display = u === 0 ? "none" : "";
    }
  }
};
var fH = "data:image/svg+xml;base64,PHN2ZyByb2xlPSJpbWciIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjI0IiBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIGFyaWEtbGFiZWxsZWRieT0ibWF4aW1pc2VJY29uVGl0bGUiPgogICAgPHRpdGxlIGlkPSJtYXhpbWlzZUljb25UaXRsZSI+TWF4aW1pc2UgVmlldzwvdGl0bGU+ICAgIAogICAgPHBvbHlsaW5lIHBvaW50cz0iMjEgMTYgMjEgMjEgMTYgMjEiLz4KICAgIDxwb2x5bGluZSBwb2ludHM9IjggMjEgMyAyMSAzIDE2Ii8+CiAgICA8cG9seWxpbmUgcG9pbnRzPSIxNiAzIDIxIDMgMjEgOCIvPgogICAgPHBvbHlsaW5lIHBvaW50cz0iMyA4IDMgMyA4IDMiLz4KPC9zdmc+";
function sS(n = {}) {
  return Tt(RZr({ svg: fH }, n));
}
(function(n, e) {
  (function(t) {
    t(sl());
  })(function(t) {
    var i = "CodeMirror-lint-markers", r = "CodeMirror-lint-line-";
    function s(P, N, O) {
      var B = document.createElement("div");
      B.className = "CodeMirror-lint-tooltip cm-s-" + P.options.theme, B.appendChild(O.cloneNode(true)), P.state.lint.options.selfContain ? P.getWrapperElement().appendChild(B) : document.body.appendChild(B);
      function j(U) {
        if (!B.parentNode)
          return t.off(document, "mousemove", j);
        var V = Math.max(0, U.clientY - B.offsetHeight - 5), G = Math.max(0, Math.min(U.clientX + 5, B.ownerDocument.defaultView.innerWidth - B.offsetWidth));
        B.style.top = V + "px", B.style.left = G + "px";
      }
      return t.on(document, "mousemove", j), j(N), B.style.opacity != null && (B.style.opacity = 1), B;
    }
    function a(P) {
      P.parentNode && P.parentNode.removeChild(P);
    }
    function l(P) {
      P.parentNode && (P.style.opacity == null && a(P), P.style.opacity = 0, setTimeout(function() {
        a(P);
      }, 600));
    }
    function d(P, N, O, B) {
      var j = s(P, N, O);
      function U() {
        t.off(B, "mouseout", U), j && (l(j), j = null);
      }
      var V = setInterval(function() {
        if (j)
          for (var G = B; ; G = G.parentNode) {
            if (G && G.nodeType == 11 && (G = G.host), G == document.body)
              return;
            if (!G) {
              U();
              break;
            }
          }
        if (!j)
          return clearInterval(V);
      }, 400);
      t.on(B, "mouseout", U);
    }
    function u(P, N, O) {
      this.marked = [], N instanceof Function && (N = { getAnnotations: N }), (!N || N === true) && (N = {}), this.options = {}, this.linterOptions = N.options || {};
      for (var B in f)
        this.options[B] = f[B];
      for (var B in N)
        f.hasOwnProperty(B) ? N[B] != null && (this.options[B] = N[B]) : N.options || (this.linterOptions[B] = N[B]);
      this.timeout = null, this.hasGutter = O, this.onMouseOver = function(j) {
        I(P, j);
      }, this.waitingFor = 0;
    }
    var f = {
      highlightLines: false,
      tooltips: true,
      delay: 500,
      lintOnChange: true,
      getAnnotations: null,
      async: false,
      selfContain: null,
      formatAnnotation: null,
      onUpdateLinting: null
    };
    function g(P) {
      var N = P.state.lint;
      N.hasGutter && P.clearGutter(i), N.options.highlightLines && v(P);
      for (var O = 0; O < N.marked.length; ++O)
        N.marked[O].clear();
      N.marked.length = 0;
    }
    function v(P) {
      P.eachLine(function(N) {
        var O = N.wrapClass && /\bCodeMirror-lint-line-\w+\b/.exec(N.wrapClass);
        O && P.removeLineClass(N, "wrap", O[0]);
      });
    }
    function y(P, N, O, B, j) {
      var U = document.createElement("div"), V = U;
      return U.className = "CodeMirror-lint-marker CodeMirror-lint-marker-" + O, B && (V = U.appendChild(document.createElement("div")), V.className = "CodeMirror-lint-marker CodeMirror-lint-marker-multiple"), j != false && t.on(V, "mouseover", function(G) {
        d(P, G, N, V);
      }), U;
    }
    function w(P, N) {
      return P == "error" ? P : N;
    }
    function C(P) {
      for (var N = [], O = 0; O < P.length; ++O) {
        var B = P[O], j = B.from.line;
        (N[j] || (N[j] = [])).push(B);
      }
      return N;
    }
    function b(P) {
      var N = P.severity;
      N || (N = "error");
      var O = document.createElement("div");
      return O.className = "CodeMirror-lint-message CodeMirror-lint-message-" + N, typeof P.messageHTML < "u" ? O.innerHTML = P.messageHTML : O.appendChild(document.createTextNode(P.message)), O;
    }
    function E(P, N) {
      var O = P.state.lint, B = ++O.waitingFor;
      function j() {
        B = -1, P.off("change", j);
      }
      P.on("change", j), N(P.getValue(), function(U, V) {
        P.off("change", j), O.waitingFor == B && (V && U instanceof t && (U = V), P.operation(function() {
          R(P, U);
        }));
      }, O.linterOptions, P);
    }
    function L(P) {
      var N = P.state.lint;
      if (N) {
        var O = N.options, B = O.getAnnotations || P.getHelper(t.Pos(0, 0), "lint");
        if (B)
          if (O.async || B.async)
            E(P, B);
          else {
            var j = B(P.getValue(), N.linterOptions, P);
            if (!j)
              return;
            j.then ? j.then(function(U) {
              P.operation(function() {
                R(P, U);
              });
            }) : P.operation(function() {
              R(P, j);
            });
          }
      }
    }
    function R(P, N) {
      var O = P.state.lint;
      if (O) {
        var B = O.options;
        g(P);
        for (var j = C(N), U = 0; U < j.length; ++U) {
          var V = j[U];
          if (V) {
            for (var G = null, F = O.hasGutter && document.createDocumentFragment(), ue = 0; ue < V.length; ++ue) {
              var ae = V[ue], Ie = ae.severity;
              Ie || (Ie = "error"), G = w(G, Ie), B.formatAnnotation && (ae = B.formatAnnotation(ae)), O.hasGutter && F.appendChild(b(ae)), ae.to && O.marked.push(P.markText(ae.from, ae.to, {
                className: "CodeMirror-lint-mark CodeMirror-lint-mark-" + Ie,
                __annotation: ae
              }));
            }
            O.hasGutter && P.setGutterMarker(U, i, y(
              P,
              F,
              G,
              V.length > 1,
              B.tooltips
            )), B.highlightLines && P.addLineClass(U, "wrap", r + G);
          }
        }
        B.onUpdateLinting && B.onUpdateLinting(N, j, P);
      }
    }
    function _(P) {
      var N = P.state.lint;
      N && (clearTimeout(N.timeout), N.timeout = setTimeout(function() {
        L(P);
      }, N.options.delay));
    }
    function A(P, N, O) {
      for (var B = O.target || O.srcElement, j = document.createDocumentFragment(), U = 0; U < N.length; U++) {
        var V = N[U];
        j.appendChild(b(V));
      }
      d(P, O, j, B);
    }
    function I(P, N) {
      var O = N.target || N.srcElement;
      if (/\bCodeMirror-lint-mark-/.test(O.className)) {
        for (var B = O.getBoundingClientRect(), j = (B.left + B.right) / 2, U = (B.top + B.bottom) / 2, V = P.findMarksAt(P.coordsChar({ left: j, top: U }, "client")), G = [], F = 0; F < V.length; ++F) {
          var ue = V[F].__annotation;
          ue && G.push(ue);
        }
        G.length && A(P, G, N);
      }
    }
    t.defineOption("lint", false, function(P, N, O) {
      if (O && O != t.Init && (g(P), P.state.lint.options.lintOnChange !== false && P.off("change", _), t.off(P.getWrapperElement(), "mouseover", P.state.lint.onMouseOver), clearTimeout(P.state.lint.timeout), delete P.state.lint), N) {
        for (var B = P.getOption("gutters"), j = false, U = 0; U < B.length; ++U)
          B[U] == i && (j = true);
        var V = P.state.lint = new u(P, N, j);
        V.options.lintOnChange && P.on("change", _), V.options.tooltips != false && V.options.tooltips != "gutter" && t.on(P.getWrapperElement(), "mouseover", V.onMouseOver), L(P);
      }
    }), t.defineExtension("performLint", function() {
      L(this);
    });
  });
})();
var pH = function(n) {
  n.defineMode("glsl", function(s, a) {
    var l = s.indentUnit, d = a.keywords || e(t), u = a.builtins || e(i), f = a.blockKeywords || e("case do else for if switch while struct"), g = a.atoms || e("null"), v = a.hooks || {}, y = a.multiLineStrings, w = /[+\-*&%=<>!?|\/]/, C;
    function b(I, P) {
      var N = I.next();
      if (v[N]) {
        var O = v[N](I, P);
        if (O !== false)
          return O;
      }
      if (N == '"' || N == "'")
        return P.tokenize = E(N), P.tokenize(I, P);
      if (/[\[\]{}\(\),;\:\.]/.test(N))
        return C = N, "bracket";
      if (/\d/.test(N))
        return I.eatWhile(/[\w\.]/), "number";
      if (N == "/") {
        if (I.eat("*"))
          return P.tokenize = L, L(I, P);
        if (I.eat("/"))
          return I.skipToEnd(), "comment";
      }
      if (N == "#")
        return I.eatWhile(/[\S]+/), I.eatWhile(/[\s]+/), I.eatWhile(/[\S]+/), I.eatWhile(/[\s]+/), "comment";
      if (w.test(N))
        return I.eatWhile(w), "operator";
      I.eatWhile(/[\w\$_]/);
      var B = I.current();
      return d.propertyIsEnumerable(B) ? (f.propertyIsEnumerable(B) && (C = "newstatement"), "keyword") : u.propertyIsEnumerable(B) ? "builtin" : g.propertyIsEnumerable(B) ? "atom" : "word";
    }
    function E(I) {
      return function(P, N) {
        for (var O = false, B, j = false; (B = P.next()) != null; ) {
          if (B == I && !O) {
            j = true;
            break;
          }
          O = !O && B == "\\";
        }
        return (j || !(O || y)) && (N.tokenize = b), "string";
      };
    }
    function L(I, P) {
      for (var N = false, O; O = I.next(); ) {
        if (O == "/" && N) {
          P.tokenize = b;
          break;
        }
        N = O == "*";
      }
      return "comment";
    }
    function R(I, P, N, O, B) {
      this.indented = I, this.column = P, this.type = N, this.align = O, this.prev = B;
    }
    function _(I, P, N) {
      return I.context = new R(I.indented, P, N, null, I.context);
    }
    function A(I) {
      var P = I.context.type;
      return (P == ")" || P == "]" || P == "}") && (I.indented = I.context.indented), I.context = I.context.prev;
    }
    return {
      startState: function(I) {
        return {
          tokenize: null,
          context: new R((I || 0) - l, 0, "top", false),
          indented: 0,
          startOfLine: true
        };
      },
      token: function(I, P) {
        var N = P.context;
        if (I.sol() && (N.align == null && (N.align = false), P.indented = I.indentation(), P.startOfLine = true), I.eatSpace())
          return null;
        C = null;
        var O = (P.tokenize || b)(I, P);
        if (O == "comment" || O == "meta")
          return O;
        if (N.align == null && (N.align = true), (C == ";" || C == ":") && N.type == "statement")
          A(P);
        else if (C == "{")
          _(P, I.column(), "}");
        else if (C == "[")
          _(P, I.column(), "]");
        else if (C == "(")
          _(P, I.column(), ")");
        else if (C == "}") {
          for (; N.type == "statement"; )
            N = A(P);
          for (N.type == "}" && (N = A(P)); N.type == "statement"; )
            N = A(P);
        } else
          C == N.type ? A(P) : (N.type == "}" || N.type == "top" || N.type == "statement" && C == "newstatement") && _(P, I.column(), "statement");
        return P.startOfLine = false, O;
      },
      indent: function(I, P) {
        if (I.tokenize != b && I.tokenize != null)
          return 0;
        var N = P && P.charAt(0), O = I.context, B = N == O.type;
        return O.type == "statement" ? O.indented + (N == "{" ? 0 : l) : O.align ? O.column + (B ? 0 : 1) : O.indented + (B ? 0 : l);
      },
      electricChars: "{}"
    };
  });
  function e(s) {
    for (var a = {}, l = s.split(" "), d = 0; d < l.length; ++d)
      a[l[d]] = true;
    return a;
  }
  var t = "attribute const uniform varying break continue do for while if else in out inout float int void bool true false lowp mediump highp precision invariant discard return mat2 mat3 mat4 vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 sampler2D samplerCube struct gl_FragCoord gl_FragColor", i = "radians degrees sin cos tan asin acos atan pow exp log exp2 log2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not dFdx dFdy fwidth texture2D texture2DProj texture2DLod texture2DProjLod textureCube textureCubeLod require export";
  function r(s, a) {
    return a.startOfLine ? (s.skipToEnd(), "meta") : false;
  }
  (function() {
    n.defineMIME("text/x-glsl", {
      name: "glsl",
      keywords: e(t),
      builtins: e(i),
      blockKeywords: e("case do else for if switch while struct"),
      atoms: e("null"),
      hooks: { "#": r }
    });
  })();
};
var gH = Gs(pH);
gH(ms);
var mH = 500;
var aS = class extends Z {
  constructor(e) {
    super(), this.state = e, this.changingValue = false, this.debouncedValueUpdater = lt(() => {
      this.changingValue = true;
      try {
        this.state.fragmentMain.value = this.textEditor.getValue();
      } finally {
        this.changingValue = false;
      }
    }, mH), this.textEditor = ms((r) => {
    }, {
      value: this.state.fragmentMain.value,
      mode: "glsl",
      gutters: ["CodeMirror-lint-markers"]
    }), this.textEditor.on("change", () => {
      this.setValidState(void 0), this.debouncedValueUpdater();
    }), this.registerDisposer(this.state.fragmentMain.changed.add(() => {
      this.changingValue || this.textEditor.setValue(this.state.fragmentMain.value);
    })), this.element.classList.add("neuroglancer-shader-code-widget"), this.registerDisposer(this.state.shaderError.changed.add(() => {
      this.updateErrorState();
    }));
    const t = this.state.shaderControlState;
    t !== void 0 && this.registerDisposer(t.parseErrors.changed.add(() => {
      this.updateErrorState();
    })), this.updateErrorState();
    const i = new IntersectionObserver((r) => {
      r.some((s) => s.isIntersecting) && this.textEditor.refresh();
    }, {
      root: document.body
    });
    i.observe(this.element), this.registerDisposer(() => i.disconnect());
  }
  get element() {
    return this.textEditor.getWrapperElement();
  }
  updateErrorState() {
    var e = this.state.sourceStringNumber;
    const t = e === void 0 ? 1 : e, i = this.state.shaderError.value;
    let r;
    const s = this.state.shaderControlState;
    s !== void 0 ? r = s.parseErrors.value : r = [], i === void 0 && r.length === 0 ? this.setValidState(void 0) : i != null || r.length !== 0 ? (this.textEditor.setOption("lint", {
      getAnnotations: () => {
        const a = [];
        for (const l of r)
          a.push({
            message: l.message,
            severity: "error",
            from: ms.Pos(l.line)
          });
        if (i != null)
          if (i.name === "ShaderCompilationError")
            for (const l of i.errorMessages)
              a.push({
                message: l.message,
                severity: "error",
                from: ms.Pos(l.file === t && l.line || 0)
              });
          else
            i.name === "ShaderLinkError" ? a.push({
              message: i.log,
              severity: "error",
              from: ms.Pos(0)
            }) : a.push({
              message: i.message,
              severity: "error",
              from: ms.Pos(0)
            });
        return a;
      }
    }), this.setValidState(false)) : (this.textEditor.setOption("lint", void 0), this.setValidState(true));
  }
  setValidState(e) {
    let t = this.element;
    t.classList.remove("invalid-input"), t.classList.remove("valid-input"), e === true ? t.classList.add("valid-input") : e === false && t.classList.add("invalid-input");
  }
  disposed() {
    this.debouncedValueUpdater.flush(), this.debouncedValueUpdater = void 0, Ft(this.element), this.textEditor = void 0, super.disposed();
  }
};
var vH = vt.fromObject({
  "at:shift+wheel": { action: "adjust-contrast-via-wheel" },
  "at:shift+mousedown0": { action: "adjust-via-drag" },
  "at:shift+mousedown2": { action: "invert-range" }
});
function yH(n) {
  return {
    makeControl: (e, t, i) => {
      var r = n(e);
      const s = r.watchableValue, a = r.channelCoordinateSpaceCombiner, l = r.dataType, d = r.defaultChannel, u = r.histogramSpecifications, f = r.legendShaderOptions, g = r.histogramIndex;
      if (a !== void 0 && d.length !== 0) {
        const y = t.registerDisposer(new ea(a.combined)), w = t.registerDisposer(new uf(y, a, { copyButton: false }));
        t.registerDisposer(y.changed.add(() => {
          const b = y.value, E = De(b, (R) => Math.floor(R)), L = s.value;
          Fe(L.channel, E) || (s.value = RZr(RZr({}, s.value), { channel: E }));
        }));
        const C = () => {
          const b = y.value, E = s.value;
          Fe(b, E.channel) || (b.set(E.channel), y.changed.dispatch());
        };
        C(), t.registerDisposer(s.changed.add(C)), i.labelContainer.appendChild(w.element);
      }
      const v = t.registerDisposer(new K4(i.visibility, i.display, l, s, u, g, d.length === 0 ? f : void 0));
      return { control: v, controlElement: v.element };
    },
    activateTool: (e, t) => {
      e.bindInputEventMap(vH), e.bindAction("adjust-contrast-via-wheel", (i) => {
        i.stopPropagation();
        const r = Ju(i.detail);
        Y4(t.dataType, t.trackable, r);
      }), e.bindAction("adjust-via-drag", (i) => {
        i.stopPropagation();
        let r = i.detail.screenX, s = i.detail.screenY, a = t.trackable.value.range, l = a, d = r, u = s;
        zi(i.detail, (f) => {
          const g = t.trackable.value.range, v = f.screenX, y = f.screenY;
          Mr(t.dataType, g, l) || (a = g, r = d, s = u), q4(t.dataType, t.trackable, a, (y - s) * 2 / screen.height, (v - r) * 4 / screen.width), l = t.trackable.value.range, d = v, u = y;
        });
      }), e.bindAction("invert-range", (i) => {
        i.stopPropagation(), JL(t.trackable);
      });
    }
  };
}
function cc(n) {
  return {
    makeControl: (e, t) => {
      const i = n(e), r = t.registerDisposer(new Rs(i));
      return { control: r, controlElement: r.element };
    },
    activateTool: (e, t) => {
      t.model.value = !t.model.value;
    }
  };
}
var SH = vt.fromObject({
  "at:shift+wheel": { action: "adjust-hue-via-wheel" }
});
function eD(n) {
  return {
    makeControl: (e, t) => {
      const i = n(e), r = t.registerDisposer(new By(i));
      return { control: r, controlElement: r.element };
    },
    activateTool: (e, t) => {
      e.bindInputEventMap(SH), e.bindAction("adjust-via-wheel", (i) => {
        i.stopPropagation(), i.preventDefault(), t.adjustHueViaWheel(i.detail);
      });
    }
  };
}
var bH = class extends Z {
  constructor(e, { min: t = 0, max: i = 1, step: r = 0.01 } = {}) {
    super(), this.value = e, this.element = document.createElement("label"), this.inputElement = document.createElement("input"), this.numericInputElement = document.createElement("input");
    let s = this.element, a = this.inputElement, l = this.numericInputElement;
    s.className = "range-slider";
    const d = (f) => {
      f.min = "" + t, f.max = "" + i, f.step = "" + r, f.valueAsNumber = this.value.value, this.registerEventListener(f, "change", () => this.inputValueChanged(f)), this.registerEventListener(f, "input", () => this.inputValueChanged(f)), this.registerEventListener(f, "wheel", (g) => {
        this.adjustViaWheel(f, g);
      });
    };
    a.type = "range", d(a), l.type = "number";
    const u = Math.max(t.toString().length, i.toString().length, Math.min(i, t + r).toString().length, Math.max(t, i - r).toString().length);
    l.style.width = u + 2 + "ch", d(l), s.appendChild(a), s.appendChild(l), e.changed.add(() => {
      this.inputElement.valueAsNumber = this.value.value, this.numericInputElement.valueAsNumber = this.value.value;
    });
  }
  inputValueChanged(e) {
    this.value.value = e.valueAsNumber;
  }
  adjustViaWheel(e, t) {
    const i = this.inputElement;
    let r = t.deltaY;
    r > 0 ? (i.stepUp(), this.inputValueChanged(e)) : r < 0 && (i.stepDown(), this.inputValueChanged(e));
  }
  disposed() {
    Ft(this.element), super.disposed();
  }
};
var CH = vt.fromObject({
  "at:shift+wheel": { action: "adjust-via-wheel" }
});
function vs(n) {
  return {
    makeControl: (e, t) => {
      var i = n(e);
      const r = i.value, s = i.options, a = t.registerDisposer(new bH(r, s));
      return { control: a, controlElement: a.element };
    },
    activateTool: (e, t) => {
      e.bindInputEventMap(CH), e.bindAction("adjust-via-wheel", (i) => {
        i.stopPropagation(), i.preventDefault(), t.adjustViaWheel(t.inputElement, i.detail);
      });
    }
  };
}
function Ox(n, e) {
  const t = n.shaderControlState, i = t.state.get(e);
  if (i === void 0)
    return;
  const r = i.control;
  switch (r.type) {
    case "slider":
      return vs(() => ({
        value: i.trackable,
        options: { min: r.min, max: r.max, step: r.step }
      }));
    case "color":
      return eD(() => i.trackable);
    case "checkbox":
      return cc(() => i.trackable);
    case "invlerp": {
      let a = 0;
      for (const l of t.state) {
        var s = ce(l, 2);
        const d = s[0], u = s[1].control.type;
        if (d === e)
          break;
        u === "invlerp" && ++a;
      }
      return yH(() => ({
        dataType: r.dataType,
        defaultChannel: r.default.channel,
        watchableValue: i.trackable,
        channelCoordinateSpaceCombiner: t.channelCoordinateSpaceCombiner,
        histogramSpecifications: t.histogramSpecifications,
        histogramIndex: a,
        legendShaderOptions: n.legendShaderOptions
      }));
    }
  }
}
function tD(n, e, t) {
  return {
    label: t,
    toolJson: wH(t, e),
    makeControl: (i, r, s) => {
      const a = n(i);
      return Ox(a, t).makeControl(i, r, s);
    },
    activateTool: (i, r) => {
      const s = n(i.tool.layer);
      return Ox(s, t).activateTool(i, r);
    }
  };
}
var oS = class extends Kr {
  constructor(e, t, i, r = {}) {
    super(r.visibility), this.state = e, this.display = t, this.layer = i, this.options = r, this.controlDisposer = void 0;
    var s = r.toolId;
    const a = s === void 0 ? nD : s;
    this.toolId = a;
    const l = this.element;
    l.style.display = "contents";
    const d = e.controls;
    this.registerDisposer(d.changed.add(this.registerCancellable(lt(() => this.updateControls(), 0)))), this.updateControls();
  }
  updateControls() {
    const e = this.element;
    this.controlDisposer !== void 0 && (this.controlDisposer.dispose(), it(e));
    const t = this.controlDisposer = new Z(), i = () => ({
      shaderControlState: this.state,
      legendShaderOptions: this.options.legendShaderOptions
    });
    for (const r of this.state.state.keys())
      e.appendChild(rS(t, this.layer, this.visibility, tD(i, this.toolId, r)));
  }
  disposed() {
    var e;
    (e = this.controlDisposer) === null || e === void 0 || e.dispose(), super.disposed();
  }
};
var nD = "shaderControl";
var iD = "control";
function wH(n, e) {
  return { type: e, [iD]: n };
}
var xH = class extends XL {
  constructor(e, t, i, r) {
    super(e, tD(() => t, i, r)), this.layerShaderControls = t, this.control = r, this.registerDisposer(t.shaderControlState.controls.changed.add(this.registerCancellable(lt(() => {
      t.shaderControlState.state.get(r) === void 0 && this.unbind();
    }))));
  }
  activate(e) {
    this.layerShaderControls.shaderControlState.state.get(this.control) !== void 0 && super.activate(e);
  }
};
function lS(n, e, t = nD) {
  Dc(n, t, (i, r) => {
    const s = K(r, iD, Le);
    return new xH(i, e(i), t, s);
  });
}
function rD(n) {
  return new aS({
    fragmentMain: n.displayState.skeletonRenderingOptions.shader,
    shaderError: n.displayState.shaderError,
    shaderControlState: n.displayState.skeletonRenderingOptions.shaderControlState
  });
}
var EH = class extends Kr {
  constructor(e) {
    super(), this.layer = e;
    const t = this.element;
    t.classList.add("neuroglancer-segmentation-rendering-tab");
    {
      const r = this.registerDisposer(new _x(e.displayState.linkedSegmentationGroup));
      r.label.textContent = "Linked to: ", t.appendChild(r.element);
    }
    {
      const r = this.registerDisposer(new _x(e.displayState.linkedSegmentationColorGroup));
      r.label.textContent = "Colors linked to: ", t.appendChild(r.element);
    }
    for (const r of dS)
      t.appendChild(rS(this, e, this.visibility, r));
    const i = this.registerDisposer(new ur(e.hasSkeletonsLayer, (r, s, a) => {
      if (!r)
        return;
      let l = document.createElement("div");
      l.className = "neuroglancer-segmentation-dropdown-skeleton-shader-header";
      let d = document.createElement("div");
      d.style.flex = "1", d.textContent = "Skeleton shader:", l.appendChild(d), l.appendChild(sS({
        title: "Show larger editor view",
        onClick: () => {
          new TH(this.layer);
        }
      })), l.appendChild(iS({
        title: "Documentation on skeleton rendering",
        href: "https://github.com/google/neuroglancer/blob/master/src/neuroglancer/sliceview/image_layer_rendering.md"
      })), s.appendChild(l);
      const u = a.registerDisposer(rD(this.layer));
      s.appendChild(u.element), s.appendChild(a.registerDisposer(new oS(e.displayState.skeletonRenderingOptions.shaderControlState, this.layer.manager.root.display, this.layer, {
        visibility: this.visibility,
        toolId: cS
      })).element), u.textEditor.refresh();
    }, this.visibility));
    t.appendChild(i.element);
  }
};
var TH = class extends hf {
  constructor(e) {
    super(), this.layer = e, this.codeWidget = this.registerDisposer(rD(this.layer)), this.content.classList.add("neuroglancer-segmentation-layer-skeleton-shader-overlay"), this.content.appendChild(this.codeWidget.element), this.codeWidget.textEditor.refresh();
  }
};
var kH = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, s = r < 3 ? e : i === null ? i = $i(e, t) : i, a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(n, e, t, i);
  else
    for (var l = n.length - 1; l >= 0; l--)
      (a = n[l]) && (s = (r < 3 ? a(s) : r > 3 ? a(e, t, s) : a(e, t)) || s);
  return r > 3 && s && UZr(e, t, s), s;
};
var Gm;
var $m = Gm = class extends Nh {
  constructor() {
    super(...arguments), this.hashTable = new py(), this.changed = new ot();
  }
  get value() {
    return this;
  }
  static makeWithCounterpart(e) {
    let t = new Gm();
    return t.initializeCounterpart(e), t;
  }
  set_(e, t) {
    return this.hashTable.set(e, t);
  }
  set(e, t) {
    if (this.set_(e, t)) {
      let i = this.rpc;
      i && i.invoke("Uint64Map.set", { id: this.rpcId, key: e, value: t }), this.changed.dispatch(e, true);
    }
  }
  has(e) {
    return this.hashTable.has(e);
  }
  get(e, t) {
    return this.hashTable.get(e, t);
  }
  [wZr]() {
    return this.hashTable.entries();
  }
  unsafeEntries() {
    return this.hashTable.unsafeEntries();
  }
  delete_(e) {
    return this.hashTable.delete(e);
  }
  delete(e) {
    if (this.delete_(e)) {
      let t = this.rpc;
      t && t.invoke("Uint64Map.delete", { id: this.rpcId, key: e }), this.changed.dispatch(e, false);
    }
  }
  get size() {
    return this.hashTable.size;
  }
  assignFrom(e) {
    this.clear();
    for (const i of e.unsafeEntries()) {
      var t = ce(i, 2);
      const r = t[0], s = t[1];
      this.set(r, s);
    }
  }
  clear() {
    if (this.hashTable.clear()) {
      let e = this.rpc;
      e && e.invoke("Uint64Map.clear", { id: this.rpcId }), this.changed.dispatch(null, false);
    }
  }
  toJSON() {
    let e = {};
    for (let i of this.hashTable.unsafeEntries()) {
      var t = ce(i, 2);
      let r = t[0], s = t[1];
      e[r.toString()] = s.toString();
    }
    return e;
  }
};
$m = Gm = kH([_h("Uint64Map")], $m);
Ut("Uint64Map.set", function(n) {
  let e = this.get(n.id);
  e.set_(n.key, n.value) && e.changed.dispatch();
});
Ut("Uint64Map.delete", function(n) {
  let e = this.get(n.id);
  e.delete_(n.key) && e.changed.dispatch();
});
Ut("Uint64Map.clear", function(n) {
  let e = this.get(n.id);
  e.hashTable.clear() && e.changed.dispatch();
});
var IH = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, s = r < 3 ? e : i === null ? i = $i(e, t) : i, a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(n, e, t, i);
  else
    for (var l = n.length - 1; l >= 0; l--)
      (a = n[l]) && (s = (r < 3 ? a(s) : r > 3 ? a(e, t, s) : a(e, t)) || s);
  return r > 3 && s && UZr(e, t, s), s;
};
var Wm;
var sh = Wm = class extends Nh {
  constructor() {
    super(...arguments), this.hashTable = new Lk(), this.changed = new ot();
  }
  get value() {
    return this;
  }
  static makeWithCounterpart(e) {
    let t = new Wm();
    return t.initializeCounterpart(e), t;
  }
  set(e, t) {
    t ? this.add(e) : this.delete(e);
  }
  reserve_(e) {
    return this.hashTable.reserve(e);
  }
  reserve(e) {
    if (this.reserve_(e)) {
      let t = this.rpc;
      t && t.invoke("Uint64Set.reserve", { id: this.rpcId, value: e });
    }
  }
  add_(e) {
    let t = false;
    for (const i of e)
      t = this.hashTable.add(i) || t;
    return t;
  }
  add(e) {
    const t = Array().concat(e);
    if (this.add_(t)) {
      let i = this.rpc;
      i && i.invoke("Uint64Set.add", { id: this.rpcId, value: t }), this.changed.dispatch(e, true);
    }
  }
  has(e) {
    return this.hashTable.has(e);
  }
  [wZr]() {
    return this.hashTable.keys();
  }
  unsafeKeys() {
    return this.hashTable.unsafeKeys();
  }
  delete_(e) {
    let t = false;
    for (const i of e)
      t = this.hashTable.delete(i) || t;
    return t;
  }
  delete(e) {
    const t = Array().concat(e);
    if (this.delete_(Array().concat(e))) {
      let i = this.rpc;
      i && i.invoke("Uint64Set.delete", { id: this.rpcId, value: t }), this.changed.dispatch(e, false);
    }
  }
  get size() {
    return this.hashTable.size;
  }
  clear() {
    if (this.hashTable.clear()) {
      let e = this.rpc;
      e && e.invoke("Uint64Set.clear", { id: this.rpcId }), this.changed.dispatch(null, false);
    }
  }
  toJSON() {
    let e = new Array();
    for (let t of this.unsafeKeys())
      e.push(t.toString());
    return e.sort(), e;
  }
  assignFrom(e) {
    this.clear();
    for (const t of e.unsafeKeys())
      this.add(t);
  }
};
sh = Wm = IH([_h("Uint64Set")], sh);
Ut("Uint64Set.reserve", function(n) {
  let e = this.get(n.id);
  e.reserve_(n.value) && e.changed.dispatch();
});
Ut("Uint64Set.add", function(n) {
  let e = this.get(n.id);
  e.add_(n.value) && e.changed.dispatch();
});
Ut("Uint64Set.delete", function(n) {
  let e = this.get(n.id);
  e.delete_(n.value) && e.changed.dispatch();
});
Ut("Uint64Set.clear", function(n) {
  let e = this.get(n.id);
  e.hashTable.clear() && e.changed.dispatch();
});
var LH = vt.fromObject({
  "at:shift+wheel": { action: "adjust-via-wheel" }
});
function sD(n) {
  return {
    makeControl: (e, t) => {
      const i = n(e), r = t.registerDisposer(new FI(i));
      return { control: r, controlElement: r.element };
    },
    activateTool: (e, t) => {
      e.bindInputEventMap(LH), e.bindAction("adjust-via-wheel", (i) => {
        i.stopPropagation(), i.preventDefault(), t.adjustViaWheel(i.detail);
      });
    }
  };
}
var DH = 200;
var Vx = vt.fromObject({
  mousedown0: { action: "set" },
  wheel: { action: "adjust-via-wheel" },
  dblclick0: { action: "reset" }
});
function PH(n) {
  if (n < 1 || n > 1024) {
    const e = Zn(n) | 0, t = n / 2 ** e;
    return `${xI(t, 1)}p${e}`;
  }
  return Math.round(n) + "";
}
var Hm = class extends Z {
  constructor(e, t) {
    super(), this.histogram = e, this.target = t, this.label = document.createElement("div"), this.element = document.createElement("div"), this.canvas = document.createElement("canvas"), this.legend = document.createElement("div"), this.legendRenderScale = document.createElement("div"), this.legendSpatialScale = document.createElement("div"), this.legendChunks = document.createElement("div"), this.ctx = this.canvas.getContext("2d"), this.hoverTarget = new gt(void 0), this.throttledUpdateView = this.registerCancellable(zh(() => this.debouncedUpdateView(), DH, { leading: true, trailing: true })), this.debouncedUpdateView = this.registerCancellable(lt(() => this.updateView(), 0));
    const i = this.canvas, r = this.label, s = this.element, a = this.legend, l = this.legendRenderScale, d = this.legendSpatialScale, u = this.legendChunks;
    r.className = "neuroglancer-render-scale-widget-prompt", s.className = "neuroglancer-render-scale-widget", s.title = Vx.describe(), a.className = "neuroglancer-render-scale-widget-legend", s.appendChild(r), s.appendChild(i), s.appendChild(a), l.title = "Target resolution of data in screen pixels", u.title = "Number of chunks rendered", a.appendChild(l), a.appendChild(u), a.appendChild(d), this.registerDisposer(e.changed.add(this.throttledUpdateView)), this.registerDisposer(e.visibility.changed.add(this.debouncedUpdateView)), this.registerDisposer(t.changed.add(this.debouncedUpdateView)), this.registerDisposer(new qr(i, Vx)), this.registerDisposer(t.changed.add(this.debouncedUpdateView)), this.registerDisposer(this.hoverTarget.changed.add(this.debouncedUpdateView));
    const f = (v) => {
      const y = v.offsetX / i.width * cn;
      return JB(y);
    };
    this.registerEventListener(i, "pointermove", (v) => {
      this.hoverTarget.value = [f(v), v.offsetY];
    }), this.registerEventListener(i, "pointerleave", () => {
      this.hoverTarget.value = void 0;
    }), this.registerDisposer(be(i, "set", (v) => {
      this.target.value = f(v.detail);
    })), this.registerDisposer(be(i, "adjust-via-wheel", (v) => {
      this.adjustViaWheel(v.detail);
    })), this.registerDisposer(be(i, "reset", (v) => {
      this.reset(), v.preventDefault();
    }));
    const g = new ResizeObserver(() => this.debouncedUpdateView());
    g.observe(i), this.registerDisposer(() => g.disconnect()), this.updateView();
  }
  adjustViaWheel(e) {
    const t = e.deltaY;
    t !== 0 && (this.hoverTarget.value = void 0, this.target.value *= 2 ** Ec(t), e.preventDefault());
  }
  reset() {
    this.hoverTarget.value = void 0, this.target.reset();
  }
  updateView() {
    const e = this.ctx, t = this.canvas, i = t.width = t.offsetWidth, r = t.height = t.offsetHeight, s = this.target.value, a = this.hoverTarget.value;
    {
      const I = this.legendRenderScale, P = a === void 0 ? s : a[0], N = PH(P);
      I.textContent = N + " px";
    }
    function l(I) {
      return I * i / cn;
    }
    e.clearRect(0, 0, i, r);
    const d = this.histogram, u = d.value, f = d.spatialScales;
    d.visibility.visible || u.fill(0);
    const g = De(f.keys());
    g.sort();
    const v = _e();
    let y = 1;
    const w = f.size;
    let C = 0, b = 0;
    for (let I = 0; I < cn; ++I) {
      let P = 0;
      for (let N = 0; N < w; ++N) {
        const O = N * cn * 2 + I, B = u[O], j = u[O + cn];
        C += B, b += j, P += B + j;
      }
      y = Math.max(P, y);
    }
    const L = r / Math.log(1 + y);
    function R(I) {
      return r - Math.log(1 + I) * L;
    }
    let _;
    if (a !== void 0) {
      const I = Math.floor(pu(a[0]));
      if (I >= 0 && I < cn) {
        let P = 0;
        const N = a[1];
        for (let O = w - 1; O >= 0; --O) {
          const B = g[O], U = 2 * f.get(B) * cn + I, V = u[U] + u[U + cn];
          if (V === 0)
            continue;
          const G = Math.round(R(P));
          if (P += V, Math.round(R(P)) <= N && N <= G) {
            _ = B;
            break;
          }
        }
      }
    }
    if (_ !== void 0) {
      C = 0, b = 0;
      const P = 2 * f.get(_) * cn;
      for (let N = 0; N < cn; ++N) {
        const O = P + N;
        C += u[O], b += u[O + cn];
      }
      kt(_) ? this.legendSpatialScale.textContent = ca(_, "m", { precision: 2, elide1: false }) : this.legendSpatialScale.textContent = "unknown";
    } else
      this.legendSpatialScale.textContent = "";
    this.legendChunks.textContent = `${C}/${C + b}`;
    const A = g.map((I) => {
      const P = I === _ ? 0.5 : 1;
      let N;
      kt(I) ? N = (Zn(I) * 0.1 % 1 + 1) % 1 : N = 0, $u(v, N, P, 1);
      const O = Wn(v);
      $u(v, N, P, 0.5);
      const B = Wn(v);
      return [O, B];
    });
    for (let I = 0; I < cn; ++I) {
      let P = 0;
      for (let N = w - 1; N >= 0; --N) {
        const O = g[N], j = f.get(O) * cn * 2 + I, U = u[j], V = u[j + cn], G = U + V;
        if (G === 0)
          continue;
        const F = Math.round(l(I)), ue = Math.round(l(I + 1)), ae = Math.round(R(P));
        P += G;
        const Ie = Math.round(R(P)), le = (U * Ie + V * ae) / G;
        e.fillStyle = A[N][1], e.fillRect(F, Ie, ue - F, le - Ie), e.fillStyle = A[N][0], e.fillRect(F, le, ue - F, ae - le);
      }
    }
    {
      const I = s;
      e.fillStyle = "#fff";
      const P = l(pu(I)), N = 1;
      e.fillRect(Math.floor(P), 0, N, r);
    }
    if (a !== void 0) {
      const I = a[0];
      e.fillStyle = "#888";
      const P = l(pu(I)), N = 1;
      e.fillRect(Math.floor(P), 0, N, r);
    }
  }
};
var AH = vt.fromObject({
  "at:shift+wheel": { action: "adjust-via-wheel" },
  "at:shift+dblclick0": { action: "reset" }
});
function ah(n) {
  return {
    makeControl: (e, t) => {
      var i = n(e);
      const r = i.histogram, s = i.target, a = t.registerDisposer(new Hm(r, s));
      return { control: a, controlElement: a.element };
    },
    activateTool: (e, t) => {
      e.bindInputEventMap(AH), e.bindAction("adjust-via-wheel", (i) => {
        i.stopPropagation(), i.preventDefault(), t.adjustViaWheel(i.detail);
      }), e.bindAction("reset", (i) => {
        i.stopPropagation(), i.preventDefault(), t.reset();
      });
    }
  };
}
var RH = "data:image/svg+xml;base64,PHN2ZyByb2xlPSJpbWciIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjI0IiBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIGFyaWEtbGFiZWxsZWRieT0icm90YXRlSWNvblRpdGxlIj4KICAgIDx0aXRsZSBpZD0icm90YXRlSWNvblRpdGxlIj5Sb3RhdGU8L3RpdGxlPiAgICAKICAgIDxwYXRoIGQ9Ik0yMiAxMmwtMyAzLTMtMyIvPgogICAgPHBhdGggZD0iTTIgMTJsMy0zIDMgMyIvPgogICAgPHBhdGggZD0iTTE5LjAxNiAxNHYtMS45NUE3LjA1IDcuMDUgMCAwIDAgOCA2LjIyIi8+CiAgICA8cGF0aCBkPSJNMTYuMDE2IDE3Ljg0NUE3LjA1IDcuMDUgMCAwIDEgNSAxMi4wMTVWMTAiLz4KICAgIDxwYXRoIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgZD0iTTUgMTBWOSIvPgogICAgPHBhdGggc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBkPSJNMTkgMTV2LTEiLz4KPC9zdmc+";
function oh(n, e) {
  e ? n.displayState.segmentDefaultColor.value = St(1, 0, 0) : n.displayState.segmentDefaultColor.value = void 0;
}
function MH() {
  const n = (e) => {
    e.displayState.segmentationColorGroupState.value.segmentColorHash.randomize();
  };
  return {
    makeControl: (e, t, { labelTextContainer: i }) => {
      const r = document.createElement("input");
      r.type = "radio", r.addEventListener("change", () => {
        oh(e, !r.checked);
      }), i.prepend(r);
      const s = document.createElement("div");
      s.classList.add("neuroglancer-segmentation-color-seed-control");
      const a = t.registerDisposer(new $I(e.displayState.segmentColorHash));
      s.appendChild(a.element);
      const l = Tt({
        svg: RH,
        title: "Randomize",
        onClick: () => n(e)
      });
      return s.appendChild(l), t.registerDisposer(Vr((d) => {
        const u = d === void 0;
        s.style.visibility = u ? "" : "hidden", r.checked = u;
      }, e.displayState.segmentDefaultColor)), { controlElement: s, control: a };
    },
    activateTool: (e) => {
      const t = e.tool.layer;
      oh(t, false), n(t);
    }
  };
}
function NH() {
  const n = eD((e) => e.displayState.segmentDefaultColor);
  return RZr(RZr({}, n), { makeControl: (e, t, i) => {
    const r = n.makeControl(e, t, i), s = r.controlElement, a = document.createElement("input");
    return a.type = "radio", a.addEventListener("change", () => {
      oh(e, a.checked), a.checked && s.click();
    }), i.labelTextContainer.prepend(a), t.registerDisposer(Vr((l) => {
      const d = l !== void 0;
      s.style.visibility = d ? "" : "hidden", a.checked = d;
    }, e.displayState.segmentDefaultColor)), r;
  }, activateTool: (e, t) => {
    oh(e.tool.layer, true), n.activateTool(e, t);
  } });
}
var jm = "selectedAlpha";
var Jm = "notSelectedAlpha";
var Ym = "objectAlpha";
var qm = "saturation";
var Km = "hideSegmentZero";
var Zm = "baseSegmentColoring";
var Xm = "ignoreNullVisibleSet";
var _H = "mesh";
var OH = "skeletons";
var Bx = "segments";
var lh = "equivalences";
var Qm = "colorSeed";
var Fx = "segmentColors";
var ev = "meshRenderScale";
var tv = "crossSectionRenderScale";
var ch = "skeletonRendering";
var VH = "skeletonShader";
var Ux = "segmentQuery";
var nv = "meshSilhouetteRendering";
var zx = "linkedSegmentationGroup";
var Gx = "linkedSegmentationColorGroup";
var iv = "segmentDefaultColor";
var $x = "anchorSegment";
var cS = "skeletonShaderControl";
var aD = class extends Z {
  constructor(e) {
    super(), this.layer = e, this.specificationChanged = new ot(), this.localGraph = new $W(), this.visibleSegments = this.registerDisposer(sh.makeWithCounterpart(this.layer.manager.rpc)), this.segmentPropertyMap = new gt(void 0), this.graph = new gt(void 0), this.segmentEquivalences = this.registerDisposer(Pc.makeWithCounterpart(this.layer.manager.rpc, this.layer.registerDisposer(wi((i) => i && i.visibleSegmentEquivalencePolicy || Fi.MIN_REPRESENTATIVE, [this.graph])))), this.localSegmentEquivalences = false, this.maxIdLength = new gt(1), this.hideSegmentZero = new en(true, true), this.segmentQuery = new hn("", Le), this.temporaryVisibleSegments = this.layer.registerDisposer(sh.makeWithCounterpart(this.layer.manager.rpc)), this.temporarySegmentEquivalences = this.layer.registerDisposer(Pc.makeWithCounterpart(this.layer.manager.rpc, this.segmentEquivalences.disjointSets.visibleSegmentEquivalencePolicy)), this.useTemporaryVisibleSegments = this.layer.registerDisposer(An.make(this.layer.manager.rpc, false)), this.useTemporarySegmentEquivalences = this.layer.registerDisposer(An.make(this.layer.manager.rpc, false));
    const t = this.specificationChanged;
    this.visibleSegments.changed.add(t.dispatch), this.hideSegmentZero.changed.add(t.dispatch), this.segmentQuery.changed.add(t.dispatch);
  }
  restoreState(e) {
    Ce(e, Km, (t) => this.hideSegmentZero.restoreState(t)), Ce(e, lh, (t) => {
      this.localGraph.restoreState(t);
    }), Ce(e, Bx, (t) => {
      const i = this.segmentEquivalences, r = this.visibleSegments;
      Je(t, (s) => {
        let a = re.parseString(String(s), 10);
        r.add(i.get(a));
      });
    }), Ce(e, Ux, (t) => this.segmentQuery.restoreState(t));
  }
  toJSON() {
    const e = {};
    e[Km] = this.hideSegmentZero.toJSON();
    let t = this.visibleSegments;
    t.size > 0 && (e[Bx] = t.toJSON());
    let i = this.segmentEquivalences;
    return this.localSegmentEquivalences && i.size > 0 && (e[lh] = i.toJSON()), e[Ux] = this.segmentQuery.toJSON(), e;
  }
  assignFrom(e) {
    this.maxIdLength.value = e.maxIdLength.value, this.hideSegmentZero.value = e.hideSegmentZero.value, this.visibleSegments.assignFrom(e.visibleSegments), this.segmentEquivalences.assignFrom(e.segmentEquivalences);
  }
};
var oD = class extends Z {
  constructor(e) {
    super(), this.layer = e, this.specificationChanged = new ot(), this.segmentColorHash = yy.getDefault(), this.segmentStatedColors = this.registerDisposer(new $m()), this.segmentDefaultColor = new r1();
    const t = this.specificationChanged;
    this.segmentColorHash.changed.add(t.dispatch), this.segmentStatedColors.changed.add(t.dispatch), this.segmentDefaultColor.changed.add(t.dispatch);
  }
  restoreState(e) {
    Ce(e, Qm, (t) => this.segmentColorHash.restoreState(t)), Ce(e, iv, (t) => this.segmentDefaultColor.restoreState(t)), Ce(e, Fx, (t) => {
      let i = Dh(t, (s) => va(String(s)));
      for (let s of i) {
        var r = ce(s, 2);
        let a = r[0], l = r[1];
        const d = re.parseString(String(a)), u = new re(Tu(l));
        this.segmentStatedColors.set(d, u);
      }
    });
  }
  toJSON() {
    const e = {};
    e[Qm] = this.segmentColorHash.toJSON(), e[iv] = this.segmentDefaultColor.toJSON();
    const t = this.segmentStatedColors;
    if (t.size > 0) {
      const r = e[Fx] = {};
      for (const s of t.unsafeEntries()) {
        var i = ce(s, 2);
        const a = i[0], l = i[1];
        r[a.toString()] = Wn(ia(l.low));
      }
    }
    return e;
  }
  assignFrom(e) {
    this.segmentColorHash.value = e.segmentColorHash.value, this.segmentStatedColors.assignFrom(e.segmentStatedColors), this.segmentDefaultColor.value = e.segmentDefaultColor.value;
  }
};
var Wx = class extends Z {
  constructor(e, t) {
    super(), this.linkedGroup = e, this.propertyName = t, this.value;
  }
  get changed() {
    return this.linkedGroup.root.changed;
  }
  get value() {
    const e = this.linkedGroup.root.value;
    if (e !== this.curRoot) {
      this.curRoot = e;
      const t = e.displayState[this.propertyName];
      if (e === this.linkedGroup.layer) {
        const i = this.curGroupState;
        i !== void 0 && (t.assignFrom(i), i.dispose());
      }
      this.curGroupState = t.addRef();
    }
    return this.curGroupState;
  }
  disposed() {
    var e;
    (e = this.curGroupState) === null || e === void 0 || e.dispose();
  }
};
var BH = class {
  constructor(e) {
    this.layer = e, this.segmentSelectionState = new $k(), this.selectedAlpha = tc(0.5), this.saturation = tc(1), this.notSelectedAlpha = tc(0), this.silhouetteRendering = new hn(0, Iv, 0), this.objectAlpha = tc(1), this.ignoreNullVisibleSet = new en(true, true), this.skeletonRenderingOptions = new wU(), this.shaderError = Vh(), this.renderScaleHistogram = new Ro(), this.renderScaleTarget = ua(1), this.selectSegment = this.layer.selectSegment, this.transparentPickEnabled = this.layer.pick, this.baseSegmentColoring = new en(false, false), this.filterBySegmentLabel = this.layer.filterBySegmentLabel, this.moveToSegment = (t) => {
      this.layer.moveToSegment(t);
    }, this.linkedSegmentationGroup = this.layer.registerDisposer(new hx(this.layer.manager.rootLayers, this.layer, (t) => t instanceof Mn, (t) => t.displayState.linkedSegmentationGroup)), this.linkedSegmentationColorGroup = this.layer.registerDisposer(new hx(this.layer.manager.rootLayers, this.layer, (t) => t instanceof Mn, (t) => t.displayState.linkedSegmentationColorGroup)), this.originalSegmentationGroupState = this.layer.registerDisposer(new aD(this.layer)), this.originalSegmentationColorGroupState = this.layer.registerDisposer(new oD(this.layer)), e.displayState = this, this.segmentationGroupState = this.layer.registerDisposer(new Wx(this.linkedSegmentationGroup, "originalSegmentationGroupState")), this.segmentationColorGroupState = this.layer.registerDisposer(new Wx(this.linkedSegmentationColorGroup, "originalSegmentationColorGroupState")), this.hideSegmentZero = this.layer.registerDisposer(new ou(this.segmentationGroupState, (t) => t.hideSegmentZero)), this.segmentColorHash = this.layer.registerDisposer(new Ep(this.segmentationColorGroupState, (t) => t.segmentColorHash)), this.segmentStatedColors = this.layer.registerDisposer(new Ep(this.segmentationColorGroupState, (t) => t.segmentStatedColors)), this.segmentDefaultColor = this.layer.registerDisposer(new Ep(this.segmentationColorGroupState, (t) => t.segmentDefaultColor)), this.segmentQuery = this.layer.registerDisposer(new ou(this.segmentationGroupState, (t) => t.segmentQuery)), this.segmentPropertyMap = this.layer.registerDisposer(new ou(this.segmentationGroupState, (t) => t.segmentPropertyMap));
  }
};
var FH = Qy(al);
var Mn = class extends FH {
  constructor(e) {
    super(e), this.sliceViewRenderScaleHistogram = new Ro(), this.sliceViewRenderScaleTarget = ua(1), this.segmentQueryFocusTime = new gt(Number.NEGATIVE_INFINITY), this.selectSegment = (t, i) => {
      this.manager.root.selectionState.captureSingleLayerState(this, (r) => (r.value = t.clone(), true), i);
    }, this.filterBySegmentLabel = (t) => {
      const r = ha(this.displayState, t).label;
      r && this.filterSegments(r);
    }, this.filterSegments = (t) => {
      this.displayState.segmentationGroupState.value.segmentQuery.value = t, this.segmentQueryFocusTime.value = Date.now(), this.tabs.value = "segments", this.manager.root.selectedLayer.layer = this.managedLayer;
    }, this.displayState = new BH(this), this.anchorSegment = new hn(void 0, (t) => t === void 0 ? void 0 : re.parseString(t)), this.has2dLayer = this.registerDisposer(rr((t) => t.some((i) => i instanceof fg), { changed: this.layersChanged, value: this.renderLayers })), this.has3dLayer = this.registerDisposer(rr((t) => t.some((i) => i instanceof ww || i instanceof Xp || i instanceof Qp || i instanceof Iw), { changed: this.layersChanged, value: this.renderLayers })), this.hasSkeletonsLayer = this.registerDisposer(rr((t) => t.some((i) => i instanceof Qp), { changed: this.layersChanged, value: this.renderLayers })), this.registerDisposer(wo((t, i) => {
      t.registerDisposer(i.specificationChanged.add(this.specificationChanged.dispatch)), this.specificationChanged.dispatch();
    }, this.displayState.segmentationGroupState)), this.registerDisposer(wo((t, i) => {
      t.registerDisposer(i.specificationChanged.add(this.specificationChanged.dispatch)), this.specificationChanged.dispatch();
    }, this.displayState.segmentationColorGroupState)), this.displayState.segmentSelectionState.bindTo(this.manager.layerSelectedValues, this), this.displayState.selectedAlpha.changed.add(this.specificationChanged.dispatch), this.displayState.saturation.changed.add(this.specificationChanged.dispatch), this.displayState.notSelectedAlpha.changed.add(this.specificationChanged.dispatch), this.displayState.objectAlpha.changed.add(this.specificationChanged.dispatch), this.displayState.baseSegmentColoring.changed.add(this.specificationChanged.dispatch), this.displayState.ignoreNullVisibleSet.changed.add(this.specificationChanged.dispatch), this.displayState.skeletonRenderingOptions.changed.add(this.specificationChanged.dispatch), this.displayState.renderScaleTarget.changed.add(this.specificationChanged.dispatch), this.displayState.silhouetteRendering.changed.add(this.specificationChanged.dispatch), this.anchorSegment.changed.add(this.specificationChanged.dispatch), this.sliceViewRenderScaleTarget.changed.add(this.specificationChanged.dispatch), this.displayState.originalSegmentationGroupState.localGraph.changed.add(this.specificationChanged.dispatch), this.displayState.linkedSegmentationGroup.changed.add(() => this.updateDataSubsourceActivations()), this.tabs.add("rendering", { label: "Render", order: -100, getter: () => new EH(this) }), this.tabs.add("segments", { label: "Seg.", order: -50, getter: () => new hH(this) }), this.tabs.default = "rendering";
  }
  bindSegmentListWidth(e) {
    return Bo(this.displayState, e);
  }
  get volumeOptions() {
    return { volumeType: Dn.SEGMENTATION };
  }
  activateDataSubsources(e) {
    const t = [], i = this.displayState.linkedSegmentationGroup.root.value === this;
    let r;
    for (const a of e) {
      if (this.addStaticAnnotations(a))
        continue;
      var s = a.subsourceEntry.subsource;
      const l = s.volume, d = s.mesh, u = s.segmentPropertyMap, f = s.segmentationGraph, g = s.local;
      if (l instanceof _s) {
        switch (l.dataType) {
          case J.FLOAT32:
            a.deactivate("Data type not compatible with segmentation layer");
            continue;
        }
        a.activate(() => a.addRenderLayer(new fg(l, RZr(RZr({}, this.displayState), { transform: a.getRenderLayerTransform(), renderScaleTarget: this.sliceViewRenderScaleTarget, renderScaleHistogram: this.sliceViewRenderScaleHistogram, localPosition: this.localPosition }))), this.displayState.segmentationGroupState.value);
      } else
        d !== void 0 ? a.activate(() => {
          const v = RZr(RZr({}, this.displayState), { transform: a.getRenderLayerTransform() });
          if (d instanceof Zc)
            a.addRenderLayer(new ww(this.manager.chunkManager, d, v));
          else if (d instanceof Qh)
            a.addRenderLayer(new Xp(this.manager.chunkManager, d, v));
          else {
            const y = new xU(this.manager.chunkManager, d, v);
            a.addRenderLayer(new Qp(y.addRef())), a.addRenderLayer(new Iw(
              /* transfer ownership */
              y
            ));
          }
        }, this.displayState.segmentationGroupState.value) : u !== void 0 ? i ? (a.activate(() => {
        }), t.push(u)) : a.deactivate("Not supported on non-root linked segmentation layers") : f !== void 0 ? i ? r !== void 0 ? a.deactivate("Only one segmentation graph is supported") : (r = f, a.activate((v) => {
          this.graphConnection = v.registerDisposer(f.connect(this.displayState.segmentationGroupState.value));
          const y = RZr(RZr({}, this.displayState), { transform: a.getRenderLayerTransform() }), w = this.graphConnection.createRenderLayers(this.manager.chunkManager, y, this.localPosition);
          for (const C of w)
            a.addRenderLayer(C);
        })) : a.deactivate("Not supported on non-root linked segmentation layers") : g === Gr.equivalences ? i ? r !== void 0 ? a.deactivate("Only one segmentation graph is supported") : (r = this.displayState.originalSegmentationGroupState.localGraph, a.activate((v) => {
          this.graphConnection = v.registerDisposer(r.connect(this.displayState.segmentationGroupState.value)), v.registerDisposer(() => {
            this.graphConnection = void 0;
          });
        })) : a.deactivate("Not supported on non-root linked segmentation layers") : a.deactivate("Not compatible with segmentation layer");
    }
    this.displayState.originalSegmentationGroupState.segmentPropertyMap.value = DW(this.manager.chunkManager, t), this.displayState.originalSegmentationGroupState.graph.value = r;
  }
  getLegacyDataSourceSpecifications(e, t, i, r) {
    const s = super.getLegacyDataSourceSpecifications(e, t, i, r), a = Ce(t, _H, (d) => d === null ? null : Le(d)), l = Ce(t, OH, (d) => d === null ? null : Le(d));
    if (a !== void 0 || l !== void 0)
      for (const d of s)
        d.enableDefaultSubsources = false, d.subsources = new de([["default", { enabled: true }], ["bounds", { enabled: true }]]);
    return a != null && s.push(ac(this.manager.dataSourceProviderRegistry.convertLegacyUrl({ url: a, type: "mesh" }))), l != null && s.push(ac(this.manager.dataSourceProviderRegistry.convertLegacyUrl({ url: l, type: "skeletons" }))), t[lh] !== void 0 && r.find((d) => d.url === am) === void 0 && s.push({
      url: am,
      enableDefaultSubsources: true,
      transform: {
        outputSpace: To,
        sourceRank: 0,
        transform: void 0,
        inputSpace: To
      },
      subsources: new de()
    }), s;
  }
  restoreState(e) {
    super.restoreState(e), this.displayState.selectedAlpha.restoreState(e[jm]), this.displayState.saturation.restoreState(e[qm]), this.displayState.notSelectedAlpha.restoreState(e[Jm]), this.displayState.objectAlpha.restoreState(e[Ym]), this.displayState.baseSegmentColoring.restoreState(e[Zm]), this.displayState.silhouetteRendering.restoreState(e[nv]), this.displayState.ignoreNullVisibleSet.restoreState(e[Xm]);
    const t = this.displayState.skeletonRenderingOptions;
    t.restoreState(e[ch]);
    const i = e[VH];
    i !== void 0 && t.shader.restoreState(i), this.displayState.renderScaleTarget.restoreState(e[ev]), this.anchorSegment.restoreState(e[$x]), this.sliceViewRenderScaleTarget.restoreState(e[tv]);
    const r = Ce(e, zx, Le);
    r !== void 0 && this.displayState.linkedSegmentationGroup.linkByName(r);
    const s = Ce(e, Gx, (a) => a === false ? void 0 : Le(a), r);
    s !== void 0 && this.displayState.linkedSegmentationColorGroup.linkByName(s), this.displayState.segmentationGroupState.value.restoreState(e), this.displayState.segmentationColorGroupState.value.restoreState(e);
  }
  toJSON() {
    var e;
    const t = super.toJSON();
    t[jm] = this.displayState.selectedAlpha.toJSON(), t[Jm] = this.displayState.notSelectedAlpha.toJSON(), t[qm] = this.displayState.saturation.toJSON(), t[Ym] = this.displayState.objectAlpha.toJSON(), t[Zm] = this.displayState.baseSegmentColoring.toJSON(), t[Xm] = this.displayState.ignoreNullVisibleSet.toJSON(), t[nv] = this.displayState.silhouetteRendering.toJSON(), t[$x] = this.anchorSegment.toJSON(), t[ch] = this.displayState.skeletonRenderingOptions.toJSON(), t[ev] = this.displayState.renderScaleTarget.toJSON(), t[tv] = this.sliceViewRenderScaleTarget.toJSON();
    var i = this.displayState;
    const r = i.linkedSegmentationGroup, s = i.linkedSegmentationColorGroup;
    return t[zx] = r.toJSON(), s.root.value !== r.root.value && (t[Gx] = (e = s.toJSON()) !== null && e !== void 0 ? e : false), t[lh] = this.displayState.originalSegmentationGroupState.localGraph.toJSON(), r.root.value === this && RZr(t, this.displayState.segmentationGroupState.value.toJSON()), s.root.value === this && RZr(t, this.displayState.segmentationColorGroupState.value.toJSON()), t;
  }
  transformPickedValue(e) {
    return e == null ? e : wy(
      this.displayState,
      e,
      /*mustCopy=*/
      true
    );
  }
  handleAction(e, t) {
    switch (e) {
      case "recolor": {
        this.displayState.segmentationColorGroupState.value.segmentColorHash.randomize();
        break;
      }
      case "clear-segments": {
        if (!this.pick.value)
          break;
        this.displayState.segmentationGroupState.value.visibleSegments.clear();
        break;
      }
      case "select": {
        if (!this.pick.value)
          break;
        const i = this.displayState.segmentSelectionState;
        if (i.hasSelectedSegment) {
          const r = i.selectedSegment, s = this.displayState.segmentationGroupState.value.visibleSegments, a = !s.has(r);
          (a || t.segmentationToggleSegmentState === void 0) && (t.segmentationToggleSegmentState = a), t.defer(() => {
            t.segmentationToggleSegmentState === a && s.set(r, a);
          });
        }
        break;
      }
      case "copy-segment-id": {
        if (!this.pick.value)
          break;
        const i = this.displayState.segmentSelectionState;
        if (i.hasSelectedSegment) {
          const r = i.selectedSegment;
          this.copiedSegments = [r.clone()];
          const s = r.toString();
          oi(s) && nt.showTemporaryMessage(s + " copied to clipboard");
        }
        break;
      }
      case "add-copy-segment-id": {
        if (!this.pick.value)
          break;
        const i = this.displayState.segmentSelectionState;
        if (i.hasSelectedSegment) {
          const r = i.selectedSegment;
          this.copiedSegments.push(r.clone());
          const s = this.copiedSegments.map((a) => a.toString()).join(",");
          oi(s) && nt.showTemporaryMessage(s + " copied to clipboard");
        }
        break;
      }
    }
  }
  selectionStateFromJson(e, t) {
    super.selectionStateFromJson(e, t);
    const i = new re();
    let r = e.value;
    typeof r == "number" && (r = r.toString()), typeof r != "string" || !i.tryParseString(r) ? e.value = void 0 : e.value = i;
  }
  selectionStateToJson(e, t) {
    const i = super.selectionStateToJson(e, t);
    let r = e.value;
    return r instanceof $r ? t ? i.value = {
      key: r.key.toString(),
      value: r.value ? r.value.toString() : void 0,
      label: r.label
    } : i.value = (r.value || r.key).toString() : r instanceof re && (i.value = r.toString()), i;
  }
  displaySegmentationSelection(e, t, i) {
    const r = e.value;
    let s;
    if ((typeof r == "number" || typeof r == "string") && (s = new re(), !s.tryParseString(r.toString())))
      return false;
    if (r instanceof re)
      s = r.clone();
    else if (r instanceof $r)
      s = r.key.clone();
    else
      return false;
    const a = this.displayState, l = ha(a, s);
    var d = this.displayState.segmentationGroupState.value;
    const u = d.segmentEquivalences, f = d.segmentPropertyMap.value, g = u.get(s), v = qh(this.displayState, l);
    if (nl(a, i, i.redraw), i.registerDisposer(Bo(a, v)), v.classList.add("neuroglancer-selection-details-segment"), t.appendChild(v), f !== void 0) {
      const y = f.segmentPropertyMap.inlineProperties;
      if (y !== void 0) {
        const w = f.getSegmentInlineIndex(g);
        if (w !== -1) {
          for (const C of y.properties)
            if (C.type !== "label") {
              if (C.type === "description") {
                const b = C.values[w];
                if (!b)
                  continue;
                const E = document.createElement("div");
                E.classList.add("neuroglancer-selection-details-segment-description"), E.textContent = b, t.appendChild(E);
              } else if (C.type === "number" || C.type === "string") {
                const b = C.values[w];
                if (C.type === "number" ? isNaN(b) : !b)
                  continue;
                const E = document.createElement("div");
                E.classList.add("neuroglancer-selection-details-segment-property");
                const L = document.createElement("div");
                L.classList.add("neuroglancer-selection-details-segment-property-name"), L.textContent = C.id, C.description && (L.title = C.description);
                const R = document.createElement("div");
                R.classList.add("neuroglancer-selection-details-segment-property-value"), R.textContent = b.toString(), E.appendChild(L), E.appendChild(R), t.appendChild(E);
              }
            }
        }
      }
    }
    return true;
  }
  displaySelectionState(e, t, i) {
    let r = this.displaySegmentationSelection(e, t, i);
    return super.displaySelectionState(e, t, i) && (r = true), r;
  }
  moveToSegment(e) {
    for (const i of this.renderLayers) {
      if (!(i instanceof Xp))
        continue;
      const r = i.getObjectPosition(e);
      if (r !== void 0) {
        this.setLayerPosition(i.displayState.transform.value, r);
        return;
      }
    }
    let t = false;
    for (const i of this.renderLayers)
      if (i instanceof fg) {
        const r = i.multiscaleSource;
        r.getSegmentPosition && (t = true, r.getSegmentPosition(e).then((s) => {
          this.setLayerPosition(null, s);
        }).catch((s) => {
          nt.showTemporaryMessage(`Failed to retrieve position for segment ${e}: ${s}`);
        }));
      }
    t || nt.showTemporaryMessage(`No position information loaded for segment ${e}`);
  }
};
Mn.type = "segmentation";
Mn.typeAbbreviation = "seg";
Mn.supportsPickOption = true;
var UH = 10;
function Hx(n) {
  return [RZr({ label: `Skeleton mode (${n})`, toolJson: `${ch}.mode${n}`, isValid: (e) => e.hasSkeletonsLayer }, sD((e) => e.displayState.skeletonRenderingOptions[`params${n}`].mode)), RZr({ label: `Line width (${n})`, toolJson: `${ch}.lineWidth${n}`, isValid: (e) => e.hasSkeletonsLayer, toolDescription: `Skeleton line width (${n})`, title: `Skeleton line width (${n})` }, vs((e) => ({
    value: e.displayState.skeletonRenderingOptions[`params${n}`].lineWidth,
    options: { min: 1, max: 40, step: 1 }
  })))];
}
var dS = [RZr({ label: "Color seed", title: "Color segments based on a hash of their id", toolJson: Qm }, MH()), RZr({ label: "Fixed color", title: "Use a fixed color for all segments without an explicitly-specified color", toolJson: iv }, NH()), RZr({ label: "Saturation", toolJson: qm, title: "Saturation of segment colors" }, vs((n) => ({ value: n.displayState.saturation }))), RZr({ label: "Opacity (on)", toolJson: jm, isValid: (n) => n.has2dLayer, title: "Opacity in cross-section views of segments that are selected" }, vs((n) => ({ value: n.displayState.selectedAlpha }))), RZr({ label: "Opacity (off)", toolJson: Jm, isValid: (n) => n.has2dLayer, title: "Opacity in cross-section views of segments that are not selected" }, vs((n) => ({ value: n.displayState.notSelectedAlpha }))), RZr({ label: "Resolution (slice)", toolJson: tv, isValid: (n) => n.has2dLayer }, ah((n) => ({
  histogram: n.sliceViewRenderScaleHistogram,
  target: n.sliceViewRenderScaleTarget
}))), RZr({ label: "Resolution (mesh)", toolJson: ev, isValid: (n) => n.has3dLayer }, ah((n) => ({
  histogram: n.displayState.renderScaleHistogram,
  target: n.displayState.renderScaleTarget
}))), RZr({ label: "Opacity (3d)", toolJson: Ym, isValid: (n) => n.has3dLayer, title: "Opacity of meshes and skeletons" }, vs((n) => ({ value: n.displayState.objectAlpha }))), RZr({ label: "Silhouette (3d)", toolJson: nv, isValid: (n) => n.has3dLayer, title: "Set to a non-zero value to increase transparency of object faces perpendicular to view direction" }, vs((n) => ({
  value: n.displayState.silhouetteRendering,
  options: { min: 0, max: UH, step: 0.1 }
}))), RZr({ label: "Hide segment ID 0", toolJson: Km, title: "Disallow selection and display of segment id 0" }, cc((n) => n.displayState.hideSegmentZero)), RZr({ label: "Base segment coloring", toolJson: Zm, title: "Color base segments individually" }, cc((n) => n.displayState.baseSegmentColoring)), RZr({ label: "Show all by default", title: "Show all segments if none are selected", toolJson: Xm }, cc((n) => n.displayState.ignoreNullVisibleSet)), ...Hx("2d"), ...Hx("3d")];
for (const n of dS)
  QL(Mn, n);
ol(Mn);
nL(Dn.SEGMENTATION, Mn);
Gy((n) => {
  if (n.mesh !== void 0)
    return { layerConstructor: Mn, priority: 1 };
});
lS(Mn, (n) => ({
  shaderControlState: n.displayState.skeletonRenderingOptions.shaderControlState
}), cS);
tH();
rH();
var zH = Object.freeze(Object.defineProperty({
  __proto__: null,
  LAYER_CONTROLS: dS,
  SKELETON_RENDERING_SHADER_CONTROL_TOOL_ID: cS,
  SegmentationUserLayer: Mn,
  SegmentationUserLayerColorGroupState: oD,
  SegmentationUserLayerGroupState: aD
}, Symbol.toStringTag, { value: "Module" }));
var GH = class extends Z {
  constructor(e) {
    super(), this.ref = e, this.element = document.createElement("label"), this.selectElement = document.createElement("select"), this.registerDisposer(e);
    const t = this.element, i = this.selectElement;
    t.appendChild(i), this.updateView(), this.registerEventListener(i, "change", () => this.updateModel()), this.registerDisposer(this.ref.changed.add(lt(() => this.updateView(), 0)));
  }
  updateModel() {
    this.ref.layerName = this.selectElement.value || void 0;
  }
  updateView() {
    const e = this.selectElement, t = this.ref, i = t.filter;
    it(e);
    const r = document.createElement("option");
    e.appendChild(r);
    for (const s of this.ref.layerManager.managedLayers)
      if (i(s)) {
        const a = document.createElement("option"), l = s.name;
        a.textContent = l, a.value = l, e.appendChild(a);
      }
    e.value = t.layerName || "";
  }
};
var $H = "points";
var gg = "annotations";
var jx = "annotationProperties";
var Jx = "annotationRelationships";
var Yx = "crossSectionAnnotationSpacing";
var qx = "projectionAnnotationSpacing";
var Kx = "shader";
var Zx = "shaderControls";
function WH(n, e) {
  e !== void 0 && Je(e, (t, i) => {
    n.add({
      type: Me.POINT,
      id: "" + i,
      point: v1(t),
      properties: []
    });
  });
}
function HH(n) {
  const e = n.layer;
  return e === null || e instanceof Mn;
}
function jH(n) {
  if (n === void 0)
    return null;
  const e = n.layer;
  return e === null || !(e instanceof Mn) ? null : e.displayState;
}
var Xx = "linkedSegmentationLayer";
var Qx = "filterBySegmentation";
var eE = "ignoreNullSegmentFilter";
var JH = class extends Z {
  constructor(e, t, i) {
    super(), this.layerManager = e, this.annotationStates = t, this.annotationDisplayState = i, this.changed = new Ee(), this.curGeneration = -1, this.wasLoading = void 0, this.map = new de(), this.registerDisposer(t.changed.add(() => this.update())), this.registerDisposer(t.isLoadingChanged.add(() => this.update())), this.update();
  }
  update() {
    const e = this.annotationStates.changed.count, t = this.annotationStates.isLoading;
    if (this.curGeneration === e && t === this.wasLoading)
      return;
    this.wasLoading = t, this.curGeneration = e;
    const i = this.map;
    let r = false;
    for (const a of this.annotationStates.relationships) {
      let l = i.get(a);
      l === void 0 && (l = this.addRelationship(a), r = true), l.seenGeneration = e;
    }
    if (!t)
      for (const a of i) {
        var s = ce(a, 2);
        const l = s[0];
        s[1].seenGeneration !== e && (i.delete(l), r = true);
      }
    r && this.changed.dispatch();
  }
  addRelationship(e) {
    const t = this.annotationDisplayState.relationshipStates.get(e), i = new hW(this.layerManager.addRef(), HH);
    i.registerDisposer(i.changed.add(() => {
      t.segmentationState.value = i.layerName === void 0 ? void 0 : jH(i.layer);
    }));
    const r = t.showMatches, s = {
      layerRef: i,
      showMatches: r,
      seenGeneration: -1
    };
    return i.changed.add(this.changed.dispatch), r.changed.add(this.changed.dispatch), this.map.set(e, s), s;
  }
  get(e) {
    return this.update(), this.map.get(e);
  }
  unbind(e) {
    e.layerRef.changed.remove(this.changed.dispatch), e.showMatches.changed.remove(this.changed.dispatch);
  }
  reset() {
    for (const e of this.map.values())
      e.showMatches.reset();
  }
  toJSON() {
    const e = this.map;
    if (e.size === 0)
      return {};
    let t;
    const i = [];
    for (const s of e) {
      var r = ce(s, 2);
      const a = r[0], l = r[1];
      l.showMatches.value && i.push(a);
      const d = l.layerRef.layerName;
      d !== void 0 && ((t = t || {})[a] = d);
    }
    return i.sort(), {
      [Xx]: t,
      [Qx]: i.length === 0 ? void 0 : i
    };
  }
  restoreState(e) {
    const t = this.annotationStates.isLoading;
    Ce(e, Xx, (i) => {
      typeof i == "string" && (i = { segments: i }), pe(i);
      for (const s of un(i)) {
        const a = Le(i[s]);
        let l = this.map.get(s);
        if (l === void 0) {
          if (!t)
            continue;
          l = this.addRelationship(s);
        }
        l.layerRef.layerName = a;
      }
      for (const s of this.map) {
        var r = ce(s, 2);
        const a = r[0], l = r[1];
        Object.prototype.hasOwnProperty.call(i, a) || (l.layerRef.layerName = void 0);
      }
    }), Ce(e, Qx, (i) => {
      typeof i == "boolean" && (i = i === true ? ["segments"] : []);
      for (const r of Ci(i)) {
        let s = this.map.get(r);
        if (s === void 0) {
          if (!t)
            continue;
          s = this.addRelationship(r);
        }
        s.showMatches.value = true;
      }
    });
  }
  disposed() {
    const e = this.map;
    for (const t of e.values())
      this.unbind(t);
    e.clear(), super.disposed();
  }
};
var YH = class extends Z {
  constructor(e, t) {
    super(), this.relationship = e, this.state = t, this.element = document.createElement("label"), this.seenGeneration = -1;
    const i = this.element, r = this.registerDisposer(new Rs(t.showMatches)), s = new GH(t.layerRef);
    i.appendChild(r.element), i.appendChild(document.createTextNode(e)), i.appendChild(s.element);
  }
};
var qH = class extends Z {
  constructor(e) {
    super(), this.linkedSegmentationLayers = e, this.widgets = new de(), this.element = document.createElement("div"), this.element.style.display = "contents";
    const t = this.registerCancellable(Ct(() => this.updateView()));
    this.registerDisposer(this.linkedSegmentationLayers.annotationStates.changed.add(t)), this.updateView();
  }
  updateView() {
    const e = this.linkedSegmentationLayers, t = e.annotationStates, i = t.changed.count, r = this.widgets;
    function* s() {
      for (const l of t.relationships) {
        let d = r.get(l);
        d === void 0 && (d = new YH(l, e.get(l))), d.seenGeneration = i, yield d.element;
      }
    }
    for (const l of r) {
      var a = ce(l, 2);
      const d = a[0], u = a[1];
      u.seenGeneration !== i && (u.dispose(), r.delete(d));
    }
    ar(this.element, s.call(this));
  }
  disposed() {
    super.disposed();
    for (const e of this.widgets.values())
      e.dispose();
  }
};
var KH = Qy(al);
var ks = class extends KH {
  constructor(e) {
    super(e), this.annotationProperties = new gt(void 0), this.localAnnotationsJson = void 0, this.pointAnnotationsJson = void 0, this.linkedSegmentationLayers = this.registerDisposer(new JH(this.manager.rootLayers, this.annotationStates, this.annotationDisplayState)), this.linkedSegmentationLayers.changed.add(this.specificationChanged.dispatch), this.annotationDisplayState.ignoreNullSegmentFilter.changed.add(this.specificationChanged.dispatch), this.annotationCrossSectionRenderScaleTarget.changed.add(this.specificationChanged.dispatch), this.tabs.add("rendering", { label: "Rendering", order: -100, getter: () => new XH(this) }), this.tabs.default = "annotations", this.allowingRefresh = true;
  }
  disposed() {
    const e = this.localAnnotations;
    e !== void 0 && e.dispose(), super.disposed();
  }
  restoreState(e) {
    super.restoreState(e), this.linkedSegmentationLayers.restoreState(e), this.localAnnotationsJson = e[gg], this.localAnnotationProperties = Ce(e, jx, x1), this.localAnnotationRelationships = Ce(e, Jx, Ci, ["segments"]), this.pointAnnotationsJson = e[$H], this.annotationCrossSectionRenderScaleTarget.restoreState(e[Yx]), this.annotationProjectionRenderScaleTarget.restoreState(e[qx]), this.annotationDisplayState.ignoreNullSegmentFilter.restoreState(e[eE]), this.annotationDisplayState.shader.restoreState(e[Kx]), this.annotationDisplayState.shaderControls.restoreState(e[Zx]);
  }
  getLegacyDataSourceSpecifications(e, t, i, r) {
    if (Object.prototype.hasOwnProperty.call(t, "source"))
      return super.getLegacyDataSourceSpecifications(e, t, i, r);
    const s = Ce(t, "voxelSize", (l) => at(new Float64Array(3), l, (d) => vn(d) / 1e9)), a = ["m", "m", "m"];
    if (s !== void 0) {
      const l = mt({ rank: 3, units: a, scales: s, names: ["x", "y", "z"] });
      i === void 0 ? i = {
        outputSpace: l,
        sourceRank: 3,
        transform: void 0,
        inputSpace: l
      } : i = RZr(RZr({}, i), { inputSpace: l });
    }
    return [{
      url: lk,
      transform: i,
      enableDefaultSubsources: true,
      subsources: new de()
    }];
  }
  activateDataSubsources(e) {
    var t;
    let i = false, r;
    for (const a of e) {
      const l = a.subsourceEntry, d = l.subsource.local, u = (g) => r !== void 0 && ri(g) !== ri(r) ? (a.deactivate("Annotation properties are not compatible"), false) : (r = g, true);
      if (d === Gr.annotations) {
        if (i) {
          a.deactivate("Only one local annotations source per layer is supported");
          continue;
        }
        if (i = true, !u((t = this.localAnnotationProperties) !== null && t !== void 0 ? t : []))
          continue;
        a.activate((g) => {
          var v;
          const y = this.localAnnotations = new p2(a.loadedDataSource.transform, (v = this.localAnnotationProperties) !== null && v !== void 0 ? v : [], this.localAnnotationRelationships);
          try {
            y.restoreState(this.localAnnotationsJson);
          } catch {
          }
          g.registerDisposer(() => {
            y.dispose(), this.localAnnotations = void 0;
          }), g.registerDisposer(this.localAnnotations.changed.add(this.specificationChanged.dispatch));
          try {
            WH(this.localAnnotations, this.pointAnnotationsJson);
          } catch {
          }
          this.pointAnnotationsJson = void 0, this.localAnnotationsJson = void 0;
          const w = new em({
            localPosition: this.localPosition,
            transform: g.registerDisposer(G1(this.manager.root.coordinateSpace, this.localPosition.coordinateSpace, a.loadedDataSource.transform, void 0)),
            source: y.addRef(),
            displayState: this.annotationDisplayState,
            dataSource: a.loadedDataSource.layerDataSource,
            subsourceIndex: a.subsourceIndex,
            subsourceId: l.id,
            role: Ti.ANNOTATION
          });
          this.addAnnotationLayerState(w, a);
        });
        continue;
      }
      const f = l.subsource.annotation;
      if (f !== void 0) {
        if (!u(f.properties))
          continue;
        a.activate(() => {
          const g = new em({
            localPosition: this.localPosition,
            transform: a.getRenderLayerTransform(),
            source: f,
            displayState: this.annotationDisplayState,
            dataSource: a.loadedDataSource.layerDataSource,
            subsourceIndex: a.subsourceIndex,
            subsourceId: l.id,
            role: Ti.ANNOTATION
          });
          this.addAnnotationLayerState(g, a);
        });
        continue;
      }
      a.deactivate("Not compatible with annotation layer");
    }
    const s = this.annotationProperties.value;
    ri(s) !== ri(r) && (this.annotationProperties.value = r);
  }
  initializeAnnotationLayerViewTab(e) {
    const t = e.registerDisposer(rr((r) => r.some((s) => s.source instanceof Ui), this.annotationStates)), i = e.registerDisposer(new ur(t, (r, s, a) => {
      if (r) {
        {
          const l = a.registerDisposer(new Hm(this.annotationCrossSectionRenderScaleHistogram, this.annotationCrossSectionRenderScaleTarget));
          l.label.textContent = "Spacing (cross section)", s.appendChild(l.element);
        }
        {
          const l = a.registerDisposer(new Hm(this.annotationProjectionRenderScaleHistogram, this.annotationProjectionRenderScaleTarget));
          l.label.textContent = "Spacing (projection)", s.appendChild(l.element);
        }
      }
    }));
    e.element.insertBefore(i.element, e.element.firstChild);
    {
      const r = e.registerDisposer(new Rs(this.annotationDisplayState.ignoreNullSegmentFilter)), s = document.createElement("label");
      s.appendChild(document.createTextNode("Ignore null related segment filter")), s.title = "Display all annotations if filtering by related segments is enabled but no segments are selected", s.appendChild(r.element), e.element.appendChild(s);
    }
    e.element.appendChild(e.registerDisposer(new qH(this.linkedSegmentationLayers)).element);
  }
  toJSON() {
    const e = super.toJSON();
    e[Yx] = this.annotationCrossSectionRenderScaleTarget.toJSON(), e[qx] = this.annotationProjectionRenderScaleTarget.toJSON(), this.localAnnotations !== void 0 ? e[gg] = this.localAnnotations.toJSON() : this.localAnnotationsJson !== void 0 && (e[gg] = this.localAnnotationsJson), e[jx] = h2(this.localAnnotationProperties);
    const t = this.localAnnotationRelationships;
    return e[Jx] = t && t.length === 1 && t[0] === "segments" ? void 0 : t, e[eE] = this.annotationDisplayState.ignoreNullSegmentFilter.toJSON(), e[Kx] = this.annotationDisplayState.shader.toJSON(), e[Zx] = this.annotationDisplayState.shaderControls.toJSON(), RZr(e, this.linkedSegmentationLayers.toJSON()), e;
  }
};
ks.type = "annotation";
ks.typeAbbreviation = "ann";
function lD(n) {
  return new aS({
    shaderError: n.annotationDisplayState.shaderError,
    fragmentMain: n.annotationDisplayState.shader,
    shaderControlState: n.annotationDisplayState.shaderControls
  });
}
var ZH = class extends hf {
  constructor(e) {
    super(), this.layer = e, this.codeWidget = this.registerDisposer(lD(this.layer)), this.content.appendChild(this.codeWidget.element), this.codeWidget.textEditor.refresh();
  }
};
var XH = class extends Kr {
  constructor(e) {
    super(), this.layer = e, this.codeWidget = this.registerDisposer(lD(this.layer));
    const t = this.element;
    t.classList.add("neuroglancer-annotation-rendering-tab"), t.appendChild(this.registerDisposer(new ur(e.annotationProperties, (s, a) => {
      if (s === void 0 || s.length === 0)
        return;
      const l = document.createElement("div");
      a.appendChild(l), l.classList.add("neuroglancer-annotation-shader-property-list");
      for (const d of s) {
        const u = document.createElement("div");
        u.classList.add("neuroglancer-annotation-shader-property");
        const f = document.createElement("span");
        f.classList.add("neuroglancer-annotation-shader-property-type"), f.textContent = d.type;
        const g = document.createElement("span");
        g.classList.add("neuroglancer-annotation-shader-property-identifier"), g.textContent = `prop_${d.identifier}`, u.appendChild(f), u.appendChild(g);
        const v = d.description;
        v !== void 0 && (u.title = v), l.appendChild(u);
      }
    })).element);
    let i = document.createElement("div");
    i.className = "neuroglancer-segmentation-dropdown-skeleton-shader-header";
    let r = document.createElement("div");
    r.style.flex = "1", r.textContent = "Annotation shader:", i.appendChild(r), i.appendChild(sS({
      title: "Show larger editor view",
      onClick: () => {
        new ZH(this.layer);
      }
    })), i.appendChild(iS({
      title: "Documentation on annotation rendering",
      href: "https://github.com/google/neuroglancer/blob/master/src/neuroglancer/annotation/rendering.md"
    })), t.appendChild(i), t.appendChild(this.codeWidget.element), t.appendChild(this.registerDisposer(new oS(e.annotationDisplayState.shaderControls, this.layer.manager.root.display, this.layer, { visibility: this.visibility })).element);
  }
};
ol(ks);
ol(ks, "pointAnnotation");
Gy((n) => {
  if (n.local === Gr.annotations)
    return { layerConstructor: ks, priority: 100 };
  if (n.annotation !== void 0)
    return { layerConstructor: ks, priority: 1 };
});
lS(ks, (n) => ({
  shaderControlState: n.annotationDisplayState.shaderControls
}));
var QH = Object.freeze(Object.defineProperty({
  __proto__: null,
  AnnotationUserLayer: ks
}, Symbol.toStringTag, { value: "Module" }));
var ej = hl(QH);
var tj = hl(sU);
var nj = hl(zH);
var ij = hl(k_);
function rj(n) {
  n.registerEventListener(document, "copy", (e) => {
    if (by(e.target))
      return;
    const t = document.getSelection();
    if (t !== null && t.type === "Range")
      return;
    const i = Wh(n.state).value, r = e.clipboardData;
    r !== null && r.setData("text/plain", se(i, void 0, "  ")), e.preventDefault();
  });
}
function sj(n, e) {
  let t = Ql`^[\[\]{}()\s,]*`;
  for (let s = 0; s < e; ++s)
    s !== 0 && (t += Ql`[,\s]+`), t += Ql`(\d+(?:\.\d+)?)`;
  t += Ql`[\[\]{}()\s,]*$`;
  const i = n.match(t);
  if (i === null)
    return;
  const r = new Float32Array(e);
  for (let s = 0; s < e; ++s) {
    const a = Number(i[s + 1]);
    if (!kt(a))
      return;
    r[s] = a;
  }
  return r;
}
function aj(n) {
  n.registerEventListener(document, "paste", (e) => {
    if (by(e.target))
      return;
    const t = e.clipboardData;
    if (t !== null) {
      const i = t.getData("text/plain"), r = sj(i, n.coordinateSpace.value.rank);
      r !== void 0 && (n.navigationState.position.value = r);
    }
    e.preventDefault();
  });
}
var tE = NZr("SingleTextureVolumeChunk.textureUnit");
var su = NZr("SingleTextureVolumeChunk.textureLayout");
var cD = class extends Z {
  constructor(e, t) {
    super(), this.shaderKey = e, this.dataType = t;
  }
  defineShader(e, t) {
    e.addTextureSampler(this.shaderSamplerType, "uVolumeChunkSampler", tE);
  }
  beginDrawing(e, t) {
    let i = t.textureUnit(tE);
    e.activeTexture(WebGL2RenderingContext.TEXTURE0 + i), t[su] = null;
  }
  endDrawing(e, t) {
    e.bindTexture(Qg[this.shaderSamplerType], null), t[su] = null;
  }
  bindChunk(e, t, i, r, s, a, l) {
    let d = i.textureLayout;
    (t[su] !== d || l) && (t[su] = d, this.setupTextureLayout(e, t, d, r, s, a)), e.bindTexture(Qg[this.shaderSamplerType], i.texture);
  }
  /**
   * Does nothing, but may be overridden by subclass.
   */
  beginSource(e, t) {
  }
};
var dD = class extends PU {
  constructor(e, t) {
    super(e, t), this.texture = null, this.data = t.data;
  }
  copyToGPU(e) {
    super.copyToGPU(e);
    let t = this.texture = e.createTexture();
    const i = Qg[this.chunkFormat.shaderSamplerType];
    e.bindTexture(i, t), this.setTextureData(e), e.bindTexture(i, null);
  }
  freeGPUMemory(e) {
    super.freeGPUMemory(e), e.deleteTexture(this.texture), this.texture = null, this.textureLayout.dispose(), this.textureLayout = null;
  }
};
var oj = class uD extends Z {
  constructor(e, t, i) {
    super(), this.chunkDataSize = t, this.textureDims = i, this.textureShape = new Uint32Array(this.textureDims);
    const r = t.length;
    let s = 0;
    for (const g of t)
      g !== 1 && ++s;
    const a = this.strides = new Uint32Array(r * i), l = i === 3 ? e.max3dTextureSize : e.maxTextureSize;
    let d = 0, u = 1;
    const f = this.textureShape;
    f.fill(1);
    for (let g = 0; g < r; ++g) {
      const v = t[g];
      if (v === 1)
        continue;
      const y = v * u;
      let w;
      y > l || u !== 1 && d + s < i ? (++d, u = v, w = 1) : (w = u, u = y), a[i * g + d] = w, f[d] = u;
    }
  }
  static get(e, t, i) {
    return e.memoize.get(`sliceview.UncompressedTextureLayout:${t.join()}:${i}`, () => new uD(e, t, i));
  }
};
var mg = new Uint32Array(3 * 5);
var lj = class hD extends cD {
  constructor(e, t, i, r) {
    super(i, t), this.textureDims = r, Kc(this, t), this.shaderSamplerType = `${this.samplerPrefix}sampler${r}D`, this.textureAccessHelper = new I3("chunkData", r);
  }
  static get(e, t, i) {
    const r = `sliceview.UncompressedChunkFormat:${t}:${i}`;
    return e.memoize.get(r, () => new hD(e, t, r, i));
  }
  defineShader(e, t) {
    super.defineShader(e, t);
    const i = this.textureDims, r = `ivec${this.textureDims}`;
    let s = this.textureAccessHelper;
    const a = (4 + t) * i;
    mg.length < a && (mg = new Uint32Array(a)), e.addUniform(`highp ${r}`, "uVolumeChunkStrides", 4 + t), e.addFragmentCode(s.getAccessor("readVolumeData", "uVolumeChunkSampler", this.dataType));
    let d = `
${wn(this.dataType)} getDataValueAt(highp ivec3 p`;
    for (let u = 0; u < t; ++u)
      d += `, highp int channelIndex${u}`;
    d += `) {
  highp ${r} offset = uVolumeChunkStrides[0]
                     + p.x * uVolumeChunkStrides[1]
                     + p.y * uVolumeChunkStrides[2]
                     + p.z * uVolumeChunkStrides[3];
`;
    for (let u = 0; u < t; ++u)
      d += `
  offset += channelIndex${u} * uVolumeChunkStrides[${4 + u}];
`;
    d += `
  return readVolumeData(offset);
}
`, e.addFragmentCode(d);
  }
  /**
   * Called each time textureLayout changes while drawing chunks.
   */
  setupTextureLayout(e, t, i, r, s, a) {
    const l = mg, d = a.length, u = i.strides, f = r.length, g = this.textureDims;
    for (let y = 0; y < g; ++y) {
      let w = 0;
      for (let C = 0; C < f; ++C)
        w += r[C] * u[C * g + y];
      l[y] = w;
    }
    for (let y = 0; y < 3; ++y) {
      const w = s[y];
      if (!(w >= f))
        for (let C = 0; C < g; ++C)
          l[(y + 1) * g + C] = u[w * g + C];
    }
    for (let y = 0; y < d; ++y) {
      const w = a[y];
      if (w === -1)
        l.fill(0, (4 + y) * g, (4 + y + 1) * g);
      else
        for (let C = 0; C < g; ++C)
          l[(4 + y) * g + C] = u[w * g + C];
    }
    const v = (4 + d) * g;
    g === 3 ? e.uniform3iv(t.uniform("uVolumeChunkStrides"), l, 0, v) : e.uniform2iv(t.uniform("uVolumeChunkStrides"), l, 0, v);
  }
  getTextureLayout(e, t) {
    return oj.get(e, t, this.textureDims);
  }
  setTextureData(e, t, i) {
    const r = t.textureShape;
    (this.textureDims === 3 ? T3 : E3)(e, this, i, r[0], r[1], r[2]);
  }
};
var cj = class extends dD {
  setTextureData(e) {
    let t = this.source, i = t.chunkFormatHandler, r = i.chunkFormat, s;
    this.chunkDataSize === t.spec.chunkDataSize ? this.textureLayout = s = i.textureLayout.addRef() : this.textureLayout = s = r.getTextureLayout(e, this.chunkDataSize), this.chunkFormat.setTextureData(e, s, this.data);
  }
  getValueAt(e) {
    let t = this.chunkFormat;
    const i = this.chunkDataSize;
    let r = 0, s = 1;
    const a = e.length;
    for (let u = 0; u < a; ++u)
      r += s * e[u], s *= i[u];
    let l = t.dataType, d = this.data;
    switch (l) {
      case J.UINT8:
      case J.INT8:
      case J.FLOAT32:
      case J.UINT16:
      case J.INT16:
      case J.UINT32:
      case J.INT32:
        return d[r];
      case J.UINT64: {
        let u = r * 2;
        return new re(d[u], d[u + 1]);
      }
    }
  }
};
var dj = class extends Z {
  constructor(e, t) {
    super();
    let i = 0;
    for (const r of t.chunkDataSize)
      r > 1 && ++i;
    this.chunkFormat = this.registerDisposer(lj.get(e, t.dataType, i >= 3 ? 3 : 2)), this.textureLayout = this.registerDisposer(this.chunkFormat.getTextureLayout(e, t.chunkDataSize));
  }
  getChunk(e, t) {
    return new cj(e, t);
  }
};
rI((n, e) => e.compressedSegmentationBlockSize == null ? new dj(n, e) : null);
function fD(n, e, t, i, r, s) {
  let a = 0, l = 0, d = 1, u = 1;
  for (let C = 0; C < 3; ++C) {
    let b = r[C], E = i[C], L = Math.floor(b / E), R = b % E;
    a += L * d, d *= Math.ceil(t[C] / E), l += R * u, u *= E;
  }
  let f = e + a * 2, g = n[f], v = n[f + 1], y = g & 16777215, w = g >> 24 & 255;
  if (w > 0) {
    let b = (e + v & 16777215) + Math.floor(l * w / 32), E = n[b], L = l * w % 32, R = E >> L & (1 << w) - 1;
    y += s * R;
  }
  return y;
}
function uj(n, e, t, i, r) {
  let s = fD(n, e, t, i, r, 1) + e;
  return n[s];
}
function hj(n, e, t, i, r, s) {
  let a = fD(e, t, i, r, s, 2) + t;
  return n.low = e[a], n.high = e[a + 1], n;
}
var uS = class _uS extends Z {
  constructor(e, t) {
    super(), this.chunkDataSize = e, this.subchunkSize = t;
    const i = this.subchunkGridSize = _e();
    for (let r = 0; r < 3; ++r)
      i[r] = Math.ceil(e[r] / t[r]);
  }
  static get(e, t, i) {
    return e.memoize.get(`sliceview.CompressedSegmentationTextureLayout:${Ng(t)},${Ng(i)}`, () => new _uS(t, i));
  }
};
var fj = Kc(new jh(), J.UINT32);
var vg = new Uint32Array(4 * 4);
var hS = class _hS extends cD {
  constructor(e, t, i, r) {
    super(r, e), this.subchunkSize = t, this.numChannels = i, this.textureAccessHelper = new vy("chunkData");
  }
  // numChannels is the number of channels in the compressed segmentation format, which is
  // independent of the channel dimensions presented to the user.
  static get(e, t, i, r) {
    let s = `sliceview.CompressedSegmentationChunkFormat:${t}:${r}`, a = `${s}:${Ng(i)}`;
    return e.memoize.get(a, () => new _hS(t, i, r, s));
  }
  get shaderSamplerType() {
    return "usampler2D";
  }
  defineShader(e, t) {
    super.defineShader(e, t);
    const i = 4 * (4 + t);
    vg.length < i && (vg = new Uint32Array(i));
    let r = this.textureAccessHelper;
    r.defineShader(e);
    let s = (u) => "compressedSegmentationChunkFormat_" + u;
    e.addUniform("highp ivec3", "uSubchunkGridSize"), e.addUniform("highp ivec3", "uSubchunkSize"), e.addUniform("highp ivec4", "uVolumeChunkStrides", 4 + t), e.addFragmentCode(_V);
    const a = this.dataType, l = wn(a);
    a === J.UINT64 ? e.addFragmentCode(Ht) : e.addFragmentCode(Zv), e.addFragmentCode(r.getAccessor(s("readTextureValue"), "uVolumeChunkSampler", J.UINT32, 1));
    let d = `
uint ${s("getChannelOffset")}(int channelIndex) {
  if (channelIndex == 0) {
    return ${this.numChannels}u;
  }
  return ${s("readTextureValue")}(uint(channelIndex)).value;
}
${l} getDataValueAt(highp ivec3 p`;
    for (let u = 0; u < t; ++u)
      d += `, highp int channelIndex${u}`;
    d += `) {
  highp ivec4 chunkPositionFull = uVolumeChunkStrides[0] +
                     + p.x * uVolumeChunkStrides[1]
                     + p.y * uVolumeChunkStrides[2]
                     + p.z * uVolumeChunkStrides[3];
`;
    for (let u = 0; u < t; ++u)
      d += `
  chunkPositionFull += channelIndex${u} * uVolumeChunkStrides[${4 + u}];
`;
    d += `
  highp ivec3 chunkPosition = chunkPositionFull.xyz;

  // TODO: maybe premultiply this and store as uniform.
  ivec3 subchunkGridPosition = chunkPosition / uSubchunkSize;
  int subchunkGridOffset = getFortranOrderIndex(subchunkGridPosition, uSubchunkGridSize);

  int channelOffset = int(${s("getChannelOffset")}(chunkPositionFull[3]));

  // TODO: Maybe just combine this offset into subchunkGridStrides.
  int subchunkHeaderOffset = subchunkGridOffset * 2 + channelOffset;

  highp uint subchunkHeader0 = ${s("readTextureValue")}(uint(subchunkHeaderOffset)).value;
  highp uint subchunkHeader1 = ${s("readTextureValue")}(uint(subchunkHeaderOffset + 1)).value;
  highp uint outputValueOffset = (subchunkHeader0 & 0xFFFFFFu) + uint(channelOffset);
  highp uint encodingBits = subchunkHeader0 >> 24u;
  if (encodingBits > 0u) {
    ivec3 subchunkPosition = chunkPosition - subchunkGridPosition * uSubchunkSize;
    int subchunkOffset = getFortranOrderIndex(subchunkPosition, uSubchunkSize);
    uint encodedValueBaseOffset = subchunkHeader1 + uint(channelOffset);
    uint encodedValueOffset = encodedValueBaseOffset + uint(subchunkOffset) * encodingBits / 32u;
    uint encodedValue = ${s("readTextureValue")}(encodedValueOffset).value;
    uint wordOffset = uint(subchunkOffset) * encodingBits % 32u;
    uint encodedValueShifted = encodedValue >> wordOffset;
    uint decodedValue = encodedValueShifted - (encodedValueShifted >> encodingBits << encodingBits);
    outputValueOffset += decodedValue * ${this.dataType === J.UINT64 ? "2u" : "1u"};
  }
  ${l} result;
`, a === J.UINT64 ? d += `
  result.value[0] = ${s("readTextureValue")}(outputValueOffset).value;
  result.value[1] = ${s("readTextureValue")}(outputValueOffset+1u).value;
` : d += `
  result.value = ${s("readTextureValue")}(outputValueOffset).value;
`, d += `
  return result;
}
`, e.addFragmentCode(d);
  }
  /**
   * Called each time textureLayout changes while drawing chunks.
   *
   * @param channelDimensions The user-specified channel dimensions, independent of the compressed
   * segmentation channels.
   */
  setupTextureLayout(e, t, i, r, s, a) {
    const l = i.subchunkGridSize;
    e.uniform3i(t.uniform("uSubchunkGridSize"), l[0], l[1], l[2]);
    const d = vg, u = a.length;
    d.fill(0);
    for (let f = 0; f < 3; ++f) {
      d[f] = r[f];
      const g = s[f];
      g !== -1 && (d[4 * (f + 1) + g] = 1);
    }
    for (let f = 0; f < u; ++f) {
      const g = a[f];
      g !== -1 && (d[4 * (4 + f) + g] = 1);
    }
    e.uniform4iv(t.uniform("uVolumeChunkStrides"), d, 0, (u + 4) * 4);
  }
  setTextureData(e, t, i) {
    my(e, fj, i);
  }
  getTextureLayout(e, t) {
    return uS.get(e, t, this.subchunkSize);
  }
  beginSource(e, t) {
    super.beginSource(e, t);
    const i = this.subchunkSize;
    e.uniform3i(t.uniform("uSubchunkSize"), i[0], i[1], i[2]);
  }
};
var pj = class extends dD {
  setTextureData(e) {
    let t = this.data, i = this.chunkFormat, r = this.textureLayout = i.getTextureLayout(e, this.chunkDataSize);
    i.setTextureData(e, r, t);
  }
  getValueAt(e) {
    let t = this.chunkDataSize, i = this.chunkFormat, r = this.data, s = r[e[3] || 0];
    if (i.dataType === J.UINT64) {
      let a = new re();
      return hj(
        a,
        r,
        /*baseOffset=*/
        s,
        t,
        i.subchunkSize,
        e
      ), a;
    } else
      return uj(
        r,
        /*baseOffset=*/
        s,
        t,
        i.subchunkSize,
        e
      );
  }
};
var gj = class extends Z {
  constructor(e, t) {
    super();
    let i = t.dataType;
    if (i !== J.UINT64 && i !== J.UINT32)
      throw new Error(`Unsupported compressed segmentation data type: ${J[i]}`);
    this.chunkFormat = this.registerDisposer(hS.get(e, t.dataType, t.compressedSegmentationBlockSize, t.chunkDataSize[3] || 1));
  }
  getChunk(e, t) {
    return new pj(e, t);
  }
};
rI((n, e) => e.compressedSegmentationBlockSize != null ? new gj(n, e) : null);
function mj(n, e = document.getElementById("neuroglancer-container")) {
  try {
    let t = new gO(e);
    return new eW(t, n);
  } catch (t) {
    throw nt.showMessage(`Error: ${t.message}`), t;
  }
}
function vj(n = document) {
  return Vi(n, "contextmenu", (e) => {
    e.preventDefault();
  });
}
var fS = "DVID";
function pS(n) {
  return n.text();
}
function yj(n, e = Zt) {
  const t = `${n.url}`, i = { method: n.method, body: n.payload };
  return n.responseType === "" ? lr(t, i, pS, e) : n.responseType === "arraybuffer" ? lr(t, i, of, e) : lr(t, i, Hi, e);
}
function Sj(n, e, t = Zt) {
  return bj(n, e.url, { method: e.method, body: e.payload }, e.responseType === "" ? pS : e.responseType === "json" ? Hi : of, t);
}
function bj(n, e, t, i, r = Zt) {
  return _y(n, e, t, i, (s, a) => {
    const l = RZr({}, a);
    return s.token && (l.headers = RZr(RZr({}, l.headers), { Authorization: `Bearer ${s}` })), l;
  }, (s) => {
    if (s.status === 504)
      return "retry";
    throw s;
  }, r);
}
async function Cj(n, e = Zt) {
  return { token: await lr(n, { method: "GET", credentials: "include" }, pS, e) };
}
var wj = class extends id {
  constructor(e) {
    super(), this.authServer = e, this.get = nf((t) => {
      if (!this.authServer)
        return Bt.resolve({ token: "" });
      const i = new nt(
        /*delay=*/
        true
      );
      let r;
      return new Bt((s, a) => {
        const l = () => {
          r = void 0, i.dispose();
        };
        t.add(() => {
          r !== void 0 && (r.cancel(), r = void 0, i.dispose(), a(Ts));
        });
        function d(f, g = "DVID authorization required.", v = "Request authorization.") {
          i.setText(g + " ");
          let y = document.createElement("button");
          y.textContent = v, i.element.appendChild(y), y.addEventListener("click", () => {
            let w = f.match(/^[^\/]+\/\/[^\/\.]+\.([^\/]+)/);
            if (w) {
              const C = `https://flyemlogin.${w[1]}/login`;
              window.alert(`Please log into ${C} and then refresh the neurogalncer page to try again.
If you are unable to log into ${C}, please check your authorization server ${f} to make sure it is correct.`);
            } else
              window.alert(`Please check your authorization server ${f} to make sure it is correct.`);
          }), i.setVisible(true);
        }
        function u(f) {
          r !== void 0 && r.cancel(), r = new As(), d(f, "Waiting for DVID authorization...", "Retry"), Cj(f, r).then((g) => {
            r !== void 0 && (l(), s(g));
          }, (g) => {
            r !== void 0 && (r = void 0, d(f, `DVID authorization failed: ${g}.`, "Retry"));
          });
        }
        u(this.authServer);
      });
    });
  }
};
var xj = class extends bz {
  constructor(e, t) {
    super(new wj(t), {});
  }
};
il.register(fS, (n) => new xj(n.dvidServer, n.authServer));
var Ej = "CredentialsProvider";
var Tj = "CredentialsProvider.get";
var kj = globalThis && globalThis.__decorate || function(n, e, t, i) {
  var r = arguments.length, s = r < 3 ? e : i === null ? i = $i(e, t) : i, a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(n, e, t, i);
  else
    for (var l = n.length - 1; l >= 0; l--)
      (a = n[l]) && (s = (r < 3 ? a(s) : r > 3 ? a(e, t, s) : a(e, t)) || s);
  return r > 3 && s && UZr(e, t, s), s;
};
var rv = class extends hr {
  constructor(e, t) {
    super(), this.provider = e, this.registerDisposer(e), this.initializeCounterpart(t);
  }
  get(e, t) {
    return this.provider.get(e, t);
  }
};
rv = kj([ki(Ej)], rv);
gT(Tj, function(n, e) {
  return this.get(n.providerId).get(n.invalidCredentials, e).then((i) => ({
    value: i
  }));
});
function Ij(n, e) {
  if (e === void 0)
    return;
  const t = n.memoize.get({ type: "getSharedCredentialsProvider", credentialsProvider: xn(e) }, () => new rv(e.addRef(), n.rpc)), i = t.addCounterpartRef();
  return t.dispose(), i;
}
function Jt() {
  return function(n) {
    class e extends n {
      constructor(...i) {
        var r;
        super(...i);
        const s = i[1];
        this.credentialsProvider = (r = s.credentialsProvider) === null || r === void 0 ? void 0 : r.addRef();
      }
      initializeCounterpart(i, r) {
        const s = this.credentialsProvider;
        r.credentialsProvider = Ij(this.chunkManager, s), super.initializeCounterpart(i, r);
      }
      static encodeOptions(i) {
        const r = super.encodeOptions(i), s = i.credentialsProvider;
        return r.credentialsProvider = s === void 0 ? void 0 : xn(s), r;
      }
    }
    return e;
  };
}
var Lj = St(128, 128, 128);
var yi;
(function(n) {
  n[n.JPEG = 0] = "JPEG", n[n.RAW = 1] = "RAW", n[n.COMPRESSED_SEGMENTATION = 2] = "COMPRESSED_SEGMENTATION", n[n.COMPRESSED_SEGMENTATIONARRAY = 3] = "COMPRESSED_SEGMENTATIONARRAY";
})(yi || (yi = {}));
var ff = class {
};
var pD = class extends ff {
};
pD.RPC_ID = "dvid/VolumeChunkSource";
var gD = class extends ff {
};
gD.RPC_ID = "dvid/SkeletonSource";
var mD = class extends ff {
};
mD.RPC_ID = "dvid/MeshSource";
var vD = class extends ff {
  constructor() {
    super(...arguments), this.chunkDataSize = Lj;
  }
};
var gS = class extends vD {
};
gS.RPC_ID = "dvid/AnnotationSource";
var yD = class extends vD {
};
yD.RPC_ID = "dvid/AnnotationChunkSource";
var SD = class {
  constructor(e, t) {
    this.numLevels = 1;
    try {
      if (pe(e), t === "dvid") {
        let i = K(e, "Extended", pe);
        if (i.MaxDownresLevel) {
          let r = K(i, "MaxDownresLevel", dn);
          this.numLevels = r + 1;
        }
        this.voxelSize = K(i, "VoxelSize", (r) => Qs(_e(), r)), this.upperVoxelBound = K(i, "MaxPoint", (r) => Qs(_e(), r.map((s) => ++s))), this.lowerVoxelBound = K(i, "MinPoint", (r) => Qs(_e(), r)), this.blockSize = K(i, "BlockSize", (r) => Qs(_e(), r));
      } else if (t === "gs") {
        pe(e);
        const i = K(e, "scales", (a) => a);
        if (i.length === 0)
          throw new Error("Expected at least one scale");
        const r = i[0];
        this.voxelSize = K(r, "resolution", (a) => go(_e(), a)), this.lowerVoxelBound = Ce(r, "offset", (a) => Qs(_e(), a)) || St(0, 0, 0);
        const s = K(r, "size", (a) => Qs(_e(), a));
        this.upperVoxelBound = $E(_e(), s, this.lowerVoxelBound), this.blockSize = St(64, 64, 64);
      } else
        throw new Error("unrecognized volume info");
    } catch (i) {
      throw new Error(`Failed to parse volume geometry: ${i.message}`);
    }
  }
};
var Dj = class {
  constructor(e) {
    try {
      this.scales = [], this.scales.push(e);
      let t = e.voxelSize, i = e.lowerVoxelBound, r = e.upperVoxelBound;
      for (let s = 1; s < e.numLevels; ++s) {
        let a = RZr({}, e);
        a.voxelSize = HE(_e(), t, St(2, 2, 2)), t = a.voxelSize, a.upperVoxelBound = Ub(_e(), Dg(_e(), r, St(2, 2, 2))), r = a.upperVoxelBound, a.lowerVoxelBound = Ub(_e(), Dg(_e(), i, St(2, 2, 2))), i = a.lowerVoxelBound, this.scales.push(a);
      }
    } catch (t) {
      throw new Error(`Failed to parse multiscale volume specification: ${t.message}`);
    }
  }
  get numChannels() {
    return this.scales.length === 0 ? 0 : this.scales[0].numChannels;
  }
};
var pf = new de();
pf.set("uint8", J.UINT8);
pf.set("uint32", J.UINT32);
pf.set("uint64", J.UINT64);
var bD = class {
  constructor(e) {
    this.obj = e, pe(e), K(e, "TypeName", Le);
  }
  get typeName() {
    return this.obj.TypeName;
  }
  get compressionName() {
    return this.obj.Compression;
  }
  get tags() {
    return this.obj.Tags;
  }
};
var CD = class {
  constructor(e, t, i) {
    this.name = t, this.base = i, this.volumeInfo = new SD(Mj(i.tags, e), "dvid");
  }
  get lowerVoxelBound() {
    return this.volumeInfo.lowerVoxelBound;
  }
  get upperVoxelBound() {
    return this.volumeInfo.upperVoxelBound;
  }
  get blockSize() {
    return this.volumeInfo.blockSize;
  }
  get voxelSize() {
    return this.volumeInfo.voxelSize;
  }
  get numLevels() {
    return this.volumeInfo.numLevels;
  }
};
var Pj = class extends jt(Jt()(td), pD) {
};
var Aj = class extends jt(Jt()(ef), gD) {
};
var Rj = class extends jt(Jt()(Zc), mD) {
};
var bu = class extends CD {
  constructor(e, t, i, r, s) {
    super(e, t, i), this.encoding = r;
    let a = K(e, "Extended", pe), l = K(a, "Values", (u) => Je(u, pe));
    if (l.length < 1)
      throw new Error("Expected Extended.Values property to have length >= 1, but received: ${JSON.stringify(extendedValues)}.");
    let d = new je(s);
    if (r !== yi.COMPRESSED_SEGMENTATIONARRAY)
      for (; d.has(t + "_" + this.volumeInfo.numLevels.toString()); )
        this.volumeInfo.numLevels += 1;
    d.has(t + "_meshes") ? this.meshSrc = t + "_meshes" : this.meshSrc = "", d.has(t + "_skeletons") ? this.skeletonSrc = t + "_skeletons" : this.skeletonSrc = "", this.dataType = K(l[0], "DataType", (u) => Lv(u, pf));
  }
  get volumeType() {
    return this.encoding === yi.COMPRESSED_SEGMENTATION || this.encoding === yi.COMPRESSED_SEGMENTATIONARRAY ? Dn.SEGMENTATION : Dn.IMAGE;
  }
  getSources(e, t, i, r) {
    const s = this.encoding, a = [], l = 64;
    for (let d = 0; d < this.numLevels; ++d) {
      const u = Math.pow(2, d), f = Math.pow(2, -d), g = _e(), v = _e();
      for (let E = 0; E < 3; ++E) {
        const L = Math.floor(this.lowerVoxelBound[E] * f);
        g[E] = L - L % l;
        const R = Math.ceil(this.upperVoxelBound[E] * f);
        v[E] = R, R % l !== 0 && (v[E] += l - R % l);
      }
      let y = t.dataInstanceKey;
      s !== yi.COMPRESSED_SEGMENTATIONARRAY && d > 0 && (y += "_" + d.toString());
      const w = RZr(RZr({}, t), { dataInstanceKey: y, dataScale: d.toString(), encoding: s }), C = et();
      for (let E = 0; E < 3; ++E)
        C[5 * E] = u, C[12 + E] = g[E] * u;
      const b = rd({
        rank: 3,
        chunkToMultiscaleTransform: C,
        dataType: this.dataType,
        baseVoxelOffset: g,
        upperVoxelBound: WE(_e(), v, g),
        volumeType: this.volumeType,
        volumeSourceOptions: i,
        compressedSegmentationBlockSize: s === yi.COMPRESSED_SEGMENTATION || s === yi.COMPRESSED_SEGMENTATIONARRAY ? St(8, 8, 8) : void 0
      }).map((E) => ({
        chunkSource: e.getChunkSource(Pj, { spec: E, parameters: w, credentialsProvider: r }),
        chunkToMultiscaleTransform: C
      }));
      a.push(b);
    }
    return Rc(a);
  }
};
function wD(n) {
  let e = K(n, "Base", pe), t = K(e, "Syncs", Ci);
  return t.length === 1 ? t[0] : "";
}
function Mj(n, e) {
  if (!n)
    return e;
  const t = e && e.Extended || {};
  let i = t.MaxDownresLevel, r = t.MaxPoint, s = t.MinPoint, a = t.VoxelSize, l = t.BlockSize;
  try {
    n.MaxDownresLevel && typeof n.MaxDownresLevel == "string" ? (i = parseInt(K(n, "MaxDownresLevel", Le)), i < 0 && (i = t.MaxDownresLevel)) : typeof n.MaxDownresLevel == "number" && (i = K(n, "MaxDownresLevel", g1));
  } catch {
  }
  try {
    n.MaxPoint && typeof n.MaxPoint == "string" ? r = JSON.parse(K(n, "MaxPoint", Le)) : Array.isArray(n.MaxPoint) && n.MaxPoint.length === 3 && (r = n.MaxPoint);
  } catch {
  }
  try {
    n.MinPoint && typeof n.MinPoint == "string" ? s = JSON.parse(K(n, "MinPoint", Le)) : Array.isArray(n.MinPoint) && n.MinPoint.length === 3 && (s = n.MinPoint);
  } catch {
  }
  try {
    n.VoxelSize && typeof n.VoxelSize == "string" ? a = JSON.parse(K(n, "VoxelSize", Le)) : Array.isArray(n.VoxelSize) && n.VoxelSize.length === 3 && (a = n.VoxelSize);
  } catch {
  }
  try {
    n.BlockSize && typeof n.BlockSize == "string" ? l = JSON.parse(K(n, "BlockSize", Le)) : Array.isArray(n.BlockSize) && n.BlockSize.length === 3 && (l = n.BlockSize);
  } catch {
  }
  return {
    Base: e && e.Base || {},
    Extended: RZr(RZr({}, t), {
      VoxelSize: a,
      MinPoint: s,
      MaxPoint: r,
      MaxDownresLevel: i,
      BlockSize: l
    })
  };
}
var xD = class extends CD {
  get tags() {
    return K(this.base.obj, "Tags", pe);
  }
  constructor(e, t, i) {
    super(e, t, i);
  }
};
function Nj(n, e, t) {
  pe(n);
  let i = n[e], r = K(i, "Base", (s) => new bD(s));
  if (r.typeName === "annotation") {
    let s = wD(i);
    return s && (i = n[s]), new xD(i, e, r);
  }
  return _j(i, e, t);
}
function _j(n, e, t) {
  pe(n);
  let i = K(n, "Base", (r) => new bD(r));
  switch (i.typeName) {
    case "uint8blk":
    case "grayscale8":
      let r = i.compressionName.indexOf("jpeg") !== -1;
      return new bu(n, e, i, r ? yi.JPEG : yi.RAW, t);
    case "labels64":
    case "labelblk":
      return new bu(n, e, i, yi.COMPRESSED_SEGMENTATION, t);
    case "labelarray":
    case "labelmap":
      return new bu(n, e, i, yi.COMPRESSED_SEGMENTATIONARRAY, t);
    default:
      throw new Error(`DVID data type ${se(i.typeName)} is not supported.`);
  }
}
var dh = class _dh {
  constructor(e) {
    if (this.errors = [], this.dataInstances = new de(), this.vnodes = new je(), e instanceof _dh) {
      this.alias = e.alias, this.description = e.description, this.errors = e.errors, this.dataInstances = e.dataInstances;
      return;
    }
    pe(e), this.alias = K(e, "Alias", Le), this.description = K(e, "Description", Le);
    let t = K(e, "DataInstances", pe), i = un(t);
    for (let a of i)
      try {
        this.dataInstances.set(a, Nj(t, a, i));
      } catch (l) {
        let d = `Failed to parse data instance ${se(a)}: ${l.message}`;
        console.log(d), this.errors.push(d);
      }
    let r = K(e, "DAG", pe), s = K(r, "Nodes", pe);
    for (let a of un(s))
      this.vnodes.add(a);
  }
};
function Oj(n) {
  try {
    let i = Dh(n, (s) => new dh(s)), r = new de();
    for (let s of i) {
      var e = ce(s, 2);
      let a = e[0], l = e[1];
      r.set(a, l);
      for (let d of l.vnodes)
        if (d !== a) {
          let u = new dh(l);
          r.set(d, u);
        }
    }
    for (let s of r) {
      var t = ce(s, 2);
      let a = t[0], l = t[1];
      l.uuid = a;
    }
    return r;
  } catch (i) {
    throw new Error(`Failed to parse DVID repositories info: ${i.message}`);
  }
}
var Vj = class {
  constructor(e) {
    this.repositories = Oj(e);
  }
  getNode(e) {
    let t = [];
    for (let i of this.repositories.keys())
      i.startsWith(e) && t.push(i);
    if (t.length !== 1)
      throw new Error(`Node key ${se(e)} matches ${se(t)} nodes.`);
    return this.repositories.get(t[0]);
  }
};
function ED(n, e, t) {
  return n.memoize.getUncounted({ type: "dvid:getServerInfo", baseUrl: e }, () => {
    const i = Sj(t, { url: `${e}/api/repos/info`, method: "GET", responseType: "json" }).then((s) => new Vj(s)), r = `repository info for DVID server ${e}`;
    return nt.forPromise(i, {
      initialMessage: `Retrieving ${r}.`,
      delay: true,
      errorPrefix: `Error retrieving ${r}: `
    }), i;
  });
}
var Bj = class extends _s {
  constructor(e, t, i, r) {
    super(e), this.sourceParameters = t, this.info = i, this.credentialsProvider = r;
  }
  get dataType() {
    return this.info.dataType;
  }
  get volumeType() {
    return this.info.volumeType;
  }
  get rank() {
    return 3;
  }
  get baseUrl() {
    return this.sourceParameters.baseUrl;
  }
  get nodeKey() {
    return this.sourceParameters.nodeKey;
  }
  get dataInstanceKey() {
    return this.sourceParameters.dataInstanceKey;
  }
  get supervoxels() {
    return this.sourceParameters.supervoxels || false;
  }
  getSegmentPosition(e) {
    const t = this.sourceParameters.dvidService;
    return t ? fetch(`${t}/locate-body?dvid=${this.baseUrl}&uuid=${this.nodeKey}&segmentation=${this.dataInstanceKey}&body=${e.toString()}${this.supervoxels ? "&supervoxels=true" : ""}`, {
      method: "GET"
    }).then((i) => i.json()).then((i) => new Float32Array(i)) : Bt.reject("No locate service is available");
  }
  getSources(e) {
    return this.info.getSources(this.chunkManager, this.sourceParameters, e, this.credentialsProvider);
  }
};
var Fj = /^((?:http|https):\/\/[^\/]+)\/([^\/]+)\/([^\/\?#]+)(?:(?:\?|#)(.*))?$/;
function TD(n) {
  if (n.startsWith("https"))
    return n + "/api/server/token";
}
function Uj(n) {
  let e = n.match(Fj);
  if (e === null)
    throw new Error(`Invalid DVID URL: ${se(n)}.`);
  let t = {
    baseUrl: e[1],
    nodeKey: e[2],
    dataInstanceKey: e[3]
  };
  const i = e[4];
  if (i) {
    const r = Yo(i);
    r.usertag === "true" && (t.usertag = true), r.user && (t.user = r.user);
    const s = r.dvidService || r.dvidservice || r["dvid-service"];
    s && (t.dvidService = s), (r.forceDvidService || r.forcedividservice || r["force-dvid-service"]) && (t.forceDvidService = true), t.supervoxels = r.supervoxels === "true";
  }
  return t.authServer = TD(t.baseUrl), t;
}
function zj(n, e, t) {
  return n.usertag ? l_(_e(), t, e) : n.chunkDataSize;
}
function Gj(n, e) {
  let i = (r) => {
    const s = r.lowerVoxelBound, a = r.upperVoxelBound, l = zj(e, s, a);
    return { spec: Gc({
      rank: 3,
      chunkDataSize: Uint32Array.from(l),
      lowerVoxelBound: s,
      upperVoxelBound: a
    }), chunkToMultiscaleTransform: et() };
  };
  if (e.usertag) {
    if (e.user)
      return [[i(n.scales[0])]];
    throw "Expecting a valid user";
  } else
    return [n.scales.map((r) => i(r))];
}
var $j = jt(Jt()(Ui), gS);
var Wj = class extends jt(Jt()(No), yD) {
};
var Hj = class extends $j {
  constructor(e, t) {
    super(e, RZr({ rank: 3, relationships: ["segments"], properties: t.parameters.properties }, t)), this.readonly = false, this.parameters = t.parameters, this.multiscaleVolumeInfo = t.multiscaleVolumeInfo, this.childAdded = this.childAdded || new ot(), this.childUpdated = this.childUpdated || new ot(), this.childDeleted = this.childDeleted || new ot(), this.childRefreshed = this.childRefreshed || new Ee(), this.parameters.readonly !== void 0 && (this.readonly = this.parameters.readonly), this.parameters.user || (this.readonly = true);
  }
  getSources(e) {
    let t = Gj(this.multiscaleVolumeInfo, this.parameters), i = 0;
    return t[0].length > 1 && (i = 3), this.chunkSources = t.map((r) => r.map(({ spec: s, chunkToMultiscaleTransform: a }) => ({
      chunkSource: this.chunkManager.getChunkSource(Wj, {
        spec: RZr({ limit: i, chunkToMultiscaleTransform: a }, s),
        parent: this,
        credentialsProvider: this.credentialsProvider,
        parameters: this.parameters
      }),
      chunkToMultiscaleTransform: a
    }))), this.chunkSources;
  }
  invalidateCache() {
    this.metadataChunkSource.invalidateCache();
    for (let e of this.chunkSources)
      for (let t of e)
        t.chunkSource.invalidateCache();
    for (let e of this.segmentFilteredSources)
      e.invalidateCache();
    this.childRefreshed.dispatch();
  }
};
async function jj(n, e, t, i) {
  let r = (a, l) => n.chunkManager.getChunkSource(Hj, {
    parameters: l,
    credentialsProvider: i,
    multiscaleVolumeInfo: a
  }), s = new Dj(t.volumeInfo);
  return r(s, e);
}
async function Jj(n, e, t, i) {
  const r = {
    lowerBounds: new Float64Array(t.lowerVoxelBound),
    upperBounds: Float64Array.from(t.upperVoxelBound)
  }, s = mt({
    rank: 3,
    names: ["x", "y", "z"],
    units: ["m", "m", "m"],
    scales: Float64Array.from(t.voxelSize, (d) => d / 1e9),
    boundingBoxes: [Sa(r)]
  }), a = await jj(n, e, t, i);
  return {
    modelTransform: Qn(s),
    subsources: [{
      id: "default",
      subsource: { annotation: a },
      default: true
    }]
  };
}
function Yj(n, e, t, i) {
  const r = t, s = {
    lowerBounds: new Float64Array(r.lowerVoxelBound),
    upperBounds: Float64Array.from(r.upperVoxelBound)
  }, a = mt({
    rank: 3,
    names: ["x", "y", "z"],
    units: ["m", "m", "m"],
    scales: Float64Array.from(r.voxelSize, (u) => u / 1e9),
    boundingBoxes: [Sa(s)]
  }), l = new Bj(n.chunkManager, e, r, i), d = {
    modelTransform: Qn(a),
    subsources: [{
      id: "default",
      subsource: { volume: l },
      default: true
    }]
  };
  if (r.meshSrc) {
    const u = et();
    for (let f = 0; f < 3; ++f)
      u[5 * f] = 1 / r.voxelSize[f];
    d.subsources.push({
      id: "meshes",
      default: true,
      subsource: {
        mesh: n.chunkManager.getChunkSource(Rj, {
          parameters: RZr(RZr({}, e), { segmentationName: r.name, dataInstanceKey: r.meshSrc }),
          credentialsProvider: i
        })
      },
      subsourceToModelSubspaceTransform: u
    });
  }
  return r.skeletonSrc && d.subsources.push({
    id: "skeletons",
    default: true,
    subsource: {
      mesh: n.chunkManager.getChunkSource(Aj, {
        parameters: RZr(RZr({}, e), { dataInstanceKey: r.skeletonSrc }),
        credentialsProvider: i
      })
    }
  }), d.subsources.push({
    id: "bounds",
    subsource: { staticAnnotations: Bc(s) },
    default: true
  }), d;
}
function qj(n) {
  return n.chunkManager.memoize.getUncounted({
    type: "dvid:MultiscaleVolumeChunkSource",
    sourceUrl: n.providerUrl
  }, async () => {
    const e = Uj(n.providerUrl), t = e.baseUrl, i = e.nodeKey, r = e.dataInstanceKey, s = i.indexOf(":"), a = s !== -1 ? i.slice(0, s) : i, l = n.credentialsManager.getCredentialsProvider(fS, { dvidServer: e.baseUrl, authServer: e.authServer }), u = (await ED(n.chunkManager, t, l)).getNode(a);
    if (u === void 0)
      throw new Error(`Invalid node: ${se(i)}.`);
    const f = u.dataInstances.get(r);
    if (!f)
      throw new Error(`Invalid data instance ${r}.`);
    if (f.base.typeName === "annotation") {
      if (!(f instanceof xD))
        throw new Error(`Invalid data instance ${r}.`);
      let g = RZr(RZr({}, new gS()), e);
      return f.blockSize && (g.chunkDataSize = f.blockSize), g.syncedLabel = wD({ Base: f.base.obj }), g.properties = [{
        identifier: "rendering_attribute",
        description: "rendering attribute",
        type: "int32",
        default: 0,
        min: 0,
        max: 5,
        step: 1
      }, {
        identifier: "confidence",
        description: "confidence",
        type: "float32",
        default: 0,
        min: 0,
        max: 1,
        step: 0.01
      }], Jj(n, g, f, l);
    } else {
      if (!(f instanceof bu))
        throw new Error(`Invalid data instance ${r}.`);
      return Yj(n, e, f, l);
    }
  });
}
function Kj(n, e) {
  return {
    offset: 0,
    completions: Qo(e, n.dataInstances.values(), (t) => t.name, (t) => `${t.base.typeName}`)
  };
}
function Zj(n, e) {
  let t = e.match(/^(?:([^\/]+)(?:\/([^\/]*))?)?$/);
  if (t === null)
    throw new Error("Invalid DVID URL syntax.");
  if (t[2] === void 0)
    return {
      offset: 0,
      completions: Qo(e, n.repositories.values(), (s) => s.uuid + "/", (s) => `${s.alias}: ${s.description}`)
    };
  let i = t[1], r = n.getNode(i);
  return Xo(i.length + 1, Kj(r, t[2]));
}
async function Xj(n) {
  const e = /^((?:http|https):\/\/[^\/]+)\/([^\?]*).*$/;
  let i = n.providerUrl.match(e);
  if (i === null)
    throw null;
  let r = i[1], s = i[2], a = TD(r);
  const l = await ED(n.chunkManager, r, n.credentialsManager.getCredentialsProvider(fS, { dvidServer: r, authServer: a }));
  return Xo(r.length + 1, Zj(l, s));
}
var Qj = class extends ba {
  constructor(e) {
    super(), this.credentialsManager = e;
  }
  get description() {
    return "DVID";
  }
  get(e) {
    return qj(e);
  }
  completeUrl(e) {
    return Xj(e);
  }
};
xa("dvid", (n) => new Qj(n.credentialsManager));
function sv(n) {
  return n.text();
}
function e6(n, e, t, i = Zt) {
  const r = { method: t.method, body: t.payload };
  return r.method === "POST" && (r.headers = {
    "Content-Type": "application/json"
  }), n6(n, e, t.url, r, t.responseType === "" ? sv : t.responseType === "json" ? Hi : of, i);
}
function t6(n) {
  return (e, t) => {
    let i = RZr({}, t);
    return e ? i.headers = RZr(RZr({}, i.headers), { Authorization: `Bearer ${e}` }) : n.startsWith("https:") && (i.credentials = "include"), i;
  };
}
function n6(n, e, t, i, r, s = Zt) {
  return _y(n, t, i, r, t6(t), (a) => {
    const l = a.status;
    if ((l === 403 || l === 401) && e)
      return "refresh";
    if (l === 504)
      return "retry";
    throw a;
  }, s);
}
function i6(n) {
  return "neurohub" in n ? Bt.resolve(n.neurohub.clio.auth.getAuthResponse().id_token) : Bt.resolve("");
}
var r6 = class extends id {
  constructor(e, t) {
    super(), this.authServer = e, this.retry = t, this.get = nf((i) => {
      const r = new nt(
        /*delay=*/
        true
      );
      let s;
      return new Bt((a, l) => {
        const d = () => {
          s = void 0, r.dispose();
        };
        i.add(() => {
          s !== void 0 && (s.cancel(), s = void 0, r.dispose(), l(Ts));
        });
        const u = (v = "Authorization required.", y = "Request authorization.") => {
          if (r.setText(v + " "), this.retry) {
            let w = document.createElement("button");
            w.textContent = y, r.element.appendChild(w), w.addEventListener("click", this.retry);
          }
          r.setVisible(true);
        };
        let f = this.authServer;
        (() => {
          s !== void 0 && s.cancel(), s = new As(), u("Waiting for authorization...", "Retry"), this.getAuthToken(f, s).then((v) => {
            s !== void 0 && (d(), a(v));
          }, (v) => {
            s !== void 0 && (s = void 0, u(`Authorization failed: ${v}.`, "Retry"));
          });
        })();
      });
    });
  }
  getAuthToken(e, t = Zt) {
    if (e) {
      if (e.startsWith("token:"))
        return Bt.resolve(e.substring(6));
      if (e == "neurohub")
        return i6(window);
      {
        const i = new Headers();
        return lr(e, { method: "GET", headers: i }, sv, t).catch(() => lr(e, { method: "GET" }, sv, t));
      }
    } else
      return Bt.resolve("");
  }
};
var kD = "Clio";
var s6 = /^([^\/]+:\/\/[^\/]+)\/([^\/]+)\/([^\/\?]+)(\?.*)?$/;
function a6(n) {
  let e = n.match(s6);
  if (e === null)
    throw new Error(`Invalid DVID URL: ${se(n)}.`);
  return {
    baseUrl: e[1],
    nodeKey: e[2],
    dataInstanceKey: e[3]
  };
}
function ID(n) {
  let e = $o(n);
  return e.protocol === "precomputed" && (e = $o(e.host + e.path)), e;
}
function LD(n) {
  let e = n.protocol, t = n.host, i = n.path;
  switch (e) {
    case "gs":
      return `https://storage.googleapis.com/${t}${i}/info`;
    case "dvid":
      const r = a6(t + i);
      return `${r.baseUrl}/api/node/${r.nodeKey}/${r.dataInstanceKey}/info`;
    case "https":
      return `${e}://${t}${i}/info`;
    default:
      throw Error("Unrecognized volume information");
  }
}
var o6 = class {
  constructor(e) {
    this.parameters = e;
  }
  getTopLevelUrl() {
    var e = this.parameters;
    const t = e.baseUrl, i = e.api;
    return `${t}/${i || "clio_toplevel"}`;
  }
  getDatasetsUrl() {
    return `${this.getTopLevelUrl()}/datasets`;
  }
  getGrayscaleInfoUrl() {
    let e = ID(this.parameters.grayscale);
    return LD(e);
  }
  getAnnotationEndpoint() {
    return this.parameters.kind === "Atlas" ? "atlas" : "annotations";
  }
  getAnnotationEntryUrl() {
    return `${this.getTopLevelUrl()}/${this.getAnnotationEndpoint()}/${this.parameters.dataset}`;
  }
  getAllAnnotationsUrl() {
    return this.getAnnotationEntryUrl() + (this.parameters.groups ? `?groups=${this.parameters.groups}` : "");
  }
  hasPointQueryApi() {
    return this.parameters.api === "clio_toplevel" || this.parameters.kind === "Atlas";
  }
  getPostAnnotationUrl(e) {
    return this.hasPointQueryApi() ? `${this.getAnnotationEntryUrl()}?x=${e[0]}&y=${e[1]}&z=${e[2]}` : this.getAnnotationEntryUrl();
  }
  getDeleteAnnotationUrl(e) {
    if (this.hasPointQueryApi()) {
      const t = e.match(/(-?\d+)_(-?\d+)_(-?\d+)/);
      if (t)
        return this.getAnnotationUrl(t == null ? void 0 : t.slice(1, 4));
    }
    return `${this.getAnnotationEntryUrl()}/${e}`;
  }
  getAnnotationUrl(e) {
    return `${this.getAnnotationEntryUrl()}?x=${e[0]}&y=${e[1]}&z=${e[2]}`;
  }
};
var l6 = class extends r6 {
  constructor(e) {
    super(e), this.authServer = e;
  }
};
il.register(kD, (n) => new l6(n));
var c6 = "annotation.add.signal";
Ut(c6, function(n) {
  const e = this.get(n.id), t = Rv(n.newAnnotation);
  t && (e.parent.updateReference(t), e.parent.childAdded.dispatch(t));
});
var d6 = class {
  constructor(e) {
    this.annotation = e;
  }
  get renderingAttribute() {
    if (this.kind === "Atlas")
      if (this.title) {
        if (this.checked)
          return 1;
      } else
        return -1;
    else {
      if (this.bookmarkType === "False Split")
        return 2;
      if (this.bookmarkType === "False Merge")
        return 3;
    }
    return 0;
  }
  get confidence() {
    return 0;
  }
  updateProperties() {
    this.annotation.properties = [this.renderingAttribute, this.confidence];
  }
  get ext() {
    return this.annotation.ext === void 0 && (this.annotation.ext = {}), this.annotation.ext;
  }
  get prop() {
    return this.annotation.prop;
  }
  set prop(e) {
    this.annotation.prop = e;
  }
  get bookmarkType() {
    if (this.prop)
      switch (this.prop.type) {
        case "Split":
          return "False Merge";
        case "Merge":
          return "False Split";
      }
    return "Other";
  }
  get type() {
    return this.annotation.type;
  }
  get kind() {
    return this.annotation.kind;
  }
  set kind(e) {
    this.annotation.kind = e, this.update();
  }
  roundPos() {
    this.annotation.type === Me.POINT ? this.annotation.point = this.annotation.point.map((e) => Math.round(e)) : (this.annotation.type === Me.LINE || this.annotation.type === Me.SPHERE) && (this.annotation.pointA = this.annotation.pointA.map((e) => Math.round(e)), this.annotation.pointB = this.annotation.pointB.map((e) => Math.round(e)));
  }
  setProp(e) {
    this.prop = RZr(RZr({}, this.prop), e);
  }
  get user() {
    return this.prop && this.prop.user;
  }
  set user(e) {
    this.setProp({ user: e });
  }
  get comment() {
    return this.prop && this.prop.comment;
  }
  get description() {
    return this.comment;
  }
  updatePresentation() {
    this.title ? this.annotation.description = this.title + ": " : this.annotation.description = "", this.description && (this.annotation.description += this.description);
  }
  update() {
    this.updatePresentation(), this.updateProperties();
  }
  set comment(e) {
    this.setProp({ comment: e }), this.updatePresentation();
  }
  updateComment() {
    this.comment = this.annotation.description || "", this.annotation.description = void 0;
  }
  get title() {
    return this.prop && this.prop.title;
  }
  set title(e) {
    this.setProp({ title: e }), this.updatePresentation();
  }
  get timestamp() {
    return this.prop && this.prop.timestamp ? Number(this.prop.timestamp) : 0;
  }
  addTimeStamp() {
    this.setProp({ timestamp: String(Date.now()) });
  }
  get checked() {
    return this.ext && this.ext.verified || this.prop && this.prop.checked || false;
  }
  set checked(e) {
    this.setProp({ checked: e });
  }
  get presentation() {
    return this.updatePresentation(), this.annotation.description || "";
  }
  set presentation(e) {
    this.annotation.description = e;
  }
};
function u6(n) {
  const e = n.split(".")[1];
  if (e) {
    const t = e.replace(/-/g, "+").replace(/_/g, "/"), i = decodeURIComponent(window.atob(t).split("").map(function(r) {
      return "%" + ("00" + r.charCodeAt(0).toString(16)).slice(-2);
    }).join(""));
    return JSON.parse(i);
  }
}
function DD(n, e) {
  let t;
  const i = u6(n);
  if (i && ("user" in i ? t = i.user : "email" in i && (t = i.email)), t) {
    if (e && e !== t)
      return;
  } else
    t = e;
  return t;
}
var h6 = {
  definitions: {},
  type: "object",
  required: ["Prop"],
  properties: {
    Prop: {
      $id: "#/properties/Prop",
      type: "object",
      title: "Properties",
      required: ["comment"],
      properties: {
        comment: {
          $id: "#/properties/Prop/properties/comment",
          type: "string",
          title: "Comment",
          default: ""
        }
      }
    }
  }
};
var au = class extends d6 {
  get title() {
    return this.annotation.ext && this.annotation.ext.title;
  }
  set title(e) {
    this.ext.title = e;
  }
  get description() {
    return this.annotation.ext && this.annotation.ext.description;
  }
  set description(e) {
    this.ext.description = e;
  }
  get user() {
    return this.annotation.ext && this.annotation.ext.user;
  }
  set user(e) {
    this.ext.user = e;
  }
  get checked() {
    return this.ext && this.ext.verified;
  }
  set checked(e) {
    this.ext.verified = e;
  }
};
function f6(n) {
  let e = n.match(/^\${(.*):JSON}$/);
  return e ? JSON.parse(e[1]) : null;
}
var p6 = {
  definitions: {},
  type: "object",
  required: ["Prop"],
  properties: {
    Prop: {
      $id: "#/properties/Prop",
      type: "object",
      title: "Properties",
      required: ["description"],
      properties: {
        description: {
          $id: "#/properties/Prop/properties/description",
          type: "string",
          title: "Description",
          default: ""
        }
      }
    }
  }
};
var g6 = {
  definitions: {},
  type: "object",
  required: ["Prop"],
  properties: {
    Prop: {
      $id: "#/properties/Prop",
      type: "object",
      title: "Properties",
      required: ["title", "description"],
      properties: {
        title: {
          $id: "#/properties/Prop/properties/title",
          type: "string",
          title: "Title",
          default: ""
        },
        description: {
          $id: "#/properties/Prop/properties/description",
          type: "string",
          title: "Description",
          default: ""
        }
      }
    }
  }
};
function PD(n) {
  return Array.isArray(n);
}
function m6(n) {
  return PD(n) || n === null ? false : typeof n == "object";
}
var AD = class {
  constructor(e) {
    this.name = e, this.childNodeList = new Array(), this.parentNode = null;
  }
  isRoot() {
    return this.parentNode === null;
  }
  isLeaf() {
    return this.childNodeList.length === 0;
  }
  *[wZr]() {
    function* e(t) {
      yield t;
      for (let i of t.childNodeList)
        yield* e(i);
    }
    yield* e(this);
  }
  *leafNodes() {
    for (let e of this)
      e.childNodeList.length === 0 && (yield e);
  }
  get fullName() {
    let e = this.name, t = this.parentNode;
    for (; t; )
      e = t.name + "/" + e, t = t.parentNode;
    return e;
  }
  get nameArray() {
    let e = new Array();
    if (!this.isRoot()) {
      e.push(this.name);
      let t = this.parentNode;
      for (; t && !t.isRoot(); )
        e.push(t.name), t = t.parentNode;
    }
    return e;
  }
  getPropertyValue(e) {
    if (!this.isRoot() && e) {
      let t = this.nameArray, i = e;
      for (let r = t.length - 1; r >= 0; --r)
        if (m6(i)) {
          let s = t[r];
          i = i[s];
        } else
          return i;
      return i;
    }
  }
};
function RD(n, e) {
  if (n.type == "object") {
    e.properties == null && (e.properties = {}), e.properties.title = n.title;
    let t = n.required;
    PD(t) && t.forEach((i) => {
      let r = new AD(i);
      r.parentNode = e, e.childNodeList.push(r);
      let a = n.properties[i];
      RD(a, r);
    });
  } else
    e.properties = n;
}
function v6(n, e) {
  let t = new AD(e);
  return RD(n, t), t;
}
var y6 = "annotation";
function S6(n, e, t, i = false) {
  let r = document.createElement("div"), s = n.title;
  s && r.appendChild(document.createTextNode(s));
  let a;
  switch (n.type) {
    case "number":
      a = document.createElement("input"), typeof t == "number" && (a.text = t);
      break;
    case "string":
      let l = n.enum;
      Array.isArray(l) ? (a = document.createElement("select"), r.appendChild(a), l.forEach((d) => {
        let u = document.createElement("option");
        u.text = d, u.value = d, u.disabled = i, a.appendChild(u);
      }), t !== void 0 && (a.value = t)) : (a = document.createElement("input"), a.setAttribute("autocomplete", "off"), typeof t == "string" && (a.value = t, a.setAttribute("value", t)));
      break;
    case "boolean":
      a = document.createElement("input"), a.type = "checkbox", typeof t == "boolean" ? a.checked = t : a.checked = t == 1;
      break;
  }
  return a && (a.id = e, a.readOnly = i, r.appendChild(a)), r;
}
function b6(n, e) {
  return n + "/" + e;
}
function C6(n, e, t, i = false) {
  let r = document.createElement("div"), s = v6(n, t);
  s.record = r;
  for (let a of s)
    if (!a.isRoot())
      if (a.isLeaf()) {
        let l = a.getPropertyValue(e), d = S6(a.properties, a.fullName, l, i);
        a.parentNode.record.appendChild(d);
      } else {
        let l = document.createElement("fieldset"), d = document.createElement("legend");
        d.textContent = a.properties.title, l.appendChild(d), a.record = l, a.parentNode.record.appendChild(l);
      }
  return r;
}
function w6(n, e, t = false) {
  return C6(n, e, y6, t);
}
function x6(n) {
  let e = document.getElementById(n);
  if (e)
    return e.type === "checkbox" ? e.checked : e.value;
}
function MD(n, e, t, i) {
  n.type === "object" ? n.required.forEach((r) => {
    let s = t;
    e && (typeof t[e] > "u" && (t[e] = {}), s = t[e]), MD(n.properties[r], r, s, b6(i, r));
  }) : t[e] = x6(i);
}
function E6(n, e, t, i, r, s) {
  const a = RZr({}, n.value);
  if (a.type !== Me.POINT && a.type !== Me.LINE && a.type !== Me.SPHERE)
    return null;
  e || (e = h6);
  const l = i(a), d = r ? r(a) : l.prop;
  let u = w6(e, d ? { Prop: d } : {}, t.readonly), f = document.createElement("button");
  return f.textContent = "update", f.onclick = () => {
    let g = {};
    MD(e, "", g, "annotation");
    const v = g.Prop;
    s ? s(a, v) : l.setProp(v), l.update(), t.update(n, a), t.commit(n);
  }, u.appendChild(f), u;
}
var T6 = `
{
  "definitions": {},
  "type": "object",
  "required": [
    "Prop"
  ],
  "properties": {
    "Prop": {
      "$id": "#/properties/Prop",
      "type": "object",
      "title": "Properties",
      "required": [
        "comment",
        "type",
        "checked"
      ],
      "properties": {
        "comment": {
          "$id": "#/properties/Prop/properties/comment",
          "type": "string",
          "title": "Comment",
          "default": ""
        },
        "type": {
          "$id": "#/properties/Prop/properties/type",
          "type": "string",
          "title": "Type",
          "enum": ["Merge", "Split", "Other"]
        },
        "checked": {
          "$id": "#/properties/Prop/properties/checked",
          "type": "boolean",
          "title": "Checked"
        }
      }
    }
  }
}
`;
JSON.parse(T6);
var k6 = St(64, 64, 64);
var I6 = class {
};
function L6(n) {
  return n.authServer ? n.authServer === "neurohub" || n.authServer.startsWith("http") : false;
}
var ND = class extends I6 {
  constructor() {
    super(...arguments), this.chunkDataSize = k6;
  }
};
var mS = class extends ND {
};
mS.RPC_ID = "clio/Annotation";
var _D = class extends ND {
};
_D.RPC_ID = "clio/AnnotationChunkSource";
var D6 = class extends jt(Jt()(No), _D) {
};
async function P6(n) {
  const e = n.grayscale;
  if (e) {
    let t = ID(e);
    return yj({
      method: "GET",
      url: LD(t),
      responseType: "json"
    }).then((i) => new SD(i, t.protocol === "https" ? "gs" : t.protocol));
  } else
    return Bt.resolve({
      numChannels: 1,
      voxelSize: St(8, 8, 8),
      lowerVoxelBound: St(0, 0, 0),
      upperVoxelBound: St(5e4, 5e4, 5e4),
      blockSize: St(64, 64, 64),
      numLevels: 1
    });
}
function A6(n) {
  return [[((i) => {
    const r = i.upperVoxelBound;
    return { spec: Gc({
      rank: 3,
      chunkDataSize: Uint32Array.from(r),
      lowerVoxelBound: i.lowerVoxelBound,
      upperVoxelBound: i.upperVoxelBound
    }), chunkToMultiscaleTransform: et() };
  })(n)]];
}
var R6 = jt(Jt()(Ui), mS);
var M6 = class extends R6 {
  constructor(e, t) {
    super(e, RZr({ rank: 3, relationships: ["segments"], properties: t.parameters.properties }, t)), this.readonly = false, this.parameters = t.parameters, this.dataInfo = t.dataInfo, this.childAdded = this.childAdded || new ot(), this.childUpdated = this.childUpdated || new ot(), this.childDeleted = this.childDeleted || new ot(), this.makeEditWidget = (i) => {
      const r = (l) => new au(l), s = (l) => RZr(RZr({}, l.prop), l.ext), a = (l, d) => {
        const u = new au(l);
        d.title && (u.title = d.title), d.description && (u.description = d.description);
      };
      return E6(i, this.parameters.schema, this, r, s, a);
    }, this.getUser = () => this.parameters.user;
  }
  getSources(e) {
    let t = A6(this.dataInfo), i = 0;
    return t[0].length > 1 && (i = 10), t.map((r) => r.map(({ spec: s, chunkToMultiscaleTransform: a }) => ({
      chunkSource: this.chunkManager.getChunkSource(D6, {
        spec: RZr({ limit: i, chunkToMultiscaleTransform: a }, s),
        parent: this,
        credentialsProvider: this.credentialsProvider,
        parameters: this.parameters
      }),
      chunkToMultiscaleTransform: a
    })));
  }
  *[wZr]() {
    for (let e of this.references)
      e[1].value && (yield e[1].value);
  }
  commit(e) {
    e.value && (e.value.type === Me.LINE || e.value.type === Me.SPHERE) && (e.value.pointA = e.value.pointA.map((t) => Math.round(t)), e.value.pointB = e.value.pointB.map((t) => Math.round(t))), super.commit(e);
  }
  add(e, t = true) {
    if (this.readonly) {
      let r = "Permission denied for changing annotations.";
      throw nt.showTemporaryMessage(r), Error(r);
    }
    const i = new au(e);
    if (i.addTimeStamp(), this.parameters.user && (i.user = this.parameters.user), e.type === Me.POINT && (i.kind = this.parameters.kind || "Note", e.description)) {
      let r = f6(e.description);
      r && i.setProp(r);
    }
    return i.roundPos(), i.update(), super.add(e, t);
  }
  update(e, t) {
    const i = new au(t);
    i.roundPos(), i.update(), super.update(e, t);
  }
  invalidateCache() {
    this.references.forEach((e) => {
      e.dispose();
    }), this.references.clear(), this.childRefreshed.dispatch(), this.metadataChunkSource.invalidateCache();
    for (let e of this.getSources({
      multiscaleToViewTransform: new Float32Array(),
      displayRank: 1,
      modelChannelDimensionIndices: []
    }))
      for (let t of e)
        t.chunkSource.invalidateCache();
    for (let e of this.segmentFilteredSources)
      e.invalidateCache();
  }
};
async function N6(n, e, t, i) {
  return ((s, a) => n.chunkManager.getChunkSource(M6, {
    parameters: a,
    credentialsProvider: i,
    dataInfo: s
  }))(t, e);
}
async function _6(n, e, t) {
  const i = await P6(e), r = {
    lowerBounds: new Float64Array(i.lowerVoxelBound),
    upperBounds: Float64Array.from(i.upperVoxelBound)
  }, s = mt({
    rank: 3,
    names: ["x", "y", "z"],
    units: ["m", "m", "m"],
    scales: Float64Array.from(i.voxelSize, (d) => d / 1e9),
    boundingBoxes: [Sa(r)]
  }), a = await N6(n, e, i, t);
  return {
    modelTransform: Qn(s),
    subsources: [{
      id: "default",
      subsource: { annotation: a },
      default: true
    }]
  };
}
var O6 = /^([^\/]+:\/\/[^\/]+)\/(?:([^\/\?#]+)\/)?([^\/\?#]+)(?:(?:\?|#)(.*))?$/;
function V6(n) {
  let e = n.match(O6);
  if (e === null)
    throw new Error(`Invalid Clio URL: ${se(n)}.`);
  let t = {
    baseUrl: e[1],
    api: e[2],
    dataset: e[3]
  }, i = e[4];
  if (i) {
    let r = Yo(i);
    r.token ? (t.authToken = r.token, t.authServer = "token:" + r.token) : r.auth && (t.authServer = r.auth), r.user ? t.user = r.user : t.authToken && (t.user = DD(t.authToken)), r.kind ? r.kind === "atlas" ? t.kind = "Atlas" : t.kind = r.kind : t.kind = "Normal", r.groups && (t.groups = r.groups);
  }
  return t;
}
async function B6(n, e) {
  const t = new o6(n);
  return e6(e(n.authServer), L6(n), {
    url: t.getDatasetsUrl(),
    method: "GET",
    responseType: "json"
  }).then((i) => {
    const r = K(i, n.dataset, pe);
    if ("location" in r)
      n.grayscale = K(r, "location", Le);
    else if ("mainLayer" in r) {
      const s = K(r, "mainLayer", Le), d = K(r, "neuroglancer", pe).layers.find((u) => u.name === s);
      d.source && d.source.url ? n.grayscale = K(d.source, "url", Le) : n.grayscale = K(d, "source", Le);
    }
    return n;
  });
}
async function F6(n, e) {
  let t = V6(n.providerUrl);
  if (!t.user && t.authServer) {
    let i = e(t.authServer).get();
    t.authToken = (await i).credentials, t.user = DD(t.authToken);
  }
  return n.chunkManager.memoize.getUncounted(RZr({ type: "clio:MultiscaleVolumeChunkSource" }, t), async () => {
    t = await B6(t, e);
    let i = RZr(RZr({}, new mS()), t);
    t.kind === "Atlas" ? i.schema = g6 : i.schema = p6, i.properties = [{
      identifier: "rendering_attribute",
      description: "rendering attribute",
      type: "int32",
      default: 0,
      min: 0,
      max: 5,
      step: 1
    }];
    const r = e(t.authServer);
    return _6(n, i, r);
  });
}
async function U6(n) {
  return Bt.resolve({
    offset: 0,
    completions: [{ value: "" }]
  });
}
var z6 = class extends ba {
  constructor(e) {
    super(), this.credentialsManager = e, this.description = "Clio";
  }
  getCredentialsProvider(e) {
    let t = "";
    return e && (t = e), this.credentialsManager.getCredentialsProvider(kD, t);
  }
  get(e) {
    return F6(e, this.getCredentialsProvider.bind(this));
  }
  completeUrl(e) {
    return U6(e.providerUrl);
  }
};
xa("clio", (n) => new z6(n.credentialsManager));
var gf = "google-brainmaps";
function so(n, e, t, i = Zt) {
  return na(e, `${n.serverUrl}${t.path}`, { method: t.method, body: t.payload }, t.responseType === "json" ? Hi : of, i);
}
var Pr;
(function(n) {
  n[n.RAW = 0] = "RAW", n[n.JPEG = 1] = "JPEG", n[n.COMPRESSED_SEGMENTATION = 2] = "COMPRESSED_SEGMENTATION";
})(Pr || (Pr = {}));
var OD = class {
};
OD.RPC_ID = "brainmaps/VolumeChunkSource";
var VD = class {
};
VD.RPC_ID = "brainmaps/MultiscaleMeshSource";
var BD = class {
};
BD.RPC_ID = "brainmaps/MeshSource";
var FD = class {
};
FD.RPC_ID = "brainmaps/SkeletonSource";
var UD = class {
};
UD.RPC_ID = "brainmaps/Annotation";
var zD = class {
};
zD.RPC_ID = "brainmaps/AnnotationSpatialIndex";
var G6 = class extends jt(Jt()(td), OD) {
};
var $6 = class extends jt(Jt()(Qh), VD) {
};
var W6 = class extends jt(Jt()(Zc), BD) {
};
var H6 = class extends jt(Jt()(ef), FD) {
};
var j6 = class extends jt(Jt()(No), zD) {
};
var sd = new de();
sd.set("UINT8", J.UINT8);
sd.set("FLOAT", J.FLOAT32);
sd.set("UINT32", J.UINT32);
sd.set("UINT64", J.UINT64);
function J6(n) {
  pe(n);
  try {
    return {
      corner: K(n, "corner", (e) => hc(_e(), e, Lt)),
      size: K(n, "size", (e) => hc(_e(), e, vn)),
      metadata: K(n, "metadata", xi)
    };
  } catch (e) {
    throw new Error(`Failed to parse bounding box: ${e.message}`);
  }
}
var Y6 = class {
  constructor(e) {
    try {
      pe(e), this.numChannels = K(e, "channelCount", dn), this.dataType = K(e, "channelType", (t) => Lv(t, sd)), this.voxelSize = K(e, "pixelSize", (t) => hc(_e(), t, vn)), this.upperVoxelBound = K(e, "volumeSize", (t) => hc(_e(), t, dn)), this.boundingBoxes = K(e, "boundingBox", (t) => t === void 0 ? [] : Je(t, J6));
    } catch (t) {
      throw new Error(`Failed to parse BrainMaps volume geometry: ${t.message}`);
    }
  }
};
function q6(n) {
  return pe(n), {
    name: K(n, "name", Le),
    type: K(n, "type", Le)
  };
}
function K6(n) {
  try {
    return pe(n), K(n, "meshes", (e) => e === void 0 ? [] : Je(e, q6));
  } catch (e) {
    throw new Error(`Failed to parse BrainMaps meshes specification: ${e.message}`);
  }
}
var Z6 = "([0-9]*\\.?[0-9]+(?:[eE][-+]?[0-9]+)?)";
var yg = "([0-9]+)";
var GD = new RegExp(`^(.*)_${yg}x${yg}x${yg}_lod([0-9]+)_${Z6}$`);
function X6(n, e) {
  const t = new de(), i = n.scales[0], r = new je();
  for (const a of e) {
    if (a.type !== "TRIANGLES")
      continue;
    const l = a.name.match(GD);
    if (l === null)
      continue;
    const d = l[1];
    let u = t.get(d);
    u === void 0 && (u = { key: d, chunkShape: _e(), lods: [] }, t.set(d, u));
    const f = parseInt(l[5]);
    if (u.lods[f] !== void 0) {
      r.add(d);
      continue;
    }
    const g = St(parseInt(l[2], 10), parseInt(l[3], 10), parseInt(l[4], 10)), v = new Uint32Array(3);
    for (let y = 0; y < 3; ++y)
      v[y] = Math.ceil(i.upperVoxelBound[y] / g[y]);
    u.lods[f] = {
      info: a,
      scale: parseFloat(l[6]),
      // Temporarily use the relativeBlockShape field to store the absolute shape in voxels.
      relativeBlockShape: g,
      gridShape: v
    };
  }
  const s = [];
  e:
    for (const a of t.values()) {
      if (r.has(a.key))
        continue e;
      const l = a.lods[0];
      if (l === void 0)
        continue e;
      const d = l.relativeBlockShape;
      HE(a.chunkShape, d, i.voxelSize);
      for (let u = 1; u < a.lods.length; ++u) {
        const f = a.lods[u];
        if (f === void 0)
          continue e;
        const g = f.relativeBlockShape;
        for (let v = 0; v < 3; ++v) {
          const y = g[v], w = d[v];
          if (y < w || y % w !== 0)
            continue e;
          g[v] = y / w;
        }
      }
      d.fill(1), s.push(a);
    }
  return s;
}
function Q6(n, e) {
  const t = X6(n, e), i = [], r = (a) => {
    i.some((l) => l.name === a.name) || i.push(a);
  }, s = new je();
  for (const a of t) {
    r({ multi: a, single: void 0, name: a.key, partOfMultiscale: false });
    for (const l of a.lods)
      s.add(l.info);
  }
  for (const a of e)
    r({
      single: a,
      multi: void 0,
      name: a.name,
      partOfMultiscale: s.has(a)
    });
  return i;
}
var e5 = class {
  constructor(e) {
    try {
      pe(e);
      let t = this.scales = K(e, "geometry", (a) => Je(a, (l) => new Y6(l)));
      if (t.length === 0)
        throw new Error("Expected at least one scale.");
      let i = t[0], r = this.numChannels = i.numChannels, s = this.dataType = i.dataType;
      for (let a = 1, l = t.length; a < l; ++a) {
        let d = t[a];
        if (d.dataType !== s)
          throw new Error(`Scale ${a} has data type ${J[d.dataType]} but scale 0 has data type ${J[s]}.`);
        if (d.numChannels !== r)
          throw new Error(`Scale ${a} has ${d.numChannels} channel(s) but scale 0 has ${r} channels.`);
      }
      this.box = {
        lowerBounds: new Float64Array(3),
        upperBounds: new Float64Array(i.upperVoxelBound)
      };
    } catch (t) {
      throw new Error(`Failed to parse BrainMaps multiscale volume specification: ${t.message}`);
    }
  }
  getModelSpace(e = false) {
    const t = this.scales[0], i = ["x", "y", "z"], r = ["m", "m", "m"], s = De(t.voxelSize, (l) => l / 1e9), a = De(t.upperVoxelBound);
    return e && (i.push("c^"), r.push(""), s.push(1), a.push(this.numChannels)), mt({
      names: i,
      units: r,
      scales: Float64Array.from(s),
      boundingBoxes: [Sa({
        lowerBounds: new Float64Array(i.length),
        upperBounds: Float64Array.from(a)
      })]
    });
  }
};
var t5 = class extends _s {
  constructor(e, t, i, r, s, a, l) {
    super(e), this.instance = t, this.credentialsProvider = i, this.volumeId = r, this.changeSpec = s, this.multiscaleVolumeInfo = a, this.encoding = l.encoding, this.jpegQuality = l.jpegQuality, this.chunkLayoutPreference = l.chunkLayoutPreference;
    let d = Dn.IMAGE;
    this.dataType === J.UINT64 && (d = Dn.SEGMENTATION), this.volumeType = d;
  }
  get scales() {
    return this.multiscaleVolumeInfo.scales;
  }
  get dataType() {
    return this.multiscaleVolumeInfo.dataType;
  }
  get rank() {
    return this.multiscaleVolumeInfo.numChannels !== 1 ? 4 : 3;
  }
  getSources(e) {
    let t = Pr.RAW;
    (this.dataType === J.UINT64 || this.dataType === J.UINT32) && this.volumeType === Dn.SEGMENTATION && this.encoding !== Pr.RAW ? t = Pr.COMPRESSED_SEGMENTATION : this.volumeType === Dn.IMAGE && this.dataType === J.UINT8 && this.multiscaleVolumeInfo.numChannels === 1 && this.encoding !== Pr.RAW && e.discreteValues !== true && (t = Pr.JPEG);
    const i = t === Pr.JPEG ? this.jpegQuality : void 0, r = this.scales[0], s = r.upperVoxelBound, a = _e(), l = this.rank;
    return Rc(this.scales.map((d, u) => {
      Dg(a, d.voxelSize, r.voxelSize);
      let f = d.upperVoxelBound, g, v = d.numChannels;
      const y = new Float32Array((l + 1) ** 2);
      y[(l + 1) * l + l] = 1;
      const w = new Float32Array(l);
      v !== 1 && (f = Float32Array.of(...f, v), g = Uint32Array.of(1, 1, 1, v), y[(l + 1) * 3 + 3] = 1, w[3] = v);
      for (let C = 0; C < 3; ++C)
        y[(l + 1) * C + C] = a[C], w[C] = s[C] / a[C];
      return rd({
        rank: l,
        minBlockSize: g,
        chunkToMultiscaleTransform: y,
        dataType: d.dataType,
        upperVoxelBound: f,
        volumeType: this.volumeType,
        volumeSourceOptions: e,
        chunkLayoutPreference: this.chunkLayoutPreference,
        maxCompressedSegmentationBlockSize: St(64, 64, 64)
      }).map((C) => ({
        chunkSource: this.chunkManager.getChunkSource(G6, {
          credentialsProvider: this.credentialsProvider,
          spec: C,
          parameters: {
            volumeId: this.volumeId,
            changeSpec: this.changeSpec,
            scaleIndex: u,
            encoding: t,
            jpegQuality: i,
            instance: this.instance
          }
        }),
        chunkToMultiscaleTransform: y,
        upperClipBound: w
      }));
    }));
  }
};
function n5(n) {
  const e = et(), t = n.scales[0].voxelSize;
  for (let i = 0; i < 3; ++i)
    e[5 * i] = 1 / t[i];
  return e;
}
function i5(n) {
  const e = n.match(/^([^:?\/]+:[^:?\/]+:[^:?\/]+)(?::([^:?\/]+))?(?:\/([^?]+))?(?:\?(.*))?$/);
  if (e === null)
    throw new Error(`Invalid Brain Maps volume key: ${se(n)}.`);
  let t;
  e[2] !== void 0 && (t = { changeStackId: e[2] });
  const i = Yo(e[4] || "");
  return { volumeId: e[1], changeSpec: t, meshName: e[3], parameters: i };
}
function r5(n) {
  try {
    return pe(n), {
      id: K(n, "id", Le),
      label: K(n, "label", Le),
      description: K(n, "description", xi)
    };
  } catch (e) {
    throw new Error(`Failed to parse project: ${e.message}`);
  }
}
function s5(n) {
  try {
    return pe(n), K(n, "project", (e) => e === void 0 ? [] : Je(e, r5));
  } catch (e) {
    throw new Error(`Error parsing project list: ${e.message}`);
  }
}
function nE(n, e) {
  try {
    return pe(n), K(n, e, (t) => t === void 0 ? [] : Je(t, Le));
  } catch (t) {
    throw new Error(`Error parsing dataset list: ${t.message}`);
  }
}
function a5(n) {
  return K(n, "changeStackId", (e) => e === void 0 ? void 0 : Je(e, Le));
}
var o5 = jt(Jt()(Ui), UD);
var l5 = class extends o5 {
  constructor(e, t) {
    super(e, RZr({ rank: 3, relationships: ["segments"], properties: [] }, t)), this.credentialsProvider = this.registerDisposer(t.credentialsProvider.addRef());
  }
  hasNonSerializedProperties() {
    return true;
  }
  getSources() {
    const e = this.parameters.upperVoxelBound, t = Gc({
      rank: 3,
      chunkDataSize: e,
      upperVoxelBound: e
    }), i = et();
    return [[{
      chunkSource: this.chunkManager.getChunkSource(j6, {
        parent: this,
        spec: RZr({ limit: 0, chunkToMultiscaleTransform: i }, t),
        parameters: this.parameters,
        credentialsProvider: this.credentialsProvider
      }),
      chunkToMultiscaleTransform: i
    }]];
  }
};
var c5 = [{
  key: { value: "encoding", description: "Volume chunk data encoding" },
  values: [{ value: "raw", description: "" }, { value: "jpeg", description: "" }, { value: "compressed_segmentation", description: "" }]
}, {
  key: { value: "chunkLayout", description: "Volume chunk layout preference" },
  values: [{ value: "isotropic", description: "" }, { value: "flat", description: "" }]
}, {
  key: { value: "jpegQuality", description: "JPEG quality (1 to 100)" },
  values: []
}];
var $D = class extends ba {
  constructor(e, t) {
    super(), this.instance = e, this.credentialsProvider = t;
  }
  get description() {
    return this.instance.description;
  }
  getMultiscaleInfo(e, t) {
    return e.memoize.getUncounted({
      type: "brainmaps:getMultiscaleInfo",
      volumeId: t,
      instance: this.instance,
      credentialsProvider: xn(this.credentialsProvider)
    }, () => so(this.instance, this.credentialsProvider, {
      method: "GET",
      path: `/v1beta2/volumes/${t}`,
      responseType: "json"
    }).then((i) => new e5(i)));
  }
  getMeshesInfo(e, t) {
    return e.memoize.getUncounted({
      type: "brainmaps:getMeshesInfo",
      volumeId: t,
      instance: this.instance,
      credentialsProvider: xn(this.credentialsProvider)
    }, () => so(this.instance, this.credentialsProvider, {
      method: "GET",
      path: `/v1beta2/objects/${t}/meshes`,
      responseType: "json"
    }).then((i) => K6(i)));
  }
  get(e) {
    var t = i5(e.providerUrl);
    const i = t.volumeId, r = t.changeSpec, s = t.meshName, a = t.parameters;
    pe(a);
    const l = Ce(a, "encoding", (g) => Pn(g, Pr)), d = Ce(a, "jpegQuality", (g) => {
      const v = pn(g);
      if (v < 1 || v > 100)
        throw new Error(`Expected integer in range [1, 100], but received: ${g}`);
      return v;
    }, 70), u = Ce(a, "chunkLayout", (g) => Pn(g, vo)), f = { encoding: l, chunkLayoutPreference: u, jpegQuality: d };
    return e.chunkManager.memoize.getUncounted({ type: "brainmaps:get", instance: this.instance, volumeId: i, changeSpec: r, brainmapsOptions: f }, async () => {
      var g = await Bt.all([this.getMultiscaleInfo(e.chunkManager, i), this.getMeshesInfo(e.chunkManager, i)]), v = ce(g, 2);
      const y = v[0], w = v[1], C = new t5(e.chunkManager, this.instance, this.credentialsProvider, i, r, y, f), b = {
        modelTransform: Qn(y.getModelSpace(y.numChannels !== 1)),
        subsources: [{
          id: s === void 0 ? "default" : "volume",
          subsource: { volume: C },
          default: s === void 0
        }]
      }, E = Bc(y.box);
      y.scales[0].boundingBoxes.forEach((A, I) => {
        E.add({
          type: Me.AXIS_ALIGNED_BOUNDING_BOX,
          description: A.metadata,
          pointA: A.corner,
          pointB: $E(_e(), A.corner, A.size),
          id: `boundingBox${I}`,
          properties: []
        });
      }), b.subsources.push({
        id: "bounds",
        subsource: { staticAnnotations: E },
        default: true
      });
      const R = Q6(y, w), _ = (A, I) => {
        let P;
        const N = A.single;
        if (N !== void 0)
          N.type === "TRIANGLES" ? P = e.chunkManager.getChunkSource(W6, {
            credentialsProvider: this.credentialsProvider,
            parameters: {
              instance: this.instance,
              volumeId: i,
              meshName: N.name,
              changeSpec: r
            }
          }) : P = e.chunkManager.getChunkSource(H6, {
            credentialsProvider: this.credentialsProvider,
            parameters: {
              instance: this.instance,
              volumeId: i,
              meshName: A.name,
              changeSpec: r
            }
          });
        else {
          const O = A.multi;
          P = e.chunkManager.getChunkSource($6, {
            credentialsProvider: this.credentialsProvider,
            format: {
              fragmentRelativeVertices: false,
              vertexPositionFormat: Fr.float32
            },
            parameters: {
              instance: this.instance,
              volumeId: i,
              info: O,
              changeSpec: r
            }
          });
        }
        b.subsources.push({
          id: s === void 0 ? `/${A.name}` : "default",
          subsource: { mesh: P },
          subsourceToModelSubspaceTransform: n5(y),
          modelSubspaceDimensionIndices: [0, 1, 2],
          default: I
        });
      };
      if (s !== void 0) {
        const A = R.find((I) => I.name === s);
        if (A === void 0)
          throw new Error(`Mesh/skeleton source not found: ${se(A)}`);
        _(A, true);
      } else {
        let A = true;
        for (const I of R)
          I.partOfMultiscale || (_(I, A), A = false);
      }
      return r !== void 0 && b.subsources.push({
        id: "spatials",
        default: true,
        modelSubspaceDimensionIndices: [0, 1, 2],
        subsource: {
          annotation: e.chunkManager.getChunkSource(l5, {
            parameters: {
              volumeId: i,
              changestack: r.changeStackId,
              instance: this.instance,
              upperVoxelBound: y.scales[0].upperVoxelBound
            },
            credentialsProvider: this.credentialsProvider
          })
        }
      }), b;
    });
  }
  getProjectList(e) {
    return e.memoize.getUncounted({ instance: this.instance, type: "brainmaps:getProjectList" }, () => {
      let t = so(this.instance, this.credentialsProvider, {
        method: "GET",
        path: "/v1beta2/projects",
        responseType: "json"
      }).then((r) => s5(r));
      const i = `${this.instance.description} project list`;
      return nt.forPromise(t, {
        delay: true,
        initialMessage: `Retrieving ${i}.`,
        errorPrefix: `Error retrieving ${i}: `
      }), t;
    });
  }
  getDatasetList(e, t) {
    return e.memoize.getUncounted({ instance: this.instance, type: `brainmaps:${t}:getDatasetList` }, () => {
      let i = so(this.instance, this.credentialsProvider, {
        method: "GET",
        path: `/v1beta2/datasets?project_id=${t}`,
        responseType: "json"
      }).then((s) => nE(s, "datasetIds"));
      const r = `${this.instance.description} dataset list`;
      return nt.forPromise(i, {
        delay: true,
        initialMessage: `Retrieving ${r}`,
        errorPrefix: `Error retrieving ${r}`
      }), i;
    });
  }
  getVolumeList(e, t, i) {
    return e.memoize.getUncounted({ instance: this.instance, type: `brainmaps:${t}:${i}:getVolumeList` }, () => {
      let r = so(this.instance, this.credentialsProvider, {
        method: "GET",
        path: `/v1beta2/volumes?project_id=${t}&dataset_id=${i}`,
        responseType: "json"
      }).then((a) => {
        const l = nE(a, "volumeId"), d = t.length + i.length + 2, u = [];
        for (const f of l)
          u.push(f.substring(d));
        return u;
      });
      const s = `${this.instance.description} volume list`;
      return nt.forPromise(r, {
        delay: true,
        initialMessage: `Retrieving ${s}`,
        errorPrefix: `Error retrieving ${s}`
      }), r;
    });
  }
  getChangeStackList(e, t) {
    return e.memoize.getUncounted({ instance: this.instance, type: "brainmaps:getChangeStackList", volumeId: t }, () => {
      let i = so(this.instance, this.credentialsProvider, {
        method: "GET",
        path: `/v1beta2/changes/${t}/change_stacks`,
        responseType: "json"
      }).then((s) => a5(s));
      const r = `change stacks for ${t}`;
      return nt.forPromise(i, {
        delay: true,
        initialMessage: `Retrieving ${r}.`,
        errorPrefix: `Error retrieving ${r}: `
      }), i;
    });
  }
  async completeUrl(e) {
    const t = e.providerUrl, i = t.match(/^([^:\/?]*)(?::([^:\/?]*)(?::([^:\/?]*)(?::([^:\/?]*))?(?:\/([^?]*))?(?:\?(.*))?)?)?$/);
    if (i === null)
      throw null;
    var r = ce(i, 7);
    const s = r[1], a = r[2], l = r[3], d = r[4], u = r[5], f = r[6];
    if (f !== void 0)
      return Xo(t.length - f.length, await rk(f, c5));
    if (u !== void 0) {
      const v = `${s}:${a}:${l}`, y = await this.getMeshesInfo(e.chunkManager, v), w = [], C = new je();
      for (const b of y)
        if (b.name.startsWith(u))
          switch (b.type) {
            case "LINE_SEGMENTS":
              w.push({ value: b.name, description: "Skeletons" });
              break;
            case "TRIANGLES": {
              w.push({ value: b.name, description: "Mesh (single-resolution)" });
              const E = b.name.match(GD);
              if (E !== null) {
                const L = E[1];
                if (C.has(L))
                  break;
                C.add(L), w.push({ value: L, description: "Mesh (multi-resolution)" });
              }
              break;
            }
          }
      return w.sort((b, E) => jc(b.value, E.value)), { offset: t.length - u.length, completions: w };
    }
    if (d !== void 0) {
      const v = `${s}:${a}:${l}`, y = await this.getChangeStackList(e.chunkManager, v);
      if (y === void 0)
        throw null;
      return {
        offset: t.length - d.length,
        completions: Up(d, y)
      };
    }
    if (l !== void 0)
      return {
        offset: t.length - l.length,
        completions: Up(l, await this.getVolumeList(e.chunkManager, s, a))
      };
    if (a !== void 0) {
      const v = await this.getDatasetList(e.chunkManager, s);
      return {
        offset: t.length - a.length,
        completions: Up(a, v.map((y) => `${y}:`))
      };
    }
    const g = await this.getProjectList(e.chunkManager);
    return {
      offset: 0,
      completions: Qo(s, g, (v) => `${v.id}:`, (v) => v.label)
    };
  }
};
var d5 = {
  description: "Google Brain Maps",
  serverUrl: "https://brainmaps.googleapis.com"
};
xa("brainmaps", (n) => new $D(d5, n.credentialsManager.getCredentialsProvider(gf)));
if (typeof NEUROGLANCER_BRAINMAPS_SERVERS < "u")
  for (const n of Jc(NEUROGLANCER_BRAINMAPS_SERVERS)) {
    iE = ce(n, 2);
    const e = iE[0], t = iE[1];
    xa(`brainmaps-${e}`, (i) => new $D(t, i.credentialsManager.getCredentialsProvider(gf)));
  }
var iE;
var u5 = "https://accounts.google.com/o/oauth2/auth";
var rE = "https://accounts.google.com";
function h5(n, e) {
  let t = document.createElement("iframe");
  t.style.display = "none", t.id = n, t.name = n;
  const i = location.origin;
  t.src = `https://accounts.google.com/o/oauth2/postmessageRelay?parent=${encodeURIComponent(i)}#rpctoken=${e}`, document.body.appendChild(t);
}
var f5 = class {
  constructor() {
    this.finished = new ot();
  }
};
var p5 = class {
  constructor() {
    this.proxyName = `postmessageRelay${Au()}`, this.rpcToken = `${Au()}`, this.relayReadyService = `oauth2relayReady:${this.rpcToken}`, this.oauth2CallbackService = `oauth2callback:${this.rpcToken}`, this.pendingRequests = new de(), h5(this.proxyName, this.rpcToken), this.relayReadyPromise = new Bt((e) => {
      addEventListener("message", (t) => {
        if (t.origin === rE)
          try {
            let i = pe(JSON.parse(t.data)), r = Le(i.s);
            if (r === this.relayReadyService && e(), r === this.oauth2CallbackService) {
              let s = Je(i.a, (L) => L), a = Le(s[0]), l = location.origin;
              if (!a.startsWith(l + "#") && !a.startsWith(l + "?"))
                throw new Error(`oauth2callback: URL ${se(a)} does not match current origin ${l}.`);
              let u = a.substring(l.length + 1).split("&"), f = new de();
              for (let L of u) {
                let R = L.match("^([a-z_]+)=(.*)$");
                if (R === null)
                  throw new Error(`oauth2callback: URL part ${se(R)} does not match expected pattern.`);
                f.set(R[1], R[2]);
              }
              let g = f.get("state");
              if (g === void 0)
                throw new Error("oauth2callback: State argument is missing.");
              let v = this.pendingRequests.get(g);
              if (v === void 0)
                return;
              let y = f.get("error");
              if (y !== void 0) {
                let L = f.get("error_subtype"), R = y;
                L !== void 0 && (R += ": " + L), v.finished.dispatch(void 0, new Error(`Error obtaining Google OAuth2 token: ${R}`));
                return;
              }
              let w = f.get("access_token"), C = f.get("token_type"), b = f.get("expires_in"), E = f.get("scope");
              if (w === void 0 || C === void 0 || b === void 0 || E === void 0)
                throw new Error("oauth2callback: URL lacks expected parameters.");
              v.finished.dispatch({
                accessToken: w,
                tokenType: C,
                expiresIn: b,
                scope: E
              });
              return;
            }
          } catch (i) {
            throw new Error(`Invalid message received from ${rE}: ${se(t.data)}: ${i.message}.`);
          }
      });
    });
  }
  addPendingRequest(e) {
    let t = new f5();
    return this.pendingRequests.set(e, t), t.finished.add(() => {
      this.pendingRequests.delete(e);
    }), t;
  }
  makeAuthRequestUrl(e) {
    let t = `${u5}?client_id=${encodeURIComponent(e.clientId)}`;
    t += "&redirect_uri=postmessage", t += "&response_type=token";
    var i = e.origin;
    let r = i === void 0 ? location.origin : i;
    return t += `&origin=${encodeURIComponent(r)}`, t += `&proxy=${this.proxyName}`, t += "&include_granted_scopes=true", t += `&scope=${encodeURIComponent(e.scopes.join(" "))}`, e.state && (t += `&state=${e.state}`), e.approvalPrompt && (t += `&approval_prompt=${encodeURIComponent(e.approvalPrompt)}`), e.loginHint && (t += `&login_hint=${encodeURIComponent(e.loginHint)}`), e.immediate && (t += "&immediate=true"), e.authUser !== void 0 && (t += `&authuser=${e.authUser}`), t;
  }
};
var Sg;
function g5() {
  return Sg === void 0 && (Sg = new p5()), Sg;
}
function m5(n, e = Zt) {
  const t = Au(), i = g5(), r = i.makeAuthRequestUrl({
    state: t,
    clientId: n.clientId,
    scopes: n.scopes,
    approvalPrompt: n.approvalPrompt,
    loginHint: n.loginHint,
    immediate: n.immediate,
    authUser: n.authUser
  }), s = i.addPendingRequest(t), a = new Bt((l, d) => {
    s.finished.add((u, f) => {
      u !== void 0 ? l(u) : d(f);
    });
  });
  if (s.finished.add(e.add(() => {
    s.finished.dispatch(void 0, Ts);
  })), n.immediate)
    i.relayReadyPromise.then(() => {
      if (e.isCanceled)
        return;
      const l = document.createElement("iframe");
      l.src = r, l.style.display = "none", document.body.appendChild(l), s.finished.add(() => {
        Ft(l);
      });
    });
  else if (!e.isCanceled) {
    const l = open(r);
    l !== null && s.finished.add(() => {
      l.close();
    });
  }
  return a;
}
var v5 = class extends id {
  constructor(e) {
    super(), this.options = e, this.get = nf((t) => {
      const i = this.options, r = new nt(
        /*delay=*/
        true
      );
      let s;
      return new Bt((a, l) => {
        const d = () => {
          s = void 0, r.dispose();
        };
        t.add(() => {
          s !== void 0 && (s.cancel(), s = void 0, r.dispose(), l(Ts));
        });
        function u(g = `${i.description} authorization required.`, v = "Request authorization.") {
          r.setText(g + "  ");
          let y = document.createElement("button");
          y.textContent = v, r.element.appendChild(y), y.addEventListener("click", () => {
            f(
              /*immediate=*/
              false
            );
          }), r.setVisible(true);
        }
        function f(g) {
          s !== void 0 && s.cancel(), s = new As(), u(`Waiting for ${i.description} authorization...`, "Retry"), m5({
            clientId: i.clientId,
            scopes: i.scopes,
            immediate: g,
            authUser: 0
          }, s).then((v) => {
            s !== void 0 && (d(), a(v));
          }, (v) => {
            s !== void 0 && (s = void 0, g ? u() : u(`${i.description} authorization failed: ${v}.`, "Retry"));
          });
        }
        f(
          /*immediate=*/
          true
        );
      });
    });
  }
};
var y5 = "https://www.googleapis.com/auth/brainmaps";
var WD = class extends v5 {
  constructor(e) {
    super({ clientId: e, scopes: [y5], description: "Brain Maps" });
  }
};
il.register(gf, () => new WD(BRAINMAPS_CLIENT_ID));
var uh;
(function(n) {
  n[n.RAW = 0] = "RAW", n[n.JPEG = 1] = "JPEG", n[n.COMPRESSED_SEGMENTATION = 2] = "COMPRESSED_SEGMENTATION", n[n.COMPRESSO = 3] = "COMPRESSO", n[n.PNG = 4] = "PNG";
})(uh || (uh = {}));
var HD = class {
};
HD.RPC_ID = "precomputed/VolumeChunkSource";
var jD = class {
};
jD.RPC_ID = "precomputed/MeshSource";
var hh;
(function(n) {
  n[n.RAW = 0] = "RAW", n[n.GZIP = 1] = "GZIP";
})(hh || (hh = {}));
var av;
(function(n) {
  n[n.IDENTITY = 0] = "IDENTITY", n[n.MURMURHASH3_X86_128 = 1] = "MURMURHASH3_X86_128";
})(av || (av = {}));
var JD = class {
};
JD.RPC_ID = "precomputed/MultiscaleMeshSource";
var YD = class {
};
YD.RPC_ID = "precomputed/SkeletonSource";
var qD = class {
};
qD.RPC_ID = "precomputed/AnnotationSpatialIndexSource";
var KD = class {
};
KD.RPC_ID = "precomputed/AnnotationSource";
var ZD = class {
};
ZD.RPC_ID = "precomputed/IndexedSegmentPropertySource";
async function S5(n, e, t, i, r) {
  const s = await na(n, `https://www.googleapis.com/storage/v1/b/${e}/o?delimiter=${encodeURIComponent(i)}&prefix=${encodeURIComponent(t)}&neuroglancerOrigin=${encodeURIComponent(location.origin)}`, {}, Hi, r);
  pe(s);
  const a = Ce(s, "prefixes", Ci, []), l = Ce(s, "items", (d) => Je(d, (u) => (pe(u), K(u, "name", Le))), []).filter((d) => !d.endsWith("_$folder$"));
  return [...a, ...l];
}
async function b5(n, e, t, i, r) {
  if (!i.startsWith("/"))
    throw null;
  const a = await S5(n, t, i.substring(1), "/", r);
  let l = i.lastIndexOf("/");
  return {
    offset: l + e.length + 1,
    completions: a.map((d) => ({ value: d.substring(l) }))
  };
}
async function C5(n, e, t) {
  var i = await Ea(
    t,
    n,
    /*init=*/
    { headers: { accept: "text/html" } },
    async (u) => ({ text: await u.text(), contentType: u.headers.get("content-type") }),
    e
  );
  const r = i.text, s = i.contentType;
  if (s === null || /\btext\/html\b/i.exec(s) === null)
    return [];
  const a = new DOMParser().parseFromString(r, "text/html"), l = a.evaluate("//a/@href", a, null, XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE, null), d = [];
  for (let u = 0, f = l.snapshotLength; u < f; ++u) {
    const v = l.snapshotItem(u).textContent;
    v && d.push(new URL(v, n).toString());
  }
  return d;
}
async function w5(n, e, t) {
  console.log("getHtmlPathCompletions");
  const i = n.match(/^([a-z]+:\/\/.*\/)([^\/?#]*)$/);
  if (i === null)
    throw null;
  const r = await C5(i[1], e, t), s = i[1].length, a = [];
  for (const l of r)
    l.startsWith(n) && a.push({ value: l.substring(s) });
  return {
    offset: s,
    completions: a
  };
}
var x5 = [{ value: "gs://", description: "Google Cloud Storage (JSON API)" }, { value: "gs+xml://", description: "Google Cloud Storage (XML API)" }, {
  value: "gs+json://",
  description: "Google Cloud Storage (storage JSON API)"
}, {
  value: "gs+ngauth+http://",
  description: "Google Cloud Storage (JSON API) authenticated via ngauth"
}, {
  value: "gs+ngauth+https://",
  description: "Google Cloud Storage (JSON API) authenticated via ngauth"
}, {
  value: "gs+xml+ngauth+http://",
  description: "Google Cloud Storage (XML API) authenticated via ngauth"
}, {
  value: "gs+xml+ngauth+https://",
  description: "Google Cloud Storage (XML API) authenticated via ngauth"
}, { value: "s3://", description: "Amazon Simple Storage Service (S3)" }, { value: "https://" }, { value: "http://" }];
async function vS(n, e, t) {
  if (!e.includes("://"))
    return {
      offset: 0,
      completions: Qo(e, x5, (y) => y.value, (y) => y.description)
    };
  var i = rl(e, n);
  const r = i.url, s = i.credentialsProvider, a = e.length - r.length;
  let l;
  try {
    l = $o(r);
  } catch {
    throw null;
  }
  var d = l;
  const u = d.protocol, f = d.host, g = d.path, v = await (async () => {
    if (u === "gs+xml" && g.length > 0)
      return await bm(s, `${u}://${f}`, `https://storage.googleapis.com/${f}`, g, t);
    if ((u === "gs" || u === "gs+json") && g.length > 0)
      return await b5(s, `${u}://${f}`, f, g, t);
    if (u === "s3" && g.length > 0)
      return await IG(f, g, t);
    const y = r.match(/^((?:http|https):\/\/(?:storage\.googleapis\.com\/[^\/]+|[^\/]+\.storage\.googleapis\.com|[^\/]+\.s3(?:[^./]+)?\.amazonaws.com))(\/.*)$/);
    if (y !== null)
      return await bm(s, y[1], y[1], y[2], t);
    if ((u === "http" || u === "https") && g.length > 0)
      return await w5(r, t, s);
    throw null;
  })();
  return { offset: a + v.offset, completions: v.completions };
}
var E5 = class extends jt(Jt()(td), HD) {
};
var T5 = class extends jt(Jt()(Zc), jD) {
};
var k52 = class extends jt(Jt()(Qh), JD) {
};
var I5 = class extends jt(Jt()(ef), YD) {
  get skeletonVertexCoordinatesInVoxels() {
    return false;
  }
  get vertexAttributes() {
    return this.parameters.metadata.vertexAttributes;
  }
};
function aa(n, e) {
  const t = n.split("/");
  for (const i of e.split("/")) {
    if (i === ".." && t.length !== 0) {
      t.length = t.length - 1;
      continue;
    }
    t.push(i);
  }
  return t.join("/");
}
var L52 = class {
  constructor(e, t) {
    pe(e);
    const i = t === 1 ? 3 : 4, r = this.resolution = new Float64Array(i), s = this.voxelOffset = new Float32Array(i), a = this.size = new Float32Array(i);
    if (i === 4 && (r[3] = 1, a[3] = t), K(e, "resolution", (d) => at(r.subarray(0, 3), d, vn)), Ce(e, "voxel_offset", (d) => at(s.subarray(0, 3), d, pn)), K(e, "size", (d) => at(a.subarray(0, 3), d, dn)), this.chunkSizes = K(e, "chunk_sizes", (d) => Je(d, (u) => {
      const f = new Uint32Array(i);
      return i === 4 && (f[3] = t), at(f.subarray(0, 3), u, dn), f;
    })), this.chunkSizes.length === 0)
      throw new Error("No chunk sizes specified.");
    if (this.sharding = K(e, "sharding", mf), this.sharding !== void 0 && this.chunkSizes.length !== 1)
      throw new Error("Sharding requires a single chunk size per scale");
    (this.encoding = K(e, "encoding", (d) => Pn(d, uh))) === uh.COMPRESSED_SEGMENTATION && (this.compressedSegmentationBlockSize = K(e, "compressed_segmentation_block_size", (d) => at(_e(), d, dn))), this.key = K(e, "key", Le);
  }
};
function D5(n) {
  pe(n);
  const e = K(n, "data_type", (E) => Pn(E, J)), t = K(n, "num_channels", dn), i = K(n, "type", (E) => Pn(E, Dn)), r = K(n, "mesh", xi), s = K(n, "skeletons", xi), a = K(n, "segment_properties", xi), l = K(n, "scales", (E) => Je(E, (L) => new L52(L, t)));
  if (l.length === 0)
    throw new Error("Expected at least one scale");
  const d = l[0], u = t === 1 ? 3 : 4, f = new Float64Array(u), g = new Float64Array(u), v = new Float64Array(u), y = ["x", "y", "z"], w = ["m", "m", "m"];
  for (let E = 0; E < 3; ++E)
    f[E] = d.resolution[E] / 1e9, g[E] = d.voxelOffset[E], v[E] = g[E] + d.size[E];
  u === 4 && (f[3] = 1, v[3] = t, y[3] = "c^", w[3] = "");
  const b = mt({
    rank: u,
    names: y,
    units: w,
    scales: f,
    boundingBoxes: [Sa({ lowerBounds: g, upperBounds: v })]
  });
  return {
    dataType: e,
    volumeType: i,
    mesh: r,
    skeletons: s,
    segmentPropertyMap: a,
    scales: l,
    modelSpace: b
  };
}
var P5 = class extends _s {
  constructor(e, t, i, r) {
    super(e), this.credentialsProvider = t, this.url = i, this.info = r;
  }
  get dataType() {
    return this.info.dataType;
  }
  get volumeType() {
    return this.info.volumeType;
  }
  get rank() {
    return this.info.modelSpace.rank;
  }
  getSources(e) {
    const t = this.info.scales[0].resolution, i = this.rank;
    return Rc(this.info.scales.map((r) => {
      const s = r.resolution, a = i + 1, l = new Float32Array(a * a);
      l[l.length - 1] = 1;
      var d = this.info.modelSpace.boundingBoxes[0].box;
      const u = d.lowerBounds, f = d.upperBounds, g = new Float32Array(i), v = new Float32Array(i);
      for (let y = 0; y < 3; ++y) {
        const w = s[y] / t[y];
        l[a * y + y] = w;
        const C = r.voxelOffset[y];
        l[a * i + y] = C * w, g[y] = u[y] / w - C, v[y] = f[y] / w - C;
      }
      return i === 4 && (l[a * 3 + 3] = 1, g[3] = u[3], v[3] = f[3]), rd({
        rank: i,
        dataType: this.dataType,
        chunkToMultiscaleTransform: l,
        upperVoxelBound: r.size,
        volumeType: this.volumeType,
        chunkDataSizes: r.chunkSizes,
        baseVoxelOffset: r.voxelOffset,
        compressedSegmentationBlockSize: r.compressedSegmentationBlockSize,
        volumeSourceOptions: e
      }).map((y) => ({
        chunkSource: this.chunkManager.getChunkSource(E5, {
          credentialsProvider: this.credentialsProvider,
          spec: y,
          parameters: {
            url: aa(this.url, r.key),
            encoding: r.encoding,
            sharding: r.sharding
          }
        }),
        chunkToMultiscaleTransform: l,
        lowerClipBound: g,
        upperClipBound: v
      }));
    }));
  }
};
var A5 = jt(Jt()(Ui), KD);
var R5 = class extends jt(Jt()(No), qD) {
};
var M5 = class extends A5 {
  constructor(e, t) {
    const i = t.parameters;
    super(e, {
      rank: i.rank,
      relationships: i.relationships.map((r) => r.name),
      properties: i.properties,
      parameters: i
    }), this.readonly = true, this.metadata = t.metadata, this.credentialsProvider = t.credentialsProvider;
  }
  getSources() {
    return [this.metadata.spatialIndices.map((e) => {
      const t = e.spec;
      return {
        chunkSource: this.chunkManager.getChunkSource(R5, {
          credentialsProvider: this.credentialsProvider,
          parent: this,
          spec: t,
          parameters: e.parameters
        }),
        chunkToMultiscaleTransform: t.chunkToMultiscaleTransform
      };
    })];
  }
};
function N5(n, e, t) {
  return n.getChunkSource(T5, { parameters: t, credentialsProvider: e });
}
function XD(n) {
  return K(n, "transform", (e) => {
    const t = et();
    return e !== void 0 && at(t.subarray(0, 12), e, Lt), xv2(t, t), t;
  });
}
function _5(n) {
  pe(n);
  const e = K(n, "@type", Le);
  let t;
  if (e === "neuroglancer_legacy_mesh")
    t = void 0;
  else {
    if (e !== "neuroglancer_multilod_draco")
      throw new Error(`Unsupported mesh type: ${se(e)}`);
    {
      const r = K(n, "lod_scale_multiplier", vn), s = K(n, "vertex_quantization_bits", dn), a = XD(n), l = K(n, "sharding", mf);
      t = { lodScaleMultiplier: r, transform: a, sharding: l, vertexQuantizationBits: s };
    }
  }
  const i = K(n, "segment_properties", xi);
  return { metadata: t, segmentPropertyMap: i };
}
async function O5(n, e, t) {
  let i;
  try {
    i = await cl(n, e, t);
  } catch (r) {
    if (lf(r))
      return { metadata: void 0 };
    throw r;
  }
  return _5(i);
}
function sE(n) {
  return n === void 0 ? hh.RAW : Pn(n, hh);
}
function mf(n) {
  if (n === void 0)
    return;
  pe(n);
  const e = K(n, "@type", Le);
  if (e !== "neuroglancer_uint64_sharded_v1")
    throw new Error(`Unsupported sharding format: ${se(e)}`);
  const t = K(n, "hash", (d) => Pn(d, av)), i = K(n, "preshift_bits", pn), r = K(n, "shard_bits", pn), s = K(n, "minishard_bits", pn), a = K(n, "minishard_index_encoding", sE), l = K(n, "data_encoding", sE);
  return { hash: t, preshiftBits: i, shardBits: r, minishardBits: s, minishardIndexEncoding: a, dataEncoding: l };
}
function V5(n) {
  pe(n);
  const e = K(n, "@type", Le);
  if (e !== "neuroglancer_skeletons")
    throw new Error(`Unsupported skeleton type: ${se(e)}`);
  const t = XD(n), i = new de();
  K(n, "vertex_attributes", (a) => {
    a !== void 0 && Je(a, (l) => {
      pe(l);
      const d = K(l, "id", Le);
      if (d === "")
        throw new Error("vertex attribute id must not be empty");
      if (i.has(d))
        throw new Error(`duplicate vertex attribute id ${se(d)}`);
      const u = K(l, "data_type", (g) => Pn(g, J)), f = K(l, "num_components", dn);
      i.set(d, { dataType: u, numComponents: f });
    });
  });
  const r = K(n, "sharding", mf), s = K(n, "segment_properties", xi);
  return {
    metadata: { transform: t, vertexAttributes: i, sharding: r },
    segmentPropertyMap: s
  };
}
async function B5(n, e, t) {
  const i = await cl(n, e, t);
  return V5(i);
}
function QD() {
  return mt({ names: ["x", "y", "z"], units: ["m", "m", "m"], scales: Float64Array.of(1e-9, 1e-9, 1e-9) });
}
async function eP(n, e, t) {
  var i = await O5(n, e, t);
  const r = i.metadata, s = i.segmentPropertyMap;
  if (r === void 0)
    return {
      source: N5(n, e, { url: t, lod: 0 }),
      transform: et(),
      segmentPropertyMap: s
    };
  let a;
  const l = r.vertexQuantizationBits;
  if (l === 10)
    a = Fr.uint10;
  else if (l === 16)
    a = Fr.uint16;
  else
    throw new Error(`Invalid vertex quantization bits: ${l}`);
  return {
    source: n.getChunkSource(k52, {
      credentialsProvider: e,
      parameters: { url: t, metadata: r },
      format: {
        fragmentRelativeVertices: true,
        vertexPositionFormat: a
      }
    }),
    transform: r.transform,
    segmentPropertyMap: s
  };
}
async function tP(n, e, t) {
  var i = await B5(n, e, t);
  const r = i.metadata, s = i.segmentPropertyMap;
  return {
    source: n.getChunkSource(I5, {
      credentialsProvider: e,
      parameters: {
        url: t,
        metadata: r
      }
    }),
    transform: r.transform,
    segmentPropertyMap: s
  };
}
function cl(n, e, t) {
  return n.memoize.getUncounted({ type: "precomputed:metadata", url: t, credentialsProvider: xn(e) }, async () => await Ea(e, `${t}/info`, {}, Hi));
}
function aE(n) {
  const e = et(), t = n.scales[0].resolution;
  for (let i = 0; i < 3; ++i)
    e[5 * i] = 1 / t[i];
  return e;
}
async function F5(n, e, t, i) {
  const r = D5(i), s = new P5(n.chunkManager, e, t, r), a = r.modelSpace, l = [{
    id: "default",
    default: true,
    subsource: { volume: s }
  }, {
    id: "bounds",
    default: true,
    subsource: {
      staticAnnotations: Bc(a.bounds)
    }
  }];
  if (r.segmentPropertyMap !== void 0) {
    const f = aa(t, r.segmentPropertyMap), g = await cl(n.chunkManager, e, f), v = vf(n.chunkManager, e, g);
    l.push({
      id: "properties",
      default: true,
      subsource: { segmentPropertyMap: v }
    });
  }
  if (r.mesh !== void 0) {
    const f = aa(t, r.mesh);
    var d = await eP(n.chunkManager, e, f);
    const g = d.source, v = d.transform, y = aE(r);
    mn(y, y, v), l.push({
      id: "mesh",
      default: true,
      subsource: { mesh: g },
      subsourceToModelSubspaceTransform: y
    });
  }
  if (r.skeletons !== void 0) {
    const f = aa(t, r.skeletons);
    var u = await tP(n.chunkManager, e, f);
    const g = u.source, v = u.transform, y = aE(r);
    mn(y, y, v), l.push({
      id: "skeletons",
      default: true,
      subsource: { mesh: g },
      subsourceToModelSubspaceTransform: y
    });
  }
  return { modelTransform: Qn(a), subsources: l };
}
async function U5(n, e, t) {
  var i = await tP(n.chunkManager, e, t);
  const r = i.source, s = i.transform, a = i.segmentPropertyMap, l = [{
    id: "default",
    default: true,
    subsource: { mesh: r },
    subsourceToModelSubspaceTransform: s
  }];
  if (a !== void 0) {
    const d = aa(t, a), u = await cl(n.chunkManager, e, d), f = vf(n.chunkManager, e, u);
    l.push({
      id: "properties",
      default: true,
      subsource: { segmentPropertyMap: f }
    });
  }
  return {
    modelTransform: Qn(QD()),
    subsources: l
  };
}
function bg(n, e) {
  return pe(e), {
    url: aa(n, K(e, "key", Le)),
    sharding: K(e, "sharding", mf)
  };
}
var z5 = class {
  constructor(e, t) {
    this.url = e, pe(t);
    const i = K(t, "dimensions", Mu), r = i.rank, s = K(t, "lower_bound", (l) => at(new Float64Array(r), l, Lt)), a = K(t, "upper_bound", (l) => at(new Float64Array(r), l, Lt));
    this.coordinateSpace = mt({
      rank: r,
      names: i.names,
      units: i.units,
      scales: i.scales,
      boundingBoxes: [Sa({ lowerBounds: s, upperBounds: a })]
    }), this.parameters = {
      type: K(t, "annotation_type", (l) => Pn(l, Me)),
      rank: r,
      relationships: K(t, "relationships", (l) => Je(l, (d) => {
        const u = bg(e, d), f = K(d, "id", Le);
        return RZr(RZr({}, u), { name: f });
      })),
      properties: K(t, "properties", x1),
      byId: K(t, "by_id", (l) => bg(e, l))
    }, this.spatialIndices = K(t, "spatial", (l) => Je(l, (d) => {
      const u = bg(e, d), f = K(d, "grid_shape", (b) => at(new Float32Array(r), b, dn)), g = K(d, "chunk_size", (b) => at(new Float32Array(r), b, vn)), v = K(d, "limit", dn), y = new Float32Array(r);
      for (let b = 0; b < r; ++b)
        y[b] = f[b] * g[b];
      const w = Ds(Float32Array, r + 1);
      for (let b = 0; b < r; ++b)
        w[(r + 1) * r + b] = s[b];
      const C = RZr({
        limit: v,
        chunkToMultiscaleTransform: w
      }, Gc({
        rank: r,
        chunkDataSize: g,
        upperVoxelBound: y
      }));
      return C.upperChunkBound = f, {
        parameters: u,
        spec: C,
        limit: v
      };
    })), this.spatialIndices.reverse();
  }
};
async function G5(n, e, t, i) {
  const r = new z5(t, i);
  return {
    modelTransform: Qn(r.coordinateSpace),
    subsources: [{
      id: "default",
      default: true,
      subsource: {
        annotation: n.chunkManager.getChunkSource(M5, {
          credentialsProvider: e,
          metadata: r,
          parameters: r.parameters
        })
      }
    }]
  };
}
async function oE(n, e, t) {
  var i = await eP(n.chunkManager, e, t);
  const r = i.source, s = i.transform, a = i.segmentPropertyMap, l = [{
    id: "default",
    default: true,
    subsource: { mesh: r },
    subsourceToModelSubspaceTransform: s
  }];
  if (a !== void 0) {
    const d = aa(t, a), u = await cl(n.chunkManager, e, d), f = vf(n.chunkManager, e, u);
    l.push({
      id: "properties",
      default: true,
      subsource: { segmentPropertyMap: f }
    });
  }
  return {
    modelTransform: Qn(QD()),
    subsources: l
  };
}
function $5(n) {
  pe(n);
  const e = new re(), t = K(n, "ids", (s) => {
    s = Ci(s);
    const a = s.length, l = new Uint32Array(a * 2);
    for (let d = 0; d < a; ++d) {
      if (!e.tryParseString(s[d]))
        throw new Error(`Invalid uint64 id: ${se(s[d])}`);
      l[2 * d] = e.low, l[2 * d + 1] = e.high;
    }
    return l;
  }), i = t.length / 2, r = K(n, "properties", (s) => Je(s, (a) => {
    pe(a);
    const l = K(a, "id", Le), d = Ce(a, "description", Le), u = K(a, "type", (g) => {
      if (g !== "label" && g !== "description" && g !== "string" && g !== "tags" && g !== "number")
        throw new Error(`Invalid property type: ${se(g)}`);
      return g;
    });
    if (u === "tags") {
      const g = K(a, "tags", Ci);
      let v = Ce(a, "tag_descriptions", Ci);
      if (v === void 0)
        v = new Array(g.length), v.fill("");
      else if (v.length !== g.length)
        throw new Error(`Expected tag_descriptions to have length: ${g.length}`);
      const y = K(a, "values", (w) => {
        if (!Array.isArray(w) || w.length !== i)
          throw new Error(`Expected ${i} values, but received: ${w.length}`);
        return w.map((C) => String.fromCharCode(...C));
      });
      return { id: l, description: d, type: u, tags: g, tagDescriptions: v, values: y };
    }
    if (u === "number") {
      const g = K(a, "data_type", (C) => Pn(C, J));
      if (g === J.UINT64)
        throw new Error("uint64 properties not supported");
      const v = K(a, "values", (C) => {
        if (!Array.isArray(C) || C.length !== i)
          throw new Error(`Expected ${i} values, but received: ${C.length}`);
        return L_[g].from(C);
      });
      let y = 1 / 0, w = -1 / 0;
      for (let C = v.length - 1; C >= 0; --C) {
        const b = v[C];
        b < y && (y = b), b > w && (w = b);
      }
      return { id: l, description: d, type: u, dataType: g, values: v, bounds: [y, w] };
    }
    const f = K(a, "values", (g) => {
      if (Ci(g), g.length !== i)
        throw new Error(`Expected ${i} values, but received: ${g.length}`);
      return g;
    });
    return { id: l, description: d, type: u, values: f };
  }));
  return xW({ ids: t, properties: r });
}
jt(Jt()(vW), ZD);
function vf(n, e, t, i) {
  try {
    const r = K(t, "@type", Le);
    if (r !== "neuroglancer_segment_properties")
      throw new Error(`Unsupported segment property map type: ${se(r)}`);
    const s = Ce(t, "inline", $5);
    return new oL({ inlineProperties: s });
  } catch (r) {
    throw new Error(`Error parsing segment property map: ${r.message}`);
  }
}
async function W52(n, e, t, i) {
  return {
    modelTransform: Qn(To),
    subsources: [{
      id: "default",
      default: true,
      subsource: {
        segmentPropertyMap: vf(n.chunkManager, e, i)
      }
    }]
  };
}
var H5 = /^([^#]*)(?:#(.*))?$/;
function Cg(n) {
  var e = n.match(H5), t = ce(e, 3);
  let i = t[1], r = t[2];
  i.endsWith("/") && (i = i.substring(0, i.length - 1));
  const s = Yo(r || "");
  return { url: i, parameters: s };
}
function lE2(n, e) {
  const t = m1(e);
  return t && (n += `#${t}`), n;
}
var j5 = class extends ba {
  get description() {
    return "Precomputed file-backed data source";
  }
  normalizeUrl(e) {
    var t = Cg(e.providerUrl);
    const i = t.url, r = t.parameters;
    return e.providerProtocol + "://" + lE2(i, r);
  }
  convertLegacyUrl(e) {
    var t = Cg(e.providerUrl);
    const i = t.url, r = t.parameters;
    return e.type === "mesh" && (r.type = "mesh"), e.providerProtocol + "://" + lE2(i, r);
  }
  get(e) {
    var t = Cg(e.providerUrl);
    const i = t.url, r = t.parameters;
    return e.chunkManager.memoize.getUncounted({ type: "precomputed:get", providerUrl: i, parameters: r }, async () => {
      var s = rl(i, e.credentialsManager);
      const a = s.url, l = s.credentialsProvider;
      let d;
      try {
        d = await cl(e.chunkManager, l, a);
      } catch (g) {
        if (lf(g) && r.type === "mesh")
          return await oE(e, l, a);
        throw g;
      }
      pe(d);
      const u = Ce(d, "redirect", Le);
      if (u !== void 0)
        throw new sk(u);
      const f = Ce(d, "@type", Le);
      switch (f) {
        case "neuroglancer_skeletons":
          return await U5(e, l, a);
        case "neuroglancer_multilod_draco":
        case "neuroglancer_legacy_mesh":
          return await oE(e, l, a);
        case "neuroglancer_annotations_v1":
          return await G5(e, l, a, d);
        case "neuroglancer_segment_properties":
          return await W52(e, l, a, d);
        case "neuroglancer_multiscale_volume":
        case void 0:
          return await F5(e, l, a, d);
        default:
          throw new Error(`Invalid type: ${se(f)}`);
      }
    });
  }
  completeUrl(e) {
    return vS(e.credentialsManager, e.providerUrl, e.cancellationToken);
  }
};
xa("precomputed", () => new j5());
var nP = function(n) {
  if (n == null)
    throw new TypeError("Cannot destructure undefined");
};
var fh;
(function(n) {
  n[n.RAW = 0] = "RAW", n[n.GZIP = 1] = "GZIP", n[n.BLOSC = 2] = "BLOSC";
})(fh || (fh = {}));
var iP = class {
};
iP.RPC_ID = "n5/VolumeChunkSource";
var J5 = class extends jt(Jt()(td), iP) {
};
var Y5 = class extends _s {
  constructor(e, t, i, r) {
    super(e), this.credentialsProvider = t, this.multiscaleMetadata = i, this.scales = r;
    let s, a;
    if (r.forEach((g, v) => {
      if (g !== void 0) {
        if (a === void 0 && (a = v), s !== void 0 && g.dataType !== s)
          throw new Error(`Scale s${v} has data type ${J[g.dataType]} but expected ${J[s]}.`);
        s = g.dataType;
      }
    }), s === void 0)
      throw new Error("At least one scale must be specified.");
    const l = i.scales[a], d = r[a];
    this.dataType = s, this.volumeType = Dn.IMAGE, this.baseScaleIndex = a;
    const u = i.modelSpace, f = u.rank;
    this.modelSpace = mt({
      names: u.names,
      scales: u.scales,
      units: u.units,
      boundingBoxes: [{
        transform: eC(
          Float64Array,
          l.downsamplingFactor,
          /*square=*/
          false
        ),
        box: {
          lowerBounds: new Float64Array(f),
          upperBounds: new Float64Array(d.size)
        }
      }],
      coordinateArrays: u.coordinateArrays
    });
  }
  get rank() {
    return this.modelSpace.rank;
  }
  getSources(e) {
    nP(this);
    const t = this.scales, i = this.rank, r = this.multiscaleMetadata.scales;
    return Rc(t.filter((s) => s !== void 0).map((s, a) => {
      const l = r[a], d = eC(Float32Array, l.downsamplingFactor);
      return rd({
        rank: i,
        chunkToMultiscaleTransform: d,
        dataType: s.dataType,
        upperVoxelBound: s.size,
        volumeType: this.volumeType,
        chunkDataSizes: [s.chunkSize],
        volumeSourceOptions: e
      }).map((u) => ({
        chunkSource: this.chunkManager.getChunkSource(J5, {
          credentialsProvider: this.credentialsProvider,
          spec: u,
          parameters: { url: l.url, encoding: s.encoding }
        }),
        chunkToMultiscaleTransform: d
      }));
    }));
  }
};
var q5 = class {
  constructor(e) {
    pe(e), this.dataType = K(e, "dataType", (i) => Pn(i, J)), this.size = Float32Array.from(K(e, "dimensions", (i) => Je(i, dn))), this.chunkSize = K(e, "blockSize", (i) => at(new Uint32Array(this.size.length), i, dn));
    let t;
    Ce(e, "compression", (i) => {
      t = K(i, "type", (r) => Pn(r, fh));
    }), t === void 0 && (t = K(e, "compressionType", (i) => Pn(i, fh))), this.encoding = t;
  }
};
function K5(n, e, t) {
  return Bt.all(t.scales.map(async (i) => {
    const r = await rP(n, e, i.url, true);
    if (r !== void 0)
      return new q5(r);
  }));
}
function Z5(n) {
  var e = $o(n);
  let t = e.protocol, i = e.host, r = e.path;
  r.endsWith("/") && (r = r.substring(0, r.length - 1));
  const s = [];
  for (; ; ) {
    s.push(`${t}://${i}${r}/attributes.json`);
    const a = r.lastIndexOf("/");
    if (a === -1)
      break;
    r = r.substring(0, a);
  }
  return s;
}
function X5(n, e, t, i) {
  return n.memoize.getUncounted({ type: "n5:attributes.json", url: t, credentialsProvider: xn(e) }, () => Ea(e, t, {}, Hi).then((r) => {
    try {
      return pe(r);
    } catch (s) {
      throw new Error(`Error reading attributes from ${t}: ${s.message}`);
    }
  }).catch((r) => {
    if (lf(r))
      return i ? void 0 : {};
    throw r;
  }));
}
async function rP(n, e, t, i) {
  const r = Z5(t), s = await Bt.all(r.map((a, l) => X5(n, e, a, i && l === r.length - 1)));
  if (s.indexOf(void 0) === -1)
    return s.reverse(), RZr({}, ...s);
}
function gs(n, e) {
  if (n !== -1 && e !== n)
    throw new Error(`Rank mismatch, received ${e} but expected ${n}`);
  return e;
}
function sP(n) {
  return Float64Array.from(Je(n, vn));
}
function aP(n) {
  const e = Bi(n);
  if (e.length === 0)
    throw new Error("Expected non-empty array");
  let t = -1;
  return { all: Je(e, (r) => {
    const s = sP(r);
    return t = gs(t, s.length), s;
  }), single: void 0, rank: t };
}
function Q5(n) {
  const e = Bi(n);
  if (e.length === 0)
    throw new Error("Expected non-empty array");
  if (Array.isArray(e[0]))
    return aP(e);
  const t = sP(n);
  return { all: void 0, single: t, rank: t.length };
}
var eJ = ["x", "y", "z", "t", "c"];
function tJ(n) {
  const e = eJ.slice(0, n);
  for (; e.length < n; )
    e.push(`d${e.length + 1}`);
  return e;
}
function nJ(n, e) {
  pe(e);
  let t = -1, i = Ce(e, "resolution", (v) => {
    const y = Float64Array.from(Je(v, vn));
    return t = gs(t, y.length), y;
  }), r = Ce(e, "axes", (v) => {
    const y = Je(v, Le);
    return t = gs(t, y.length), y;
  }), s = Ce(e, "units", (v) => {
    const y = Je(v, nC);
    return t = gs(t, y.length), y;
  }), a = { unit: "m", exponent: -9 }, l, d;
  Ce(e, "downsamplingFactors", (v) => {
    var y = Q5(v);
    const w = y.single, C = y.all, b = y.rank;
    t = gs(t, b), w !== void 0 && (l = w), C !== void 0 && (d = C);
  }), Ce(e, "pixelResolution", (v) => {
    a = K(v, "unit", nC), Ce(v, "dimensions", (y) => {
      i = Float64Array.from(Je(y, vn)), t = gs(t, i.length);
    });
  }), Ce(e, "scales", (v) => {
    var y = aP(v);
    const w = y.all, C = y.rank;
    t = gs(t, C), d = w;
  });
  const u = Ce(e, "dimensions", (v) => {
    const y = Je(v, dn);
    return t = gs(t, y.length), y;
  });
  if (t === -1)
    throw new Error("Unable to determine rank of dataset");
  s === void 0 && (s = new Array(t), s.fill(a)), i === void 0 && (i = new Float64Array(t), i.fill(1));
  for (let v = 0; v < t; ++v)
    i[v] = Ov(i[v], s[v].exponent);
  const f = new Array(t);
  r !== void 0 && Ce(e, "coordinateArrays", (v) => {
    pe(v);
    for (let y = 0; y < t; ++y) {
      const w = r[y];
      if (Object.prototype.hasOwnProperty.call(v, w)) {
        const C = Ci(v[w]);
        f[y] = {
          explicit: false,
          labels: C,
          coordinates: De(C, (b, E) => E)
        }, s[y] = { unit: "", exponent: 0 }, i[y] = 1;
      }
    }
  }), r === void 0 && (r = tJ(t));
  const g = mt({
    rank: t,
    valid: true,
    names: r,
    scales: i,
    units: s.map((v) => v.unit),
    coordinateArrays: f
  });
  if (u === void 0) {
    if (d === void 0)
      throw new Error("Not valid single-resolution or multi-resolution dataset");
    return {
      modelSpace: g,
      url: n,
      attributes: e,
      scales: d.map((v, y) => ({ url: `${n}/s${y}`, downsamplingFactor: v }))
    };
  }
  return l === void 0 && (l = new Float64Array(t), l.fill(1)), {
    modelSpace: g,
    url: n,
    attributes: e,
    scales: [{ url: n, downsamplingFactor: l }]
  };
}
var iJ = class extends ba {
  get description() {
    return "N5 data source";
  }
  get(e) {
    let t = e.providerUrl;
    return t.endsWith("/") && (t = t.substring(0, t.length - 1)), e.chunkManager.memoize.getUncounted({ type: "n5:MultiscaleVolumeChunkSource", providerUrl: t }, async () => {
      var i = rl(t, e.credentialsManager);
      const r = i.url, s = i.credentialsProvider, a = await rP(e.chunkManager, s, r, false), l = nJ(r, a), d = await K5(e.chunkManager, s, l), u = new Y5(e.chunkManager, s, l, d);
      return {
        modelTransform: Qn(u.modelSpace),
        subsources: [{
          id: "default",
          default: true,
          url: void 0,
          subsource: { volume: u }
        }, {
          id: "bounds",
          default: true,
          url: void 0,
          subsource: {
            staticAnnotations: Bc(u.modelSpace.bounds)
          }
        }]
      };
    });
  }
  completeUrl(e) {
    return vS(e.credentialsManager, e.providerUrl, e.cancellationToken);
  }
};
xa("n5", () => new iJ());
var fo;
(function(n) {
  n[n.RAW = 0] = "RAW", n[n.GZIP = 1] = "GZIP", n[n.BLOSC = 2] = "BLOSC";
})(fo || (fo = {}));
var oP = class {
};
oP.RPC_ID = "zarr/VolumeChunkSource";
var Ar = new de();
Ar.set("|u1", {
  endianness: ai.LITTLE,
  dataType: J.UINT8
});
Ar.set("|i1", {
  endianness: ai.LITTLE,
  dataType: J.INT8
});
for (let n of [["<", ai.LITTLE], [">", ai.BIG]]) {
  cE = ce(n, 2);
  let e = cE[0], t = cE[1];
  for (let i of ["u", "i"])
    Ar.set(`${e}${i}8`, {
      endianness: t,
      dataType: J.UINT64
    });
  Ar.set(`${e}u2`, {
    endianness: t,
    dataType: J.UINT16
  }), Ar.set(`${e}i2`, {
    endianness: t,
    dataType: J.INT16
  }), Ar.set(`${e}u4`, {
    endianness: t,
    dataType: J.UINT32
  }), Ar.set(`${e}i4`, {
    endianness: t,
    dataType: J.INT32
  }), Ar.set(`${e}f4`, {
    endianness: t,
    dataType: J.FLOAT32
  });
}
var cE;
function rJ(n) {
  const e = Ar.get(n);
  if (e === void 0)
    throw new Error(`Unsupported numpy data type: ${se(n)}`);
  return e;
}
var sJ = class extends jt(Jt()(td), oP) {
};
function lP(n) {
  return Ce(n, "dimension_separator", (e) => {
    if (e !== "." && e !== "/")
      throw new Error(`Expected "." or "/", but received: ${se(e)}`);
    return e;
  });
}
function aJ(n) {
  try {
    pe(n), K(n, "zarr_format", (l) => {
      if (l !== 2)
        throw new Error(`Expected 2 but received: ${se(l)}`);
    });
    const e = K(n, "shape", (l) => Je(l, (d) => {
      if (typeof d != "number" || !jn(d) || d < 0)
        throw new Error(`Expected non-negative integer, but received: ${se(d)}`);
      return d;
    })), t = K(n, "chunks", (l) => at(new Array(e.length), l, (d) => {
      if (typeof d != "number" || !jn(d) || d <= 0)
        throw new Error(`Expected positive integer, but received: ${se(d)}`);
      return d;
    })), i = K(n, "order", (l) => {
      if (l !== "C" && l !== "F")
        throw new Error(`Expected "C" or "F", but received: ${se(l)}`);
      return l;
    }), r = lP(n), s = K(n, "dtype", (l) => rJ(Le(l))), a = K(n, "compressor", (l) => {
      if (l === null)
        return fo.RAW;
      pe(l);
      const d = K(l, "id", Le);
      switch (d) {
        case "blosc":
          return fo.BLOSC;
        case "gzip":
          return fo.GZIP;
        case "zlib":
          return fo.GZIP;
        default:
          throw new Error(`Unsupported compressor: ${se(d)}`);
      }
    });
    return {
      rank: e.length,
      shape: e,
      chunks: t,
      order: i,
      dataType: s.dataType,
      encoding: { compressor: a, endianness: s.endianness },
      dimensionSeparator: r
    };
  } catch (e) {
    throw new Error(`Error parsing zarr metadata: ${e.message}`);
  }
}
var oJ = class extends _s {
  constructor(e, t, i, r, s, a) {
    super(e), this.credentialsProvider = t, this.url = i, this.separator = r, this.metadata = s, this.attrs = a, this.dataType = s.dataType, this.volumeType = Dn.IMAGE;
    let l = Ce(a, "_ARRAY_DIMENSIONS", (d) => at(new Array(s.rank), d, Le));
    l === void 0 && (l = De(s.shape, (d, u) => `d${u}`)), this.modelSpace = mt({
      names: l,
      scales: Float64Array.from(s.shape, () => 1),
      units: De(s.shape, () => ""),
      boundingBoxes: [Sa({
        lowerBounds: new Float64Array(s.rank),
        upperBounds: Float64Array.from(s.shape)
      })]
    });
  }
  get rank() {
    return this.metadata.rank;
  }
  getSources(e) {
    const t = this.metadata, i = t.rank, r = t.chunks, s = t.shape;
    let a, l, d;
    if (t.order === "F")
      a = Uint32Array.from(r), l = Float32Array.from(s), d = Ds(Float32Array, i + 1);
    else {
      a = new Uint32Array(i), l = new Float32Array(i), d = new Float32Array((i + 1) ** 2), d[(i + 1) ** 2 - 1] = 1;
      for (let u = 0; u < i; ++u)
        a[u] = r[i - 1 - u], l[u] = s[i - 1 - u], d[u + (i - 1 - u) * (i + 1)] = 1;
    }
    return Rc([rd({
      rank: i,
      chunkToMultiscaleTransform: d,
      dataType: t.dataType,
      upperVoxelBound: l,
      volumeType: this.volumeType,
      chunkDataSizes: [a],
      volumeSourceOptions: e
    }).map((u) => ({
      chunkSource: this.chunkManager.getChunkSource(sJ, {
        credentialsProvider: this.credentialsProvider,
        spec: u,
        parameters: {
          url: this.url,
          encoding: t.encoding,
          separator: this.separator
        }
      }),
      chunkToMultiscaleTransform: d
    }))]);
  }
};
function lJ(n, e, t) {
  return n.memoize.getUncounted({ type: "zarr:.zattrs json", url: t, credentialsProvider: xn(e) }, async () => {
    try {
      const i = await Ea(e, t + "/.zattrs", {}, Hi);
      return pe(i), i;
    } catch (i) {
      if (lf(i))
        return {};
      throw i;
    }
  });
}
function cJ(n, e, t) {
  return n.memoize.getUncounted({ type: "zarr:.zarray json", url: t, credentialsProvider: xn(e) }, async () => {
    const i = await Ea(e, t + "/.zarray", {}, Hi);
    return aJ(i);
  });
}
var dJ = [{
  key: { value: "dimension_separator", description: "Dimension separator in chunk keys" },
  values: [{ value: ".", description: "(default)" }, { value: "/", description: "" }]
}];
var uJ = class extends ba {
  get description() {
    return "Zarr data source";
  }
  get(e) {
    var t = e.providerUrl.match(/([^?]*)(?:\?(.*))?$/), i = ce(t, 3);
    let r = i[1], s = i[2];
    const a = Yo(s || "");
    pe(a);
    const l = lP(a);
    return r.endsWith("/") && (r = r.substring(0, r.length - 1)), e.chunkManager.memoize.getUncounted({ type: "zarr:MultiscaleVolumeChunkSource", providerUrl: r, dimensionSeparator: l }, async () => {
      var d = rl(r, e.credentialsManager);
      const u = d.url, f = d.credentialsProvider;
      var g = await Bt.all([cJ(e.chunkManager, f, u), lJ(e.chunkManager, f, u)]), v = ce(g, 2);
      const y = v[0], w = v[1];
      if (y.dimensionSeparator !== void 0 && l !== void 0 && y.dimensionSeparator !== l)
        throw new Error(`Explicitly specified dimension separator ${se(l)} does not match value in .zarray ${se(y.dimensionSeparator)}`);
      const C = new oJ(e.chunkManager, f, u, l || y.dimensionSeparator || ".", y, w);
      return {
        modelTransform: Qn(C.modelSpace),
        subsources: [{
          id: "default",
          default: true,
          url: void 0,
          subsource: { volume: C }
        }, {
          id: "bounds",
          default: true,
          url: void 0,
          subsource: {
            staticAnnotations: Bc(C.modelSpace.bounds)
          }
        }]
      };
    });
  }
  async completeUrl(e) {
    var t = e.providerUrl.match(/([^?]*)(?:\?(.*))?$/), i = ce(t, 3);
    let r = i[2];
    return r !== void 0 ? Xo(e.providerUrl.length - r.length, await rk(r, dJ)) : await vS(e.credentialsManager, e.providerUrl, e.cancellationToken);
  }
};
xa("zarr", () => new uJ());
var pa;
(function(n) {
  n[n.DEFAULT = 0] = "DEFAULT", n[n.ADDITIVE = 1] = "ADDITIVE";
})(pa || (pa = {}));
var hJ = new de([[pa.DEFAULT, (n) => {
  n.blendFunc(n.SRC_ALPHA, n.ONE_MINUS_SRC_ALPHA);
}], [pa.ADDITIVE, (n) => {
  n.blendFunc(n.SRC_ALPHA, n.ONE);
}]]);
function fJ(n = pa.DEFAULT) {
  return new Hh(pa, n);
}
var cP = `#uicontrol invlerp normalized
void main() {
  emitGrayscale(normalized());
}
`;
function pJ(n = cP) {
  return Yv(n);
}
function dP(n, e) {
  n.addFragmentCode(`
#define VOLUME_RENDERING false

void emitRGBA(vec4 rgba) {
  emit(vec4(rgba.rgb, rgba.a * uOpacity));
}
void emitRGB(vec3 rgb) {
  emit(vec4(rgb, uOpacity));
}
void emitGrayscale(float value) {
  emit(vec4(value, value, value, uOpacity));
}
void emitTransparent() {
  emit(vec4(0.0, 0.0, 0.0, 0.0));
}
`), n.addFragmentCode(xc), wc(e, n), n.setFragmentMainFunction(Sc(e.parseResult.code));
}
var gJ = class extends mL {
  constructor(e, t) {
    var i, r, s;
    const a = t.opacity, l = t.blendMode, d = t.shaderControlState;
    super(e, RZr(RZr({}, t), { fallbackShaderParameters: new gt(ny(Fh(cP, {
      imageData: {
        dataType: e.dataType,
        channelRank: (s = (r = (i = t.channelCoordinateSpace) === null || i === void 0 ? void 0 : i.value) === null || r === void 0 ? void 0 : r.rank) !== null && s !== void 0 ? s : 0
      }
    }))), encodeShaderParameters: (u) => u.key, shaderParameters: d.builderState, dataHistogramSpecifications: d.histogramSpecifications })), this.shaderControlState = d, this.opacity = a, this.blendMode = l, this.registerDisposer(a.changed.add(this.redrawNeeded.dispatch)), this.registerDisposer(l.changed.add(this.redrawNeeded.dispatch)), this.registerDisposer(d.changed.add(this.redrawNeeded.dispatch));
  }
  defineShader(e, t) {
    if (t.parseResult.errors.length !== 0)
      throw new Error("Invalid UI control specification");
    e.addUniform("highp float", "uOpacity"), dP(e, t);
  }
  initializeShader(e, t, i) {
    const r = this.gl;
    r.uniform1f(t.uniform("uOpacity"), this.opacity.value), Ao(r, t, this.shaderControlState, i.parseResult.controls);
  }
  setGLBlendMode(e, t) {
    const i = this.blendMode.value;
    i === pa.ADDITIVE || t > 0 ? (e.enable(e.BLEND), hJ.get(i)(e)) : e.disable(WebGL2RenderingContext.BLEND);
  }
};
var mJ = "volume_rendering/VolumeRenderingRenderLayer";
var vJ = "volume_rendering/VolumeRenderingRenderLayer/update";
var ov = 64;
var yJ = Mc();
function SJ(n, e, t) {
  let i = 0, r = 0;
  for (let u = 0; u < 3; ++u) {
    const f = n[16 + u], g = f * e[u], v = f * t[u];
    i += Math.min(g, v), r += Math.max(g, v);
  }
  const s = -n[19], a = Math.max(s, i), l = n[23], d = Math.min(l, r);
  return { near: s, far: l, adjustedNear: a, adjustedFar: d };
}
function dE(n, e, t, i, r, s) {
  if (i.length === 0)
    return;
  const a = n.viewMatrix, l = n.projectionMat, u = n.displayDimensionRenderInfo.voxelPhysicalScales, f = Mg(u), v = (e1(l) / ov) ** 3, y = wv(kh(yJ, a)), w = (A) => {
    const I = i[A];
    return Math.abs(I.chunkLayout.detTransform * y);
  };
  let C = i.length - 1, b = w(C);
  for (let A = C - 1; A >= 0; --A) {
    const I = w(A);
    if (Math.abs(I - v) < Math.abs(b - v))
      b = I, C = A;
    else
      break;
  }
  const E = Math.pow(b * f / y, 1 / 3), L = Math.pow(b, 1 / 3) * n.width / (2 * l[0]);
  let R = true;
  const _ = i[C];
  $T(n, e, _, (A, I) => {
    R && (r(_, C, E, L, I), R = false), s(_, C, A);
  });
}
var bJ = et();
var CJ = new Float32Array(24);
var wJ = class extends el {
  constructor(e) {
    super(), this.multiscaleSource = e.multiscaleSource, this.transform = e.transform, this.channelCoordinateSpace = e.channelCoordinateSpace, this.shaderControlState = e.shaderControlState, this.localPosition = e.localPosition, this.renderScaleTarget = e.renderScaleTarget, this.renderScaleHistogram = e.renderScaleHistogram, this.registerDisposer(this.renderScaleHistogram.visibility.add(this.visibility));
    const t = this.registerDisposer(wi((a) => a.rank, [this.channelCoordinateSpace]));
    this.shaderGetter = qv(this, this.gl, {
      memoizeKey: "VolumeRenderingRenderLayer",
      parameters: e.shaderControlState.builderState,
      getContextKey: ({ emitter: a, chunkFormat: l }) => `${xn(a)}:${l.shaderKey}`,
      shaderError: e.shaderError,
      extraParameters: t,
      defineShader: (a, { emitter: l, chunkFormat: d }, u, f) => {
        if (u.parseResult.errors.length !== 0)
          throw new Error("Invalid UI control specification");
        Wr(a), a.addFragmentCode(`
#define VOLUME_RENDERING true
`), l(a), a.addUniform("highp float", "uNearLimitFraction"), a.addUniform("highp float", "uFarLimitFraction"), a.addUniform("highp int", "uMaxSteps"), a.addUniform("highp vec3", "uTranslation"), a.addUniform("highp mat4", "uModelViewProjectionMatrix"), a.addUniform("highp mat4", "uInvModelViewProjectionMatrix"), a.addUniform("highp vec3", "uChunkDataSize"), a.addUniform("highp vec3", "uLowerClipBound"), a.addUniform("highp vec3", "uUpperClipBound"), a.addUniform("highp float", "uBrightnessFactor"), a.addVarying("highp vec4", "vNormalizedPosition"), a.addVertexCode(l4), a.setVertexMain(`
vec3 boxVertex = getBoxFaceVertexPosition(gl_VertexID);
vec3 position = max(uLowerClipBound, min(uUpperClipBound, uTranslation + boxVertex * uChunkDataSize));
vNormalizedPosition = gl_Position = uModelViewProjectionMatrix * vec4(position, 1.0);
gl_Position.z = 0.0;
`), a.addFragmentCode(`
vec3 curChunkPosition;
vec4 outputColor;
void userMain();
`), nI(a, d, f, "curChunkPosition"), a.addFragmentCode(`
void emitRGBA(vec4 rgba) {
  float alpha = rgba.a * uBrightnessFactor;
  outputColor += vec4(rgba.rgb * alpha, alpha);
}
void emitRGB(vec3 rgb) {
  emitRGBA(vec4(rgb, 1.0));
}
void emitGrayscale(float value) {
  emitRGB(vec3(value, value, value));
}
void emitTransparent() {
  emitRGBA(vec4(0.0, 0.0, 0.0, 0.0));
}
`), a.setFragmentMainFunction(`
void main() {
  vec2 normalizedPosition = vNormalizedPosition.xy / vNormalizedPosition.w;
  vec4 nearPointH = uInvModelViewProjectionMatrix * vec4(normalizedPosition, -1.0, 1.0);
  vec4 farPointH = uInvModelViewProjectionMatrix * vec4(normalizedPosition, 1.0, 1.0);
  vec3 nearPoint = nearPointH.xyz / nearPointH.w;
  vec3 farPoint = farPointH.xyz / farPointH.w;
  vec3 rayVector = farPoint - nearPoint;
  vec3 boxStart = max(uLowerClipBound, uTranslation);
  vec3 boxEnd = min(boxStart + uChunkDataSize, uUpperClipBound);
  float intersectStart = uNearLimitFraction;
  float intersectEnd = uFarLimitFraction;
  for (int i = 0; i < 3; ++i) {
    float startPt = nearPoint[i];
    float endPt = farPoint[i];
    float boxLower = boxStart[i];
    float boxUpper = boxEnd[i];
    float r = rayVector[i];
    float startFraction;
    float endFraction;
    if (startPt >= boxLower && startPt <= boxUpper) {
      startFraction = 0.0;
    } else {
      startFraction = min((boxLower - startPt) / r, (boxUpper - startPt) / r);
    }
    if (endPt >= boxLower && endPt <= boxUpper) {
      endFraction = 1.0;
    } else {
      endFraction = max((boxLower - startPt) / r, (boxUpper - startPt) / r);
    }
    intersectStart = max(intersectStart, startFraction);
    intersectEnd = min(intersectEnd, endFraction);
  }
  float stepSize = (uFarLimitFraction - uNearLimitFraction) / float(uMaxSteps - 1);
  int startStep = int(floor((intersectStart - uNearLimitFraction) / stepSize));
  int endStep = min(uMaxSteps, int(floor((intersectEnd - uNearLimitFraction) / stepSize)) + 1);
  outputColor = vec4(0, 0, 0, 0);
  for (int step = startStep; step < endStep; ++step) {
    vec3 position = mix(nearPoint, farPoint, uNearLimitFraction + float(step) * stepSize);
    curChunkPosition = position - uTranslation;
    userMain();
  }
  emit(outputColor, 0u);
}
`), a.addFragmentCode(xc), wc(u, a), a.addFragmentCode(`
#define main userMain
` + Sc(u.parseResult.code) + `
#undef main
`);
      }
    }), this.vertexIdHelper = this.registerDisposer(mr.get(this.gl)), this.registerDisposer(this.renderScaleTarget.changed.add(this.redrawNeeded.dispatch)), this.registerDisposer(this.shaderControlState.changed.add(this.redrawNeeded.dispatch)), this.registerDisposer(this.localPosition.changed.add(this.redrawNeeded.dispatch)), this.registerDisposer(this.transform.changed.add(this.redrawNeeded.dispatch)), this.registerDisposer(this.shaderControlState.fragmentMain.changed.add(this.redrawNeeded.dispatch));
    const i = this.multiscaleSource.chunkManager, r = this.registerDisposer(new Hc(this.layerChunkProgressInfo)), s = i.rpc;
    r.RPC_TYPE_ID = mJ, r.initializeCounterpart(s, {
      chunkManager: i.rpcId,
      localPosition: this.registerDisposer(An.makeFromExisting(s, this.localPosition)).rpcId,
      renderScaleTarget: this.registerDisposer(An.makeFromExisting(s, this.renderScaleTarget)).rpcId
    }), this.backend = r;
  }
  get gl() {
    return this.multiscaleSource.chunkManager.gl;
  }
  get isTransparent() {
    return true;
  }
  get isVolumeRendering() {
    return true;
  }
  get dataType() {
    return this.multiscaleSource.dataType;
  }
  attach(e) {
    super.attach(e), e.state = {
      sources: e.registerDisposer(Ur((t, i, r) => {
        const s = uy(r, i, (a) => this.multiscaleSource.getSources(a), e.messages, this);
        for (const a of s)
          for (const l of a)
            t.registerDisposer(l.source);
        return e.view.flushBackendProjectionParameters(), this.backend.rpc.invoke(vJ, {
          layer: this.backend.rpcId,
          view: e.view.rpcId,
          sources: dy(s)
        }), this.redrawNeeded.dispatch(), s;
      }, this.transform, e.view.displayDimensionRenderInfo))
    };
  }
  get chunkManager() {
    return this.multiscaleSource.chunkManager;
  }
  draw(e, t) {
    if (!e.emitColor)
      return;
    const i = t.state.sources.value;
    if (i.length === 0)
      return;
    let r = 0, s = 0, a = null, l, d;
    const u = _e(), f = this.gl;
    this.vertexIdHelper.enable();
    const g = this.renderScaleHistogram;
    g.begin(this.chunkManager.chunkQueueManager.frameNumberCounter.frameNumber);
    const v = () => {
      a !== null && (l !== null && l.endDrawing(f, a), (b !== 0 || E !== 0) && g.add(r, s, b, E));
    };
    let y = true;
    const w = e.projectionParameters;
    let C, b = 0, E = 0, L;
    const R = this.multiscaleSource.rank, _ = _e();
    f.enable(WebGL2RenderingContext.CULL_FACE), f.cullFace(WebGL2RenderingContext.FRONT), dE(e.projectionParameters, this.localPosition.value, this.renderScaleTarget.value, i[0], (A, I, P, N) => {
      r = P, s = N;
      const O = ay(w, A.chunkLayout), B = A.source, j = A.fixedPositionWithinChunk, U = A.chunkDisplayDimensionIndices;
      for (const Xe of U)
        j[Xe] = 0;
      const V = B.chunkFormat;
      if (V !== l && (l = V, v(), d = this.shaderGetter({ emitter: e.emitter, chunkFormat: V }), a = d.shader, a !== null && (a.bind(), V !== null && (Ao(f, a, this.shaderControlState, d.parameters.parseResult.controls), V.beginDrawing(f, a), V.beginSource(f, a)))), L = void 0, a === null)
        return;
      C = B.chunks, u.fill(1);
      const G = mn(bJ, w.viewProjectionMat, O.transform);
      f.uniformMatrix4fv(a.uniform("uModelViewProjectionMatrix"), false, G);
      const F = CJ;
      Eu(F, G), xs(G, G), f.uniformMatrix4fv(a.uniform("uInvModelViewProjectionMatrix"), false, G);
      var ue = SJ(F, A.lowerClipDisplayBound, A.upperClipDisplayBound);
      const ae = ue.near, Ie = ue.far, le = ue.adjustedNear, Te = ue.adjustedFar, Ye = (Te - le) / (ov - 1) / (Ie - ae);
      f.uniform1f(a.uniform("uBrightnessFactor"), Ye);
      const Ze = (le - ae) / (Ie - ae), rt = (Te - ae) / (Ie - ae);
      f.uniform1f(a.uniform("uNearLimitFraction"), Ze), f.uniform1f(a.uniform("uFarLimitFraction"), rt), f.uniform1i(a.uniform("uMaxSteps"), ov), f.uniform3fv(a.uniform("uLowerClipBound"), A.lowerClipDisplayBound), f.uniform3fv(a.uniform("uUpperClipBound"), A.upperClipDisplayBound);
    }, (A) => {
      if (a === null)
        return;
      const I = A.curPositionInChunks.join(), P = C.get(I);
      if (P !== void 0 && P.state === Et.GPU_MEMORY) {
        const N = A.chunkLayout.size;
        let O = P.chunkDataSize;
        const B = A.chunkDisplayDimensionIndices, j = A.fixedPositionWithinChunk, U = A.chunkTransform.channelToChunkDimensionIndices;
        if (nP(A), O !== L) {
          L = O;
          for (let G = 0; G < 3; ++G) {
            const F = B[G];
            u[G] = F === -1 || F >= R ? 1 : L[F];
          }
          f.uniform3fv(a.uniform("uChunkDataSize"), u);
        }
        const V = P.chunkGridPosition;
        for (let G = 0; G < 3; ++G) {
          const F = B[G];
          _[G] = F === -1 || F >= R ? 0 : N[G] * V[F];
        }
        l == null ? void 0 : l.bindChunk(f, a, P, j, B, U, y), y = false, f.uniform3fv(a.uniform("uTranslation"), _), c4(f, 1, 1), ++b;
      } else
        ++E;
    }), f.disable(WebGL2RenderingContext.CULL_FACE), v(), this.vertexIdHelper.disable();
  }
  isReady(e, t) {
    const i = t.state.sources.value;
    if (i.length === 0)
      return true;
    let r = false;
    return dE(e.projectionParameters, this.localPosition.value, this.renderScaleTarget.value, i[0], () => {
    }, (s) => {
      const a = s.source.chunks.get(s.curPositionInChunks.join());
      (a === void 0 || a.state !== Et.GPU_MEMORY) && (r = true);
    }), r;
  }
};
var xJ = vt.fromObject({
  arrowup: { action: "tab-backward" },
  arrowdown: { action: "tab-forward" },
  tab: { action: "tab-forward" },
  "shift+tab": { action: "tab-backward" },
  enter: { action: "commit" },
  escape: { action: "cancel" }
});
var EJ = class {
  constructor(e) {
    this.id = e, this.element = document.createElement("div"), this.nameContainer = document.createElement("div"), this.nameElement = document.createElement("input"), this.lowerElement = document.createElement("div"), this.upperElement = document.createElement("div");
    const t = this.element, i = this.nameContainer, r = this.nameElement, s = this.lowerElement, a = this.upperElement;
    t.classList.add("neuroglancer-channel-dimensions-widget-dim"), i.classList.add("neuroglancer-channel-dimensions-widget-name-container"), r.classList.add("neuroglancer-channel-dimensions-widget-name"), i.appendChild(r), s.classList.add("neuroglancer-channel-dimensions-widget-lower"), a.classList.add("neuroglancer-channel-dimensions-widget-upper"), t.appendChild(i), t.appendChild(s), t.appendChild(a), i.draggable = true, r.disabled = true, r.spellcheck = false, r.autocomplete = "off", r.required = true, r.placeholder = " ", i.title = "Drag to reorder, double click to rename.  Names ending in ' or ^ indicate dimensions local to the layer; names ending in ^ indicate channel dimensions (image layers only).", i.addEventListener("dblclick", () => {
      r.disabled = false, r.focus(), r.select();
    }), r.addEventListener("focus", () => {
      r.select();
    });
  }
};
var TJ = class extends Z {
  constructor(e) {
    super(), this.combiner = e, this.element = document.createElement("div"), this.dimensionWidgets = [], this.curCoordinateSpace = void 0, this.dragSource = void 0, this.coordinateSpace = this.combiner.combined;
    const t = this.element;
    t.classList.add("neuroglancer-channel-dimensions-widget");
    const i = this.registerCancellable(Ct(() => this.updateView()));
    this.registerDisposer(e.combined.changed.add(i));
    const r = this.registerDisposer(new Wi(t, xJ));
    r.allShortcutsAreGlobal = true, this.registerDisposer(be(t, "cancel", (s) => {
      this.forceUpdateView();
      const a = s.target;
      a instanceof HTMLElement && a.blur();
    })), this.updateView();
  }
  reorderDimensionTo(e, t) {
    if (e === t)
      return;
    const i = this.coordinateSpace;
    i.value = z1(i.value, e, t);
  }
  makeNewDimensionWidget(e) {
    const t = new EJ(e);
    return t.nameContainer.addEventListener("dragstart", (i) => {
      this.dragSource = t, i.stopPropagation(), i.dataTransfer.setData("neuroglancer-dimension", "");
    }), t.nameContainer.addEventListener("dragenter", (i) => {
      const r = this.dragSource;
      if (r === void 0 || r === t)
        return;
      const s = this.dimensionWidgets, a = s.indexOf(r), l = s.indexOf(t);
      a === -1 || l === -1 || (i.preventDefault(), this.reorderDimensionTo(l, a));
    }), t.nameContainer.addEventListener("dragend", (i) => {
      this.dragSource === t && (this.dragSource = void 0);
    }), t.nameElement.addEventListener("blur", (i) => {
      t.nameElement.disabled = true;
      const r = i.relatedTarget;
      this.dimensionWidgets.some((s) => s.nameElement === r) || this.updateNames() || this.forceUpdateView();
    }), t.nameElement.addEventListener("input", () => {
      const i = t.nameElement;
      Kn(i), this.updateNameValidity();
    }), be(t.nameElement, "commit", () => {
      this.updateNames();
    }), be(t.nameElement, "tab-forward", (i) => this.selectAdjacentField(i, t, 1)), be(t.nameElement, "tab-backward", (i) => this.selectAdjacentField(i, t, -1)), t;
  }
  selectAdjacentField(e, t, i) {
    e.stopPropagation();
    const r = this.dimensionWidgets, s = r.indexOf(t);
    if (s === -1)
      return;
    const a = s + i;
    if (a < 0 || a >= r.length)
      return;
    const l = r[a];
    l.nameElement.disabled = false, l.nameElement.focus(), e.preventDefault();
  }
  updateNames() {
    const e = this.dimensionWidgets, t = this.coordinateSpace, i = t.value, r = e.map((d) => d.nameElement.value);
    if (this.combiner.getRenameValidity(r).includes(false))
      return false;
    const s = i.names;
    if (Fe(s, r))
      return false;
    const a = i.timestamps.map((d, u) => s[u] === r[u] ? d : Date.now()), l = RZr(RZr({}, i), { names: r, timestamps: a });
    return t.value = l, true;
  }
  updateNameValidity() {
    const e = this.dimensionWidgets, t = e.map((s) => s.nameElement.value), i = t.length, r = this.combiner.getRenameValidity(t);
    for (let s = 0; s < i; ++s)
      e[s].nameElement.dataset.isValid = r[s] === false ? "false" : "true";
  }
  forceUpdateView() {
    this.curCoordinateSpace = void 0, this.updateView();
  }
  updateView() {
    const e = this.coordinateSpace.value;
    if (this.curCoordinateSpace === e)
      return;
    this.curCoordinateSpace = e;
    const t = this.element, i = this.dimensionWidgets, r = this.dimensionWidgets = e.ids.map((a) => i.find((l) => l.id === a) || this.makeNewDimensionWidget(a));
    function* s() {
      const a = e.names, l = e.rank;
      var d = e.bounds;
      const u = d.lowerBounds, f = d.upperBounds;
      for (let g = 0; g < l; ++g) {
        const v = r[g];
        v.nameElement.value = a[g], delete v.nameElement.dataset.isValid, Kn(v.nameElement), v.lowerElement.textContent = u[g].toString(), v.upperElement.textContent = f[g].toString(), yield v.element;
      }
    }
    ar(t, s.call(this));
  }
};
var lv = "opacity";
var cv = "blend";
var uE = "shader";
var hE = "shaderControls";
var dv = "crossSectionRenderScale";
var fE = "channelDimensions";
var uv = "volumeRendering";
var kJ = "volumeRenderScale";
var IJ = Qy(al);
var Ta = class extends IJ {
  constructor(e) {
    super(e), this.opacity = tc(0.5), this.blendMode = fJ(), this.fragmentMain = pJ(), this.shaderError = Vh(), this.dataType = new gt(void 0), this.sliceViewRenderScaleHistogram = new Ro(), this.sliceViewRenderScaleTarget = ua(1), this.volumeRenderingRenderScaleHistogram = new Ro(), this.volumeRenderingRenderScaleTarget = ua(1), this.channelCoordinateSpace = new Bv(), this.channelCoordinateSpaceCombiner = new Gv2(this.channelCoordinateSpace, z2), this.channelSpace = this.registerDisposer(rr((t) => CT(() => q2(t)), this.channelCoordinateSpace)), this.volumeRendering = new en(false, false), this.shaderControlState = this.registerDisposer(new iy(this.fragmentMain, this.registerDisposer(wi((t, i) => t === void 0 ? null : { imageData: { dataType: t, channelRank: i.rank } }, [this.dataType, this.channelCoordinateSpace], (t, i) => se(t) === se(i))), this.channelCoordinateSpaceCombiner)), this.localCoordinateSpaceCombiner.includeDimensionPredicate = ic, this.blendMode.changed.add(this.specificationChanged.dispatch), this.opacity.changed.add(this.specificationChanged.dispatch), this.fragmentMain.changed.add(this.specificationChanged.dispatch), this.shaderControlState.changed.add(this.specificationChanged.dispatch), this.sliceViewRenderScaleTarget.changed.add(this.specificationChanged.dispatch), this.volumeRendering.changed.add(this.specificationChanged.dispatch), this.tabs.add("rendering", { label: "Rendering", order: -100, getter: () => new LJ(this) }), this.tabs.default = "rendering";
  }
  markLoading() {
    const e = super.markLoading(), t = this.channelCoordinateSpaceCombiner.retain();
    return () => {
      e(), t();
    };
  }
  addCoordinateSpace(e) {
    const t = super.addCoordinateSpace(e), i = this.channelCoordinateSpaceCombiner.bind(e);
    return () => {
      t(), i();
    };
  }
  activateDataSubsources(e) {
    let t;
    for (const i of e) {
      if (this.addStaticAnnotations(i))
        continue;
      const a = i.subsourceEntry.subsource.volume;
      if (!(a instanceof _s)) {
        i.deactivate("Not compatible with image layer");
        continue;
      }
      if (t && a.dataType !== t) {
        i.deactivate(`Data type must be ${J[a.dataType].toLowerCase()}`);
        continue;
      }
      t = a.dataType, i.activate((l) => {
        i.addRenderLayer(new gJ(a, {
          opacity: this.opacity,
          blendMode: this.blendMode,
          shaderControlState: this.shaderControlState,
          shaderError: this.shaderError,
          transform: i.getRenderLayerTransform(this.channelCoordinateSpace),
          renderScaleTarget: this.sliceViewRenderScaleTarget,
          renderScaleHistogram: this.sliceViewRenderScaleHistogram,
          localPosition: this.localPosition,
          channelCoordinateSpace: this.channelCoordinateSpace
        }));
        const d = l.registerDisposer(new wJ({
          multiscaleSource: a,
          shaderControlState: this.shaderControlState,
          shaderError: this.shaderError,
          transform: i.getRenderLayerTransform(this.channelCoordinateSpace),
          renderScaleTarget: this.volumeRenderingRenderScaleTarget,
          renderScaleHistogram: this.volumeRenderingRenderScaleHistogram,
          localPosition: this.localPosition,
          channelCoordinateSpace: this.channelCoordinateSpace
        }));
        l.registerDisposer(i.messages.addChild(d.messages)), l.registerDisposer(Ur((u, f) => {
          f && u.registerDisposer(this.addRenderLayer(d.addRef()));
        }, this.volumeRendering)), this.shaderError.changed.dispatch();
      });
    }
    this.dataType.value = t;
  }
  restoreState(e) {
    super.restoreState(e), this.opacity.restoreState(e[lv]), Ce(e, cv, (t) => this.blendMode.restoreState(t)), this.fragmentMain.restoreState(e[uE]), this.shaderControlState.restoreState(e[hE]), this.sliceViewRenderScaleTarget.restoreState(e[dv]), this.channelCoordinateSpace.restoreState(e[fE]), this.volumeRendering.restoreState(e[uv]);
  }
  toJSON() {
    const e = super.toJSON();
    return e[lv] = this.opacity.toJSON(), e[cv] = this.blendMode.toJSON(), e[uE] = this.fragmentMain.toJSON(), e[hE] = this.shaderControlState.toJSON(), e[dv] = this.sliceViewRenderScaleTarget.toJSON(), e[fE] = this.channelCoordinateSpace.toJSON(), e[uv] = this.volumeRendering.toJSON(), e;
  }
  displayImageSelectionState(e, t) {
    const i = e.value;
    if (i == null)
      return false;
    const r = this.channelSpace.value;
    if (r.error !== void 0)
      return false;
    const s = r.numChannels, a = r.coordinates;
    var l = r.channelCoordinateSpace;
    const d = l.names, u = l.rank, f = document.createElement("div");
    f.classList.add("neuroglancer-selection-details-value-grid");
    let g = "[copy] 0fr ";
    u !== 0 && (g += `repeat(${u}, [dim] 0fr [coord] 0fr) `), g += "[value] 1fr", f.style.gridTemplateColumns = g;
    for (let v = 0; v < s; ++v) {
      const y = u === 0 ? i : i[v], w = y == null ? "" : y.toString(), C = dr({
        title: "Copy value",
        onClick: () => {
          oi(w);
        }
      });
      f.appendChild(C);
      for (let E = 0; E < u; ++E) {
        const L = document.createElement("div");
        L.classList.add("neuroglancer-selection-details-value-grid-dim"), L.textContent = d[E], f.appendChild(L);
        const R = document.createElement("div");
        R.classList.add("neuroglancer-selection-details-value-grid-coord"), R.textContent = a[v * u + E].toString(), f.appendChild(R);
      }
      const b = document.createElement("div");
      b.classList.add("neuroglancer-selection-details-value-grid-value"), b.textContent = w, f.appendChild(b);
    }
    return t.appendChild(f), true;
  }
  displaySelectionState(e, t, i) {
    let r = this.displayImageSelectionState(e, t);
    return super.displaySelectionState(e, t, i) && (r = true), r;
  }
  getLegendShaderOptions() {
    return {
      memoizeKey: "ImageUserLayer",
      parameters: this.shaderControlState.builderState,
      // fixme: support fallback
      encodeParameters: (e) => e.key,
      defineShader: (e, t) => {
        e.addFragmentCode(`
#define uOpacity 1.0
`), dP(e, t);
      },
      initializeShader: (e) => {
        const t = e.shader;
        Ao(this.manager.root.display.gl, t, this.shaderControlState, e.parameters.parseResult.controls);
      }
    };
  }
};
Ta.type = "image";
Ta.typeAbbreviation = "img";
function uP(n) {
  return new aS({
    shaderError: n.shaderError,
    fragmentMain: n.fragmentMain,
    shaderControlState: n.shaderControlState
  });
}
var hP = [RZr({ label: "Resolution (slice)", toolJson: dv }, ah((n) => ({
  histogram: n.sliceViewRenderScaleHistogram,
  target: n.sliceViewRenderScaleTarget
}))), RZr({ label: "Blending", toolJson: cv }, sD((n) => n.blendMode)), RZr({ label: "Volume rendering (experimental)", toolJson: uv }, cc((n) => n.volumeRendering)), RZr({ label: "Resolution (3d)", toolJson: kJ, isValid: (n) => n.volumeRendering }, ah((n) => ({
  histogram: n.volumeRenderingRenderScaleHistogram,
  target: n.volumeRenderingRenderScaleTarget
}))), RZr({ label: "Opacity", toolJson: lv }, vs((n) => ({ value: n.opacity })))];
for (const n of hP)
  QL(Ta, n);
var LJ = class extends Kr {
  constructor(e) {
    super(), this.layer = e, this.codeWidget = this.registerDisposer(uP(this.layer));
    const t = this.element;
    t.classList.add("neuroglancer-image-dropdown");
    for (const s of hP)
      t.appendChild(rS(this, e, this.visibility, s));
    let i = document.createElement("div");
    i.style.flex = "1";
    let r = document.createElement("div");
    r.className = "neuroglancer-image-dropdown-top-row", r.appendChild(document.createTextNode("Shader")), r.appendChild(i), r.appendChild(sS({
      title: "Show larger editor view",
      onClick: () => {
        new DJ(this.layer);
      }
    })), r.appendChild(iS({
      title: "Documentation on image layer rendering",
      href: "https://github.com/google/neuroglancer/blob/master/src/neuroglancer/sliceview/image_layer_rendering.md"
    })), t.appendChild(r), t.appendChild(this.registerDisposer(new TJ(e.channelCoordinateSpaceCombiner)).element), t.appendChild(this.codeWidget.element), t.appendChild(this.registerDisposer(new oS(e.shaderControlState, this.layer.manager.root.display, this.layer, {
      visibility: this.visibility,
      legendShaderOptions: this.layer.getLegendShaderOptions()
    })).element);
  }
};
var DJ = class extends hf {
  constructor(e) {
    super(), this.layer = e, this.codeWidget = this.registerDisposer(uP(this.layer)), this.content.classList.add("neuroglancer-image-layer-shader-overlay"), this.content.appendChild(this.codeWidget.element), this.codeWidget.textEditor.refresh();
  }
};
ol(Ta);
nL(Dn.IMAGE, Ta);
Gy((n) => {
  const e = n.volume;
  if (e !== void 0 && e.volumeType === Dn.UNKNOWN)
    return { layerConstructor: Ta, priority: -100 };
});
lS(Ta, (n) => ({
  shaderControlState: n.shaderControlState,
  legendShaderOptions: n.getLegendShaderOptions()
}));
function PJ(n) {
  if (n.brainMapsClientId) {
    const t = n.brainMapsClientId;
    il.register(gf, () => new WD(t));
  }
  let e = mj({ bundleRoot: n.bundleRoot }, n.target);
  return U3(e.inputEventBindings), rj(e), aj(e), vj(n.target), e;
}
var AJ = class {
  version() {
    return "0.0.1";
  }
};
var RJ = Object.freeze(Object.defineProperty({
  __proto__: null,
  default: AJ,
  setupDefaultViewer: PJ
}, Symbol.toStringTag, { value: "Module" }));
var MJ = hl(RJ);
var NJ = hl(Q_);
var _J = hl(J_);
var OJ = hl(Y$);
(function(n) {
  function e(X) {
    "@babel/helpers - typeof";
    return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? e = function(te) {
      return typeof te;
    } : e = function(te) {
      return te && typeof Symbol == "function" && te.constructor === Symbol && te !== Symbol.prototype ? "symbol" : typeof te;
    }, e(X);
  }
  Object.defineProperty(n, "__esModule", {
    value: true
  }), n.parseUrlHash = F, n.getNeuroglancerViewerState = ue, n.getNeuroglancerColor = ae, n.closeSelectionTab = Ie, n.getLayerManager = le, n.getManagedLayer = Te, n.getAnnotationLayer = Ue, n.getAnnotationSource = Ye, n.addLayerSignalRemover = Ze, n.unsubscribeLayersChangedSignals = rt, n.configureLayersChangedSignals = Xe, n.configureAnnotationLayer = $e, n.configureAnnotationLayerChanged = Pe, n.getAnnotationSelectionHost = bt, n.getSelectedAnnotationId = ci, n.default = void 0;
  var t = v(import_react.default), i = v(eg), r = ej, s = tj, a = nj, l = ij, d = MJ, u = NJ, f = _J, g = OJ;
  function v(X) {
    return X && X.__esModule ? X : { default: X };
  }
  function y(X, ne) {
    var te = Object.keys(X);
    if (Object.getOwnPropertySymbols) {
      var ge = Object.getOwnPropertySymbols(X);
      ne && (ge = ge.filter(function(we) {
        return Object.getOwnPropertyDescriptor(X, we).enumerable;
      })), te.push.apply(te, ge);
    }
    return te;
  }
  function w(X) {
    for (var ne = 1; ne < arguments.length; ne++) {
      var te = arguments[ne] != null ? arguments[ne] : {};
      ne % 2 ? y(Object(te), true).forEach(function(ge) {
        O(X, ge, te[ge]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(X, Object.getOwnPropertyDescriptors(te)) : y(Object(te)).forEach(function(ge) {
        Object.defineProperty(X, ge, Object.getOwnPropertyDescriptor(te, ge));
      });
    }
    return X;
  }
  function C(X, ne) {
    if (!(X instanceof ne))
      throw new TypeError("Cannot call a class as a function");
  }
  function b(X, ne) {
    for (var te = 0; te < ne.length; te++) {
      var ge = ne[te];
      ge.enumerable = ge.enumerable || false, ge.configurable = true, "value" in ge && (ge.writable = true), Object.defineProperty(X, ge.key, ge);
    }
  }
  function E(X, ne, te) {
    return ne && b(X.prototype, ne), te && b(X, te), X;
  }
  function L(X, ne) {
    if (typeof ne != "function" && ne !== null)
      throw new TypeError("Super expression must either be null or a function");
    X.prototype = Object.create(ne && ne.prototype, { constructor: { value: X, writable: true, configurable: true } }), ne && R(X, ne);
  }
  function R(X, ne) {
    return R = Object.setPrototypeOf || function(ge, we) {
      return ge.__proto__ = we, ge;
    }, R(X, ne);
  }
  function _(X) {
    var ne = P();
    return function() {
      var ge = N(X), we;
      if (ne) {
        var me = N(this).constructor;
        we = Reflect.construct(ge, arguments, me);
      } else
        we = ge.apply(this, arguments);
      return A(this, we);
    };
  }
  function A(X, ne) {
    return ne && (e(ne) === "object" || typeof ne == "function") ? ne : I(X);
  }
  function I(X) {
    if (X === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return X;
  }
  function P() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
      return false;
    if (typeof Proxy == "function")
      return true;
    try {
      return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      })), true;
    } catch {
      return false;
    }
  }
  function N(X) {
    return N = Object.setPrototypeOf ? Object.getPrototypeOf : function(te) {
      return te.__proto__ || Object.getPrototypeOf(te);
    }, N(X);
  }
  function O(X, ne, te) {
    return ne in X ? Object.defineProperty(X, ne, { value: te, enumerable: true, configurable: true, writable: true }) : X[ne] = te, X;
  }
  function B(X, ne) {
    var te;
    if (typeof Symbol > "u" || X[Symbol.iterator] == null) {
      if (Array.isArray(X) || (te = j(X)) || ne && X && typeof X.length == "number") {
        te && (X = te);
        var ge = 0, we = function() {
        };
        return { s: we, n: function() {
          return ge >= X.length ? { done: true } : { done: false, value: X[ge++] };
        }, e: function(ft) {
          throw ft;
        }, f: we };
      }
      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    var me = true, Ge = false, tt;
    return { s: function() {
      te = X[Symbol.iterator]();
    }, n: function() {
      var ft = te.next();
      return me = ft.done, ft;
    }, e: function(ft) {
      Ge = true, tt = ft;
    }, f: function() {
      try {
        !me && te.return != null && te.return();
      } finally {
        if (Ge)
          throw tt;
      }
    } };
  }
  function j(X, ne) {
    if (X) {
      if (typeof X == "string")
        return U(X, ne);
      var te = Object.prototype.toString.call(X).slice(8, -1);
      if (te === "Object" && X.constructor && (te = X.constructor.name), te === "Map" || te === "Set")
        return Array.from(X);
      if (te === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(te))
        return U(X, ne);
    }
  }
  function U(X, ne) {
    (ne == null || ne > X.length) && (ne = X.length);
    for (var te = 0, ge = new Array(ne); te < ne; te++)
      ge[te] = X[te];
    return ge;
  }
  var V = {}, G;
  function F(X) {
    var ne = null, te = X.replace(/^[^#]+/, "");
    if ((te === "" || te === "#" || te === "#!") && (te = "#!{}"), te.startsWith("#!+"))
      te = te.slice(3), te = decodeURIComponent(te), ne = (0, f.urlSafeParse)(te);
    else if (te.startsWith("#!"))
      te = te.slice(2), te = decodeURIComponent(te), ne = (0, f.urlSafeParse)(te);
    else
      throw new Error('URL hash is expected to be of the form "#!{...}" or "#!+{...}".');
    return ne;
  }
  function ue(X) {
    var ne = X ? V[X] : G;
    return ne ? ne.state.toJSON() : {};
  }
  function ae(X, ne) {
    try {
      var te = u.Uint64.parseString(X), ge = ne ? V[ne] : G;
      if (ge) {
        var we = B(ge.layerManager.managedLayers), me;
        try {
          for (we.s(); !(me = we.n()).done; ) {
            var Ge = me.value;
            if (Ge.layer instanceof a.SegmentationUserLayer) {
              var tt = Ge.layer.displayState, ht = (0, s.getObjectColor)(tt, te);
              if (tt.segmentSelectionState.isSelected(te))
                for (var ft = 0; ft < 3; ft += 1)
                  ht[ft] = (ht[ft] - 0.5) / 0.5;
              var st = (0, l.serializeColor)(ht);
              return st;
            }
          }
        } catch (zt) {
          we.e(zt);
        } finally {
          we.f();
        }
      }
    } catch {
    }
    return "";
  }
  function Ie(X) {
    var ne = X ? V[X] : G;
    ne && ne.closeSelectionTab && ne.closeSelectionTab();
  }
  function le(X) {
    var ne = X ? V[X] : G;
    if (ne)
      return ne.layerManager;
  }
  function Te(X, ne) {
    var te = le(X);
    if (te)
      return te.managedLayers.filter(function(ge) {
        return ge.name === ne;
      })[0];
  }
  function Ue(X, ne) {
    var te = Te(X, ne);
    if (te && te.layer instanceof r.AnnotationUserLayer)
      return te.layer;
  }
  function Ye(X, ne) {
    var te = Ue(X, ne);
    if (te && te.dataSources && te.dataSources[0].loadState_) {
      var ge = te.dataSources[0].loadState_.dataSource;
      if (ge)
        return ge.subsources[0].subsource.annotation;
    }
  }
  function Ze(X, ne, te) {
    var ge = le(X);
    ge && ne && te && (ge.customSignalHandlerRemovers || (ge.customSignalHandlerRemovers = {}), ge.customSignalHandlerRemovers[ne] || (ge.customSignalHandlerRemovers[ne] = []), ge.customSignalHandlerRemovers[ne].push(te));
  }
  function rt(X, ne) {
    X && X.customSignalHandlerRemovers && X.customSignalHandlerRemovers[ne] && (X.customSignalHandlerRemovers[ne].forEach(function(te) {
      te();
    }), delete X.customSignalHandlerRemovers[ne]);
  }
  function Xe(X, ne) {
    var te = le(X);
    if (te) {
      var ge = ne.layerName;
      if (rt(te, ge), ne.process) {
        var we = function(tt) {
          return Ze(void 0, ge, tt);
        };
        we(te.layersChanged.add(function() {
          var Ge = Te(void 0, ge);
          Ge && ne.process(Ge);
        }));
        var me = Te(void 0, ge);
        return me && ne.process(me), function() {
          ne.cancel && ne.cancel(), rt(te, ge);
        };
      }
    }
    return ne.cancel;
  }
  function Be(X, ne, te) {
    X && !X.signalReady && (ne.onAnnotationAdded && te(X.childAdded.add(function(ge) {
      ne.onAnnotationAdded(ge);
    })), ne.onAnnotationDeleted && te(X.childDeleted.add(function(ge) {
      ne.onAnnotationDeleted(ge);
    })), ne.onAnnotationUpdated && te(X.childUpdated.add(function(ge) {
      ne.onAnnotationUpdated(ge);
    })), ne.onAnnotationChanged && X.referencesChanged && te(X.referencesChanged.add(ne.onAnnotationChanged)), X.signalReady = true, te(function() {
      X.signalReady = false;
    }));
  }
  function Ae(X) {
    if (X.dataSources && X.dataSources.length > 0 && X.dataSources[0].loadState_ && X.dataSources[0].loadState_.dataSource)
      return X.dataSources[0].loadState_.dataSource;
  }
  function ze(X) {
    var ne = Ae(X);
    if (ne)
      return ne.subsources[0].subsource.annotation;
  }
  function We(X, ne, te) {
    var ge = function() {
      var Ge = ze(X);
      Ge && Be(Ge, ne, te);
    }, we = X.dataSourcesChanged;
    we && !we.signalReady && (te(we.add(ge)), we.signalReady = true, te(function() {
      we.signalReady = false;
    }), ge());
  }
  function $e(X, ne, te) {
    X && (X.expectingExternalTable = true, X.selectedAnnotation && !X.selectedAnnotation.changed.signalReady && ne.onAnnotationSelectionChanged && (te(X.selectedAnnotation.changed.add(function() {
      ne.onAnnotationSelectionChanged(X.selectedAnnotation.value);
    })), te(function() {
      X.selectedAnnotation.changed.signalReady = false;
    }), X.selectedAnnotation.changed.signalReady = true), We(X, ne, te));
  }
  function Pe(X, ne, te) {
    if (!X.layerChanged.signalReady) {
      var ge = X.layerChanged.add(function() {
        $e(X.layer, ne, te);
      });
      X.layerChanged.signalReady = true, te(ge), te(function() {
        X.layerChanged.signalReady = false;
      }), $e(X.layer, ne, te);
    }
  }
  function bt(X) {
    var ne = X ? V[X] : G;
    return ne ? ne.selectionDetailsState ? "viewer" : "layer" : null;
  }
  function ci(X, ne) {
    var te = X ? V[X] : G;
    if (te)
      if (te.selectionDetailsState) {
        if (te.selectionDetailsState.value) {
          var ge = te.selectionDetailsState.value.layers;
          if (ge) {
            var we = ge.find(function(Ge) {
              return Ge.layer.managedLayer.name === ne;
            });
            if (we && we.state)
              return we.state.annotationId;
          }
        }
      } else {
        var me = Ue(void 0, ne);
        if (me && me.selectedAnnotation && me.selectedAnnotation.value)
          return me.selectedAnnotation.value.id;
      }
    return null;
  }
  var tn = function(X) {
    L(te, X);
    var ne = _(te);
    function te(ge) {
      var we;
      return C(this, te), we = ne.call(this, ge), O(I(we), "updateEventBindings", function(me) {
        var Ge = we.viewer.inputEventBindings, tt = function ht(ft) {
          var st = function(Dt, Gt, qe) {
            var Rt = Dt.get(Gt);
            Rt && (Dt.delete(Gt), qe && Dt.set(qe, Rt));
          }, zt = ft.bindings;
          me.forEach(function(pt) {
            var Dt = Array.isArray(pt) ? pt[0] : pt, Gt = "at:".concat(Dt), qe = pt[1] ? "at:".concat(pt[1]) : void 0;
            st(zt, Gt, qe);
            var Rt = "bubble:".concat(Dt), Pt = pt[1] ? "bubble:".concat(pt[1]) : void 0;
            st(zt, Rt, Pt);
          }), ft.parents.forEach(function(pt) {
            ht(pt);
          });
        };
        tt(Ge.global), tt(Ge.perspectiveView), tt(Ge.sliceView);
      }), O(I(we), "selectionDetailsStateChanged", function() {
        if (we.viewer) {
          var me = we.props.onSelectionDetailsStateChanged;
          me && me();
        }
      }), O(I(we), "layersChanged", function() {
        if (we.handlerRemovers && we.handlerRemovers.forEach(function(Pt) {
          return Pt();
        }), we.viewer) {
          var me = we.props, Ge = me.onSelectedChanged, tt = me.onVisibleChanged;
          if (Ge || tt) {
            we.handlerRemovers = [];
            var ht = B(we.viewer.layerManager.managedLayers), ft;
            try {
              for (ht.s(); !(ft = ht.n()).done; ) {
                var st = ft.value;
                if (st.layer instanceof a.SegmentationUserLayer) {
                  var zt = st.layer.displayState.segmentSelectionState, pt = st.layer.displayState.segmentationGroupState.value.visibleSegments;
                  if (zt && Ge) {
                    var Dt = we.selectedChanged.bind(void 0, st), Gt = zt.changed.add(Dt);
                    we.handlerRemovers.push(Gt), st.registerDisposer(Gt);
                  }
                  if (pt && tt) {
                    var qe = we.visibleChanged.bind(void 0, st), Rt = pt.changed.add(qe);
                    we.handlerRemovers.push(Rt), st.registerDisposer(Rt);
                  }
                }
              }
            } catch (Pt) {
              ht.e(Pt);
            } finally {
              ht.f();
            }
          }
        }
      }), O(I(we), "selectedChanged", function(me) {
        if (we.viewer) {
          var Ge = we.props.onSelectedChanged;
          if (Ge) {
            var tt = me.layer.displayState.segmentSelectionState;
            if (tt) {
              var ht = tt.hasSelectedSegment ? tt.selectedSegment : null;
              Ge(ht, me);
            }
          }
        }
      }), O(I(we), "visibleChanged", function(me) {
        if (we.viewer) {
          var Ge = we.props.onVisibleChanged;
          if (Ge) {
            var tt = me.layer.displayState.segmentationGroupState.value.visibleSegments;
            tt && Ge(tt, me);
          }
        }
      }), we.ngContainer = t.default.createRef(), we.viewer = null, we;
    }
    return E(te, [{
      key: "componentDidMount",
      value: function() {
        var we = this, me = this.props, Ge = me.perspectiveZoom, tt = me.viewerState, ht = me.brainMapsClientId, ft = me.eventBindingsToUpdate, st = me.onViewerStateChanged, zt = me.callbacks, pt = me.ngServer, Dt = me.key, Gt = me.bundleRoot;
        if (this.viewer = (0, d.setupDefaultViewer)({
          brainMapsClientId: ht,
          target: this.ngContainer.current,
          bundleRoot: Gt || "/"
        }), this.setCallbacks(zt), ft && this.updateEventBindings(ft), this.viewer.expectingExternalUI = true, pt && (this.viewer.makeUrlFromState = function(Rt) {
          var Pt = w({}, Rt);
          return Rt.layers && (Pt.layers = Rt.layers.filter(function(di) {
            if (di.source) {
              var ji = di.source.url || di.source;
              if (typeof ji == "string")
                return !ji.startsWith("clio://");
            }
            return true;
          })), "".concat(pt, "/#!").concat((0, g.encodeFragment)(JSON.stringify(Pt)));
        }), this.viewer.selectionDetailsState && this.viewer.selectionDetailsState.changed.add(this.selectionDetailsStateChanged), this.viewer.layerManager.layersChanged.add(this.layersChanged), tt) {
          var qe = tt;
          qe.projectionScale === null && delete qe.projectionScale, qe.crossSectionScale === null && delete qe.crossSectionScale, qe.projectionOrientation === null && delete qe.projectionOrientation, qe.crossSectionOrientation === null && delete qe.crossSectionOrientation, this.viewer.state.restoreState(qe);
        } else
          this.viewer.state.restoreState({
            layers: {
              grayscale: {
                type: "image",
                source: "dvid://https://flyem.dvid.io/ab6e610d4fe140aba0e030645a1d7229/grayscalejpeg"
              },
              segmentation: {
                type: "segmentation",
                source: "dvid://https://flyem.dvid.io/d925633ed0974da78e2bb5cf38d01f4d/segmentation"
              }
            },
            perspectiveZoom: Ge,
            navigation: {
              zoomFactor: 8
            }
          });
        this.viewer.state.changed.add(function() {
          if (st)
            try {
              we.viewer.state.viewer.position && st(we.viewer.state.toJSON());
            } catch (Rt) {
              console.debug(Rt);
            }
        }), Dt ? V[Dt] = this.viewer : G = this.viewer, window.viewer = this.viewer;
      }
    }, {
      key: "componentDidUpdate",
      value: function() {
        var we = this, me = {}, Ge = B(this.viewer.layerManager.managedLayers), tt;
        try {
          for (Ge.s(); !(tt = Ge.n()).done; ) {
            var ht = tt.value;
            if (ht.layer instanceof a.SegmentationUserLayer) {
              var ft = ht.layer.displayState.segmentSelectionState;
              me[ht.name] = ft.selectedSegment;
            }
          }
        } catch (Pt) {
          Ge.e(Pt);
        } finally {
          Ge.f();
        }
        var st = this.props.viewerState;
        if (st) {
          var zt = w({}, st), pt = [function() {
            we.viewer.state.restoreState(zt);
          }];
          st.projectionScale === null && (delete zt.projectionScale, pt.push(function() {
            we.viewer.projectionScale.reset();
          })), st.crossSectionScale === null && delete zt.crossSectionScale, pt.forEach(function(Pt) {
            return Pt();
          });
        }
        var Dt = B(this.viewer.layerManager.managedLayers), Gt;
        try {
          for (Dt.s(); !(Gt = Dt.n()).done; ) {
            var qe = Gt.value;
            if (qe.layer instanceof a.SegmentationUserLayer) {
              var Rt = qe.layer.displayState.segmentSelectionState;
              Rt.set(me[qe.name]);
            }
          }
        } catch (Pt) {
          Dt.e(Pt);
        } finally {
          Dt.f();
        }
        "position" in st && Array.isArray(st.position) && st.position.length === 0 && this.viewer.position.reset();
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        var we = this.props.key;
        we ? delete V[we] : G = void 0;
      }
      /* setCallbacks allows us to set a callback on a neuroglancer event
       * each callback created should be in the format:
       * [
       *   {
       *     name: 'unique-name',
       *     event: 'the neuroglancer event to target, eg: click0, keyt',
       *     function: (slice) => { slice.whatever }
       *   },
       *   {...}
       * ]
       *
       */
    }, {
      key: "setCallbacks",
      value: function(we) {
        var me = this;
        we.forEach(function(Ge) {
          me.viewer.bindCallback(Ge.name, Ge.function), me.viewer.inputEventBindings.sliceView.set(Ge.event, Ge.name);
        });
      }
    }, {
      key: "render",
      value: function() {
        var we = this.props.perspectiveZoom;
        return t.default.createElement("div", {
          className: "neuroglancer-container",
          ref: this.ngContainer
        }, t.default.createElement("p", null, "Neuroglancer here with zoom ", we));
      }
    }]), te;
  }(t.default.Component);
  n.default = tn, tn.propTypes = {
    perspectiveZoom: i.default.number,
    viewerState: i.default.object,
    brainMapsClientId: i.default.string,
    key: i.default.string,
    /**
     * An array of event bindings to change in Neuroglancer.  The array format is as follows:
     * [[old-event1, new-event1], [old-event2], old-event3]
     * Here, `old-event1`'s will be unbound and its action will be re-bound to `new-event1`.
     * The bindings for `old-event2` and `old-event3` will be removed.
     * Neuroglancer has its own syntax for event descriptors, and here are some examples:
     * 'keya', 'shift+keyb' 'control+keyc', 'digit4', 'space', 'arrowleft', 'comma', 'period',
     * 'minus', 'equal', 'bracketleft'.
     */
    eventBindingsToUpdate: i.default.array,
    /**
     * A function of the form `(segment, layer) => {}`, called each time there is a change to
     * the segment the user has "selected" (i.e., hovered over) in Neuroglancer.
     * The `segment` argument will be a Neuroglancer `Uint64` with the ID of the now-selected
     * segment, or `null` if no segment is now selected.
     * The `layer` argument will be a Neuroglaner `ManagedUserLayer`, whose `layer` property
     * will be a Neuroglancer `SegmentationUserLayer`.
     */
    onSelectedChanged: i.default.func,
    /**
     * A function of the form `(segments, layer) => {}`, called each time there is a change to
     * the segments the user has designated as "visible" (i.e., double-clicked on) in Neuroglancer.
     * The `segments` argument will be a Neuroglancer `Uint64Set` whose elements are `Uint64`
     * instances for the IDs of the now-visible segments.
     * The `layer` argument will be a Neuroglaner `ManagedUserLayer`, whose `layer` property
     * will be a Neuroglancer `SegmentationUserLayer`.
     */
    onVisibleChanged: i.default.func,
    /**
     * A function of the form `() => {}` to respond to selection changes in the viewer.
     */
    onSelectionDetailsStateChanged: i.default.func,
    onViewerStateChanged: i.default.func,
    callbacks: i.default.arrayOf(i.default.object),
    ngServer: i.default.string
  }, tn.defaultProps = {
    perspectiveZoom: 20,
    eventBindingsToUpdate: null,
    brainMapsClientId: "NOT_A_VALID_ID",
    viewerState: null,
    onSelectedChanged: null,
    onVisibleChanged: null,
    onSelectionDetailsStateChanged: null,
    onViewerStateChanged: null,
    key: null,
    callbacks: [],
    ngServer: "https://neuroglancer-demo.appspot.com/"
  };
})(yv);
var VJ = Gs(yv);
var R8 = RR({
  __proto__: null,
  default: VJ
}, [yv]);
export {
  R8 as i
};
/*! Bundled license information:

vitessce/dist/index-0d803e7f.js:
  (**
   * @license
   * Copyright 2016 Google Inc.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2018 Google Inc.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2017 Google Inc.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2021 Google Inc.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2019 Google Inc.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2020 Google Inc.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * /**
   * @license
   * This work is a derivative of the Google Neuroglancer project,
   * Copyright 2016 Google Inc.
   * The Derivative Work is covered by
   * Copyright 2021 Howard Hughes Medical Institute
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * This work is a derivative of the Google Neuroglancer project,
   * Copyright 2016 Google Inc.
   * The Derivative Work is covered by
   * Copyright 2019 Howard Hughes Medical Institute
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
*/
//# sourceMappingURL=index-0d803e7f-F7TITIEP.js.map
